;;; compiled by jwz@thalidomide on Sat Aug 29 19:38:43 1992
;;; from file /wg1/emacs-base/lisp/bytecomp/bytecomp.el
;;; emacs version 19.2.13 Lucid.
;;; bytecomp version 2.08;  7-aug-92.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(byte-code "ÀÂÃ!¬„ÄÅ!ˆÆÇ!«„¬†É™«œÆÊ!¬„Ê \nËÌMˆÂÍ!«†ÎÍK!¬„ÍÏMˆÂ‡" ["2.08; 27-aug-92." byte-compile-version fboundp defsubst load-library "bytecomp-runtime" boundp epoch::version emacs-version "19" baud-rate compiled-function-p (lambda (x) "Emacs 18 doesn't have these." nil) member subrp #[(elt list) "«Œ	@š¬†A‰¬t‡" [list elt] 3 "like memq, but uses equal instead of eq.  In v19, this is a subr."]] 2)
(defvar emacs-lisp-file-regexp (byte-code "Á=«‚Â‡Ã‡" [system-type vax-vms "\\.EL\\(;[0-9]+\\)?$" "\\.el$"] 2) "\
*Regexp which matches the extension of elisp source-files.
You may want to redefine defun byte-compile-dest-file to match this.")
(byte-code "ÀÁ!¬„ÁÂMˆÃÄÅ\"ˆÃÆÅ\"ˆÃÇÅ\"ˆÃÈÅ\"‡" [fboundp byte-compile-dest-file #[(filename) "À	!\nÃ=«Š	ÄÅÆ	\"OÇP‡Å	\"«ˆ	Ä‰”OÉP‡	ÇP‡" [file-name-sans-versions filename system-type vax-vms 0 string-match ";" "c" emacs-lisp-file-regexp ".elc"] 5 "Converts an emacs-lisp source-filename to a compiled-filename."] autoload byte-compile-inline-expand "byte-optimize" byte-optimize-form byte-optimize-lapcode byte-compile-unfold-lambda] 3)
(defvar byte-compile-verbose (byte-code "?­ƒ	\nV‡" [noninteractive baud-rate search-slow-speed] 2) "\
*Non-nil means print messages describing progress of byte-compiler.")
(defvar byte-compile-emacs18-compatibility (byte-code "ÀÁ!«ƒ	®ƒ\nÃ™‡" [boundp epoch::version emacs-version "19"] 2) "\
*If this is true, then the byte compiler will generate .elc files which will
work in generic version 18 emacses without having bytecomp-runtime.el loaded.
If this is false, the generated code will be more efficient in emacs 19, and
will be loadable in emacs 18 only if bytecomp-runtime.el is loaded.
See also byte-compile-generate-emacs19-bytecodes.")
(defvar byte-compile-generate-emacs19-bytecodes (byte-code "ÀÁ!«ƒ	®ƒ\nÃ™?‡" [boundp epoch::version emacs-version "19"] 2) "\
*If this is true, then the byte-compiler will generate bytecode which 
makes use of byte-ops which are present only in emacs19.  Code generated
this way can never be run in emacs18, and may even cause it to crash.")
(defvar byte-optimize t "\
*If nil, no compile-optimizations will be done.
Compilation will be faster, generated code will be slower and larger.
This may be nil, t, 'byte, or 'source.  If it is 'byte, then only byte-level
optimizations will be done; if it is 'source, then only source-level 
optimizations will be done.")
(defvar byte-compile-delete-errors t "\
*If non-nil, the optimizer may delete forms that may signal an error
(variable references and side-effect-free functions such as CAR).")
(defvar byte-optimize-log nil "\
*If true, the byte-compiler will log its optimizations into *Compile-Log*.
If this is 'source, then only source-level optimizations will be logged.
If it is 'byte, then only byte-level optimizations will be logged.")
(defvar byte-compile-error-on-warn nil "\
*If true, the byte-compiler will report warnings with `error' instead
of `message.'")
(byte-code "ÀÂ‡" [(redefine callargs free-vars unresolved) byte-compile-warning-types nil] 1)
(defvar byte-compile-warnings t "\
*List of warnings that the byte-compiler should issue (t for all).
Elements of the list may be be:

  free-vars	references to variables not in the current lexical scope.
  unresolved	calls to unknown functions.
  callargs	lambda calls with args that don't match the definition.
  redefine	function cell redefined from a macro to a lambda or vice
		versa, or redefined to take a different number of arguments.

See also the macro byte-compiler-options.")
(defvar byte-compile-generate-call-tree nil "\
*If this is true, then the compiler will collect statistics on what
functions were called and from where.  This will be displayed after the
compilation completes.  If it is non-nil, but not t, you will be asked
for whether to display this.

The call tree only lists functions called, not macros used. Those functions
which the byte-code interpreter knows about directly (eq, cons, etc.) are
not reported.

The call tree also lists those functions which are not known to be called
(that is, to which no calls have been compiled.)  Functions which can be
invoked interactively are excluded from this list.")
(defconst byte-compile-call-tree nil "\
Alist of functions and their call tree.
Each element looks like

  (FUNCTION CALLERS CALLS)

where CALLERS is a list of functions that call FUNCTION, and CALLS
is a list of functions for which calls were generated while compiling
FUNCTION.")
(defvar byte-compile-call-tree-sort 'name "\
*If non nil, the call tree is sorted.
The values 'name, 'callers, 'calls, 'calls+callers means to sort on
the those fields.")
(defvar byte-compile-overwrite-file t "\
If nil, old .elc files are deleted before the new is saved, and .elc
files will have the same modes as the corresponding .el file.  Otherwise,
existing .elc files will simply be overwritten, and the existing modes
will not be changed.  If this variable is nil, then an .elc file which 
is a symbolic link will be turned into a normal file, instead of the file
which the link points to being overwritten.")
(defvar byte-compile-constants nil "\
list of all constants encountered during compilation of this form")
(defvar byte-compile-variables nil "\
list of all variables encountered during compilation of this form")
(defvar byte-compile-bound-variables nil "\
list of variables bound in the context of the current form; this list
lives partly on the stack.")
(defconst byte-compile-initial-macro-environment '((byte-compiler-options lambda (&rest forms) (apply 'byte-compiler-options-handler forms)) (eval-when-compile lambda (&rest body) (list 'quote (eval (byte-compile-top-level (cons 'progn body))))) (eval-and-compile lambda (&rest body) (eval (cons 'progn body)) (cons 'progn body))) "\
The default macro-environment passed to macroexpand by the compiler.
Placing a macro here will cause a macro to have different semantics when
expanded by the compiler as when expanded by the interpreter.")
(defvar byte-compile-macro-environment byte-compile-initial-macro-environment "\
Alist of (MACRONAME . DEFINITION) macros defined in the file which is being 
compiled.  It is (MACRONAME . nil) when a macro is redefined as a function.")
(defvar byte-compile-function-environment nil "\
Alist of (FUNCTIONNAME . DEFINITION) functions defined in the file which
is being compiled (this is so we can inline them if necessary).  It is
(FUNCTIONNAME . nil) when a function is redefined as a macro.")
(defvar byte-compile-unresolved-functions nil "\
Alist of undefined functions to which calls have been compiled (used for
warnings when the function is later defined with incorrect args).")
(byte-code "ÀÁ!¬‚ÂÀ‡" [boundp byte-compile-tag-number 0] 2)
(defvar byte-compile-output nil "\
Alist describing contents to put in byte code string.
Each element is (INDEX . VALUE)")
(defvar byte-compile-depth 0 "\
Current depth of execution stack.")
(defvar byte-compile-maxdepth 0 "\
Maximum depth of execution stack.")
(defconst byte-code-vector nil "\
An array containing byte-code names indexed by byte-code values.")
(defconst byte-stack+-info nil "\
An array with the stack adjustment for each byte-code.")
(byte-code "ÀÁMˆÂÃM‡" [byte-defop (macro . #[(opcode stack-adjust opname &optional docstring) "ÀÁN®ˆÂÀÁÃÄÅ\"#ÆÁN®ˆÂÆÁÃÄÅ\"#‰	\nIˆ	Iˆ*«ŒÍ\n	ÎÏQF‡Í\n	E‡" [byte-code-vector tmp-compile-time-value put make-vector 256 nil byte-stack+-info v2 v1 opcode opname stack-adjust docstring defconst "Byte code opcode " "."] 8]) byte-extrude-byte-code-vectors (macro . #[nil "ÀÁ‰ÂNÃ‰ÂN¯ÄÁÂÅ#ˆÄÃÂÅ#ˆ‡" [setq byte-code-vector tmp-compile-time-value byte-stack+-info put nil] 6])] 2)
(defconst byte-varref 8 "\
Byte code opcode for variable reference.")
(defconst byte-varset 16 "\
Byte code opcode for setting a variable.")
(defconst byte-varbind 24 "\
Byte code opcode for binding a variable.")
(defconst byte-call 32 "\
Byte code opcode for calling a function.")
(defconst byte-unbind 40 "\
Byte code opcode for unbinding special bindings.")
(byte-code "ÀÂÄÆÈ	ÊÌÎĞÒÔÖØÚÜŞà!â#ä%æ'è)ê+ì-î/ğ1ò3ô5ö7ø9ú;ü=ş?@ AB CD EF GH IJ KL MN OP QR ST UV WX YZ [\\ ]^ _` ab cd ef gh ij kl mn op qr st uv wx yz {| }~ € ‚ ƒ„ …† ‡ˆ ‰Š ‹Œ  À‡" [56 byte-nth 57 byte-symbolp 58 byte-consp 59 byte-stringp 60 byte-listp 61 byte-eq 62 byte-memq 63 byte-not 64 byte-car 65 byte-cdr 66 byte-cons 67 byte-list1 68 byte-list2 69 byte-list3 70 byte-list4 71 byte-length 72 byte-aref 73 byte-aset 74 byte-symbol-value 75 byte-symbol-function 76 byte-set 77 byte-fset 78 byte-get 79 byte-substring 80 byte-concat2 81 byte-concat3 82 byte-concat4 83 byte-sub1 84 byte-add1 85 byte-eqlsign 86 byte-gtr 87 byte-lss 88 byte-leq 89 byte-geq 90 byte-diff 91 byte-negate 92 byte-plus 93 byte-max 94 byte-min 95 byte-mult 96 byte-point 97 byte-mark-OBSOLETE 98 byte-goto-char 99 byte-insert 100 byte-point-max 101 byte-point-min 102 byte-char-after 103 byte-following-char 104 byte-preceding-char 105 byte-current-column 106 byte-indent-to 107 byte-scan-buffer-OBSOLETE 108 byte-eolp 109 byte-eobp 110 byte-bolp 111 byte-bobp 112 byte-current-buffer 113 byte-set-buffer 114 byte-read-char-OBSOLETE 115 byte-set-mark-OBSOLETE 116 byte-interactive-p 117 byte-forward-char 118 byte-forward-word 119 byte-skip-chars-forward 120 byte-skip-chars-backward 121 byte-forward-line 122 byte-char-syntax 123 byte-buffer-substring 124 byte-delete-region 125 byte-narrow-to-region 126 byte-widen 127 byte-end-of-line] 1)
(defconst byte-constant2 129 "\
Byte code opcode for reference to a constant with vector index >= byte-constant-limit.")
(defconst byte-goto 130 "\
Byte code opcode for unconditional jump.")
(defconst byte-goto-if-nil 131 "\
Byte code opcode to pop value and jump if it's nil.")
(defconst byte-goto-if-not-nil 132 "\
Byte code opcode to pop value and jump if it's not nil.")
(defconst byte-goto-if-nil-else-pop 133 "\
Byte code opcode to examine top-of-stack, jump and don't pop it if it's nil, 
otherwise pop it.")
(defconst byte-goto-if-not-nil-else-pop 134 "\
Byte code opcode to examine top-of-stack, jump and don't pop it if it's non nil, 
otherwise pop it.")
(defconst byte-return 135 "\
Byte code opcode to pop a value and return it from `byte-code'.")
(defconst byte-discard 136 "\
Byte code opcode to discard one value from stack.")
(defconst byte-dup 137 "\
Byte code opcode to duplicate the top of the stack.")
(defconst byte-save-excursion 138 "\
Byte code opcode to make a binding to record the buffer, point and mark.")
(defconst byte-save-window-excursion 139 "\
Byte code opcode to make a binding to record entire window configuration.")
(defconst byte-save-restriction 140 "\
Byte code opcode to make a binding to record the current buffer clipping restrictions.")
(defconst byte-catch 141 "\
Byte code opcode for catch.  Takes, on stack, the tag and an expression for the body.")
(defconst byte-unwind-protect 142 "\
Byte code opcode for unwind-protect.  Takes, on stack, an expression for the unwind-action.")
(defconst byte-condition-case 143 "\
Byte code opcode for condition-case.  Takes, on stack, the variable to bind, 
an expression for the body, and a list of clauses.")
(defconst byte-temp-output-buffer-setup 144 "\
Byte code opcode for entry to with-output-to-temp-buffer.
Takes, on stack, the buffer name.
Binds standard-output and does some other things.
Returns with temp buffer on the stack in place of buffer name.")
(defconst byte-temp-output-buffer-show 145 "\
Byte code opcode for exit from with-output-to-temp-buffer.
Expects the temp buffer on the stack underneath value to return.
Pops them both, then pushes the value back on.
Unbinds standard-output and makes the temp buffer visible.")
(defconst byte-unbind-all 146 "\
Byte code opcode to unbind back to the beginning of 
this frame.  Not used yet, but wil be needed for tail-recursion elimination..")
(byte-code "ÀÂÄÆÈ	ÊÌÎĞÒÔÖØÚÜŞà!â#ä%æ'è)ê+ì-î/ğ1ò3ô5ö7ø9ú;À‡" [147 byte-set-marker 148 byte-match-beginning 149 byte-match-end 150 byte-upcase 151 byte-downcase 152 byte-string= 153 byte-string< 154 byte-equal 155 byte-nthcdr 156 byte-elt 157 byte-member 158 byte-assq 159 byte-nreverse 160 byte-setcar 161 byte-setcdr 162 byte-car-safe 163 byte-cdr-safe 164 byte-nconc 165 byte-quo 166 byte-rem 167 byte-numberp 168 byte-integerp 170 byte-rel-goto 171 byte-rel-goto-if-nil 172 byte-rel-goto-if-not-nil 173 byte-rel-goto-if-nil-else-pop 174 byte-rel-goto-if-not-nil-else-pop 175 byte-listN 176 byte-concatN 177 byte-insertN] 1)
(defconst byte-constant 192 "\
Byte code opcode for reference to a constant.")
(defconst byte-constant-limit 64 "\
Exclusive maximum index usable in the `byte-constant' opcode.")
(defconst byte-goto-ops '(byte-goto byte-goto-if-nil byte-goto-if-not-nil byte-goto-if-nil-else-pop byte-goto-if-not-nil-else-pop) "\
those byte-codes whose offset is a pc.")
(byte-code "ÀÂ‡" [(byte-goto-if-nil byte-goto-if-not-nil) byte-goto-always-pop-ops nil] 1)
(defconst byte-rel-goto-ops '(byte-rel-goto byte-rel-goto-if-nil byte-rel-goto-if-not-nil byte-rel-goto-if-nil-else-pop byte-rel-goto-if-not-nil-else-pop) "\
byte-codes for relative jumps.")
(byte-code "ÀÂÄ‡" [[nil nil nil nil nil nil nil nil byte-varref nil nil nil nil nil nil nil byte-varset nil nil nil nil nil nil nil byte-varbind nil nil nil nil nil nil nil byte-call nil nil nil nil nil nil nil byte-unbind nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil byte-nth byte-symbolp byte-consp byte-stringp byte-listp byte-eq byte-memq byte-not byte-car byte-cdr byte-cons byte-list1 byte-list2 byte-list3 byte-list4 byte-length byte-aref byte-aset byte-symbol-value byte-symbol-function byte-set byte-fset byte-get byte-substring byte-concat2 byte-concat3 byte-concat4 byte-sub1 byte-add1 byte-eqlsign byte-gtr byte-lss byte-leq byte-geq byte-diff byte-negate byte-plus byte-max byte-min byte-mult byte-point byte-mark-OBSOLETE byte-goto-char byte-insert byte-point-max byte-point-min byte-char-after byte-following-char byte-preceding-char byte-current-column byte-indent-to byte-scan-buffer-OBSOLETE byte-eolp byte-eobp byte-bolp byte-bobp byte-current-buffer byte-set-buffer byte-read-char-OBSOLETE byte-set-mark-OBSOLETE byte-interactive-p byte-forward-char byte-forward-word byte-skip-chars-forward byte-skip-chars-backward byte-forward-line byte-char-syntax byte-buffer-substring byte-delete-region byte-narrow-to-region byte-widen byte-end-of-line nil byte-constant2 byte-goto byte-goto-if-nil byte-goto-if-not-nil byte-goto-if-nil-else-pop byte-goto-if-not-nil-else-pop byte-return byte-discard byte-dup byte-save-excursion byte-save-window-excursion byte-save-restriction byte-catch byte-unwind-protect byte-condition-case byte-temp-output-buffer-setup byte-temp-output-buffer-show byte-unbind-all byte-set-marker byte-match-beginning byte-match-end byte-upcase byte-downcase byte-string= byte-string< byte-equal byte-nthcdr byte-elt byte-member byte-assq byte-nreverse byte-setcar byte-setcdr byte-car-safe byte-cdr-safe byte-nconc byte-quo byte-rem byte-numberp byte-integerp nil byte-rel-goto byte-rel-goto-if-nil byte-rel-goto-if-not-nil byte-rel-goto-if-nil-else-pop byte-rel-goto-if-not-nil-else-pop byte-listN byte-concatN byte-insertN nil nil nil nil nil nil nil nil nil nil nil nil nil nil byte-constant nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] byte-code-vector [nil nil nil nil nil nil nil nil 1 nil nil nil nil nil nil nil -1 nil nil nil nil nil nil nil -1 nil nil nil nil nil nil nil 0 nil nil nil nil nil nil nil 0 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil -1 0 0 0 0 -1 -1 0 0 0 -1 0 -1 -2 -3 0 -1 -2 0 0 -1 -1 -1 -2 -1 -2 -3 0 0 -1 -1 -1 -1 -1 -1 0 -1 -1 -1 -1 1 1 0 0 1 1 0 1 1 1 0 0 1 1 1 1 1 0 1 0 1 0 0 -1 -1 0 0 -1 -1 -1 1 0 nil 1 0 -1 -1 -1 -1 -1 -1 1 0 0 0 -1 -1 -2 0 -1 0 -2 0 0 0 0 -1 -1 -1 -1 -1 -1 -1 0 -1 -1 0 0 -1 -1 -1 0 0 nil 0 -1 -1 -1 -1 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 1 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] byte-stack+-info nil] 1)
(fset 'byte-compile-lapcode #[(lap) "ÀÁ‰‰‰‰‰‰	\nƒ\n@@\n@A9¬‰ËÌ\"ˆ‚Í=«	 ˆB‚>«	Ï\\‰	ABÁJBBB‰B‚:«ºAĞ=«¯W«	T	\\Bªû	Ï\\	ÒÓ\"ÔÕ\"BBBªâJX«‘	Ø\\	JBBªÉÙW«	T	J\\Bª³ÚW«“	Ø\\	JÙ\\BBªš	Ï\\	ÒÓ\"ÔÕ\"JÛ\\BBB\nA‰\n„ «áŸÀ‰«Ì@‰@:«¶\nA@?\n@«­\nA@\n@ZİX«¡ŞW«œ@@AA¡ˆ@A@A@ Z\\ ˆS\n‰@\\ ˆA‰¬4!«†ÀU«\"Á«À@‰@:«±A@«‘‰@A@@@ZŞ\\ ˆªš@A@	AÔ	Õ\" ˆÒ	Ó\" ˆA‰¬@)Ÿ°.‡" [0 nil tmp rel rest patchlist bytes off op pc lap error "non-symbolic opcode %s" TAG byte-goto-ops 3 byte-constant byte-constant-limit lsh -8 logand 255 byte-constant2 byte-listN 2 6 256 7 byte-compile-generate-emacs19-bytecodes -129 128 byte-rel-goto byte-goto byte-optimize] 9 "\
Turns lapcode into bytecode.  The lapcode is destroyed."])
(byte-code "ÀÀÃÄMˆÀÆÇMˆÈÉMˆÊËMˆÌÍ!¬ƒÎÏĞMˆÑÒMˆÓÔMˆÕÖMˆ×ØM‡" [nil byte-compile-current-form byte-compile-current-file byte-compile-log (macro . #[(format-string &rest args) "ÀÁÂÃÄÅÆÈÉ\n\"BBDEF‡" [and byte-optimize (memq byte-optimize-log '(t source)) let ((print-escape-newlines t) (print-level 4) (print-length 4)) byte-compile-log-1 format format-string mapcar #[(x) "9«„ÁD‡‡" [x prin1-to-string] 2] args] 11]) byte-compile-last-warned-form byte-compile-log-1 #[(string &optional fill) "«±	¬ˆ\n«£\n=¬ÄÅÆ®Ç	«	;«…È	PªˆÉÊ	!PªË#!ˆÄÌ\"ˆªâŠÎÏ!qˆdbˆ	¬ˆ\n«µ\n=¬°	«‡ĞÑ Ò±ˆÓ«†ÅÔ\"ªÇ±ˆ	«’	;«‡È	±ˆª‡ÉÊ	!±ˆÕcˆÖÒ±ˆ«’ØÒ\"¬‹ÙÚİŞ!ˆ*)Ş‰‡" [noninteractive byte-compile-current-file byte-compile-last-warned-form byte-compile-current-form message format "While compiling %s%s:" "toplevel forms" " in file " " in buffer " buffer-name "" "  %s" string get-buffer-create "*Compile-Log*" "\n\n" current-time-string "\n" "While compiling " "%s" ":\n" "  " fill string-match "     " 78 fill-column fill-prefix fill-paragraph nil] 7] byte-compile-warn #[(format &rest args) "ÀÁ	\n#«…ÄÅ	\"‡ÆÇ	PÈ\"ˆ	®„ÊË	\"‡" [apply format args byte-compile-error-on-warn error "%s" byte-compile-log-1 "** " t noninteractive message "Warning: %s"] 4] byte-compile-obsolete #[(form) "@ÁNÃÄ@\n@;«„\n@ª…ÅÆ\n@\"#ˆ\nA®Ç!)‡" [form byte-obsolete-info new byte-compile-warn "%s is an obsolete function; %s" format "use %s instead." byte-compile-normal-call] 6] boundp byte-compiler-legal-options ((optimize byte-optimize (t nil source byte) val) (file-format byte-compile-emacs18-compatibility (emacs18 emacs19) (eq val 'emacs18)) (new-bytecodes byte-compile-generate-emacs19-bytecodes (t nil) val) (delete-errors byte-compile-delete-errors (t nil) val) (verbose byte-compile-verbose (t nil) val) (warnings byte-compile-warnings ((callargs redefine free-vars unresolved)) val)) byte-compiler-options-handler #[(&rest args) "À‰‰‰ƒÂ @:«‹@AA¬…@A¬†ÆÇ@\"ˆ@@@A@‰¬…ÆÉ\"ˆÊ\n8‰@:«åÀË@Ì>­‘Í\nA@JÎ=«ƒ	ª„\nA@J!	@«¶@‰	>«‹\"ªœÒ=«…Ëª‘Ó=«…Ôª†ÆÕ	#ˆA‰¬J\nA@Lˆ+ª•	>¬†ÆÖ	#ˆ\nA@×Ø\n8!LˆA‰„ ,À‡" [nil choices desc val key args error "malformed byte-compiler-option %s" byte-compiler-legal-options "unknown byte-compiler option %s" 2 cons (+ -) copy-sequence t ret handler this + - delq "%s only accepts %s." "%s must be one of %s." eval 3] 6] byte-compile-fdefinition #[(name macro-p) "«ƒ	ª\nA‰®Ø‰9«¤Ç!«K9¬K:¬Š¬ÈK!«ˆK‰ªY¬ŠÈ!«„ªŸ:­š@É=«…Aª?­Š@Ê=?­‚)*‡" [macro-p byte-compile-macro-environment byte-compile-function-environment list name env fn fboundp compiled-function-p macro autoload] 3] byte-compile-arglist-signature #[(arglist) "ÀÁ‰«®@Æ=«‡¬ŸÀª›@Ç=«ŠA«‘ÈÁª‹«…TªƒTA‰¬R\n?­‰«…\\ª+B‡" [0 nil restp opts args arglist &optional &rest t] 4] byte-compile-arglist-signatures-congruent-p #[(old new) "@	@V®•	A¬„A®A­‰	A­…A	AW?‡" [new old] 2] byte-compile-arglist-signature-string #[(signature) "A¬†ÁÂ@\"‡@AU«†ÁÃ@\"‡ÁÄ@A#‡" [signature format "%d+" "%d" "%d-%d"] 4]] 2)
(fset 'byte-compile-callargs-warn #[(form) "À	@Â\"®…À	@Ã\"‰­Å¢Æ=«…A@ªƒÇH!	AG	«¸	@W¬A­æ	AV­ŞÊË	@	‰ÌU«ƒÍªÎ	@W«ƒÏªĞÑ!&ª»Ò	@!®µ	@=®®	@	AG‰«“A>®–AB¡ª‹	@DB‰*+‡" [byte-compile-fdefinition form nil t def byte-compile-arglist-signature lambda 0 sig ncall byte-compile-warn "%s called with %d argument%s, but %s %s" 1 "" "s" "requires" "accepts only" byte-compile-arglist-signature-string fboundp byte-compile-current-form byte-compile-unresolved-functions n cons] 9 "\
warn if the form is calling a function with the wrong number of arguments."])
(fset 'byte-compile-arglist-warn #[(form macrop) "À	A@\n\"‰«ÇÄ¢Å=«…A@ªƒÆH!ÄÇ	8!	Ê	\"®£ËÌ	@Í=«ƒÎªÏ	A@Ğ	!	Ñš«ƒÒªÓĞ!&*ªí	A@Õ‰‰‰‰­ÕÄÇ	8!ÛÜA!İ\"‰@Ÿ@@W¬A«¤AV«œËŞ	A@Ğ!ßš«ƒàªáĞB!%ˆâ\"‰-)‡" [byte-compile-fdefinition form macrop old byte-compile-arglist-signature lambda 0 2 sig2 sig1 byte-compile-arglist-signatures-congruent-p byte-compile-warn "%s %s used to take %s %s, now takes %s" defun "function" "macro" byte-compile-arglist-signature-string (1 . 1) "argument" "arguments" byte-compile-unresolved-functions nil max min sig nums calls sort copy-sequence < "%s being defined to take %s%s, but was previously called with %s" (1 . 1) " arg" " args" delq] 9 "\
warn if the function or macro is being redefined with a different
number of arguments."])
(fset 'byte-compile-warn-about-unresolved-functions #[nil "À	>«ñÂA«àÅÅGÈ!	Ê	«ÄÌ	@@!GÍ\\\\	A	SW«Ï	­ĞRªNÑ	­ĞRGÒ\\ª8ÓÔ\"ˆ,ªŠ«‡ÓÕ@@\"ˆ)Ê‡" [unresolved byte-compile-warnings "the end of the data" byte-compile-current-form byte-compile-unresolved-functions "The following functions are not known to be defined: " str L reverse rest nil s symbol-name 2 fill-column " " "," "\n    " 4 byte-compile-warn "%s" "the function %s is not known to be defined."] 4 "\
If we have compiled any calls to functions which are not known to be 
defined, issue a warning enumerating them.  You can disable this by including
'unresolved in variable byte-compile-warnings."])
(byte-code "ÀÁMˆÂÃMˆÄÅM‡" [byte-compile-constp (macro . #[(form) "ÀÁ\nDÃÄ\nDÅEDÆÇ\nDDCÈ\nÉECF‡" [cond consp form eq car 'quote not symbolp memq '(nil t)] 6]) byte-compile-close-variables (macro . #[(&rest body) "ÀÁ\nBB‡" [let ((byte-compile-macro-environment (copy-alist byte-compile-initial-macro-environment)) (byte-compile-function-environment nil) (byte-compile-bound-variables nil) (byte-compile-free-references nil) (byte-compile-free-assignments nil) (byte-compile-verbose byte-compile-verbose) (byte-optimize byte-optimize) (byte-compile-generate-emacs19-bytecodes byte-compile-generate-emacs19-bytecodes) (byte-compile-warnings (if (eq byte-compile-warnings t) byte-compile-warning-types byte-compile-warnings))) body] 3]) displaying-byte-compile-warnings (macro . #[(&rest body) "ÀÁÂÃBÅEE‡" [let ((byte-compile-warnings-point-max (if (boundp 'byte-compile-warnings-point-max) byte-compile-warnings-point-max (save-excursion (set-buffer (get-buffer-create "*Compile-Log*")) (point-max))))) unwind-protect progn body (save-excursion (set-buffer "*Compile-Log*") (if (= byte-compile-warnings-point-max (point-max)) nil (select-window (prog1 (selected-window) (select-window (display-buffer (current-buffer))) (goto-char byte-compile-warnings-point-max) (recenter 1)))))] 5])] 2)
(fset 'byte-recompile-directory #[(directory &optional arg) "À ˆÁÂ !ˆÃ!CÅ‰Æ	\nËÌ!«„ªˆŠÍÎ!qˆd)Ï\nƒŞ \n@ĞÑ\"ˆÒ!Æ‰‰ƒÔ Ã@\"@Ö¬£×!««Å=¬‰ÙÚÛQ!«Ú\nC¤\nªĞÜ\"«ÈŞ!¬Âß!‰«¹à!«ˆá\"ª‘«§Å=¬‰ÙâÛQ!«˜ã!ˆ	T	=¬ˆTA‰„I +\nA‰\n„1 *Ğä	‰åU«ƒæªçåV«‡èé\"ªæ$,‡" [save-some-buffers set-buffer-modified-p buffer-modified-p expand-file-name directory 0 nil last-dir dir-count file-count directories boundp byte-compile-warnings-point-max get-buffer-create "*Compile-Log*" ((byte-code "ŠÀqˆ	dU¬’ÂÃ ÂÄp!!ˆ	bˆÅÆ!ˆ!ˆ)Â‡" ["*Compile-Log*" byte-compile-warnings-point-max select-window selected-window display-buffer recenter 1] 5)) message "Checking %s..." directory-files dest source files ("." ".." "RCS" "CVS") file-directory-p arg y-or-n-p "Check " "? " string-match emacs-lisp-file-regexp auto-save-file-name-p byte-compile-dest-file file-exists-p file-newer-than-file-p "Compile " byte-compile-file "Done (Total of %d file%s compiled%s)" 1 "" "s" format " in %d directories"] 8 "\
Recompile every `.el' file in DIRECTORY that needs recompilation.
This is if a `.elc' file exists but is older than the `.el' file.

If the `.elc' file does not exist, normally the `.el' file is *not* compiled.
But a prefix argument (optional second arg) means ask user,
for each such `.el' file, whether to compile it.  Prefix argument 0 means
don't ask and compile the file anyway." "DByte recompile directory: \nP"])
(fset 'byte-compile-file #[(filename &optional load) "À	!\n¬¡ÃÀ	!!‰«—Å!«’ÆÇÈÉ!\"!«ˆŠqˆÊ ˆ))«…ÌÍ	\"ˆÎ	!ÏŠÒÓ!qˆÔ ˆÕ	!ˆ	× ˆ)ØpÙp!qˆ!ˆdbˆÚcˆÛİ	!¬…Ïßàˆá!«Ï\"ãäd#ˆ)ª’åæçè!«ƒéªêE\"ˆ¬…Ïëìˆ)Øp!ˆ)-«”-Û=¬ˆÆÇî	\"!«†Šï	!ˆ)0«…ğ!ˆ*Û‡" [expand-file-name filename noninteractive get-file-buffer b buffer-modified-p y-or-n-p format "save buffer %s first? " buffer-name save-buffer byte-compile-verbose message "Compiling %s..." file-name-nondirectory nil target-file byte-compile-current-file get-buffer-create " *Compiler Input*" erase-buffer insert-file-contents buffer-file-name set-auto-mode kill-buffer byte-compile-from-buffer "\n" t vms-stmlf-recfm byte-compile-dest-file byte-compile-overwrite-file (delete-file target-file) ((error)) file-writable-p kanji-flag write-region 1 signal file-error "Opening output file" file-exists-p "cannot overwrite file" "directory not writable or nonexistent" (byte-code "À	Â!\"‡" [set-file-modes target-file file-modes filename] 4) ((error)) byte-compile-generate-call-tree "Report call tree for %s? " byte-compile-report-call-tree load] 6 "\
Compile a file of Lisp code named FILENAME into a file of byte code.
The output file's name is made by appending `c' to the end of FILENAME.
With prefix arg (noninteractively: 2nd arg), load the file after compiling." (byte-code "Á‰‰«‘ÅÆ AÇ=«ˆÈ!É!ÊË!«„¬†Í™«Î«ƒĞªÑ\nÁ$ªÎ«ƒĞªÑ\nÁ‰%+D‡" [buffer-file-name nil file-dir file-name file major-mode buffer-local-variables emacs-lisp-mode file-name-nondirectory file-name-directory boundp epoch::version emacs-version "19" read-file-name current-prefix-arg "Byte compile and load file: " "Byte compile file: "] 7)])
(fset 'byte-compile-and-load-file #[(&optional filename) "«…ÁÂ\"‡ÃÅÁ!)‡" [filename byte-compile-file t (4) current-prefix-arg call-interactively] 3 "\
Compile a file of Lisp code named FILENAME into a file of byte code,
and then load it.  The output file's name is made by appending \"c\" to 
the end of FILENAME." nil])
(fset 'byte-compile-buffer #[(&optional buffer) "«…Á!ªpÂÃÄ!\"ˆÅ!®†ÆÄ!ÇQ	ÊË\"ˆ*ÂÌÄ!\"ˆË‡" [buffer get-buffer message "Compiling %s..." buffer-name buffer-file-name "#<buffer " ">" filename byte-compile-current-file byte-compile-from-buffer t "Compiling %s...done"] 4 "\
Byte-compile and evaluate contents of BUFFER (default: the current buffer)." "bByte compile buffer: "])
(fset 'elisp-compile-defun #[(&optional arg) "ŠÀ ˆÁ ˆÂÄÆÇÈp!!!	\n«ËÌ!ˆÍ	p\"ˆÎcª‡ËÏĞ	!\",‡" [end-of-defun beginning-of-defun nil byte-compile-current-file nothing byte-compile-last-warned-form eval byte-compile-sexp read value arg message "Compiling from buffer... done." prin1 "\n" "%s" prin1-to-string] 4 "\
Compile and evaluate the current top-level form.
Print the result in the minibuffer.
With argument, insert value in current buffer after the form." "P"])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏĞÑ#ˆÑÒMˆÎÓĞÔ#ˆÔÕMˆÎÖĞ×#ˆÎØĞ×#ˆ×ÙMˆÎÚĞÛ#ˆÛÜMˆÎİĞŞ#ˆÎßĞŞ#ˆÎàĞŞ#ˆŞáMˆÎâĞã#ˆãäMˆÎåĞæ#ˆæçMˆÎèĞé#ˆéêMˆëìM‡" [byte-compile-from-buffer #[(inbuffer &optional eval) "ÀÂÀ‰‰‰Ã‰‰À	\nÍ!À‰‰‰Ó=«„ª‚ŠÚÛ!qÜ ˆÀ)İŞ!«„ªˆŠÚß!qˆd)àŠ!qˆâbˆãÀwˆäå!«…âyˆªrm¬‰æç!!!ˆªfè ˆ)¬ƒê ˆë ˆÀ,+Š	qˆebˆ.)¬ƒ	ª’Àíî«‡é/!ˆªsğ	!ˆÀ)‡" [nil outbuffer "%20e" 0 byte-compile-output byte-compile-maxdepth byte-compile-depth byte-compile-tag-number byte-compile-variables byte-compile-constants print-length case-fold-search float-output-format copy-alist byte-compile-initial-macro-environment byte-compile-verbose byte-optimize byte-compile-generate-emacs19-bytecodes byte-compile-warnings t byte-compile-warning-types byte-compile-free-assignments byte-compile-free-references byte-compile-bound-variables byte-compile-function-environment byte-compile-macro-environment get-buffer-create " *Compiler Output*" erase-buffer boundp byte-compile-warnings-point-max "*Compile-Log*" ((byte-code "ŠÀqˆ	dU¬’ÂÃ ÂÄp!!ˆ	bˆÅÆ!ˆ!ˆ)Â‡" ["*Compile-Log*" byte-compile-warnings-point-max select-window selected-window display-buffer recenter 1] 5)) inbuffer 1 " 	\n" looking-at ";" byte-compile-file-form read byte-compile-flush-pending eval byte-compile-insert-header byte-compile-warn-about-unresolved-functions byte-compile-unresolved-functions (byte-code "À	!Ã‡" [read outbuffer form t] 2) ((end-of-file)) form kill-buffer] 10] byte-compile-insert-header #[nil "ŠqˆÁbˆÂÃ ÄÅ ÆÇ È	Ê±	ˆËÍ±ˆÎĞÒ=«ƒÓª‘Ô=«ƒÕªˆ«ƒÖª×«ƒÙªÍ±ˆ­‡ÛÜİŞß±)‡" [outbuffer 1 ";;; compiled by " user-login-name "@" system-name " on " current-time-string "\n;;; from file " filename "\n" ";;; emacs version " emacs-version ".\n" ";;; bytecomp version " byte-compile-version "\n;;; " byte-optimize source "source-level optimization only" byte "byte-level optimization only" "optimization is on" "optimization is off" byte-compile-emacs18-compatibility "; compiled with emacs18 compatibility.\n" byte-compile-generate-emacs19-bytecodes ";;; this file uses opcodes which do not exist in Emacs18.\n" "\n(if (and (boundp 'emacs-version)\n" "	 (or (and (boundp 'epoch::version) epoch::version)\n" "	     (string-lessp emacs-version \"19\")))\n" "    (error \"This file was compiled for Emacs19.\"))\n"] 9] byte-compile-output-file-form #[(form) "¢Á>«‹Â8;«…ÃÄ\"‡Å‰Æ	ÊË\"ˆÍ\"ˆ+Æ‡" [form (defun defmacro defvar defconst autoload) 3 byte-compile-output-docform ("\n(" 3 ")") t nil print-gensym print-readably print-escape-newlines princ "\n" outbuffer prin1] 3] byte-compile-output-docform #[(info form) "pqˆ	@cˆ	A@\n›Ã‰ÄÉ\n@\"ˆ\nA‰«§Êcˆ\n=«–Ä`TÉ\n@\"ˆbˆËcˆdbˆ)ª[É\n@\"ˆªS,Ì	8cˆqˆÄ‡" [outbuffer info form t nil print-gensym print-readably print-escape-newlines docl prin1 " " "\\\n" 2] 5] byte-compile-keep-pending #[(form &optional handler) "Á>«…ÂÄ\"« Ä¢Ç=«‰È	›«ƒÊ ˆ!ˆ«ƒË ˆ)ª…ÌÄ\"ˆÍ‡" [byte-optimize (t source) byte-optimize-form form t handler for-effect fset 300 byte-compile-output byte-compile-flush-pending byte-compile-discard byte-compile-form nil] 3] byte-compile-flush-pending #[nil "­ªÁÂÃ\"‰¢Å=«ˆÆÇA\"ˆª‡«„Ç!ˆÈ	È\nËËÈ‰)‡" [byte-compile-output byte-compile-out-toplevel t file form progn mapcar byte-compile-output-file-form nil byte-compile-constants byte-compile-variables 0 byte-compile-depth byte-compile-maxdepth] 4] byte-compile-file-form #[(form) "À‰:¬…Ä!ª¯@9«—@ÅN‰«	!‰­›Æ ˆÇ!ª“È	\"‰=«…Ä!ªƒÊ!*‡" [nil handler byte-compile-current-form form byte-compile-keep-pending byte-hunk-handler byte-compile-flush-pending byte-compile-output-file-form macroexpand byte-compile-macro-environment byte-compile-file-form] 4] put defsubst byte-hunk-handler byte-compile-file-form-defsubst #[(form) "A@	«‹A@ÃÄA@\"ˆÅÆ\"!ˆÈ‡" [form byte-compile-unresolved-functions byte-compile-current-form byte-compile-warn "defsubst %s was used before it was defined" byte-compile-file-form macroexpand byte-compile-macro-environment nil] 4] autoload byte-compile-file-form-autoload #[(form) "A‰«—@:«‡@@Á=ª‰@9«i@Â>¬c)¬‹ÃÄ8!«„Ã!ˆÅ8;«‚‡ÆÇ\"‡" [form quote (nil t) eval 5 3 byte-compile-keep-pending byte-compile-normal-call] 3] defvar byte-compile-file-form-defvar defconst #[(form) "À	8¬„Â	!‡Ã>«†	A@BÆ	8:«Ç	!‰AAÈÆ	8ÉÊ# ˆ	‡" [3 form byte-compile-keep-pending free-vars byte-compile-warnings byte-compile-bound-variables 2 copy-sequence byte-compile-top-level nil file] 6] require byte-compile-file-form-eval-boundary #[(form) "À	!ˆÂ	Ã\"‡" [eval form byte-compile-keep-pending byte-compile-normal-call] 3] progn byte-compile-file-form-progn prog1 prog2 #[(form) "ÀÁ\nA\"ˆÃ‡" [mapcar byte-compile-file-form form nil] 3] eval byte-compile-file-form-eval #[(form) "A@¢Á=«†A@A@‡Â!‡" [form quote byte-compile-keep-pending] 2] defun byte-compile-file-form-defun #[(form) "À	Â\"‡" [byte-compile-file-form-defmumble form nil] 3] defmacro byte-compile-file-form-defmacro #[(form) "À	Â\"‡" [byte-compile-file-form-defmumble form t] 3] byte-compile-file-form-defmumble #[(form macrop) "A@\n«ƒÃªÄ\n«ƒÄªÃ	J	JÉ\nÉ«	¬‰	É‰EB	Ï>«…Ñ\n\"ˆ«ŒÓÔ®ÖA@#ˆ«œÏ>«A@¬‡ØÙA@\"ˆÉ¡ˆªØ«Ï>«ÎA@¬ÆØÚ\n«ƒÛªÜA@#ˆª¶İ	!«±	K¢\n«ƒŞªß=«¤Ï>«•Øà\n«ƒÜªÛA@\n«ƒÛªÜ$ˆ	ÉBJBLˆá›‰\"@;«œ\"£¢9«•\"£¢«\"££¢;«‡ØãA@\"ˆ)äŞAAB!%æ%!'«ˆ%¡ˆªŠ	%BJBLˆá8;«œ'¢è=«•'A@¢Ş=«Œ@	'A@ABBªùá8;¬¬éêè	D\n¬„'ª›'¢ë=«‡ìí'Eªè\n«†ß%Bª‚%DEî\"ªÇï ˆğñ2\"ˆó	2\"ˆô':¬‰\n«ƒõªöª›'@è=«%'\n«ƒ÷ªŠøª‡\n«ƒùªúû'É\"\"ˆğü2\"ˆÉ.	‡" [form name macrop byte-compile-macro-environment byte-compile-function-environment this-kind that-kind this-one that-one nil byte-compile-free-references byte-compile-free-assignments byte-compile-generate-call-tree byte-compile-call-tree byte-compile-current-form redefine byte-compile-warnings byte-compile-arglist-warn byte-compile-verbose message "Compiling %s (%s)..." filename "" byte-compile-initial-macro-environment byte-compile-warn "%s defined multiple times, as both function and macro" "%s %s defined multiple times in this file" "macro" "function" fboundp lambda macro "%s %s being redefined as a %s" 3 body "Probable `\"' without `\\' in doc string of %s" byte-compile-lambda new-one byte-compile-byte-code-maker code quote byte-compile-keep-pending fset make-byte-code cons 'macro byte-compile-two-args byte-compile-flush-pending princ "\n(fset '" outbuffer prin1 byte-compile-output-docform (" '(macro . #[" 4 "])") (" #[" 4 "]") (" '(macro " 2 ")") (" '(" 2 ")") (" (cons 'macro (" 5 "))") (" (" 5 ")") append ")"] 7]] 4)
(fset 'byte-compile #[(form) "ÀÁ!«ƒ	ªˆŠÂÃ!qˆd)ÄÅ!Ç‰‰‰	\nÌ=«„ª‚\n	9«‹Ô!­‡Kª‚‰¢Ö=‰«…A¢×=­ «ˆÖØ!Bª„Ø!9«‡Mª‚.‡" [boundp byte-compile-warnings-point-max get-buffer-create "*Compile-Log*" ((byte-code "ŠÀqˆ	dU¬’ÂÃ ÂÄp!!ˆ	bˆÅÆ!ˆ!ˆ)Â‡" ["*Compile-Log*" byte-compile-warnings-point-max select-window selected-window display-buffer recenter 1] 5)) copy-alist byte-compile-initial-macro-environment nil byte-compile-verbose byte-optimize byte-compile-generate-emacs19-bytecodes byte-compile-warnings t byte-compile-warning-types byte-compile-free-assignments byte-compile-free-references byte-compile-bound-variables byte-compile-function-environment byte-compile-macro-environment form fboundp fun macro lambda byte-compile-lambda] 11 "\
If FORM is a symbol, byte-compile its function definition.
If FORM is a lambda or a macro, byte-compile it as a function."])
(fset 'byte-compile-sexp #[(sexp) "ÀÁ!«ƒ	ªˆŠÂÃ!qˆd)ÄÅ!Ç‰‰‰	\nÌ=«„ª‚\n	Ó!.‡" [boundp byte-compile-warnings-point-max get-buffer-create "*Compile-Log*" ((byte-code "ŠÀqˆ	dU¬’ÂÃ ÂÄp!!ˆ	bˆÅÆ!ˆ!ˆ)Â‡" ["*Compile-Log*" byte-compile-warnings-point-max select-window selected-window display-buffer recenter 1] 5)) copy-alist byte-compile-initial-macro-environment nil byte-compile-verbose byte-optimize byte-compile-generate-emacs19-bytecodes byte-compile-warnings t byte-compile-warning-types byte-compile-free-assignments byte-compile-free-references byte-compile-bound-variables byte-compile-function-environment byte-compile-macro-environment byte-compile-top-level sexp] 10 "\
Compile and return SEXP."])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑMˆÒÓMˆÔÕMˆÖ×MˆØÙMˆÚÛMˆÜİMˆŞßMˆàáâã#ˆàäâå#ˆàæâå#ˆàçâå#ˆàèâå#ˆàéâå#ˆàêâë#ˆàìâë#ˆàíâë#ˆàîâë#ˆàïâğ#ˆàñòó#ˆàñôõ#ˆàõâñ#ˆàöòó#ˆàöô÷#ˆà÷âö#ˆàøòó#ˆàøôù#ˆàùâø#ˆàúòó#ˆàúôõ#ˆàõâú#ˆàûòó#ˆàûô÷#ˆà÷âû#ˆàüòó#ˆàüôù#ˆàùâü#ˆàıòó#ˆàıôş#ˆàşâı#ˆàÿòó#ˆàÿô@ #ˆà@ âÿ#ˆàA òó#ˆàA ôB #ˆàB âA #ˆàC òó#ˆàC ôD #ˆàD âC #ˆàE òó#ˆàE ôF #ˆàF âE #ˆàG òó#ˆàG ôH #ˆàH âG #ˆàI òó#ˆàI ôJ #ˆàJ âI #ˆàK òó#ˆàK ôL #ˆàL âK #ˆàM òó#ˆàM ôN #ˆàN âM #ˆàO P Q #ˆàR òó#ˆàR ôO #ˆàO âR #ˆàS P Q #ˆàT òU #ˆàT ôS #ˆàS âT #ˆàV P Q #ˆàW òU #ˆàW ôV #ˆàV âW #ˆàX P Q #ˆàY òU #ˆàY ôX #ˆàX âY #ˆàZ ò[ #ˆàZ ô\\ #ˆà\\ âZ #ˆà] ò[ #ˆà] ô^ #ˆà^ â] #ˆà_ ò[ #ˆà_ ô` #ˆà` â_ #ˆàa ò[ #ˆàa ôb #ˆàb âa #ˆàc ò[ #ˆàc ôd #ˆàd âc #ˆàe ò[ #ˆàe ôd #ˆàd âe #ˆàf ò[ #ˆàf ôg #ˆàg âf #ˆàh ò[ #ˆàh ôi #ˆài âh #ˆàj ò[ #ˆàj ôk #ˆàk âj #ˆàl ò[ #ˆàl ôm #ˆàm âl #ˆàn ò[ #ˆàn ôo #ˆào ân #ˆàp ò[ #ˆàp ôq #ˆàq âp #ˆàr ò[ #ˆàr ôs #ˆàs âr #ˆàt ò[ #ˆàt ôu #ˆàu ât #ˆàv ò[ #ˆàv ôw #ˆàw âv #ˆàx ò[ #ˆàx ôy #ˆày âx #ˆàz P Q #ˆà{ ò[ #ˆà{ ôz #ˆàz â{ #ˆà| P Q #ˆà} ò[ #ˆà} ô| #ˆà| â} #ˆà~ P Q #ˆà ò[ #ˆà ô~ #ˆà~ â #ˆà€ P Q #ˆà ò[ #ˆà ô€ #ˆà€ â #ˆà‚ P Q #ˆàƒ ò[ #ˆàƒ ô‚ #ˆà‚ âƒ #ˆà„ P Q #ˆà… ò[ #ˆà… ô„ #ˆà„ â… #ˆà† P Q #ˆà‡ ò[ #ˆà‡ ô† #ˆà† â‡ #ˆàˆ P Q #ˆà‰ òŠ #ˆà‰ ôˆ #ˆàˆ â‰ #ˆà‹ P Q #ˆàŒ òŠ #ˆàŒ ô‹ #ˆà‹ âŒ #ˆà ò #ˆà ô #ˆà â #ˆà ò #ˆà ô #ˆà â #ˆà‘ ò #ˆà‘ ô’ #ˆà’ â‘ #ˆà“ ò #ˆà“ ô” #ˆà” â“ #ˆà• ò #ˆà• ô– #ˆà– â• #ˆà— ò #ˆà— ô˜ #ˆà˜ â— #ˆà™ ò #ˆà™ ôš #ˆàš â™ #ˆà› ò #ˆà› ôœ #ˆàœ â› #ˆà ò #ˆà ô #ˆà â #ˆàŸ ò #ˆàŸ ô  #ˆà  âŸ #ˆà¡ ò #ˆà¡ ô¢ #ˆà¢ â¡ #ˆà£ ò #ˆà£ ô¤ #ˆà¤ â£ #ˆà¥ ò #ˆà¥ ô¦ #ˆà¦ â¥ #ˆà§ ò¨ #ˆà§ ô© #ˆà© â§ #ˆàª P Q #ˆà« ò¨ #ˆà« ôª #ˆàª â« #ˆàª P Q #ˆà¬ ò¨ #ˆà¬ ôª #ˆàª â¬ #ˆà­ P Q #ˆà® ò[ #ˆà® ô­ #ˆà­ â® #ˆà¯ P Q #ˆà° ò[ #ˆà° ô¯ #ˆà¯ â° #ˆà± P Q #ˆà² ò[ #ˆà² ô± #ˆà± â² #ˆà³ P Q #ˆà´ ò[ #ˆà´ ô³ #ˆà³ â´ #ˆàµ P Q #ˆà¶ ò #ˆà¶ ôµ #ˆàµ â¶ #ˆà· P Q #ˆà¸ ò #ˆà¸ ô· #ˆà· â¸ #ˆàµ P Q #ˆà¹ ò #ˆà¹ ôµ #ˆàµ â¹ #ˆà· P Q #ˆàº ò #ˆàº ô· #ˆà· âº #ˆà» P Q #ˆà¼ ò #ˆà¼ ô» #ˆà» â¼ #ˆà½ P Q #ˆà¾ ò #ˆà¾ ô½ #ˆà½ â¾ #ˆà¿ P Q #ˆàÀ ò #ˆàÀ ô¿ #ˆà¿ âÀ #ˆàÁ P Q #ˆàÂ ò #ˆàÂ ôÁ #ˆàÁ âÂ #ˆàÃ P Q #ˆàÄ ò #ˆàÄ ôÃ #ˆàÃ âÄ #ˆàÅ P Q #ˆàÆ ò #ˆàÆ ôÅ #ˆàÅ âÆ #ˆàÇ P Q #ˆàÈ ò #ˆàÈ ôÇ #ˆàÇ âÈ #ˆàÅ P Q #ˆàÉ ò #ˆàÉ ôÅ #ˆàÅ âÉ #ˆàÇ P Q #ˆàÊ ò #ˆàÊ ôÇ #ˆàÇ âÊ #ˆàË P Q #ˆàÌ ò #ˆàÌ ôË #ˆàË âÌ #ˆàÍ P Q #ˆàÎ ò #ˆàÎ ôÍ #ˆàÍ âÎ #ˆàÏ P Q #ˆàĞ ò #ˆàĞ ôÏ #ˆàÏ âĞ #ˆàÑ P Q #ˆàÒ ò #ˆàÒ ôÑ #ˆàÑ âÒ #ˆàÑ P Q #ˆàÓ ò #ˆàÓ ôÑ #ˆàÑ âÓ #ˆàÔ òÕ #ˆàÔ ôÖ #ˆàÖ âÔ #ˆà× òØ #ˆà× ôÙ #ˆàÙ â× #ˆàÚ òØ #ˆàÚ ôÛ #ˆàÛ âÚ #ˆàÜ òØ #ˆàÜ ôİ #ˆàİ âÜ #ˆàŞ P Q #ˆàß òØ #ˆàß ôŞ #ˆàŞ âß #ˆàà òá #‡" [byte-compile-byte-code-maker #[(fun) "«†ÁÂ!D‡:¬‚‡ÄÆA£‰«Ó>A¬ÍÇAAÈÁA@DA@É8Ê8¯É8;«†É8Cª†­‚ÄC¤­šA@«‡A@;«†A@ª†ÁA@DC¤)ªƒÁD)‡" [byte-compile-emacs18-compatibility quote byte-compile-byte-code-unmake fun nil tmp byte-code interactive make-byte-code 2 3] 6] byte-compile-byte-code-unmake #[(function) ":«‚‡ÁÂ\"Ã@DÄ8­„Ä8C¤Å›­‹ÆÅ8­ƒÅ›BC¤ÇA@È8É8FC¤‡" [function append nil lambda 4 5 interactive byte-code 2 3] 6] byte-compile-lambda #[(fun) "A@Â>­‰ÄÅÄÆÇ	!\"\"¤AA‰	@;­ˆ	@	A	\nË	‰«ª	@=«…	A	A«˜AA«ˆÍÎÏ!\"ˆËĞA@!DĞÑ	BÒÓ#‰¢Õ=«¤« ×ØÙ	CA\n¬„­ƒ\nC­…A@C$\"ª¼­ƒC¢Ñ=«…Aª‡­ƒC¤Ó	D\n¬†@;«\n®†	­‚ÒCBª‚¤.‡" [fun arglist free-vars byte-compile-warnings delq &rest &optional copy-sequence byte-compile-bound-variables body doc interactive int byte-compile-warn "malformed interactive spec: %s" prin1-to-string byte-compile-top-level progn nil lambda compiled byte-code byte-compile-generate-emacs19-bytecodes apply make-byte-code append] 8] byte-compile-constants-vector #[nil "À\nŸŸÆÆÉ\nÆ¬ƒ«Ã\n@«¯	=¬©@@‰«‰@A¡ˆª@	T‰¡ˆ@BA‰¬Q\nA\n‰ª8ÌÍÎÏ\"Ÿ\".‡" [-1 i byte-compile-variables rest byte-compile-constants other nil ret tmp (5 63 255 65535) limits limit apply vector mapcar car] 6] byte-compile-top-level #[(form &optional for-effect output-type) "À‰Á‰‰ÀÉ>«ˆÊ\"¢Í=«AA¬‰A@‰ªl¢Î=«¡Ï>¬›A@;«”ĞÑ8!«ŒÒÓ8!«„ªÔ\"ˆÕ\".‡" [nil 0 byte-compile-output byte-compile-maxdepth byte-compile-depth byte-compile-tag-number byte-compile-variables byte-compile-constants byte-optimize (t source) byte-optimize-form form for-effect progn byte-code (t byte) vectorp 2 natnump 3 byte-compile-form byte-compile-out-toplevel output-type] 7] byte-compile-out-toplevel #[(&optional for-effect output-type) "«¸	@@Â=«…	Aª¬ÃÄ?­£Æ!‰«–@@9¬@@§¬ˆA‰¬j@@)!ˆÈÉÊ\"ˆ	ŸÌ>«…Í	\"ÄÏ=?Ä‰Ó=«ƒÔªÕ	›„PÖ	„PÉ	‰ƒPÆ	!>AŸ‰@@×>«º@A@@@Ø=«¡:¬‹9«—Ù>¬‘ƒ@ÚDB‰ªøB‰ªî«õÛ›¬ï@@ÜN‰«äA«šİ>«ÙAA«ÓA@@Â=«ÊAÄŸŞ=«“@¢Ú=«‹@A@ABª…BCÓ=¬ßÄàá@A\"\"?«‰A‰‚‡ ¬Œ@:«–Ï=«â #äå	!#&F)ªA«‡çŸBªƒ@,‡" [for-effect byte-compile-output byte-discard byte-compile-push-constant nil byte-compile-constants reverse tmp byte-compile-out byte-return 0 byte-optimize (t byte) byte-optimize-lapcode output-type lambda body maycall rest file 50 8 TAG (byte-varref byte-constant) byte-constant (nil t) quote 3 byte-opcode-invert (file progn t) funcall delq mapcar consp byte-compile-constants-vector byte-compile-vector byte-code byte-compile-lapcode byte-compile-maxdepth progn] 6] byte-compile-top-level-body #[(body &optional for-effect) "ÀÁ\nBÄ#‰¢Á=«ƒ\nA‡\n­‚\nC‡" [byte-compile-top-level progn body for-effect t] 5] byte-compile-form #[(form &optional for-effect) "À	\n\"‰:¬¡	9«…	Ã>«†Ä	!ˆª÷«ˆ«„ÇªìÈÉ	\"ˆªå	@9«½	@‰\nËN\nÍ>«†ÎÏ\n\"ˆ«“¬ˆ\nÑNÒN¬‡	!ˆªÓ>«„Õ	!ˆÖ	!ˆ*ª£×	@!¬‡	@¢Ø=«’	Ù	!‰=¬‰Ú	\"ˆÇª„Ö	!ˆ­‚Û ‡" [macroexpand form byte-compile-macro-environment (nil t) byte-compile-constant for-effect byte-compile-delete-errors nil byte-compile-variable-ref byte-varref fn byte-compile handler (t nil) byte-compile-warn "%s called as a function" byte-compile-generate-emacs19-bytecodes byte-opcode emacs19-opcode callargs byte-compile-warnings byte-compile-callargs-warn byte-compile-normal-call compiled-function-p lambda byte-compile-unfold-lambda byte-compile-form byte-compile-discard] 4] byte-compile-normal-call #[(form) "«„Á\n!ˆÃ\n@!ˆÄÅ\nA\"ˆÆÇ\nAG\"‡" [byte-compile-generate-call-tree byte-compile-annotate-call-tree form byte-compile-push-constant mapcar byte-compile-form byte-compile-out byte-call] 3] byte-compile-variable-ref #[(base-op var) "9«…Á>«™ÂÄ=«ƒÅªÆ9«ƒÇªÈÉ!#ˆªåÊN«™ÊNÂÌ;«„ª…ÍÎ\"#ˆ)Ï>«ÁÄ=«ˆBª´Ò!¬¯>¬©Ó=«“>¬ÂÕ\"ˆBª‘>¬‹Â×\"ˆB‰¬ŠC‰BÚ\")‡" [var (nil t) byte-compile-warn base-op byte-varbind "Attempt to let-bind %s %s" "Variable reference to %s %s" "constant" "nonvariable" prin1-to-string byte-obsolete-variable ob "%s is an obsolete variable; %s" format "use %s instead." free-vars byte-compile-warnings byte-compile-bound-variables boundp byte-varset byte-compile-free-assignments "assignment to free variable %s" byte-compile-free-references "reference to free variable %s" byte-compile-variables tmp byte-compile-out] 7] byte-compile-get-constant (macro . #[(const) "ÀÁÂDÄÅEÆÅEFÇÈÅÉÊDÅEEDE‡" [or if stringp const assoc byte-compile-constants assq car setq cons list] 8]) byte-compile-constant #[(const) "«„Á‰‡ÂÃ;«‡Å\"ª„®‰CB‰@\"‡" [for-effect nil byte-compile-out byte-constant const assoc byte-compile-constants] 5] byte-compile-push-constant #[(const) "À\n	«…À‰ªÃÄ\n;«‡Å\n\"ª„\n®‰\nCB‰@\"*‡" [nil for-effect const byte-compile-out byte-constant assoc byte-compile-constants] 5] byte-defop-compiler (macro . #[(function &optional compile-handler) "À\n9«ŠÃÄÅ\n!P!ª‡\nA@\n@ÆÇ\nDÈÇ	ÊA®‹	®‡ÃËÅ\n!P!DF	«˜ÍÆÇ\nDÎÇ	DFÆÇ	DÏÇ\nDFFª‚*‡" [nil opcode function intern "byte-" symbol-name put quote 'byte-compile compile-handler ((0 . byte-compile-no-args) (1 . byte-compile-one-arg) (2 . byte-compile-two-args) (3 . byte-compile-three-args) (0-1 . byte-compile-zero-or-one-arg) (1-2 . byte-compile-one-or-two-args) (2-3 . byte-compile-two-or-three-args)) "byte-compile-" fnform progn 'byte-opcode 'byte-opcode-invert] 8]) byte-defop-compiler19 (macro . #[(function &optional compile-handler) "ÀÁÂ£@®‹ÄÅÆ¢®!P!DÇÈFÉ\nEE‡" [progn put quote function intern "byte-" symbol-name 'emacs19-opcode t byte-defop-compiler compile-handler] 7]) byte-defop-compiler-1 (macro . #[(function &optional compile-handler) "À	ÂDE‡" [byte-defop-compiler function nil compile-handler] 3]) put byte-call byte-opcode-invert funcall byte-list1 list byte-list2 byte-list3 byte-list4 byte-listN byte-concat2 concat byte-concat3 byte-concat4 byte-concatN byte-insertN insert dot byte-compile byte-compile-no-args byte-opcode byte-point dot-max byte-point-max dot-min byte-point-min point point-max point-min following-char byte-following-char preceding-char byte-preceding-char current-column byte-current-column eolp byte-eolp eobp byte-eobp bolp byte-bolp bobp byte-bobp current-buffer byte-current-buffer interactive-p byte-interactive-p byte-widen emacs19-opcode t widen byte-end-of-line end-of-line byte-compile-zero-or-one-arg byte-forward-char forward-char byte-forward-line forward-line symbolp byte-compile-one-arg byte-symbolp consp byte-consp stringp byte-stringp listp byte-listp not byte-not null car byte-car cdr byte-cdr length byte-length symbol-value byte-symbol-value symbol-function byte-symbol-function 1+ byte-add1 1- byte-sub1 goto-char byte-goto-char char-after byte-char-after set-buffer byte-set-buffer byte-forward-word forward-word byte-char-syntax char-syntax byte-nreverse nreverse byte-car-safe car-safe byte-cdr-safe cdr-safe byte-numberp numberp byte-integerp integerp byte-skip-chars-forward skip-chars-forward byte-compile-one-or-two-args byte-skip-chars-backward skip-chars-backward eql byte-compile-two-args byte-eq eq memq byte-memq cons byte-cons aref byte-aref set byte-set = byte-eqlsign < byte-lss > byte-gtr <= byte-leq >= byte-geq get byte-get nth byte-nth substring byte-compile-two-or-three-args byte-substring byte-set-marker move-marker set-marker byte-match-beginning match-beginning byte-match-end match-end byte-upcase upcase byte-downcase downcase byte-string= string= byte-string< string< string-equal string-lessp byte-equal equal byte-nthcdr nthcdr byte-elt elt byte-member member byte-assq assq byte-setcar rplaca byte-setcdr rplacd setcar setcdr byte-buffer-substring buffer-substring byte-delete-region delete-region byte-narrow-to-region narrow-to-region byte-rem mod % aset byte-compile-three-args byte-aset max byte-compile-associative byte-max min byte-min + byte-plus byte-mult * interactive byte-compile-noop] 4)
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑMˆÒÓMˆÔÕMˆÖ×ØÙ#ˆÖ×ÚÛ#ˆÖÛÜ×#ˆÖİØŞ#ˆÖİÚß#ˆÖßÜİ#ˆÖàØá#ˆÖàÚâ#ˆÖâÜà#ˆÖãØä#ˆÖãÚå#ˆÖåÜã#ˆÖæØä#ˆÖæÚå#ˆÖåÜæ#ˆÖçØè#ˆÖçÚé#ˆÖéÜç#ˆÖêØë#ˆÖìØí#ˆÖîïğ#ˆÖñØò#ˆÖñÚî#ˆÖîÜñ#ˆÖóïğ#ˆÖôØõ#ˆÖôÚó#ˆÖóÜô#ˆÖöØ÷#ˆÙøMˆŞùMˆíúMˆòûMˆõüMˆáıMˆşÿMˆë@ MˆäA MˆèB Mˆ÷C MˆÖD ØE #ˆÖF ØG #ˆÖH ØI #ˆÖJ ØK #ˆE L MˆG M MˆI N MˆK O M‡" [byte-compile-subr-wrong-args #[(form n) "ÀÁ\n@\nAG\nAGÃU«ƒÄªÅ%ˆÇ\n!‡" [byte-compile-warn "%s called with %d arg%s, but requires %s" form 1 "" "s" n byte-compile-normal-call] 6] byte-compile-no-args #[(form) "GÁU¬…ÂÃ\"‡Ä@ÅNÆ\"‡" [form 1 byte-compile-subr-wrong-args "none" byte-compile-out byte-opcode 0] 3] byte-compile-one-arg #[(form) "GÁU¬…ÂÃ\"‡ÄA@!ˆÅ@ÆNÇ\"‡" [form 2 byte-compile-subr-wrong-args 1 byte-compile-form byte-compile-out byte-opcode 0] 3] byte-compile-two-args #[(form) "GÁU¬…ÂÃ\"‡ÄA@!ˆÄÃ8!ˆÅ@ÆNÇ\"‡" [form 3 byte-compile-subr-wrong-args 2 byte-compile-form byte-compile-out byte-opcode 0] 3] byte-compile-three-args #[(form) "GÁU¬…ÂÃ\"‡ÄA@!ˆÄÅ8!ˆÄÃ8!ˆÆ@ÇNÈ\"‡" [form 4 byte-compile-subr-wrong-args 3 byte-compile-form 2 byte-compile-out byte-opcode 0] 3] byte-compile-zero-or-one-arg #[(form) "G‰ÂU«ˆÃÄÅ\"!ª	ÆU«…Ã!ª„ÇÈ\")‡" [form len 1 byte-compile-one-arg append (nil) 2 byte-compile-subr-wrong-args "0-1"] 5] byte-compile-one-or-two-args #[(form) "G‰ÂU«ˆÃÄÅ\"!ª	ÆU«…Ã!ª„ÇÈ\")‡" [form len 2 byte-compile-two-args append (nil) 3 byte-compile-subr-wrong-args "1-2"] 5] byte-compile-two-or-three-args #[(form) "G‰ÂU«ˆÃÄÅ\"!ª	ÆU«…Ã!ª„ÇÈ\")‡" [form len 3 byte-compile-three-args append (nil) 4 byte-compile-subr-wrong-args "2-3"] 5] byte-compile-noop #[(form) "ÀÁ!‡" [byte-compile-constant nil] 2] byte-compile-discard #[nil "ÀÁÂ\"‡" [byte-compile-out byte-discard 0] 3] byte-compile-associative #[(form) "A«œ@ÁNÃÄA‰\"ˆA‰­‡Å\nÆ\"ˆªs)‡ÇÈ!!‡" [form byte-opcode opcode mapcar byte-compile-form byte-compile-out 0 byte-compile-constant eval] 4] put list byte-compile byte-compile-list byte-opcode byte-list byte-opcode-invert concat byte-compile-concat byte-concat fset byte-compile-fset byte-fset indent-to-column byte-compile-indent-to byte-indent-to indent-to insert byte-compile-insert byte-insert function byte-compile-function-form - byte-compile-minus byte-quo emacs19-opcode t / byte-compile-quo byte-nconc nconc byte-compile-nconc beginning-of-line byte-compile-beginning-of-line #[(form) "AG‰ÂU«…ÃÄ!ª¬	ÅW«ÆÇA\"ˆÈÉ	SHÂ\"ª˜	ÊW««ŒÆÇA\"ˆÈÌ	\"ªƒÍ!)‡" [form count 0 byte-compile-constant nil 5 mapcar byte-compile-form byte-compile-out [byte-list1 byte-list2 byte-list3 byte-list4] 256 byte-compile-generate-emacs19-bytecodes byte-listN byte-compile-normal-call] 4] #[(form) "AGÂ	W«•	ÃW«ÄÅA\"ˆÆÇ	ÈZHÉ\"ª¢	ÉU«…ÅÊ!ª˜	ËW««ŒÄÅA\"ˆÆÍ	\"ªƒÎ!)‡" [form count 1 5 mapcar byte-compile-form byte-compile-out [byte-concat2 byte-concat3 byte-concat4] 2 0 "" 256 byte-compile-generate-emacs19-bytecodes byte-concatN byte-compile-normal-call] 4] #[(form) "A‰¬„ÁÂ!‡Ã@!ˆA«’A‰­Ã@!ˆÄÅÂ\"ˆªnÄÆÂ\"‡" [form byte-compile-constant 0 byte-compile-form byte-compile-out byte-diff byte-negate] 3] #[(form) "G‰ÂX«†ÃÄ\"ªšÅA‰@!ˆA‰­ŒÅ@!ˆÆÇÈ\"ˆªn)‡" [form len 2 byte-compile-subr-wrong-args "2 or more" byte-compile-form byte-compile-out byte-quo 0] 4] #[(form) "G‰ÂU«…ÃÄ!ª¦	ÅU«‡ÆA@!ªšÆA‰@!ˆA‰­ŒÆ@!ˆÇÈÉ\"ˆªn)‡" [form len 1 byte-compile-constant nil 2 byte-compile-form byte-compile-out byte-nconc 0] 4] #[(form) "À	8Â‰¢Å=«¹A@‰¢Æ=«¯	A@£¢Ç=¬¦AA‰@;«ƒA@¢È=«ƒA@:«‹@@É=¬„ÊË!ˆ*Ì	!‡" [2 form nil body fn quote lambda make-byte-code interactive byte-code byte-compile-warn "A quoted lambda form is the second argument of fset.  This is probably\n     not what you want, as that lambda cannot be compiled.  Consider using\n     the syntax (function (lambda (...) ...)) instead." byte-compile-two-args] 3] byte-compile-funarg #[(form) "À	A@‰¢Ã=«•\nA@¢Ä=«	@Å\nAB	AABBª	)!‡" [byte-compile-normal-call form fn quote lambda function] 5] #[(form) "À	A@9«…	A@ª‘\n«‰ÃÄ	A@!!ª…Ä	A@!!‡" [byte-compile-constant form byte-compile-emacs18-compatibility byte-compile-byte-code-unmake byte-compile-lambda] 4] #[(form) "G‰ÂU«ŒÃA@!ˆÄÅÆ\"ª	ÇU«…È!ª„ÉÊ\")‡" [form len 2 byte-compile-form byte-compile-out byte-indent-to 0 3 byte-compile-normal-call byte-compile-subr-wrong-args "1-2"] 4] #[(form) "A¬„ÁÂ!‡«GÄX«—ÅÆA\"ˆAA«‡ÇÈAG\"‡ÇÉÊ\"‡ËÅÌAA\">«„Í!‡A‰­“Æ@!ˆÇÉÊ\"ˆA«lÎ ˆªg‡" [form byte-compile-constant nil byte-compile-generate-emacs19-bytecodes 256 mapcar byte-compile-form byte-compile-out byte-insertN byte-insert 0 t consp byte-compile-normal-call byte-compile-discard] 4] #[(form) "A@:«ˆA@@Á=ª‹A@9«‹A@Â>¬„Ã!‡ÄÅÆA@!®Ç‰¨«„SªŠÈÉ\"ˆÊÁDDDË\"ˆÌÍ!‡" [form quote (nil t) byte-compile-normal-call byte-compile-form forward-line eval 1 byte-compile-warn "Non-numeric arg to beginning-of-line: %s" 1- t byte-compile-constant nil] 5] setq byte-compile-setq setq-default byte-compile-setq-default quote byte-compile-quote quote-form byte-compile-quote-form #[(form) "A‰«£	«¥Â	A@!ˆ¬Š	AA¬…ÄÅÆ\"ˆÇÈ	@\"ˆ	AA‰ª^ÂÉ\"ˆÉ‰)‡" [form args byte-compile-form for-effect byte-compile-out byte-dup 0 byte-compile-variable-ref byte-varset nil] 4] #[(form) "ÀÁÂA@DAABB!‡" [byte-compile-form set-default quote form] 4] #[(form) "À	A@!‡" [byte-compile-constant form] 2] #[(form) "ÀÁ\nA@!!‡" [byte-compile-constant byte-compile-top-level form] 3]] 4)
(byte-code "ÀÁMˆÂÃÄÅ#ˆÃÆMˆÂÇÄÅ#ˆÇÈMˆÂÉÊË#ˆÂÌÊË#ˆÂÍÊÎ#ˆÂÏÊĞ#ˆÂÑÊÒ#ˆÂÓÊÔ#ˆÂÕÊÖ#ˆÂ×ÊØ#ˆÂÙÊÚ#ˆÂÛÊÜ#ˆÂİÊŞ#ˆÂßÊŞ#ˆÂàÊŞ#ˆÂáÊŞ#ˆÂâÊã#ˆÂäÊå#ˆËæMˆÎçMˆĞèMˆéêMˆÒëMˆÔìMˆÖíMˆØîMˆÚïMˆÜğMˆãñMˆåòMˆÂóÊô#ˆÂõÊô#ˆÂöÊô#ˆÂó÷ø#ˆÂõ÷ù#ˆÂö÷ú#ˆôûMˆüıMˆÂşÊÿ#ˆÂ@ ÊA #ˆÂB ÊC #ˆÂD ÊE #ˆÂF ÊG #ˆÂH ÊI #ˆÂJ ÊK #ˆÿL MˆA M MˆC N MˆE O MˆG P MˆI Q MˆK R MˆÂS ÊT #ˆÂU ÊV #ˆÂW ÊX #ˆÂY ÊX #ˆÂZ Ê[ #ˆÂ\\ Ê] #‡" [byte-compile-body #[(body &optional for-effect) "A«ŒÁ@Â\"ˆA‰ªqÁ@\"‡" [body byte-compile-form t for-effect] 4] put byte-compile-body-do-effect byte-optimizer byte-compile-inline-expand #[(body) "À	\n\"ˆÃ‰‡" [byte-compile-body body for-effect nil] 3] byte-compile-form-do-effect #[(form) "À	\n\"ˆÃ‰‡" [byte-compile-form form for-effect nil] 3] inline byte-compile byte-compile-progn progn prog1 byte-compile-prog1 prog2 byte-compile-prog2 if byte-compile-if cond byte-compile-cond and byte-compile-and or byte-compile-or while byte-compile-while funcall byte-compile-funcall apply byte-compile-funarg mapcar mapatoms mapconcat let byte-compile-let let* byte-compile-let* #[(form) "AÂ	\"ˆÄ‰)‡" [form body byte-compile-body for-effect nil] 3] #[(form) "A@Á\n\"ˆÃ)ÄAAÅ\"‡" [form byte-compile-form for-effect nil byte-compile-body t] 3] #[(form) "À	A@Â\"ˆÃ	8À	\"ˆÅ)Æ	AAAÂ\"‡" [byte-compile-form form t 2 for-effect nil byte-compile-body] 3] byte-compile-goto-if (macro . #[(cond discard tag) "ÀÁ\nÁÄÅFÁÆÇFFE‡" [byte-compile-goto if cond discard 'byte-goto-if-not-nil 'byte-goto-if-not-nil-else-pop 'byte-goto-if-nil 'byte-goto-if-nil-else-pop tag] 8]) #[(form) "À	A@!ˆÂ	›¬Ã Å«ƒÇªÈ\"ˆÀÉ	8\"ˆÊ!ˆ)ª­Ã Ã ÅÇ\"ˆÀÉ	8\"ˆÅÌ\"ˆÊ!ˆÍ	AAA\"ˆÊ!ˆ*Î‰‡" [byte-compile-form form 3 byte-compile-make-tag donetag byte-compile-goto for-effect byte-goto-if-nil byte-goto-if-nil-else-pop 2 byte-compile-out-tag elsetag byte-goto byte-compile-body nil] 3] #[(clauses) "À Á‰A‰«Ô@‰@Æ=¬\n@¢Ç=«\n@£¢«‰Æ\nBÁ‰ª\\A«WÈ\n@!ˆ\nA¬É\n«ƒËªÌ\"ˆª@À ÉÍ\"ˆÎ\nA\n\"ˆÉÏ\"ˆĞ!ˆª&\nA«š\n@Æ=¬”È\n@!ˆÉ\n«ƒÍªÑ\"ˆ\nA\nÎ\n\"ˆÁ\n)Ğ!+‡" [byte-compile-make-tag nil clause nexttag donetag clauses t quote byte-compile-form byte-compile-goto for-effect byte-goto-if-not-nil byte-goto-if-not-nil-else-pop byte-goto-if-nil byte-compile-body byte-goto byte-compile-out-tag byte-goto-if-nil-else-pop body] 4] #[(form) "À 	A\n¬ÄÅ	\"ˆÇ‰)ª«\nA«—Å\n@!ˆÈ«ƒÉªÊ\"ˆ\nA‰ªf\n@Å	\"ˆÇ)Ë!*‡" [byte-compile-make-tag form args failtag t byte-compile-form for-effect nil byte-compile-goto byte-goto-if-nil byte-goto-if-nil-else-pop byte-compile-out-tag] 4] #[(form) "À 	A\n¬ÄÅ	\"ˆÄ‰)ª«\nA«—Å\n@!ˆÇ«ƒÈªÉ\"ˆ\nA‰ªf\n@Å	\"ˆÄ)Ê!*‡" [byte-compile-make-tag form args wintag nil byte-compile-form for-effect byte-compile-goto byte-goto-if-not-nil byte-goto-if-not-nil-else-pop byte-compile-out-tag] 4] #[(form) "À À Ã	!ˆÄA@!ˆÆ«ƒÈªÉ\n\"ˆÊAAË\"ˆÆÌ	\"ˆÃ\n!ˆÍ‰*‡" [byte-compile-make-tag looptag endtag byte-compile-out-tag byte-compile-form form byte-compile-goto for-effect byte-goto-if-nil byte-goto-if-nil-else-pop byte-compile-body t byte-goto nil] 3] #[(form) "ÀÁ\nA\"ˆÃÄ\nAAG\"‡" [mapcar byte-compile-form form byte-compile-out byte-call] 3] #[(form) "A@‰«˜	@:«‰Â	@A@!ˆª„ÃÄ!ˆ	A‰¬h)ÆA@!	«–ÇÈ	@:«…	@@ª‚	@\"ˆ	A‰¬jAA	Ê	\"ˆÄ)ÌÍA@G\"*‡" [form varlist byte-compile-form byte-compile-push-constant nil byte-compile-bound-variables reverse byte-compile-variable-ref byte-varbind body byte-compile-body for-effect byte-compile-out byte-unbind] 4] #[(form) "Á\nA@!«¤@:¬†ÄÅ!ˆªÆ@A@!ˆ‰@@ ˆÇÈ@\"ˆA‰¬\\\nAA	Ê	\"ˆÅ)ÌÍ\nA@G\"*‡" [byte-compile-bound-variables copy-sequence form varlist byte-compile-push-constant nil byte-compile-form byte-compile-variable-ref byte-varbind body byte-compile-body for-effect byte-compile-out byte-unbind] 4] /= byte-compile-negated atom nlistp byte-compile-negated-op = consp listp #[(form) "À	!Â	\"ˆÄ‰)‡" [byte-compile-negation-optimizer form byte-compile-form for-effect nil] 3] byte-compile-negation-optimizer #[(form) "À	@ÂN®…ÃÄ	@\"	ABD‡" [not form byte-compile-negated-op error "compiler error: %s has no byte-compile-negated-op property"] 4] catch byte-compile-catch unwind-protect byte-compile-unwind-protect condition-case byte-compile-condition-case save-excursion byte-compile-save-excursion save-restriction byte-compile-save-restriction save-window-excursion byte-compile-save-window-excursion with-output-to-temp-buffer byte-compile-with-output-to-temp-buffer #[(form) "À	A@!ˆÂÃÄ	AAB\"!ˆÆÇÈ\"‡" [byte-compile-form form byte-compile-push-constant byte-compile-top-level progn for-effect byte-compile-out byte-catch 0] 4] #[(form) "ÀÁ\nAAÃ\"!ˆÄÅÆ\"ˆ\nA@Ç\n\"ˆÉ)ÄÊË\"‡" [byte-compile-push-constant byte-compile-top-level-body form t byte-compile-out byte-unwind-protect 0 byte-compile-form for-effect nil byte-unbind 1] 4] #[(form) "A@‰«…	\nBª\n	9¬…ÃÄ	\"ˆÅ	!ˆÅÆÇ8\"!ˆAAAÉ\n‰«@‰@ÍA\"B\nB\n)A‰¬cÅ\nŸ!ˆ*ÎÏĞ\"*‡" [form var byte-compile-bound-variables byte-compile-warn "%s is not a variable-name or nil (in condition-case)" byte-compile-push-constant byte-compile-top-level 2 for-effect nil compiled-clauses clauses clause byte-compile-top-level-body byte-compile-out byte-condition-case 0] 5] #[(form) "ÀÁÂ\"ˆAÅ\"ˆÇ)ÀÈÉ\"‡" [byte-compile-out byte-save-excursion 0 form body byte-compile-body for-effect nil byte-unbind 1] 3] #[(form) "ÀÁÂ\"ˆAÅ\"ˆÇ)ÀÈÉ\"‡" [byte-compile-out byte-save-restriction 0 form body byte-compile-body for-effect nil byte-unbind 1] 3] #[(form) "ÀÁ\nA\"!ˆÄÅÆ\"‡" [byte-compile-push-constant byte-compile-top-level-body form for-effect byte-compile-out byte-save-window-excursion 0] 4] #[(form) "À	A@!ˆÂÃÄ\"ˆÅ	AA!ˆÂÆÄ\"‡" [byte-compile-form form byte-compile-out byte-temp-output-buffer-setup 0 byte-compile-body byte-temp-output-buffer-show] 3] defun byte-compile-defun defmacro byte-compile-defmacro defvar byte-compile-defvar defconst autoload byte-compile-autoload lambda byte-compile-lambda-form] 4)
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑMˆÒÓM‡" [byte-compile-defun #[(form) "ÀÁÂA@DÄÅÆAAB!!E!ˆÇ ˆÈA@!‡" [byte-compile-two-args fset quote form byte-compile-byte-code-maker byte-compile-lambda lambda byte-compile-discard byte-compile-constant] 7] byte-compile-defmacro #[(form) "ÀÁ\nA@DÃÄÅ\nAAB!!‰¢Ç=«‡ÈÉEªˆÁÊË!BD)EÁ\nA@DDÍ\"ˆÏ‰)‡" [fset quote form byte-compile-byte-code-maker byte-compile-lambda lambda code make-byte-code cons 'macro macro eval body byte-compile-body for-effect nil] 7] byte-compile-defvar #[(form) "A@Á8Â8Æ>«†BAA­—@É=«†ÊEª‹ËÌÍDDÊEE­‡ÎÍDÏFÍDEÑ\"ˆÓ‰,‡" [form 2 3 string value var free-vars byte-compile-warnings byte-compile-bound-variables defconst setq or boundp quote put 'variable-documentation body byte-compile-body for-effect nil] 5] byte-compile-autoload #[(form) "À	8:«ˆÀ	8@Â=ª‹À	89«‡À	8Ã>«´Ä	8:«ˆÄ	8@Â=ª‹Ä	89«‡Ä	8Ã>«™ÅÄ	8!«’ÆÅÀ	8!!¬‰ÇÈÅ	A@!\"ˆÉ	!‡" [1 form quote (nil t) 5 eval fboundp byte-compile-warn "The compiler ignores `autoload' except at top level.  You should \n     probably put the autoload of the macro `%s' at top-level." byte-compile-normal-call] 4] byte-compile-lambda-form #[(form) "ÀÁ!‡" [error "`lambda' used as function name is invalid"] 2] byte-compile-make-tag #[nil "À	T‰D‡" [TAG byte-compile-tag-number] 3] byte-compile-out-tag #[(tag) "	BAA«—\n«AA\nU¬‡ÃÄA@\"ˆAA‰‡A\n¡‡" [tag byte-compile-output byte-compile-depth error "bytecomp bug: depth conflict at tag %d"] 3] byte-compile-goto #[(opcode tag) "	B\nB	A>«„Sª¡ˆÅ=?­‚S‰‡" [opcode tag byte-compile-output byte-goto-always-pop-ops byte-compile-depth byte-goto] 3] byte-compile-out #[(opcode offset) "	B\nBÃ=«†	Z‰‡Å=«„Æ‰‡JH®ƒ	S[\\‰]‰‡" [opcode offset byte-compile-output byte-call byte-compile-depth byte-return nil byte-stack+-info byte-compile-maxdepth] 4] byte-compile-annotate-call-tree #[(form) "À\n@‰«’Å	8>¬”	A	A@B ˆª‰\n@CÀEB‰«”\n@Æ	8>®–	AA\n@Æ	8B ªŠÀ\n@CEB‰)‡" [nil entry form byte-compile-call-tree byte-compile-current-form 1 2] 4]] 2)
(fset 'byte-compile-report-call-tree #[(&optional filename) "ÀÁ!ˆÂÂqˆÃ ˆÀÄ\"ˆÆ¬‡®Éª;«„ª„Ê!ËÌ!Í±ˆ«ªÎĞ=«ƒÑªœÒ=«ƒÓª”Ô=«ƒÕªŒÖ=«ƒ×ª„ØÙ\"\"ÀÁ!ˆpÚ‰‰‰‰ƒhß@@\"ˆ@A@à@8áâ@@‰!¬Š¬ƒãªàäªİåK‰!«ƒæªĞ9«‡çè\"ªÄé!«ƒêª»:¬ƒëª³@ì=«–éA!¬‰íAAA«ƒîª™ïª–íAA«ƒğª‹@ñ=«ƒòªÉçóGGGG\\$ô±ˆ«¢õcˆ`ö@«ˆ÷øù#ªú±ˆö;ü`\"ˆ)«šıcˆ`ö÷øù#±ˆö;ü`\"ˆ)ôcˆA‰„z Àş!ˆÚ?«·@A@¬¨@@‰«Ÿ@ A \"¬”B @ Ú\"!¬‡?B?A‰¬I?«C ;D cˆ`÷ø?Ÿù#cˆü`\"ˆ).ÀE !‘‡" [message "Generating call tree..." "*Call-Tree*" erase-buffer "Generating call tree (sorting on %s)..." byte-compile-call-tree-sort "Call tree for " byte-compile-current-file filename "???" buffer-name " sorted on " prin1-to-string ":\n\n" sort byte-compile-call-tree callers #[(x y) "A@G	A@GW‡" [x y] 2] calls #[(x y) "À	8GÀ\n8GW‡" [2 x y] 3] calls+callers #[(x y) "A@GÁ8G\\\nA@GÁ\n8G\\W‡" [x 2 y] 4] name #[(x y) "@	@™‡" [x y] 2] error "byte-compile-call-tree-sort: %s - unknown sort mode" nil p f b rest prin1 2 "	" fboundp " <top level>" " <not defined>" subrp " <subr>" format " ==> %s" compiled-function-p "<compiled function>" "<malformed function>" macro byte-code " <compiled macro>" " <macro>" "<compiled lambda>" lambda "<function>" " (%d callers + %d calls = %d)" "\n" "  called by:\n" "    " mapconcat symbol-name ", " "<top level>" fill-prefix fill-region-as-paragraph "  calls:\n" "Generating call tree...(finding uncalled functions...)" uncalled byte-compile-fdefinition t commandp "  " "Noninteractive functions not known to be called:\n  " "Generating call tree...done."] 10 "\
Display a buffer describing which functions have been called, what functions
called them, and what functions they call.  This buffer will list all functions
whose definitions have been compiled since this emacs session was started, as
well as all functions called by those functions.

The call tree only lists functions called, not macros or inline functions
expanded.  Those functions which the byte-code interpreter knows about directly
(eq, cons, etc.) are not reported.

The call tree also lists those functions which are not known to be called
(that is, to which no calls have been compiled.)  Functions which can be
invoked interactively are excluded from this list." nil])
(fset 'batch-byte-compile #[nil "¬„ÁÂ!ˆÃ«ëÅÆ@!!«ÕÇ@!Ã‰	‰\n«ÃË\n@\"«²Í\n@!¬«Æ\n@@\"‰	«ŸÎ	!‰«–Ï!«Ğ	\"«ˆÑ	!¬‚Ò\nA‰\n¬=+ªˆÑ@!¬‚ÒA‰¬ÓÔ!ˆÕ	«ƒÖª×!)‡" [noninteractive error "batch-byte-compile is to be used only with -batch" nil command-line-args-left file-directory-p expand-file-name directory-files dest source files string-match emacs-lisp-file-regexp auto-save-file-name-p byte-compile-dest-file file-exists-p file-newer-than-file-p batch-byte-compile-file t message "Done" kill-emacs 1 0] 4 "\
Runs `byte-compile-file' on the files remaining on the command line.
Must be used only with -batch, and kills emacs on completion.
Each file will be processed even if an error occurred previously.
For example, invoke \"emacs -batch -f batch-byte-compile $emacs/ ~/*.el\""])
(byte-code "ÀÁMˆÂÃÄ\"ˆÂÅÆ\"ˆÂÇÈ\"ˆÂÉÊ\"ˆÂËÌ\"ˆÍÎ!«„¬©Ğ™¬£ÂÑÒ\"ˆÂÓÔ\"ˆÕÖ×\"ˆÕØÙ\"ˆÕÚÛ\"ˆÕÜİ\"ˆÕŞß\"ˆàá\"«ŠÕâã\"ˆÂäå\"ˆæç!ˆÍè!«„éêMˆÀ‡" [batch-byte-compile-file #[(file) "ÀÁÂ‡" [err (byte-code "À	!ˆÂ‡" [byte-compile-file file t] 2) ((error (byte-code "À	A«ƒÂªÃ	@ÅNÆ	A!$ˆÇ‡" [message err ">>Error occurred processing %s: %s (%s)" ">>Error occurred processing %s: %s" file error-message prin1-to-string nil] 6)))] 3] make-obsolete mod % dot point dot-max point-max dot-min point-min dot-marker point-marker boundp epoch::version emacs-version "19" buffer-flush-undo buffer-disable-undo baud-rate "use the baud-rate variable instead" make-obsolete-variable auto-fill-hook auto-fill-function blink-paren-hook blink-paren-function lisp-indent-hook lisp-indent-function temp-buffer-show-hook temp-buffer-show-function inhibit-local-variables "use enable-local-variables (with the reversed sense.)" string-match "Lucid" unread-command-char unread-command-event update-extent set-extent-endpoints provide byte-compile byte-code-meter byte-compile-report-ops #[nil "ÀÀqˆÁÂ‰‰‰ÇW­İÁHHÂÂ	W«ŒÊË\"ÊÌ\"ªY«ˆZHÏĞ\"cˆÑ!cˆ«ˆÒÓ!Ô±ˆÕjˆÓ!Ö±ˆT‰ª,‘‡" ["*Meter*" 0 nil off op n i 256 byte-code-meter byte-nth logand 7 248 byte-constant byte-code-vector format "%-4d" symbol-name " [" int-to-string "]" 40 "\n"] 6]] 3)
