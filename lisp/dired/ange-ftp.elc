;;; compiled by jwz@watergate on Tue Aug 18 17:13:30 1992
;;; from file /wg1/emacs-base/lisp/dired/ange-ftp.el
;;; emacs version 19.2.2 Lucid.
;;; bytecomp version 2.08;  7-aug-92.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(defvar ange-ftp-path-format '("^/\\(\\([^@/:]*\\)@\\)?\\([^@/:]*\\):\\(.*\\)" 3 2 4) "\
*Format of a fully expanded remote pathname.  This is a cons
(REGEXP . (HOST USER PATH)), where REGEXP is a regular expression matching
the full remote pathname, and HOST, USER, and PATH are the numbers of
parenthesized expressions in REGEXP for the components (in that order).")
(defvar ange-ftp-multi-msgs "^220-\\|^230-\\|^226\\|^25.-\\|^221-\\|^200-\\|^530-\\|^4[25]1-" "\
*Regular expression matching messages from the ftp process that start
a multiline reply.")
(defvar ange-ftp-good-msgs "^220 \\|^230 \\|^226 \\|^25. \\|^221 \\|^200 \\|^[Hh]ash mark" "\
*Regular expression matching messages from the ftp process that indicate
that the action that was initiated has completed successfully.")
(defvar ange-ftp-skip-msgs (concat "^200 \\(PORT\\|Port\\) \\|^331 \\|^150 \\|^350 \\|^[0-9]+ bytes \\|" "^Connected \\|^$\\|^Remote system\\|^Using\\|^ \\|Password:\\|" "^local:\\|^Trying\\|^125 \\|^550-\\|^221 .*oodbye") "\
*Regular expression matching messages from the ftp process that can be
ignored.")
(defvar ange-ftp-fatal-msgs (concat "^ftp: \\|^Not connected\\|^530 \\|^4[25]1 \\|rcmd: \\|" "^No control connection\\|unknown host\\|^lost connection") "\
*Regular expression matching messages from the FTP process that indicate
something has gone drastically wrong attempting the action that was
initiated and that the FTP process should (or already has) been killed.")
(defvar ange-ftp-gateway-fatal-msgs "No route to host\\|Connection closed\\|No such host\\|Login incorrect" "\
*Regular expression matching messages from the rlogin / telnet process that
indicates that logging in to the gateway machine has gone wrong.")
(defvar ange-ftp-xfer-size-msgs "^150 .* connection for .* (\\([0-9]+\\) bytes)" "\
*Regular expression used to determine the number of bytes in a FTP transfer.")
(defvar ange-ftp-tmp-name-template "/tmp/ange-ftp" "\
*Template used to create temporary files.")
(defvar ange-ftp-gateway-tmp-name-template "/tmp/ange-ftp" "\
*Template used to create temporary files when ftp-ing through a gateway.
Files starting with this prefix need to be accessible from BOTH the local
machine and the gateway machine, and need to have the SAME name on both
machines, that is, /tmp is probably NOT what you want, since that is rarely
cross-mounted.")
(defvar ange-ftp-netrc-filename "~/.netrc" "\
*File in .netrc format to search for passwords.")
(defvar ange-ftp-disable-netrc-security-check nil "\
*If non-nil avoid checking permissions on the .netrc file.")
(defvar ange-ftp-default-user nil "\
*User name to use when none is specied in a pathname.
If nil, then the name under which the user is logged in is used.
If non-nil but not a string, the user is prompted for the name.")
(defvar ange-ftp-default-password nil "\
*Password to use when the user is the same as ange-ftp-default-user.")
(defvar ange-ftp-default-account nil "\
*Account password to use when the user is the same as ange-ftp-default-user.")
(defvar ange-ftp-generate-anonymous-password nil "\
*If t, use a password of user@host when logging in as the anonymous user.
If a string then use that as the password.
If nil then prompt the user for a password.")
(defvar ange-ftp-dumb-unix-host-regexp nil "\
*If non-nil, if the host being ftp'd to matches this regexp then the FTP
process uses the 'dir' command to get directory information.")
(defvar ange-ftp-binary-file-name-regexp (concat "\\.Z$\\|\\.lzh$\\|\\.arc$\\|\\.zip$\\|\\.zoo$\\|\\.tar$\\|" "\\.dvi$\\|\\.ps$\\|\\.elc$\\|TAGS$\\|\\.gif$\\|" "\\.EXE\\(;[0-9]+\\)?$\\|\\.Z-part-..$") "\
*If a file matches this regexp then it is transferred in binary mode.")
(defvar ange-ftp-gateway-host nil "\
*Name of host to use as gateway machine when local FTP isn't possible.")
(defvar ange-ftp-local-host-regexp ".*" "\
*If a host being FTP'd to matches this regexp then the ftp process is started
locally, otherwise the FTP process is started on `ange-ftp-gateway-host'
instead.")
(defvar ange-ftp-gateway-program-interactive nil "\
*If non-nil then the gateway program is expected to connect to the gateway
machine and eventually give a shell prompt.  Both telnet and rlogin do something
like this.")
(defvar ange-ftp-gateway-program (byte-code "Á=«‚Â‡Ã‡" [system-type hpux "remsh" "rsh"] 2) "\
*Name of program to spawn a shell on the gateway machine.  Valid candidates
are rsh (remsh on hp-ux), telnet and rlogin.  See also the gateway variable
above.")
(defvar ange-ftp-gateway-prompt-pattern "^[^#$%>;]*[#$%>;] *" "\
*Regexp used to detect that the logging-in sequence is completed on the
gateway machine and that the shell is now awaiting input.  Make this regexp as
strict as possible; it shouldn't match *anything* at all except the user's
initial prompt.  The above string will fail under most SUN-3's since it
matches the login banner.")
(defvar ange-ftp-gateway-setup-term-command (byte-code "Á=«‚Â‡Ã‡" [system-type hpux "stty -onlcr -echo\n" "stty -echo nl\n"] 2) "\
*Command to use after logging in to the gateway machine to stop the terminal
echoing each command and to strip out trailing ^M characters.")
(defvar ange-ftp-smart-gateway nil "\
*If the gateway FTP is smart enough to use proxy server, then don't bother
telnetting etc, just issue a user@host command instead.")
(defvar ange-ftp-smart-gateway-port "21" "\
*Port on gateway machine to use when smart gateway is in operation.")
(defvar ange-ftp-send-hash t "\
*If non-nil, send the HASH command to the FTP client.")
(defvar ange-ftp-binary-hash-mark-size nil "\
*Default size, in bytes, between hash-marks when transferring a binary file.
If NIL, this variable will be locally overridden if the FTP client outputs a
suitable response to the HASH command.  If non-NIL then this value takes
precedence over the local value.")
(defvar ange-ftp-ascii-hash-mark-size 1024 "\
*Default size, in bytes, between hash-marks when transferring an ASCII file.
This variable is buffer-local and will be locally overridden if the FTP client
outputs a suitable response to the HASH command.")
(defvar ange-ftp-process-verbose t "\
*If non-NIL then be chatty about interaction with the FTP process.")
(defvar ange-ftp-ftp-program-name "ftp" "\
*Name of FTP program to run.")
(defvar ange-ftp-gateway-ftp-program-name "ftp" "\
*Name of FTP program to run on gateway machine.
Some AT&T folks claim to use something called `pftp' here.")
(defvar ange-ftp-ftp-program-args '("-i" "-n" "-g" "-v") "\
*A list of arguments passed to the FTP program when started.")
(defvar ange-ftp-nslookup-program nil "\
*If non-NIL then a string naming nslookup program.")
(defvar ange-ftp-make-backup-files nil "\
*A list of operating systems for which ange-ftp will make Emacs backup
files files on the remote host. For example, '(unix) makes sense, but
'(unix vms) or '(vms) would be silly, since vms makes its own backups.")
(defvar ange-ftp-retry-time 5 "\
*Number of seconds to wait before retrying if a file or listing
doesn't arrive. This might need to be increased for very slow connections.")
(defvar ange-ftp-auto-save 0 "\
If 1, allows ange-ftp files to be auto-saved.
If 0, suppresses auto-saving of ange-ftp files.
Don't use any other value.")
(require 'backquote)
(fset 'ange-ftp-make-hashtable #[(&optional size) "À	®ÂÃ\"‡" [make-vector size 31 0] 3 "\
Make an obarray suitable for use as a hashtable.
SIZE, if supplied, should be a prime number."])
(fset 'ange-ftp-map-hashtable #[(fun tbl) "ÀÁ\n\"‡" [mapatoms #[(sym) "	ÂN	ÃN\"‡" [fun sym key val] 4] tbl] 3 "\
Call FUNCTION on each key and value in HASHTABLE."])
(fset 'ange-ftp-make-hash-key '(macro . #[(key) "ÀÁ\nD\nÃ\nDF‡" [if stringp key prin1-to-string] 5 "\
Convert KEY into a suitable key for a hashtable."]))
(fset 'ange-ftp-get-hash-entry #[(key tbl) "À	;«ƒ	ªƒÂ	!\"‰­ƒÅN)‡" [intern-soft key prin1-to-string tbl sym val] 4 "\
Return the value associated with KEY in HASHTABLE."])
(fset 'ange-ftp-put-hash-entry #[(key val tbl) "À	;«ƒ	ªƒÂ	!\"ÅÆ#ˆÅÁ	#)‡" [intern key prin1-to-string tbl sym put val] 4 "\
Record an association between KEY and VALUE in HASHTABLE."])
(fset 'ange-ftp-del-hash-entry #[(key tbl) "GÂ	!	SÅÆ\"ˆÇY«HIˆS‰ªo+‡" [tbl len ange-ftp-make-hashtable new-tbl i ange-ftp-map-hashtable #[(k v) "	š®…Â#‡" [k key ange-ftp-put-hash-entry v new-tbl] 4] 0] 5 "\
Copy all symbols except KEY in HASHTABLE and return modified hashtable."])
(fset 'ange-ftp-hash-entry-exists-p #[(key tbl) "À	;«ƒ	ªƒÂ	!\"‡" [intern-soft key prin1-to-string tbl] 3 "\
Return whether there is an association for KEY in TABLE."])
(fset 'ange-ftp-hash-table-keys #[(tbl) "ÀÁÂ\"Ä\"‡" [sort all-completions "" tbl string-lessp] 4 "\
Return a sorted list of all the active keys in the hashtable, as strings."])
(byte-code "ÀÂ‡" ["$Revision: 1.4 $" ange-ftp-version nil] 1)
(defvar ange-ftp-data-buffer-name " *ftp data*" "\
Buffer name to hold directory listing data received from ftp process.")
(defvar ange-ftp-netrc-modtime nil "\
Last modified time of the netrc file from file-attributes.")
(defvar ange-ftp-user-hashtable (ange-ftp-make-hashtable) "\
Hash table holding associations between HOST, USER pairs.")
(defvar ange-ftp-passwd-hashtable (ange-ftp-make-hashtable) "\
Mapping between a HOST, USER pair and a PASSWORD for them.")
(defvar ange-ftp-account-hashtable (ange-ftp-make-hashtable) "\
Mapping between a HOST, USER pair and a ACCOUNT password for them.")
(defvar ange-ftp-files-hashtable (ange-ftp-make-hashtable 97) "\
Hash table for storing directories and their respective files.")
(defvar ange-ftp-ls-cache-lsargs nil "\
Last set of args used by ange-ftp-ls.")
(defvar ange-ftp-ls-cache-file nil "\
Last file passed to ange-ftp-ls.")
(defvar ange-ftp-ls-cache-res nil "\
Last result returned from ange-ftp-ls.")
(put 'ftp-error 'error-conditions '(ftp-error file-error error))
(fset 'ange-ftp-save-match-data '(macro . #[(&rest body) "ÀÁ!ÂÅÆDCÇÈ	BÊDEE*‡" [make-symbol "match-data" nil case-fold-search original let (match-data) unwind-protect progn body store-match-data] 6 "\
Execute the BODY forms, restoring the global value of the match data.
Before executing BODY, case-fold-search is locally bound to nil."]))
(byte-code "ÀÁÂÃ#ˆÀÁÄÅ#‡" [put ange-ftp-save-match-data lisp-indent-hook 0 edebug-form-hook (&rest form)] 4)
(fset 'ange-ftp-message #[(fmt &rest args) "ÀÁ\n#ÄÅ !‰GY«ŒÈÉZÊOPËÌ\"*‡" [apply format fmt args window-width minibuffer-window max msg "> " 3 nil message "%s"] 5 "\
Output the given message, but truncate to the size of the minibuffer
window."])
(fset 'ange-ftp-abbreviate-filename #[(file &optional new) "À Â«•ÄÅÆ!ÇQ\"«‰É•SÊO«‘Ì!Ì!˜«†Í!®Î*‡" [match-data match-data ((store-match-data match-data)) default-directory string-match "^" regexp-quote "." file 0 nil new file-name-nondirectory file-name-directory "./"] 4 "\
Abbreviate the given filename relative to the default-directory.  If the
optional parameter NEW is given and the non-directory parts match, only return
the directory part of the file."])
(fset 'ange-ftp-set-user #[(host user) "À	\n#‡" [ange-ftp-put-hash-entry host user ange-ftp-user-hashtable] 4 "\
For a given HOST, set or change the default USER." "sHost: \nsUser: "])
(fset 'ange-ftp-get-user #[(host) "À ˆÁ\n\"‰®¡;«ƒª“«ÆÈÉÊ\n\"Ë \")ª‚Ë ‰Ì\n\"ˆ)‡" [ange-ftp-parse-netrc ange-ftp-get-hash-entry host ange-ftp-user-hashtable user ange-ftp-default-user t enable-recursive-minibuffers read-string format "User for %s: " user-login-name ange-ftp-set-user] 5 "\
Given a HOST, return the default USER."])
(fset 'ange-ftp-read-passwd #[(prompt &optional default) "«ƒªÁÂ‰ÃÈU¬ÍÉU¬ÇÊU¬ÁËÌÎGÏ\"#ˆĞ ‰ÑU«…ÁªTÒU¬‘ÓU¬‹Ô!Pª=GÂV«6ÂÕOª-Ö ˆÂÕO,‡" [default "" 0 t cursor-in-echo-area echo-keystrokes c pass 13 10 27 message "%s%s" prompt make-string 46 read-char 21 8 127 char-to-string -1 ange-ftp-repaint-minibuffer] 7 "\
Read a password from the user. Echos a . for each character typed.
End with RET, LFD, or ESC. DEL or C-h rubs out.  ^U kills line.
Optional DEFAULT is password to start with."])
(byte-code "ÀÁMˆÂÃM‡" [ange-ftp-generate-passwd-key (macro . #[(host user) "À	ÂF‡" [concat host "/" user] 4]) ange-ftp-lookup-passwd (macro . #[(host user) "ÀÁ\nEÄE‡" [ange-ftp-get-hash-entry ange-ftp-generate-passwd-key host user ange-ftp-passwd-hashtable] 4])] 2)
(fset 'ange-ftp-set-passwd #[(host user passwd) "À	ÂQ#‡" [ange-ftp-put-hash-entry host "/" user passwd ange-ftp-passwd-hashtable] 4 "\
For a given HOST and USER, set or change the associated PASSWORD." (byte-code "ÀÁ!ÀÂ!ÃÄ!E‡" [read-string "Host: " "User: " ange-ftp-read-passwd "Password: "] 4)])
(fset 'ange-ftp-get-host-with-passwd #[(user) "À ˆÁÂ‡" [ange-ftp-parse-netrc found-one (byte-code "ÀÁ\n\"ˆÃ ÅÀÆ\"ˆ*È‡" [ange-ftp-map-hashtable #[(host val) "À	ÂQ\"­„ÅÆ	\"‡" [ange-ftp-get-hash-entry host "/" user ange-ftp-passwd-hashtable throw found-one] 4] ange-ftp-user-hashtable match-data match-data ((store-match-data match-data)) #[(key value) "ÀÁ\n\"­™\nÃÄ”O\nÄ•ÇO˜­ˆ­„ÉÊ\")‡" [string-match "^[^/]*\\(/\\).*$" key 0 1 host user nil value throw found-one] 4] ange-ftp-passwd-hashtable nil] 3)] 2 "\
Given a USER, return a host we know the password for."])
(fset 'ange-ftp-get-passwd #[(host user) "À ˆÁ\nÃQ\"®Ş;««‰˜«ƒ‡È˜¬…É˜«“\n«\n;«ƒ\n‡Ë ÌÍ Q‡Î!‰«”ĞÑÒ\n%ÁÃQ\"\"ª‡ĞÑÓ\n#!Õ\n#ˆ*‡" [ange-ftp-parse-netrc ange-ftp-get-hash-entry host "/" user ange-ftp-passwd-hashtable ange-ftp-default-user ange-ftp-default-password "anonymous" "ftp" ange-ftp-generate-anonymous-password user-login-name "@" system-name ange-ftp-get-host-with-passwd other ange-ftp-read-passwd format "passwd for %s@%s (same as %s@%s): " "Password for %s@%s: " passwd ange-ftp-set-passwd] 8 "\
Given a HOST and USER, return the FTP password, prompting if it was not
previously set."])
(fset 'ange-ftp-set-account #[(host user account) "À	ÂQ#‡" [ange-ftp-put-hash-entry host "/" user account ange-ftp-account-hashtable] 4 "\
For a given HOST and USER, set or change the associated ACCOUNT password." (byte-code "ÀÁ!ÀÂ!ÃÄ!E‡" [read-string "Host: " "User: " ange-ftp-read-passwd "Account password: "] 4)])
(fset 'ange-ftp-get-account #[(host user) "À ˆÁ\nÃQ\"®;­ˆ˜­‚‡" [ange-ftp-parse-netrc ange-ftp-get-hash-entry host "/" user ange-ftp-account-hashtable ange-ftp-default-user ange-ftp-default-account] 4 "\
Given a HOST and USER, return the FTP account."])
(fset 'ange-ftp-chase-symlinks #[(file) "ÀÂ!‰«Ä	!«ƒ	ª…Å!	Pªi)‡" [nil temp ange-ftp-real-file-symlink-p file file-name-absolute-p file-name-directory] 2 "\
Return the filename that FILENAME references, following all symbolic links."])
(fset 'ange-ftp-parse-netrc-token #[(token limit) "À	\nÃ#­§ÄÆ\nwˆgÇ=«’Èuˆ`É\nwˆÈuˆ`S{ª‰`Ê\nwˆ`{)‡" [search-forward token limit t nil beg ", 	\n" 34 1 "^\"" "^, 	\n"] 4 "\
Move along current line looking for the value of the TOKEN.  Valid
separators between TOKEN and its value are commas and whitespace.
Second arg LIMIT is a limit for the search."])
(fset 'ange-ftp-parse-netrc-group #[nil "Àyˆ`ÁÂdÃÄ$ˆ`Å‰‰‰	‰\nbˆËÌ\"	ËÍ\"ËÎ\"ËÏ\"	«£«ŸĞ	\"ˆÑ	#ˆ«ÀÒ	#ˆªµ\nbˆÓÔÕ#«ªËÍ\"ËÎ\"ËÏ\"«„«„«„b.‡" [0 re-search-forward "machine\\|default" end 2 nil account password login machine start ange-ftp-parse-netrc-token "machine" "login" "password" "account" ange-ftp-set-user ange-ftp-set-passwd ange-ftp-set-account search-forward "default" t ange-ftp-default-user ange-ftp-default-password ange-ftp-default-account] 7 "\
Extract the values for the tokens  `machine', `login', `password'
and `account' in the current buffer.  If successful, record the information
found."])
(fset 'ange-ftp-parse-netrc #[nil "ÀÁ\n!!Ä!‰­äÆ8š?­ÛÈ 	Ê¬Ì8Í =«¹ÎÏĞ8\"«±ŠÑÒ!qˆÓ!ˆÕ!×Ø!ˆÙÚ\"ˆÜebˆm¬…İ ˆªxŞp!ˆ)ª‰ßà\n\"ˆáâ!ˆÆ8‰**‡" [ange-ftp-chase-symlinks ange-ftp-real-expand-file-name ange-ftp-netrc-filename file ange-ftp-real-file-attributes attr 5 ange-ftp-netrc-modtime match-data match-data ((store-match-data match-data)) ange-ftp-disable-netrc-security-check 2 user-uid string-match ".r..------" 8 generate-new-buffer "*ftp-.netrc*" ange-ftp-real-insert-file-contents buffer-file-name file-name-directory default-directory normal-mode t mapcar funcall find-file-hooks nil ange-ftp-parse-netrc-group kill-buffer ange-ftp-message "%s either not owned by you or badly protected." sit-for 1] 5 "\
If ~/.netrc file exists and has the correct permissions then extract the
`machine', `login', `password' and `account' information from within." nil])
(fset 'ange-ftp-generate-root-prefixes #[nil "À ˆÁ ÃÄÆÇ\"ˆÆÉ\n\"ˆ®‚ÄC+‡" [ange-ftp-parse-netrc match-data match-data ((store-match-data match-data)) nil res ange-ftp-map-hashtable #[(key value) "ÀÁ\n\"­\nÃÄ”O\nÄ•ÅOÈÉRC\nB‰\n*‡" [string-match "^[^/]*\\(/\\).*$" key 0 1 nil user host "@" ":" res] 4] ange-ftp-passwd-hashtable #[(host user) "ÁPC\nB‰‡" [host ":" res] 2] ange-ftp-user-hashtable] 3 "\
Return a list of prefixes of the form 'user@host:' to be used when
completion is done in the root directory."])
(fset 'ange-ftp-ftp-path-component '(macro . #[(n ns path) "ÀÁÂEDCÅÇÈFE‡" [let elt nth n ns substring path (match-beginning elt) (match-end elt)] 6 "\
Extract the Nth ftp path component from NS."]))
(byte-code "ÀÁ!¬‚ÂÀÃ!¬‚ÄÄ‡" [boundp ange-ftp-ftp-path-arg "" ange-ftp-ftp-path-res nil] 2)
(fset 'ange-ftp-ftp-path #[(path) "	˜«‚\n‡Ã ÅÆ@\"­ÉA‰@		”	•O)\nA@		”	•O)Ì8		”	•O)GÍU«†Î\n!\nE,*‰‡" [path ange-ftp-ftp-path-arg ange-ftp-ftp-path-res match-data match-data ((store-match-data match-data)) string-match ange-ftp-path-format ns elt host user 2 0 ange-ftp-get-user] 4 "\
Parse PATH according to ange-ftp-path-format (which see).
Returns a list (HOST USER PATH), or nil if PATH does not match the format."])
(fset 'ange-ftp-replace-path-component #[(fullpath path) "À ÂÃ@\"­šAÇ8É”O\n•ËOQ**‡" [match-data match-data ((store-match-data match-data)) string-match ange-ftp-path-format fullpath ns 2 elt 0 path nil] 5 "\
Take a FULLPATH that matches according to ange-ftp-path-format and
replace the path component with PATH."])
(byte-code "À Â	ÃÄ#‡" [make-sparse-keymap ange-ftp-tmp-keymap define-key "" exit-minibuffer] 4)
(fset 'ange-ftp-repaint-minibuffer #[nil "À Á =­¦ÂÃ!«“ÄÅÃ \"ÆÉÊËË$*‡ÅÆÉÊËË$*‡" [selected-window minibuffer-window fboundp allocate-event character-to-event 13 t enable-recursive-minibuffers unread-command-event read-from-minibuffer "" nil ange-ftp-tmp-keymap unread-command-char] 5 "\
Gross hack to set minibuf_message = 0, so that the contents of the
minibuffer will show."])
(fset 'ange-ftp-ftp-process-buffer #[(host user) "À	ÂÄ°‡" ["*ftp " user "@" host "*"] 5 "\
Return the name of the buffer that collects output from the ftp process
connected to the given HOST and USER pair."])
(fset 'ange-ftp-error #[(host user msg) "À ÁÄÅÆ\"!!ˆdbˆÉ!ˆ*ÊËÌÍ\"C\"‡" [selected-window t pop-up-windows cur pop-to-buffer get-buffer-create ange-ftp-ftp-process-buffer host user select-window signal ftp-error format "FTP Error: %s" msg] 5 "\
Display the last chunk of output from the ftp process for the given HOST
USER pair, and signal an error including MSG in the text."])
(fset 'ange-ftp-set-buffer-mode #[nil ";­Á!­‹Â!ˆÄÅ!ˆÆ‰‡" [buffer-file-name ange-ftp-ftp-path auto-save-mode ange-ftp-auto-save make-variable-buffer-local revert-buffer-function ange-ftp-revert-buffer] 2 "\
Set the correct modes for the current buffer if it is visiting a remote
file."])
(fset 'ange-ftp-kill-ftp-process #[(buffer) "¬‚pÁ ®\n‰­ŸÄÅ!!‰­”@A@ÉÊ\"!*))‡" [buffer buffer-file-name default-directory file ange-ftp-ftp-path expand-file-name parsed user host kill-buffer ange-ftp-ftp-process-buffer] 5 "\
If the BUFFER's visited filename or default-directory is an ftp filename
then kill the related ftp process." "bKill FTP process associated with buffer: "])
(fset 'ange-ftp-quote-string #[(string) "ÀÁÂÃ\"\"‡" [apply concat mapcar #[(char) "ÁX¬ÂV¬ŠÃU¬…ÄU«…ÅÄ\"‡Å!‡" [char 32 126 34 92 vector] 3] string] 5 "\
Quote any characters in STRING that may confuse the ftp process."])
(fset 'ange-ftp-barf-if-not-directory #[(directory) "À	!®ÂÃÄÅ	!«ƒÆªÇ	E\"‡" [file-directory-p directory signal file-error "Opening directory" file-exists-p "not a directory" "no such file or directory"] 5])
(fset 'ange-ftp-process-handle-line #[(line proc) "À	\n\"«ÃÄ\nÅ”Å•O!Æ\"‰‡À\n\"«‚É‡À\n\n\"«‹ËÉ\n‰‡À\n\"«Ğ!ˆË\n‰‡À\n\"«…É‰‡«‚É‡Ë\n‰‡" [string-match ange-ftp-xfer-size-msgs line ash string-to-int 1 -10 ange-ftp-xfer-size ange-ftp-skip-msgs t ange-ftp-good-msgs nil ange-ftp-process-busy ange-ftp-process-result ange-ftp-process-result-line ange-ftp-fatal-msgs delete-process proc ange-ftp-multi-msgs ange-ftp-process-multi-skip] 5 "\
Look at the given LINE from the ftp process PROC.  Try to catagorize it
into one of four categories: good, skip, fatal, or unknown."])
(fset 'ange-ftp-process-log-string #[(proc str) "pÁÂÄ!qˆ`Æ!UŠÆ!bˆcˆÆ!`Â“ˆ)­„Æ!b+‡" [old-buffer ((set-buffer old-buffer)) nil moving process-buffer proc process-mark str] 3 "\
For a given PROCESS, log the given STRING at the end of its
associated buffer."])
(fset 'ange-ftp-set-xfer-size #[(host user bytes) "À	\n\"‰­•Ä!‰­ŠqˆÆÈ\"‰	)))‡" [ange-ftp-get-process host user proc process-buffer buf ash bytes -10 ange-ftp-xfer-size] 4 "\
Set the size of the next FTP transfer in bytes."])
(fset 'ange-ftp-process-handle-hash #[(str) "Á‰”OÁ•ÂOPÁ•Á”Z\\«Ç«ÄÆ Ç =¬½ÈÉ!¬¸\n¬´Ë_Í\"ÁU«‰ĞÑ#ˆª›Ò_¥‰=¬‹ĞÕ#ˆ))‡" [str 0 nil ange-ftp-hash-mark-count ange-ftp-process-msg ange-ftp-process-verbose selected-window minibuffer-window boundp search-message cursor-in-echo-area ash ange-ftp-hash-mark-unit -6 kbytes ange-ftp-xfer-size ange-ftp-message "%s...%dk" 100 percent ange-ftp-last-percent "%s...%d%%"] 5 "\
Remove hash marks from STRING and display count so far."])
(fset 'ange-ftp-call-cont #[(cont result line) "­—<«@Á=¬‰Â@A$‡\"‡" [cont lambda apply result line] 5 "\
Call the function specified by CONT.  CONT can be either a function or a
list of a function and some args.  The first two parameters passed to the
function will be RESULT and LINE.  The remaining args will be taken from CONT
if a list was passed."])
(fset 'ange-ftp-process-filter #[(proc str) "À	!pÄ!…µ ÅÆ ÈÀ	!qˆ	«‘\n«ËÌ\"«†Î!Ï	\"ˆ\n«“PËÑ\"«…Ò	Ó\"ˆ\n«±ËÓ\"«ªÔ‰”OÔ•ÖOË×\"«ŠÔ•ÖOªoØ	\"ˆ)ªK\n?­¯Ô«”««ŒİŞ\"ˆß ˆÖ ­ !Ö â!##)+*‡" [process-buffer proc old-buffer buffer buffer-name ((set-buffer old-buffer)) match-data match-data ((store-match-data match-data)) ange-ftp-hash-mark-unit ange-ftp-process-busy string-match "^#+$" str ange-ftp-process-handle-hash ange-ftp-process-log-string ange-ftp-process-string "Password: *$" send-string "\n" 0 line nil "^ftp> *" ange-ftp-process-handle-line ange-ftp-xfer-size ange-ftp-process-msg ange-ftp-process-verbose ange-ftp-process-result ange-ftp-message "%s...done" ange-ftp-repaint-minibuffer ange-ftp-process-continue cont ange-ftp-call-cont ange-ftp-process-result-line] 4 "\
Build up a complete line of output from the ftp PROCESS and pass it
on to ange-ftp-process-handle-line to deal with."])
(fset 'ange-ftp-process-sentinel #[(proc str) "À ÂÃ!ÆÇ\"«˜È”È•OÉ”É•O\nÌ\n\"ˆ*)Í‰*‡" [match-data match-data ((store-match-data match-data)) process-name proc name string-match "\\*ftp \\([^@]+\\)@\\([^*]+\\)*" 1 2 host user ange-ftp-wipe-file-entries nil ange-ftp-ls-cache-file] 4 "\
When ftp process changes state, nuke all file-entries in cache."])
(fset 'ange-ftp-use-gateway-p #[(host) "?­ŒÁ ÃÄ\"*?‡" [ange-ftp-smart-gateway match-data match-data ((store-match-data match-data)) string-match ange-ftp-local-host-regexp host] 3 "\
Returns whether to access this host via a normal (non-smart) gateway."])
(fset 'ange-ftp-use-smart-gateway-p #[(host) "­ŒÁ ÃÄ\"*?‡" [ange-ftp-smart-gateway match-data match-data ((store-match-data match-data)) string-match ange-ftp-local-host-regexp host] 3 "\
Returns whether to access this host via a smart gateway."])
(byte-code "ÀÁ!¬‚ÂÀÃ!¬„ÄÅ!ÀÆ!¬ƒÂÂ‡" [boundp ange-ftp-tmp-name-files nil ange-ftp-tmp-name-hashtable ange-ftp-make-hashtable 10 ange-ftp-pid] 2)
(fset 'ange-ftp-get-pid #[nil "ÀÁ!ÂÃO‰‡" [make-temp-name "" 1 nil ange-ftp-pid] 3 "\
Half-hearted attempt to get the current process's id."])
(fset 'ange-ftp-make-tmp-name #[(host) "À	!«ƒ\nª®‚Æ È	ÊÊÍÎ	$Ï\"‰>¬†Ò!«“	T‰	ÓV«XÔPÈ	ªOB-‡" [ange-ftp-use-gateway-p host ange-ftp-gateway-tmp-name-template ange-ftp-tmp-name-template template ange-ftp-pid ange-ftp-get-pid pid 97 start nil file entry format "%s%c%s" intern ange-ftp-tmp-name-hashtable ange-ftp-tmp-name-files ange-ftp-real-file-exists-p 122 "X"] 6 "\
This routine will return the name of a new file."])
(byte-code "ÀÁMˆÂÃ!¬‚ÄÂÅ!¬‚ÆÇÈMˆÉÊM‡" [ange-ftp-del-tmp-name #[(temp) "ÀÁ\n\"\"ÅÆÇ‡" [delq intern temp ange-ftp-tmp-name-hashtable ange-ftp-tmp-name-files nil (ange-ftp-real-delete-file temp) ((error))] 4] boundp ange-ftp-gwp-running t ange-ftp-gwp-status nil ange-ftp-gwp-sentinel #[(proc str) "À‰‡" [nil ange-ftp-gwp-running] 2] ange-ftp-gwp-filter #[(proc str) "À ÂÃ\"ˆÆÇ\"«ÈÉ\nË!)ÍP\"ª´ÆÎ\"«ÈÏË!\"ÍP\"ªŸÆ\"«ŠÑ!ˆÒ‰ªÆ\"­‡ÒÉ‰*‡" [match-data match-data ((store-match-data match-data)) ange-ftp-process-log-string proc str string-match "login: *$" send-string t ange-ftp-default-user ange-ftp-get-user ange-ftp-gateway-host "\n" "Password: *$" ange-ftp-get-passwd ange-ftp-gateway-fatal-msgs delete-process nil ange-ftp-gwp-running ange-ftp-gateway-prompt-pattern ange-ftp-gwp-status] 6]] 2)
(fset 'ange-ftp-gwp-start #[(host user name args) "À	!Ã‰	$ÇÈ	Ê#Ì!ˆÍÎ\"ˆÏĞ\"ˆÑ!`Ò“ˆÓÒÖ×	\"ˆ«‡Ø!ˆªu¬ˆÙÜ#ˆÖİ	\"ˆÓÒŞ\"ˆ«‡Ø!ˆªu¬ˆÙà#ˆÓÒŞáâQ\"ˆ+‡" [ange-ftp-get-user ange-ftp-gateway-host gw-user start-process name ange-ftp-gateway-program proc mapconcat identity args " " ftp process-kill-without-query set-process-sentinel ange-ftp-gwp-sentinel set-process-filter ange-ftp-gwp-filter process-mark nil t ange-ftp-gwp-running ange-ftp-gwp-status ange-ftp-message "Connecting to gateway %s..." accept-process-output ange-ftp-error host user "unable to login to gateway" "Connecting to gateway %s...done" process-send-string ange-ftp-gateway-setup-term-command "unable to set terminal modes on gateway" "exec " "\n"] 5 "\
Login to the gateway machine and fire up an ftp process."])
(fset 'ange-ftp-raw-send-cmd #[(proc cmd &optional msg cont nowait) "À	!Â>…™ ŠÃ	!qˆ«…Å ˆªxÆÆÉÊÊÑÓÖP«Š«†ØÙ\"ˆdbˆ`Ê“ˆÛ İŞß\"«ŒÑ‰•Oà±ˆª„cˆ*!`Ê“ˆâ	\"ˆã	!`Ê“ˆ$?­“«†Å	!ˆªw?­…B)‡" [process-status proc (run open) process-buffer ange-ftp-process-busy accept-process-output "" ange-ftp-process-string ange-ftp-process-result-line t nil ange-ftp-process-result ange-ftp-process-multi-skip msg ange-ftp-process-msg cont ange-ftp-process-continue 0 ange-ftp-hash-mark-count -1 ange-ftp-last-percent cmd "\n" ange-ftp-process-verbose ange-ftp-message "%s..." last-input-start match-data match-data ((store-match-data match-data)) string-match "^user \"[^\"]*\"" " Turtle Power!\n" last-input-end send-string process-mark nowait] 3 "\
Low-level routine to send the given ftp CMD to the ftp PROCESS.
MSG is an optional message to output before and after the command.
If CONT is non-NIL then it is either a function or a list of function and
some arguments.  The function will be called when the ftp command has completed.
If CONT is NIL then this routine will return ( RESULT . LINE ) where RESULT
is whether the command was successful, and LINE is the line from the FTP
process that caused the command to complete.
If NOWAIT is given then the routine will return immediately the command has
been queued with no result.  CONT will still be called, however."])
(fset 'ange-ftp-nslookup-host #[(host) "«¸ÁÂ‰$Æ!ˆŠÇ!qˆÈ!É>«†Ê!ˆªsebˆËÌÍÎ#«†Ï”Ï•{Ğp!ˆ)*‡‡" [ange-ftp-nslookup-program start-process " *nslookup*" host res proc process-kill-without-query process-buffer process-status (run open) accept-process-output re-search-forward "Name:.*\nAddress: *\\(.*\\)$" nil t 1 kill-buffer] 5 "\
Attempt to resolve the given HOSTNAME using nslookup if possible." "sHost:  "])
(fset 'ange-ftp-start-process #[(host user name) "À	!‰«ƒªÆC\"É\n\n«¤«Ì	$\nªÏĞ‰ÆD\"$\nªŠÏĞ‰$\nÓ\n!ˆŠÔ\n!qˆÕ ˆ)Ö\n×\"ˆØ\nÙ\"ˆÚ\n!ˆ\n,‡" [ange-ftp-use-gateway-p host use-gateway ange-ftp-gateway-ftp-program-name ange-ftp-ftp-program-name ftp-prog append ange-ftp-ftp-program-args args nil proc ange-ftp-gateway-program-interactive ange-ftp-gwp-start user name apply start-process ange-ftp-gateway-program ange-ftp-gateway-host process-kill-without-query process-buffer ange-ftp-shell-mode set-process-sentinel ange-ftp-process-sentinel set-process-filter ange-ftp-process-filter accept-process-output] 8 "\
Spawn a new ftp process ready to connect to machine HOST and give it NAME.
If HOST is only ftp-able through a gateway machine then spawn a shell
on the gateway machine to do the ftp instead."])
(fset 'ange-ftp-smart-login #[(host user pass account proc) "À	ÂÃÄ!#ÂÇ##‰	@¬ŒÊÌ	AP#ˆÀ	ÂÍÄ!%ÂĞ##‰	@®›ÑÒ#ˆÓÒ#ˆÊÔ	AP#)‡" [ange-ftp-raw-send-cmd proc format "open %s %s" ange-ftp-nslookup-host ange-ftp-gateway-host ange-ftp-smart-gateway-port "Opening FTP connection to %s via %s" host result ange-ftp-error user "OPEN request failed: " "user \"%s\"@%s %s %s" pass account "Logging in as user %s@%s" ange-ftp-set-passwd nil ange-ftp-set-account "USER request failed: "] 9 "\
Connect to the FTP-server on HOST as USER using PASSWORD and ACCOUNT.
PROC is the FTP-client's process.  This routine uses the smart-gateway
host specified in ``ange-ftp-gateway-host''."])
(fset 'ange-ftp-normal-login #[(host user pass account proc) "À	ÂÃÄ!\"ÂÆ\"#‰@¬‹È	ÊAP#ˆÀ	ÂË	$ÂÎ	##‰@®˜Ï	Ğ#ˆÑ	Ğ#ˆÈ	ÒAP#)‡" [ange-ftp-raw-send-cmd proc format "open %s" ange-ftp-nslookup-host host "Opening FTP connection to %s" result ange-ftp-error user "OPEN request failed: " "user \"%s\" %s %s" pass account "Logging in as user %s@%s" ange-ftp-set-passwd nil ange-ftp-set-account "USER request failed: "] 8 "\
Connect to the FTP-server on HOST as USER using PASSWORD and ACCOUNT.
PROC is the process to the FTP-client."])
(defvar ange-ftp-hash-mark-msgs "[hH]ash mark [^0-9]*\\([0-9]+\\)" "\
*Regexp matching the FTP client's output upon doing a HASH command.")
(fset 'ange-ftp-guess-hash-mark-size #[(proc) "­ÂŠÁ\n!qˆÃ\nÄ\"‰@AÈ 	ÊË\"­ŸÍÎ”Î•O!‰ÑÒ\"®…‰).‡" [ange-ftp-send-hash process-buffer proc ange-ftp-raw-send-cmd "hash" status result line match-data match-data ((store-match-data match-data)) string-match ange-ftp-hash-mark-msgs string-to-int 1 size ange-ftp-ascii-hash-mark-size ash -4 ange-ftp-hash-mark-unit ange-ftp-binary-hash-mark-size] 5])
(fset 'ange-ftp-get-process #[(host user) "À	\n\"Ä!‰«ŠÆ!Ç>«ƒªÀÈÉ	\n\"!ÈÊ	\n\"!Í	\n#Î	!«ŒÏ	\n%ˆªŠĞ	\n%ˆÑ!ˆÒ	\n\"ˆÓÔ!ˆ**‡" [ange-ftp-ftp-process-buffer host user name get-process proc process-status (run open) ange-ftp-quote-string ange-ftp-get-passwd ange-ftp-get-account account pass ange-ftp-start-process ange-ftp-use-smart-gateway-p ange-ftp-smart-login ange-ftp-normal-login ange-ftp-guess-hash-mark-size ange-ftp-guess-host-type run-hooks ange-ftp-process-startup-hook] 7 "\
Return the process object for a FTP process connected to HOST and
logged in as USER.  Create a new process if needed."])
(byte-code "ÀÁ!¬‚ÂÀÃ!¬‚ÂÂ‡" [boundp ange-ftp-host-cache nil ange-ftp-host-type-cache] 2)
(fset 'ange-ftp-host-type #[(host &optional user) "	=«‚\n‡«Ä\"«‡	=«‚\n‡Å!«ƒÆªµÇÈ!«ˆÈ!«ƒÉª¨ÇÊ!«ˆÊ!«ƒËª›ÇÌ!«ˆÌ!«ƒÍªÇÎ!«ˆÎ!«ƒÏªĞ‰‡" [host ange-ftp-host-cache ange-ftp-host-type-cache user ange-ftp-get-process ange-ftp-dumb-unix-host dumb-unix fboundp ange-ftp-vos-host vos ange-ftp-vms-host vms ange-ftp-mts-host mts ange-ftp-cms-host cms unix] 3 "\
Return a symbol which represents the type of the HOST given.
If the optional argument USER is given, attempts to guess the
host-type by logging in as USER."])
(defvar ange-ftp-fix-path-func-alist nil "\
Association list of ( TYPE . FUNC ) pairs, where FUNC is a routine
which can change a UNIX path into a path more suitable for a host of type
TYPE.")
(defvar ange-ftp-fix-dir-path-func-alist nil "\
Association list of ( TYPE . FUNC ) pairs, where FUNC is a routine
which can change UNIX directory path into a directory path more suitable
for a host of type TYPE.")
(defvar ange-ftp-dumb-host-types '(dumb-unix) "\
List of host types that can't take UNIX ls-style listing options.")
(fset 'ange-ftp-send-cmd #[(host user cmd &optional msg cont nowait) "@A@Á‰‰‰ƒ– È8É\n\"Ì=«¼A®Î!Ï8Ğ=«“ÑÒ\"«ŒÑÓ\"¬†ÔP>¬ÀÖ×Ø#ª³A®ÎÚ>«ˆ\n!ªœÛ>«†\n!ªÜ=«Š\n!\n!İ!‰­„ŞP­ƒŞPQÁ‰ áâ\n\"#ä\n#%&¯&%ˆ&?­Š%?­… B.‡" [cmd nil fix-pathname-func host-type cmd3 cmd2 cmd1 cmd0 2 ange-ftp-host-type host user dir ange-ftp-fix-dir-path-func-alist identity 3 unix string-match "/$" "R" "." ange-ftp-dumb-host-types ls format "\"%s %s\"" ange-ftp-fix-path-func-alist (get delete mkdir rmdir cd) (append put chmod) rename symbol-name " " afsc-line afsc-result ange-ftp-raw-send-cmd ange-ftp-get-process msg #[(result line host user cmd msg cont nowait) "¬„		«†Å	#‡ÆÇ	\"\nÌD%‡" [cont result afsc-result line afsc-line ange-ftp-call-cont ange-ftp-raw-send-cmd ange-ftp-get-process host user cmd msg #[(result line cont) "¬„	Å	#‡" [cont result afsc-result line afsc-line ange-ftp-call-cont] 4] nowait] 6] cont nowait] 12 "\
Find an ftp process connected to HOST logged in as USER and send it CMD.
MSG is an optional status message to be output before and after issuing the
command.
See the documentation for ange-ftp-raw-send-cmd for a description of CONT
and NOWAIT."])
(byte-code "ÀÁPÃÅÇ‡" ["^[-A-Z0-9$*][-A-Z0-9$*]?[-A-Z0-9$*]?[-A-Z0-9$*]?[-A-Z0-9$*]?" "[-A-Z0-9$*]?[-A-Z0-9$*]?[-A-Z0-9$*]?\\.[0-9][0-9][0-9A-Z]$" ange-ftp-cms-path-template "^[-A-Z0-9_$]+:\\[[-A-Z0-9_$]+\\(\\.[-A-Z0-9_$]+\\)*\\]$" ange-ftp-vms-path-template "^[A-Z0-9._][A-Z0-9._][A-Z0-9._][A-Z0-9._]:$" ange-ftp-mts-path-template nil] 2)
(fset 'ange-ftp-guess-host-type #[(host user) "À	!	ÂÄR‰Ç=ƒ¢ È 	ÊË	\"‰@Î¬œĞÑ!ˆÒÓ!ˆÔÕA\"«ÎÖ	!ˆ	ØªÂÔ\"«ŒÛ	!ˆ	Üª®Ô\"«ŒŞ	!ˆ	ßªšÔ \"«ŒÖ	!ˆ	Øª†	Ç!A‰«ˆâ\"ã$#ˆ-Ø=­¥å$\"?­Ë	\"@‰«‹ãÂP$#ª‡ĞÑ!ˆÒÓ!)*‡" [ange-ftp-host-type host "/" user "/~" key host-type unix match-data match-data ((store-match-data match-data)) ange-ftp-get-pwd result dir nil fix-path-func message "Warning! Unable to get home directory" sit-for 1 string-match "^450 No current working directory defined$" ange-ftp-add-cms-host ange-ftp-host-cache cms ange-ftp-host-type-cache ange-ftp-vms-path-template ange-ftp-add-vms-host vms ange-ftp-mts-path-template ange-ftp-add-mts-host mts ange-ftp-cms-path-template ange-ftp-fix-path-func-alist reverse ange-ftp-put-hash-entry ange-ftp-expand-dir-hashtable ange-ftp-hash-entry-exists-p] 6 "\
Guess at the the host type of HOST by doing a pwd, and examining
the directory syntax."])
(byte-code "ÀÁ!¬‚ÂÂ‡" [boundp ange-ftp-shell-mode-map nil] 2)
(fset 'ange-ftp-shell-mode #[nil "Àp!Â ˆ¬ÄÅ!ˆÆ!ÈÉÊ#ˆË!ˆÌÎĞÒÓ!ˆÔ ÒÕ!ˆÔ dbˆÖ	!`×“ˆÒØ!ˆÙÒÚ!ˆÒÛ!ˆÒÜ!ˆÒİ!ˆÒŞ!ˆÒß!ˆÒà!ˆÒá!ˆÒâ!ˆÒã!ˆÒä!ˆÒå!ˆæ æ$Ùçè!)‡" [get-buffer-process proc kill-all-local-variables ange-ftp-shell-mode-map require shell copy-keymap shell-mode-map define-key "" ange-ftp-shell-send-input use-local-map ange-ftp-shell-mode major-mode "ange-ftp" mode-name (": %s") mode-line-process make-local-variable last-input-start make-marker last-input-end process-mark nil ange-ftp-process-string "" ange-ftp-process-busy ange-ftp-process-result ange-ftp-process-msg ange-ftp-process-multi-skip ange-ftp-process-result-line ange-ftp-process-continue ange-ftp-hash-mark-count ange-ftp-binary-hash-mark-size ange-ftp-ascii-hash-mark-size ange-ftp-hash-mark-unit ange-ftp-xfer-size ange-ftp-last-percent 0 run-hooks ange-ftp-shell-mode-hook] 4 "\
Major mode for interacting with an FTP process.
Return at end of buffer sends line as input.
Return not at end copies rest of line to end and sends it.

The following commands imitate the usual Unix interrupt and editing
control characters:
\\{ange-ftp-shell-mode-map}
Runs ange-ftp-shell-mode-hook if not nil." nil])
(fset 'ange-ftp-shell-send-input #[nil "Àp!‰¬„ÂÃ!ˆÄˆm«’Æ	!Ä“ˆÇcˆ`Ä“ˆª©ÉyˆÊËŠÄˆ`)Ì#ˆ`Íyˆ`{dbˆ`Ä“ˆcˆ`Ä“ˆ)Ï	#ˆÆ	!`Ä“)‡" [get-buffer-process process error "Current buffer has no process" nil last-input-start process-mark 10 last-input-end 0 re-search-forward "ftp> *" t 1 copy process-send-region] 5 "\
Send input to FTP process.
At end of buffer, sends all text after last output as input to the subshell,
including a newline inserted at the end.  When not at end, copies current line
to the end of the buffer and sends it, after first attempting to discard any
prompt at the beginning of the line." nil])
(fset 'ange-ftp-dumb-unix-host #[(host) "­ŠÁ ÃÄ\"*‡" [ange-ftp-dumb-unix-host-regexp match-data match-data ((store-match-data match-data)) string-match host] 3 "\
Returns whether HOST's FTP server doesn't like 'ls' or 'dir' commands
to take switch arguments."])
(fset 'ange-ftp-add-dumb-unix-host #[(host) "À	!?­‘ÂÃ	!Ä­Æ°Ç‰‡" [ange-ftp-dumb-unix-host host "^" regexp-quote "$" ange-ftp-dumb-unix-host-regexp "\\|" nil ange-ftp-host-cache] 5 "\
Interactively adds a given HOST to ange-ftp-dumb-unix-host-regexp." (byte-code "ÀÁÂ ®†Ä=­‰­…Ç!@)\"C‡" [read-string "Host: " buffer-file-name major-mode dired-mode dired-directory name ange-ftp-ftp-path] 5)])
(defvar ange-ftp-parse-list-func-alist nil "\
Association list of ( TYPE . FUNC ) pairs.  The FUNC is a routine
which can parse the output from a DIR listing for a host of type TYPE.")
(fset 'ange-ftp-ls #[(file lsargs parse &optional no-error) "À	!Â	!‰ƒö @A@ÆÇ8!É	!\nË\"‰>ÏÏÏÏÔ˜«‰ÕÖ×#!«—\n˜«¬‡˜«…‚ò Ü!İFŞßàáâ	!\"$‰@«ßŠã$!qˆå ˆæ!«‡ç!ˆªœè)!ˆæ!«‡ç!ˆªŠêàë\"#ˆ,«˜í	.A‰«… ª„ï!\"ˆ\nğ ‰)ª1?­‰êòAP#).\nªƒóô!)‡" [ange-ftp-expand-file-name file ange-ftp-ftp-path parsed host user ange-ftp-quote-string 2 path directory-file-name key ange-ftp-host-type host-type ange-ftp-dumb-host-types dumb nil result temp lscmd parse-func "" ange-ftp-real-file-name-as-directory ange-ftp-expand-dir "~" ange-ftp-ls-cache-file lsargs ange-ftp-ls-cache-lsargs ange-ftp-ls-cache-res ange-ftp-make-tmp-name dir ((ange-ftp-del-tmp-name temp)) ange-ftp-send-cmd format "Listing %s" ange-ftp-abbreviate-filename get-buffer-create ange-ftp-data-buffer-name erase-buffer ange-ftp-real-file-readable-p ange-ftp-real-insert-file-contents sleep-for ange-ftp-retry-time ange-ftp-error "list data file %s not readable" parse ange-ftp-set-files ange-ftp-parse-list-func-alist ange-ftp-parse-dired-listing buffer-string no-error "DIR failed: " error "Should never happen. Please report. Bug ref. no.: 1"] 9 "\
Return the output of an `DIR' or `ls' command done over ftp.
FILE is the full name of the remote file, LSARGS is any args to pass to the
`ls' command, and PARSE specifies that the output should be parsed and stored
away in the internal cache."])
(byte-code "ÀÁPÃ‡" [" \\(Jan\\|Feb\\|Mar\\|Apr\\|May\\|Jun\\|Jul\\|Aug\\|Sep\\|Oct" "\\|Nov\\|Dec\\) +[0-3]?[0-9] " ange-ftp-date-regexp nil] 2)
(defvar ange-ftp-add-file-entry-alist nil "\
Association list of pairs ( TYPE . FUNC ), where FUNC
is a function to be used to add a file entry for the OS TYPE. The
main reason for this alist is to deal with file versions in VMS.")
(defvar ange-ftp-delete-file-entry-alist nil "\
Association list of pairs ( TYPE . FUNC ), where FUNC
is a function to be used to delete a file entry for the OS TYPE.
The main reason for this alist is to deal with file versions in
VMS.")
(fset 'ange-ftp-add-file-entry #[(path &optional dir-p) "ÀÁ\n!@!A®Ä\n\"ˆÆ‰‡" [ange-ftp-host-type ange-ftp-ftp-path path ange-ftp-add-file-entry-alist ange-ftp-internal-add-file-entry dir-p nil ange-ftp-ls-cache-file] 3 "\
Given a PATH, add the file entry for it, if its directory
info exists."])
(fset 'ange-ftp-delete-file-entry #[(path &optional dir-p) "ÀÁ\n!@!A®Ä\n\"ˆÆ‰‡" [ange-ftp-host-type ange-ftp-ftp-path path ange-ftp-delete-file-entry-alist ange-ftp-internal-delete-file-entry dir-p nil ange-ftp-ls-cache-file] 3 "\
Given a PATH, delete the file entry for it, if its directory
info exists."])
(byte-code "ÀÁMˆÂÃM‡" [ange-ftp-parse-filename (macro . #[nil "À‡" [(let ((eol (progn (end-of-line) (point)))) (beginning-of-line) (if (re-search-forward ange-ftp-date-regexp eol t) (progn (skip-chars-forward " ") (skip-chars-forward "^ " eol) (skip-chars-forward " " eol) (buffer-substring (point) eol))))] 1]) ange-ftp-ls-parser (macro . #[nil "À‡" [(let ((tbl (ange-ftp-make-hashtable)) (used-F (and (stringp switches) (string-match "F" switches))) file-type symlink directory file) (while (setq file (ange-ftp-parse-filename)) (beginning-of-line) (skip-chars-forward "	 0-9") (setq file-type (following-char) directory (eq file-type 100)) (if (eq file-type 108) (if (string-match " -> " file) (setq symlink (substring file (match-end 0)) file (substring file 0 (match-beginning 0))) (setq symlink "")) (setq symlink nil)) (if (and used-F (not (string-equal file "")) (looking-at ".[-r][-w]\\([^ ]\\)[-r][-w]\\([^ ]\\)[-r][-w]\\([^ ]\\)")) (let ((socket (eq file-type 115)) (executable (and (not symlink) (string-match "[xst]" (concat (buffer-substring (match-beginning 1) (match-end 1)) (buffer-substring (match-beginning 2) (match-end 2)) (buffer-substring (match-beginning 3) (match-end 3))))))) (if (or (and symlink (string-match "@$" file)) (and directory (string-match "/$" file)) (and executable (string-match "*$" file)) (and socket (string-match "=$" file))) (setq file (substring file 0 -1))))) (ange-ftp-put-hash-entry file (or symlink directory) tbl) (forward-line 1)) (ange-ftp-put-hash-entry "." t tbl) (ange-ftp-put-hash-entry ".." t tbl) tbl)] 1])] 2)
(defvar ange-ftp-dl-dir-regexp nil "\
Regexp matching directories which are listed in dl format. This regexp
shouldn't be anchored with a trailing $ so that it will match subdirectories
as well.")
(fset 'ange-ftp-add-dl-dir #[(dir) "­„Á\n\"?­ŒÃÄ\n!­ÅR‰‡" [ange-ftp-dl-dir-regexp string-match dir "^" regexp-quote "\\|"] 4 "\
Interactively adds a given directory to ange-ftp-dl-dir-regexp." (byte-code "ÀÁÂ ®†Ä=­‰­ŠÇ!­„È!)\"C‡" [read-string "Directory: " buffer-file-name major-mode dired-mode dired-directory name ange-ftp-ftp-path file-name-directory] 5)])
(fset 'ange-ftp-dl-parser '(macro . #[nil "À‡" [(let ((tbl (ange-ftp-make-hashtable))) (while (not (eobp)) (ange-ftp-put-hash-entry (buffer-substring (point) (progn (skip-chars-forward "^ /\n") (point))) (eq (following-char) 47) tbl) (forward-line 1)) (ange-ftp-put-hash-entry "." t tbl) (ange-ftp-put-hash-entry ".." t tbl) tbl)] 1]))
(fset 'ange-ftp-parse-dired-listing #[(&optional switches) "À ÂÃÄ!ƒÅyˆÆ ;­…ÈÉ\"Ê‰‰‰Êˆ`ÒyˆÓÕ#­’ÖÊwˆ×wˆÖwˆ`{)‰ƒÒyˆØÊwˆg‰Ù=Ú=«ÈÛ\"«’Ò•ÊOÒ‰”OªˆÜªƒÊ«ßÜ˜¬ÙÃİ!«ÔŞ=?­“ÈßÅ”Å•{à”à•{á”á•{Q\"\"#«‡Èä\"¬¡«‡Èå\"¬–\"«‡Èæ\"¬‹#«Èç\"«‡ÒèO*é®‚#ˆÅyˆ‚* éêÕ#ˆéëÕ#ˆ.‚wÃì!«„Ê‚wm«„Ê‚wÓÊÕ#ƒ9ÒyˆÆ ;­…ÈÉ\"Ê‰‰‰Êˆ`ÒyˆÓÕ#­’ÖÊwˆ×wˆÖwˆ`{)‰ƒ%ÒyˆØÊwˆg‰Ù=Ú=«ÈÛ\"«’Ò•ÊOÒ‰”OªˆÜªƒÊ«ßÜ˜¬ÙÃİ!«ÔŞ=?­“ÈßÅ”Å•{à”à•{á”á•{Q\"\"#«‡Èä\"¬¡«‡Èå\"¬–\"«‡Èæ\"¬‹#«Èç\"«‡ÒèO*é®‚#ˆÅyˆ‚NéêÕ#ˆéëÕ#ˆ.ª¾ÓíÊÕ#«¶î!ˆÒyˆÆ m¬”é`ïÊwˆ`{gğ=#ˆÅyˆªiéêÕ#ˆéëÕ#ˆ)ªÊ*‡" [match-data match-data ((store-match-data match-data)) looking-at "^total [0-9]+$" 1 ange-ftp-make-hashtable switches string-match "F" nil file directory symlink file-type used-F tbl eol 0 re-search-forward ange-ftp-date-regexp t " " "^ " "	 0-9" 100 108 " -> " "" ".[-r][-w]\\([^ ]\\)[-r][-w]\\([^ ]\\)[-r][-w]\\([^ ]\\)" 115 "[xst]" 2 3 executable socket "@$" "/$" "*$" "=$" -1 ange-ftp-put-hash-entry "." ".." "[^\n]+\\( not found\\|: Not a directory\\)\n\\'" "^[^ \n	]+ +\\([0-9]+\\|-\\|=\\) " ange-ftp-add-dl-dir "^ /\n" 47] 8 "\
Parse the current buffer which is assumed to be in a dired-like listing
format, and return a hashtable as the result. If the listing is not really
a listing, then return nil."])
(fset 'ange-ftp-set-files #[(directory files) "­‡ÁÂ!#‡" [files ange-ftp-put-hash-entry file-name-as-directory directory ange-ftp-files-hashtable] 4 "\
For a given DIRECTORY, set or change the associated FILES hashtable."])
(fset 'ange-ftp-get-files #[(directory &optional no-error) "À	!Â	\"®ÙÄ ÆÇ	ÈÉ!«	;«™ÊË	\"«’ÊÌ	\"«‹ÊÍ	\"¬„	ª¤ÈÎ!«;«™ÊË\"«’ÊÌ\"«‹ÊÍ\"¬„ªÏĞ$­„Â	\"*‡" [file-name-as-directory directory ange-ftp-get-hash-entry ange-ftp-files-hashtable match-data match-data ((store-match-data match-data)) ange-ftp-ls boundp dired-actual-switches string-match "[aA]" "l" "R" dired-listing-switches "-al" t no-error] 5 "\
Given a given DIRECTORY, return a hashtable of file entries.
This will give an error or return nil, depending on the value of
NO-ERROR, if a listing for DIRECTORY cannot be obtained."])
(fset 'ange-ftp-get-file-part '(macro . #[(path) "ÀÁÂDDCÄE‡" [let file file-name-nondirectory path (if (string-equal file "") "." file)] 4 "\
Given PATH, return the file part that can be used for looking up the
file's entry in a hashtable."]))
(fset 'ange-ftp-allow-child-lookup '(macro . #[(dir file) "ÀÁÂDÄDÆÇFÈED‡" [not let* efile file edir dir (parsed (ange-ftp-ftp-path edir)) (host-type (ange-ftp-host-type (car parsed))) (or (and (boundp 'dired-local-variables-file) (stringp dired-local-variables-file) (string-equal dired-local-variables-file efile)) (and (eq host-type 'vms) (string-match "\\." efile)) (and (memq host-type '(mts cms)) (not (string-equal "/" (nth 2 parsed)))))] 6 "\
Return whether ange-ftp-file-entry-p and ange-ftp-get-file-entry are
allowed to determine if PATH is a sub-directory by listing it directly,
rather than listing its parent directory. This is used for efficiency so
that a wasted listing is not done:
1. When looking for a .dired file in dired-x.el.
2. The syntax of FILE and DIR make it impossible that FILE could be a valid
    subdirectory. This is of course an OS dependent judgement."]))
(fset 'ange-ftp-file-entry-p #[(path) "À	!Â	!Ä\"Ç	!‰É˜«ƒÊª‚)«ˆË\"ªÙÎ!Ğ@!ÒÓ!«Œ;«‡˜®šÔ=«‡ÕÖ\"®×>­‡Ø8Ù˜?,¬Ú	Û\"‰«‡ÄÊ\"®‡ËÚ!\",‡" [directory-file-name path file-name-directory dir ange-ftp-get-hash-entry ange-ftp-files-hashtable ent file-name-nondirectory file "" "." ange-ftp-hash-entry-exists-p efile edir ange-ftp-ftp-path parsed ange-ftp-host-type host-type boundp dired-local-variables-file vms string-match "\\." (mts cms) 2 "/" ange-ftp-get-files t] 5 "\
Given PATH, return whether there is a file entry for it."])
(fset 'ange-ftp-get-file-entry #[(path) "À	!Â	!Ä\"Ç	!‰É˜«ƒÊª‚)«ˆÄ\"ªÙÍ!Ï@!ÑÒ!«Œ;«‡˜®šÓ=«‡ÔÕ\"®Ö>­‡×8Ø˜?,¬Ù	Ú\"‰«‡ÄÊ\"®‡ÄÙ!\",‡" [directory-file-name path file-name-directory dir ange-ftp-get-hash-entry ange-ftp-files-hashtable ent file-name-nondirectory file "" "." efile edir ange-ftp-ftp-path parsed ange-ftp-host-type host-type boundp dired-local-variables-file vms string-match "\\." (mts cms) 2 "/" ange-ftp-get-files t] 5 "\
Given PATH, return the given file entry which will be either t for a
directory, nil for a normal file, or a string for a symlink. If the file
isn't in the hashtable, this also returns nil."])
(byte-code "ÀÁMˆÂÃM‡" [ange-ftp-internal-delete-file-entry #[(path &optional dir-p) "«Á\n!Ã\n\"ˆÅ\n!ÆÇ\n!\"‰­”ÃÉ\n!‰\nË˜«ƒÌª‚\n)\")‡" [dir-p file-name-as-directory path ange-ftp-del-hash-entry ange-ftp-files-hashtable directory-file-name ange-ftp-get-hash-entry file-name-directory files file-name-nondirectory file "" "."] 4] ange-ftp-internal-add-file-entry #[(path &optional dir-p) "«„Á\n!ÃÄ\n!\"‰­•ÇÈ\n!‰	Ê˜«ƒËª‚	)#)‡" [dir-p directory-file-name path ange-ftp-get-hash-entry file-name-directory ange-ftp-files-hashtable files ange-ftp-put-hash-entry file-name-nondirectory file "" "."] 5]] 2)
(fset 'ange-ftp-wipe-file-entries #[(host user) "À	G!ÃÄ	\"ˆ\n‰)‡" [ange-ftp-make-hashtable ange-ftp-files-hashtable new-tbl ange-ftp-map-hashtable #[(key val) "À	!‰­š\n@\nA@š«†š®‡Ç		#*)‡" [ange-ftp-ftp-path key parsed u h host user ange-ftp-put-hash-entry val new-tbl] 5]] 3 "\
Replace the file entry information hashtable with one that doesn't have any
entries for the given HOST, USER pair."])
(fset 'ange-ftp-set-binary-mode #[(host user) "À	\nÃ#‰@¬ŠÅ	\nÆAP#ª’ŠÇÈ	\n\"!qˆÉ\nË\"‰))‡" [ange-ftp-send-cmd host user (type "binary") result ange-ftp-error "BINARY failed: " process-buffer ange-ftp-get-process ash ange-ftp-binary-hash-mark-size -4 ange-ftp-hash-mark-unit] 6 "\
Tell the ftp process for the given HOST & USER to switch to binary mode."])
(fset 'ange-ftp-set-ascii-mode #[(host user) "À	\nÃ#‰@¬ŠÅ	\nÆAP#ª’ŠÇÈ	\n\"!qˆÉ\nË\"‰))‡" [ange-ftp-send-cmd host user (type "ascii") result ange-ftp-error "ASCII failed: " process-buffer ange-ftp-get-process ash ange-ftp-ascii-hash-mark-size -4 ange-ftp-hash-mark-unit] 6 "\
Tell the ftp process for the given HOST & USER to switch to ascii mode."])
(fset 'ange-ftp-cd #[(host user dir) "À	\nÃDÅ$‰@®‰Ç	\nÈAP#)‡" [ange-ftp-send-cmd host user cd dir "Doing CD" result ange-ftp-error "CD failed: "] 6])
(fset 'ange-ftp-get-pwd #[(host user) "À	\nÃÄ$‰AÇ@«É \nËÌÍ\"¬‡ÌÎ\"«‰Ï”Ï•O*+B‡" [ange-ftp-send-cmd host user (pwd) "Getting PWD" result line nil dir match-data match-data ((store-match-data match-data)) string-match "\"\\([^\"]*\\)\"" " \\([^ ]+\\) " 1] 6 "\
Attempts to get the current working directory for the given HOST/USER pair.
Returns ( DIR . LINE ) where DIR is either the directory or NIL if not found,
and LINE is the relevant success or fail line from the FTP-client."])
(byte-code "À ÂÀ‡" [ange-ftp-make-hashtable ange-ftp-expand-dir-hashtable "^5.0 \\([^: ]+\\):" ange-ftp-expand-dir-regexp] 1)
(fset 'ange-ftp-expand-dir #[(host user dir) "À	\n\"‰A	Æ\nÆ°É\n\"‰†¢ \nÌ˜¬¸\nÍ˜¬³Î=«®ĞQÒ	\nÓÔEÕÖ\"$‰AÙ\"­‡Ú”Ú•O+¬¨Û˜«‰Ü	\n\"@ª™İ	\nÛ#ßà	\n#«‡Ü	\n\"@*«“«‡á\"â\n#ˆ,‡" [ange-ftp-host-type host user host-type ange-ftp-fix-path-func-alist fix-pathname-func "/" dir key ange-ftp-get-hash-entry ange-ftp-expand-dir-hashtable res "anonymous" "ftp" unix ange-ftp-expand-dir-regexp "\\|" ange-ftp-good-msgs ange-ftp-send-cmd get "/dev/null" format "expanding %s" result line string-match 1 "~" ange-ftp-get-pwd ange-ftp-expand-dir home ((ange-ftp-cd host user home)) ange-ftp-cd reverse ange-ftp-put-hash-entry] 8 "\
Return the result of doing a PWD in the current FTP session to machine HOST
logged in as user USER and cd'd to directory DIR."])
(fset 'ange-ftp-canonize-filename #[(n) "ÀÁ\n\"«‡\nÃ•SÄOÅ\n!‰ƒ  @A@Ç8	\nÀË\"¬ÖÀÌ\"«³Ã”Ã•OÃ•ÄOÏ\n	#‰«‰Pª‰ÑÒÓÄO\"ˆ+ªœÏ\n	Ô#‰«‹Õ!Pª„ÑÖ!ˆ)×!ÀØ\"«‡ÓÄOÙ\n\"+ª”Ú\n!Û=«…×\n!ªˆ×Ü\n!İ\n!\")‡" [string-match ".+//" n 0 nil ange-ftp-ftp-path parsed 2 path user host "^/" "^~[^/]*" tilda rest ange-ftp-expand-dir dir error "User \"%s\" is not known" 1 "~" ange-ftp-real-file-name-as-directory "Unable to obtain CWD" ange-ftp-real-expand-file-name "^//" ange-ftp-replace-path-component string-to-char 47 ange-ftp-real-file-name-nondirectory ange-ftp-real-file-name-directory] 6 "\
Take a string and short-circuit //, /. and /.."])
(fset 'ange-ftp-expand-file-name #[(name &optional default) "À ÂÃ!Å=« ÆÇ\"«ŠÈ•SÉO‰ªÆÊ\"«ŠÈ•SÉO‰¬`Ã!Ë=«…Ì!ª¨Ã!Å=«…Í!ªœGÈU«ŠÍ®‚!ªŒÍĞ®‚!P!*‡" [match-data match-data ((store-match-data match-data)) string-to-char name 47 string-match ".+//" 0 nil "/~" 126 ange-ftp-real-expand-file-name ange-ftp-canonize-filename default default-directory file-name-as-directory] 3 "\
Documented as original."])
(defvar ange-ftp-file-name-as-directory-alist nil "\
Association list of ( TYPE . FUNC ) pairs, where
FUNC converts a filename to a directory name for the operating
system TYPE.")
(fset 'ange-ftp-file-name-as-directory #[(name) "À	!‰«™Ã\n8Ä˜«ƒ	ª’Å\n@!A®Ç	!ªƒÇ	!)‡" [ange-ftp-ftp-path name parsed 2 "" ange-ftp-host-type ange-ftp-file-name-as-directory-alist ange-ftp-real-file-name-as-directory] 3 "\
Documented as original."])
(fset 'ange-ftp-file-name-directory #[(name) "À	!‰«Ã\n8Å ÇÈÉ\"*«ƒ	ª†Ê	Ë!\")ªƒË	!)‡" [ange-ftp-ftp-path name parsed 2 path match-data match-data ((store-match-data match-data)) string-match "^~[^/]*$" ange-ftp-replace-path-component ange-ftp-real-file-name-directory] 5 "\
Documented as original."])
(fset 'ange-ftp-file-name-nondirectory #[(name) "À	!‰«šÃ\n8Å ÇÈÉ\"*«ƒÊªƒË!)ªƒË	!)‡" [ange-ftp-ftp-path name parsed 2 path match-data match-data ((store-match-data match-data)) string-match "^~[^/]*$" "" ange-ftp-real-file-name-nondirectory] 4 "\
Documented as original."])
(fset 'ange-ftp-directory-file-name #[(dir) "À	!‰«ŠÃ	ÄÅ\n8!\"ªƒÄ	!)‡" [ange-ftp-ftp-path dir parsed ange-ftp-replace-path-component ange-ftp-real-directory-file-name 2] 6 "\
Documented as original."])
(fset 'ange-ftp-binary-file #[(file) "À ÂÃ\"*‡" [match-data match-data ((store-match-data match-data)) string-match ange-ftp-binary-file-name-regexp file] 3 "\
Returns whether the given FILE is to be considered as a binary file for
ftp transfers."])
(fset 'ange-ftp-write-region #[(start end filename &optional append visit) "À	!Â	!‰ƒ« @A@ÆÇ8!É!\nË	!«ƒÍªÎĞ	!ÒÓÔ Õ ØÙ\nÜ%ˆ,«…Ş\"ˆß\n!‰ «‰áâ 8#ˆ)ã\nEäå\"$‰&@¬çèéäê&A\"	E\"ˆ*Ó=«Šë ˆ	ìÜ!ˆíî\"ˆï	!.ª‹Ù	%)‡" [expand-file-name filename ange-ftp-ftp-path parsed host user ange-ftp-quote-string 2 path ange-ftp-make-tmp-name temp ange-ftp-binary-file binary append put cmd ange-ftp-abbreviate-filename abbr ((byte-code "À	!ˆ\n«…Ã\"ˆÀ‡" [ange-ftp-del-tmp-name temp binary ange-ftp-set-ascii-mode host user] 3)) t buffer-file-name buffer-modified-p mod-p executing-macro ((byte-code "Â!‡" [filename buffer-file-name set-buffer-modified-p mod-p] 2)) ange-ftp-real-write-region start end nil visit ange-ftp-set-binary-mode file-attributes attr ange-ftp-set-xfer-size 7 ange-ftp-send-cmd format "Writing %s" result signal ftp-error "Opening output file" "FTP Error: \"%s\"" ange-ftp-set-buffer-mode set-buffer-modified-p ange-ftp-message "Wrote %s" ange-ftp-add-file-entry] 8 "\
Documented as original." "r\nFWrite region to file: "])
(fset 'ange-ftp-insert-file-contents #[(filename &optional visit) "À ˆÁ\n!Ã\n!‰ƒ¾ «ƒ\nÇ\n!¬‘È	ÊË\n!\"ˆÇ\n!ƒ¶ @A@ÏĞ8!Ò!Ô\n!Ö\n!ÈÙ«‡Ú\"ˆÛÜEİŞ\"$‰@¬àáâİãA\"\nE\"ˆ)ä!¬Œå&!¬†ä!«‹ç\"A@ªŠàáèİé\n\"D\"ˆ)«ƒ\n\n.DªŒàêâ\nD\"ª„ç\n\")‡" [barf-if-buffer-read-only expand-file-name filename ange-ftp-ftp-path parsed visit buffer-file-name file-exists-p nil ange-ftp-ls-cache-file ange-ftp-del-hash-entry file-name-directory ange-ftp-files-hashtable host user ange-ftp-quote-string 2 path ange-ftp-make-tmp-name temp ange-ftp-binary-file binary ange-ftp-abbreviate-filename abbr size ((byte-code "«…Á\n\"ˆÄ!‡" [binary ange-ftp-set-ascii-mode host user ange-ftp-del-tmp-name temp] 3)) ange-ftp-set-binary-mode ange-ftp-send-cmd get format "Retrieving %s" result signal ftp-error "Opening input file" "FTP Error: \"%s\"" ange-ftp-real-file-readable-p sleep-for ange-ftp-retry-time ange-ftp-real-insert-file-contents "Opening input file:" "FTP Error: %s not arrived or readable" file-error] 8 "\
Documented as original."])
(fset 'ange-ftp-revert-buffer #[(arg noconfirm) "`	¬…ÂÃ!ª§¬ˆÅÆÇ	\"!­œÈ	ÈÊ ˆË ˆ)Ì	Í\"ˆ)d^bˆÎÈ!ˆÍ)‡" [opoint buffer-file-name error "Buffer does not seem to be associated with any file" noconfirm yes-or-no-p format "Revert buffer from file %s? " nil buffer-read-only unlock-buffer erase-buffer insert-file-contents t after-find-file] 4 "\
Revert this buffer from a remote file using ftp."])
(fset 'ange-ftp-expand-symlink #[(file dir) "À	!«…Â	\"‡Ä	\"‡" [file-name-absolute-p file ange-ftp-replace-path-component dir expand-file-name] 3])
(fset 'ange-ftp-file-symlink-p #[(file) "À	!Â	!«®ÃÄ	!‰Å˜«ƒÆª	)ÇÈ	!!\"‰	;­‘Ê	!«‰ËÈ	!	\"ª‚	)‡Ì	!‡" [ange-ftp-expand-file-name file ange-ftp-ftp-path ange-ftp-get-hash-entry file-name-nondirectory "" "." ange-ftp-get-files file-name-directory file-ent file-name-absolute-p ange-ftp-replace-path-component ange-ftp-real-file-symlink-p] 6 "\
Documented as original."])
(fset 'ange-ftp-file-exists-p #[(path) "À	!Â	!«œÃ	!­šÄ	!‰;«ŒÆÇÈÉ	!!\"!ªÊ)‡Ë	!‡" [expand-file-name path ange-ftp-ftp-path ange-ftp-file-entry-p ange-ftp-get-file-entry file-ent file-exists-p ange-ftp-expand-symlink file-name-directory directory-file-name t ange-ftp-real-file-exists-p] 7 "\
Documented as original."])
(fset 'ange-ftp-file-directory-p #[(path) "À	!Â	!«™ÃÄ	!!‰;«ŒÆÇÈÉ	!!\"!ª)‡Ê	!‡" [expand-file-name path ange-ftp-ftp-path ange-ftp-get-file-entry ange-ftp-file-name-as-directory file-ent file-directory-p ange-ftp-expand-symlink file-name-directory directory-file-name ange-ftp-real-file-directory-p] 7 "\
Documented as original."])
(fset 'ange-ftp-directory-files #[(directory &optional full match &rest v19-args) "À	!Â	!«ÎÃ	!ˆÄÅ	!!Æ‰	Ê	!Ë Í	«©	@	A	«ˆÏ\"«f«†	Pª‚BªS*Ÿ+‡ÑÒ	%‡" [expand-file-name directory ange-ftp-ftp-path ange-ftp-barf-if-not-directory ange-ftp-hash-table-keys ange-ftp-get-files nil f files tail file-name-as-directory match-data match-data ((store-match-data match-data)) match string-match full apply ange-ftp-real-directory-files v19-args] 6 "\
Documented as original."])
(fset 'ange-ftp-file-attributes #[(file) "À	!Â	!‰ƒ Ä	!‰Å˜«ƒÆª	)ÇÈ	!!	\nË\n	\"­à@A@Ì8Í\n	\";«Ò!«‰ÓÈ	!\"ª‚Ô‰‰ÕÖ×Ô;«ƒØªˆ«ƒÙªÚÛPÜİŞßà\"ßà\"¤ßàá!\"¤\"Ô¯,*ªƒâ	!)‡" [expand-file-name file ange-ftp-ftp-path parsed file-name-nondirectory "" "." ange-ftp-get-files file-name-directory files part ange-ftp-hash-entry-exists-p 2 ange-ftp-get-hash-entry dirp path user host file-name-absolute-p ange-ftp-expand-symlink -1 (0 0) (0 0) (0 0) "l" "d" "-" "?????????" nil apply + mapcar identity directory-file-name ange-ftp-real-file-attributes] 18 "\
Documented as original."])
(fset 'ange-ftp-file-writable-p #[(file) "À	!Â	!«‹Ã	!®‰ÄÅ	!!‡Æ	!‡" [expand-file-name file ange-ftp-ftp-path file-exists-p file-directory-p file-name-directory ange-ftp-real-file-writable-p] 3 "\
Documented as original."])
(fset 'ange-ftp-file-readable-p #[(file) "À	!Â	!«„Ã	!‡Ä	!‡" [expand-file-name file ange-ftp-ftp-path file-exists-p ange-ftp-real-file-readable-p] 2 "\
Documented as original."])
(fset 'ange-ftp-delete-file #[(file) "À	!Â	!‰«¹@A@ÆÇ8!É	!\nËÌDÍÎ\n\"$‰@¬ĞÑÒÍÓA\"	E\"ˆÔ	!-ªƒÕ	!)‡" [expand-file-name file ange-ftp-ftp-path parsed host user ange-ftp-quote-string 2 path ange-ftp-abbreviate-filename abbr ange-ftp-send-cmd delete format "Deleting %s" result signal ftp-error "Removing old name" "FTP Error: \"%s\"" ange-ftp-delete-file-entry ange-ftp-real-delete-file] 8 "\
Documented as original." "fDelete file: "])
(fset 'ange-ftp-verify-visited-file-modtime #[(buf) "À	!‰;«ˆÃ\n!«ƒÄªƒÅ	!)‡" [buffer-file-name buf name ange-ftp-ftp-path t ange-ftp-real-verify-visited-file-modtime] 3 "\
Documented as original."])
(fset 'ange-ftp-backup-buffer #[nil "À\n<­–;­’Ä!‰­‹\n?®‡Å	@!\n>??­‚Æ )‡" [nil parsed ange-ftp-make-backup-files buffer-file-name ange-ftp-ftp-path ange-ftp-host-type ange-ftp-real-backup-buffer] 2 "\
Documented as original."])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇM‡" [ange-ftp-barf-or-query-if-file-exists #[(absname querystring interactive) "À	!­™\n¬†ÃÄ	C\"‡ÅÆÇ	#!?­…ÃÄ	C\"‡" [file-exists-p absname interactive signal file-already-exists yes-or-no-p format "File %s already exists; %s anyway? " querystring] 5] ange-ftp-copy-file-internal #[(filename newname ok-if-already-exists keep-date &optional msg cont nowait) "À	!À\n!Ã\n!«‡ÀÄ	!\n\"Å	!Å\n!‰¬›¬—È	\n	\n$ˆ…?ÌÍÎ#‚?­ƒ@­„A@­†ÑÒ8!Ô	!­ƒ@­„A@­†ÑÒ8!Ô\n	\"Ú	!®ƒÚ\n!ÜÜ	«…	§«ˆß\nà	§#ˆ«îá!¬„«†â!«‡ã\"ˆäå®\nE&®–«‹«‡çè\"ª‡çé#ê	\n&+¯+&ª¥êÍÜ	\n&Ü‰+&.*‡" [expand-file-name filename newname file-directory-p file-name-nondirectory ange-ftp-ftp-path t-parsed f-parsed ange-ftp-real-copy-file ok-if-already-exists keep-date cont ange-ftp-call-cont t "Copied locally" f-host f-user ange-ftp-quote-string 2 f-path ange-ftp-abbreviate-filename f-abbr t-host t-user t-path t-abbr ange-ftp-binary-file binary nil temp1 temp2 ange-ftp-barf-or-query-if-file-exists "copy to it" ange-ftp-use-gateway-p ange-ftp-make-tmp-name ange-ftp-set-binary-mode ange-ftp-send-cmd get msg format "Getting %s" "Copying %s to %s" ange-ftp-cf1 nowait] 25] ange-ftp-cf1 #[(result line filename newname binary msg f-parsed f-host f-user f-path f-abbr t-parsed t-host t-user t-path t-abbr temp1 temp2 cont nowait) "«œÁ\n¬–«„Ä!ˆ¬ŒÆÇÈÉÊ\"E\"ˆ)\nƒÔ ƒÂ Í!«†Ï!««“˜«„ÑªœÒÓ#ˆª“ÑªŒ«ˆÒÓ#ˆ«‡Õ\"ˆ×®‚!‰«‹ÙÚ8#ˆ)ÛÜ®‚E®–«‹«‡Éà!\"ª‡Éâ#$#å!¯&&‡åÓÑ!&	‡ç\n#‡" [line ((byte-code "«…Á\n\"ˆÁ‡" [binary ange-ftp-set-ascii-mode f-host f-user] 3)) result temp1 ange-ftp-del-tmp-name cont signal ftp-error "Opening input file" format "FTP Error: \"%s\"" filename t-parsed ange-ftp-use-gateway-p t-host ange-ftp-make-tmp-name temp2 nil ange-ftp-real-copy-file t binary ange-ftp-set-binary-mode t-user file-attributes attr ange-ftp-set-xfer-size 7 ange-ftp-send-cmd put t-path msg f-parsed "Putting %s" newname "Copying %s to %s" f-abbr t-abbr ange-ftp-cf2 nowait ange-ftp-call-cont] 14] ange-ftp-cf2 #[(result line newname t-host t-user binary temp1 temp2 cont) "À	«›Â¬¬ŒÅÆÇÈÉ	\"\nE\"ˆË\n!)ª‹­‡Í\nÎ#)‡" [((byte-code "«„Á!ˆ\n«„Á\n!ˆÃ#‡" [temp1 ange-ftp-del-tmp-name temp2 ange-ftp-call-cont cont result line] 4)) line ((byte-code "«…Á\n\"ˆÁ‡" [binary ange-ftp-set-ascii-mode t-host t-user] 3)) result cont signal ftp-error "Opening output file" format "FTP Error: \"%s\"" newname ange-ftp-add-file-entry temp1 ange-ftp-real-copy-file t] 6]] 2)
(fset 'ange-ftp-copy-file #[(filename newname &optional ok-if-already-exists keep-date) "À	\nÅ‰t&‡" [ange-ftp-copy-file-internal filename newname ok-if-already-exists keep-date nil] 8 "\
Documented as original." "fCopy file: \nFCopy %s to file: \np"])
(fset 'ange-ftp-rename-remote-to-remote #[(filename newname f-parsed t-parsed binary) "@A@	@	A@‰˜«Ù\n˜«ÔÆÇ8!ÆÇ	8!	Ê	EÌ!Ì\"ÑÒÓ#$‰@¬ÕÖ×ÒØA\"F\"ˆÙ!ˆÚ!.ªÛÜİ$ˆŞ!,‡" [f-parsed t-parsed t-user t-host f-user f-host ange-ftp-quote-string 2 f-path t-path rename cmd ange-ftp-abbreviate-filename filename fabbr newname nabbr ange-ftp-send-cmd format "Renaming %s to %s" result signal ftp-error "Renaming" "FTP Error: \"%s\"" ange-ftp-add-file-entry ange-ftp-delete-file-entry ange-ftp-copy-file-internal t nil delete-file] 9 "\
Rename remote file FILE to remote file NEWNAME."])
(fset 'ange-ftp-rename-local-to-remote #[(filename newname) "À	!À	\"ÅÆ\n#È	ÉÊ%ˆÊÌ	!,‡" [ange-ftp-abbreviate-filename filename fabbr newname nabbr format "Renaming %s to %s" msg ange-ftp-copy-file-internal t nil ange-ftp-process-verbose delete-file] 6 "\
Rename local FILE to remote file NEWNAME."])
(fset 'ange-ftp-rename-remote-to-local #[(filename newname) "À	!À	\"ÅÆ\n#È	ÉÊ%ˆÊÌ	!,‡" [ange-ftp-abbreviate-filename filename fabbr newname nabbr format "Renaming %s to %s" msg ange-ftp-copy-file-internal t nil ange-ftp-process-verbose delete-file] 6 "\
Rename remote file FILE to local file NEWNAME."])
(fset 'ange-ftp-rename-file #[(filename newname &optional ok-if-already-exists) "À	!À\n!Ã	!Ã\n!¬ƒ­ƒÆ	!¬ƒ«‘«…§«ˆÉ\nÊ§#ˆ«“«ŠË	\n%ª•Ì	\n\"ª«†Í	\n\"ª†Î	\n#+‡" [expand-file-name filename newname ange-ftp-ftp-path f-parsed t-parsed ange-ftp-binary-file binary ok-if-already-exists ange-ftp-barf-or-query-if-file-exists "rename to it" ange-ftp-rename-remote-to-remote ange-ftp-rename-remote-to-local ange-ftp-rename-local-to-remote ange-ftp-real-rename-file] 6 "\
Documented as original." "fRename file: \nFRename %s to file: \np"])
(defvar ange-ftp-dired-host-type nil "\
The host type associated with a dired buffer. (buffer local)")
(make-variable-buffer-local 'ange-ftp-dired-host-type)
(fset 'ange-ftp-dired-readin #[(dirname buffer) "À	!Â	!ŠÅÆ\"ˆqˆÈ	~ˆÊ ˆË	!«”Ì@!‰Ï	Ñ#cˆ)ª¬Ò	!«ÓÔÈÈ	&ˆª™Õ	!ÓÈÈØÙÚÛ	!R&ˆ)ebˆm¬ˆÜcˆİyˆªuebˆ*ÅŞ\"*‡" [ange-ftp-abbreviate-filename dirname ange-ftp-ftp-path parsed file ange-ftp-message "Reading directory %s..." buffer nil buffer-read-only erase-buffer expand-file-name ange-ftp-host-type host-type ange-ftp-dired-host-type ange-ftp-ls dired-listing-switches t ange-ftp-real-file-directory-p call-process "ls" ange-ftp-real-file-name-directory default-directory shell-file-name "-c" "ls " " " ange-ftp-real-file-name-nondirectory "  " 1 "Reading directory %s...done"] 12 "\
Documented as original."])
(fset 'ange-ftp-dired-revert #[(&optional arg noconfirm) "«‰ÁÂ!!«‚ÃÅ\"‡" [dired-directory ange-ftp-ftp-path expand-file-name nil ange-ftp-ls-cache-file ange-ftp-real-dired-revert arg noconfirm] 3 "\
Documented as original."])
(defvar ange-ftp-dired-re-exe-alist nil "\
Association list of regexps (strings) which match file lines of
 executable files.")
(defvar ange-ftp-dired-re-dir-alist nil "\
Association list of regexps (strings) which match file lines of
 subdirectories.")
(defvar ange-ftp-dired-insert-headerline-alist nil "\
Association list of (TYPE . FUNC ) pairs, where FUNC is
the function to be used by dired to insert the headerline of
the dired buffer.")
(defvar ange-ftp-dired-move-to-filename-alist nil "\
Association list of (TYPE . FUNC ) pairs, where FUNC is
the function to be used by dired to move to the beginning of a
filename.")
(defvar ange-ftp-dired-move-to-end-of-filename-alist nil "\
Association list of (TYPE . FUNC ) pairs, where FUNC is
the function to be used by dired to move to the end of a
filename.")
(defvar ange-ftp-dired-get-filename-alist nil "\
Association list of (TYPE . FUNC ) pairs, where FUNC is
the function to be used by dired to get a filename from the
current line.")
(defvar ange-ftp-dired-between-files-alist nil "\
Association list of (TYPE . FUNC ) pairs, where FUNC is
the function to be used by dired to determine when the point
is on a line between files.")
(defvar ange-ftp-dired-ls-trim-alist nil "\
Association list of ( TYPE . FUNC ) pairs, where FUNC is
a function which trims extraneous lines from a directory listing.")
(defvar ange-ftp-dired-clean-directory-alist nil "\
Association list of ( TYPE . FUNC ) pairs, where FUNC is
a function which cleans out old versions of files in the OS TYPE.")
(defvar ange-ftp-dired-flag-backup-files-alist nil "\
Association list of ( TYPE . FUNC ) pairs, where FUNC is
a functions which flags the backup files for deletion in the OS TYPE.")
(defvar ange-ftp-dired-backup-diff-alist nil "\
Association list of ( TYPE . FUNC ) pairs, where FUNC diffs
a file with its backup. The backup file is determined according to
the OS TYPE.")
(fset 'ange-ftp-tree-dired-readin #[(dirname buffer) "À	!‰«ÈŠqˆÄ\n@!«Ç=«‰È	\"«‚É\n‰«ˆÎÏ!ALˆ«ˆÎĞ!ALˆ>«ƒÒ+)Ô	\"‡" [ange-ftp-ftp-path dirname parsed buffer ange-ftp-host-type ange-ftp-dired-host-type ange-ftp-dl-dir-regexp unix string-match unix:dl ange-ftp-dired-re-exe-alist ange-ftp-dired-re-dir-alist dentry eentry make-local-variable dired-re-exe dired-re-dir ange-ftp-dumb-host-types "-Al" dired-actual-switches ange-ftp-real-dired-readin] 4 "\
Documented as original."])
(fset 'ange-ftp-dired-insert-headerline #[(dir) "«†	A®Â!‡" [ange-ftp-dired-host-type ange-ftp-dired-insert-headerline-alist ange-ftp-real-dired-insert-headerline dir] 2 "\
Documented as original."])
(fset 'ange-ftp-dired-move-to-filename #[(&optional raise-error eol) "«†	A®Â\"‡" [ange-ftp-dired-host-type ange-ftp-dired-move-to-filename-alist ange-ftp-real-dired-move-to-filename raise-error eol] 3 "\
Documented as original."])
(fset 'ange-ftp-dired-move-to-end-of-filename #[(&optional no-error) "«†	A®Â!‡" [ange-ftp-dired-host-type ange-ftp-dired-move-to-end-of-filename-alist ange-ftp-real-dired-move-to-end-of-filename no-error] 2 "\
Documented as original."])
(fset 'ange-ftp-dired-get-filename #[(&optional localp no-error-if-not-filep) "«†	A®Â\"‡" [ange-ftp-dired-host-type ange-ftp-dired-get-filename-alist ange-ftp-real-dired-get-filename localp no-error-if-not-filep] 3 "\
Documented as original."])
(fset 'ange-ftp-dired-between-files #[nil "«†	A®Â ‡" [ange-ftp-dired-host-type ange-ftp-dired-between-files-alist ange-ftp-real-dired-between-files] 2 "\
Documented as original."])
(defvar ange-ftp-bob-version-alist nil "\
Association list of pairs ( TYPE . FUNC ), where FUNC is
a function to be used to bob the version number off of a filename
in OS TYPE.")
(fset 'ange-ftp-dired-find-file #[nil "À	«†	\nA®ÃÄ !!‡" [find-file ange-ftp-dired-host-type ange-ftp-bob-version-alist identity dired-get-filename] 3 "\
Documented as original." nil])
(defvar ange-ftp-dired-compress-make-compressed-filename-alist nil "\
Association list of ( TYPE . FUNC ) pairs, where FUNC converts a
filename to the filename of the associated compressed file.")
(fset 'ange-ftp-dired-compress-make-compressed-filename #[(name &optional reverse) "À	!Â‰«“Å@!A‰«‡	\"ª—«ÈÉ	\"«‡	Ê‰”Oª†	ªƒ	ËP*‡" [ange-ftp-ftp-path name nil conversion-func parsed ange-ftp-host-type ange-ftp-dired-compress-make-compressed-filename-alist reverse string-match "\\.Z$" 0 ".Z"] 4 "\
Converts a filename to the filename of the associated compressed
file. With an optional reverse argument, the reverse conversion is done."])
(fset 'ange-ftp-dired-clean-directory #[(keep) "«†	A®Â!‡" [ange-ftp-dired-host-type ange-ftp-dired-clean-directory-alist ange-ftp-real-dired-clean-directory keep] 2 "\
Documented as original." "P"])
(fset 'ange-ftp-dired-backup-diff #[(&optional switches) "«†	A®Â!‡" [ange-ftp-dired-host-type ange-ftp-dired-backup-diff-alist ange-ftp-real-dired-backup-diff switches] 2 "\
Documented as original." (byte-code "ÀÁ!­ƒÁÂ!C‡" [fboundp diff-read-switches "Diff with switches: "] 2)])
(fset 'ange-ftp-dired-fixup-subdirs #[(start file) "ÀŒŠ\n`}ˆ\nbˆÃ	ÄÅ#­šÆ”bˆ`Æ•{`Æ•|ˆÈ	\"cˆ)ª_+‡" ["^\\([^ \n]+\\)\\(:\\)[\n]" subdir-regexp start re-search-forward nil t 1 name ange-ftp-replace-path-component file] 4 "\
Turn each subdir name into a valid ange-ftp filename."])
(fset 'ange-ftp-dired-ls #[(file switches &optional wildcard full-directory-p) "À	!‰ƒÇ `Ä\n8Æ\n@!‰>	ÊÊ«ÎÎ>¬ŠÏ	Ê#c‚Ã Ï	ÑPÊ#cˆÒ!‰­©Ô!ŒŠ`}ˆbˆm?­•Ö «Œ×ÊØ#«„ÙÚ!ˆÛyˆªg+)ªÑÜİ\"«ˆŞ	ßàO\"Üá\"«Ï	Ê#cˆâ	\"ˆª”Ï		¬‡Üã\"­‚$#cˆ$?­”%A‰­‰Œ`}ˆ ).ª‰æ	$$)‡" [ange-ftp-ftp-path file parsed pt 2 path ange-ftp-host-type host-type ange-ftp-dumb-host-types dumb nil trim-func case-fold-search wildcard (unix dumb-unix) ange-ftp-ls switches "d" ange-ftp-real-file-name-directory dir regexp-quote dirq dired-move-to-filename re-search-forward t replace-match "" 1 string-match "/\\.$" ange-ftp-replace-path-component 0 -1 "R" ange-ftp-dired-fixup-subdirs "[aA]" full-directory-p ange-ftp-dired-ls-trim-alist ange-ftp-real-dired-ls] 7 "\
Documented as original."])
(defvar ange-ftp-remote-shell-file-name (byte-code "Á>«‚Â‡Ã‡" [system-type (hpux usg-unix-v) "remsh" "rsh"] 2) "\
Remote shell used by ange-ftp.")
(fset 'ange-ftp-dired-run-shell-command #[(command &optional in-background) "À	!‰@\nA@Å\n8\n¬ˆÇ	\"ª®GÊV«‰ËÌRÍÎ$ĞÑ\"ˆ	«†Ò!ª„Ó!,‡" [ange-ftp-ftp-path default-directory parsed host user 2 path ange-ftp-real-dired-run-shell-command command in-background 0 "cd " "; " format "%s %s \"%s\"" ange-ftp-remote-shell-file-name ange-ftp-message "Remote command '%s' ..." comint::background shell-command] 6 "\
Documented as original."])
(fset 'ange-ftp-make-directory #[(dir) "À	!«…ÂÃ	\"‡Ä	!‰«Ğ@A@ÈÉ!Ê=«‡ËÌ8!ª…ÍÌ8!!Ï	!ÑÒDÓÔ\"$‰@¬ÖÓ×	A##ˆØ	Ù\"-ªƒÚ	!)‡" [file-exists-p dir error "Cannot make directory %s: file already exists" ange-ftp-ftp-path parsed host user ange-ftp-quote-string ange-ftp-host-type unix ange-ftp-real-directory-file-name 2 ange-ftp-real-file-name-as-directory path ange-ftp-abbreviate-filename abbr ange-ftp-send-cmd mkdir format "Making directory %s" result ange-ftp-error "Could not make directory %s: %s" ange-ftp-add-file-entry t ange-ftp-real-make-directory] 8 "\
Documented as original." (byte-code "ÀÁÂ!!C‡" [expand-file-name read-file-name "Make directory: "] 3)])
(fset 'ange-ftp-remove-directory #[(dir) "À	!«ÕÂ	!‰«É@A@ÆÇ!È=«‡ÉÊ8!ª…ËÊ8!!Í	!ÏĞDÑÒ\"$‰@¬ŒÔÑÕ	A##ˆÖ	×\"-ªƒØ	!)‡ÙÚ	\"‡" [file-directory-p dir ange-ftp-ftp-path parsed host user ange-ftp-quote-string ange-ftp-host-type unix ange-ftp-real-directory-file-name 2 ange-ftp-real-file-name-as-directory path ange-ftp-abbreviate-filename abbr ange-ftp-send-cmd rmdir format "Removing directory %s" result ange-ftp-error "Could not remove directory %s: %s" ange-ftp-delete-file-entry t ange-ftp-real-remove-directory error "Not a directory: %s"] 8 "\
Documented as original." (byte-code "ÀÁÂÃ‰Ä$!C‡" [expand-file-name read-file-name "Remove directory: " nil confirm] 6)])
(fset 'ange-ftp-diff #[(fn1 fn2 &optional switches) ";«„	;¬†ÂÃ	#ˆ¬”;«ƒªŒ<«‡ÆÇÈ#ªÉÊ!Ê	!Ë!Ë	!¬…ƒ‰­…Î@!­…Î@!­ƒÑ!­ƒÑ	!Ô!Ô	!ÙÚ«ˆ«„ÂÛ!ˆ«‘ÊÜ	!\"Ë!Ñ!«‘ÊÜ!	\"Ë	!Ñ	!«ŒİŞßàá\"%ˆ«Œİ	Şßàá	\"%ˆ\"«„ãä!ˆåæ!ˆç®®	#ˆèé!«“)«³ê)!ë=««ì)!ˆªmèí!«Ÿ-«›î-!«•ï-!«êï-!!ë=«…ì ˆªa\"«„ãğ!ˆŠñò!qˆebˆóôPßŞ#«‡õôP!ˆ«˜ö!7ebˆó7ßŞ#«†õ!ˆªr)­˜ö!8ebˆó8ßŞ#­†õ	!ˆªr).\nª…ç	#,‡" [fn1 fn2 error "diff: arguments must be strings: %s %s" switches diff-switches mapconcat identity " " "" expand-file-name ange-ftp-ftp-path pa1 pa2 ange-ftp-make-tmp-name tmp1 tmp2 ange-ftp-binary-file bin1 bin2 file-directory-p dir1 dir2 default-directory old-dir "/tmp" ((byte-code "«„Á!ˆ\n«„Á\n!ˆÁ‡" [tmp1 ange-ftp-del-tmp-name tmp2] 2)) "can't compare remote directories" file-name-nondirectory ange-ftp-copy-file-internal t nil format "Getting %s" ange-ftp-process-verbose ange-ftp-message "doing diff..." sit-for 0 ange-ftp-real-diff boundp compilation-process process-status run accept-process-output compilation-last-buffer buffer-name get-buffer-process "doing diff...done" get-buffer-create "*compilation*" search-forward "cd " replace-match shell-quote q1 q2] 8 "\
Documented as original." (diff-read-args "Diff: " "Diff %s with: " "Diff with switches: ")])
(fset 'ange-ftp-dired-call-process #[(program discard &rest arguments) "À	!«…ÂÃÄ‡ÅÆÈ	?È\n&‡" [ange-ftp-ftp-path default-directory oops (byte-code "Áš«„Â!‡Äš«„Å!‡Æš«„Ç!‡ÈÉ\"‡" [program "compress" ange-ftp-call-compress arguments "uncompress" ange-ftp-call-uncompress "chmod" ange-ftp-call-chmod error "Unknown remote command: %s"] 3) ((ftp-error (byte-code "ÀÁ\nA@Ã\n8Ä\n8$c‡" [format "%s: %s, %s\n" oops 2 3] 6)) (error (byte-code "ÀÁ\nA@\"c‡" [format "%s\n" oops] 3))) apply call-process program nil discard arguments] 7 "\
Documented as original."])
(fset 'ange-ftp-call-compress #[(args) "GÁU«†@Â˜¬…ÃÄ\"ˆA@Æ!È@!	È@!\nË!Í!Ë!ĞÑ\"ĞÓ\"ÕÖ	×Ø%ˆ«†ÚÛ\"ˆÜ``Ø×ØŞĞß	\n#&ˆ«†Úà\"ˆá âU­’Øã!ˆ)Ö\n×Ø%.\n‡" [args 2 "-f" error "ange-ftp-call-compress: missing -f flag and/or missing filename: %s" file ange-ftp-ftp-path parsed ange-ftp-make-tmp-name tmp1 tmp2 ange-ftp-abbreviate-filename abbr ange-ftp-dired-compress-make-compressed-filename nfile nabbr format "Getting %s" msg1 "Putting %s" msg2 ((byte-code "À	!ˆÀ\n!‡" [ange-ftp-del-tmp-name tmp1 tmp2] 2)) ange-ftp-copy-file-internal t nil ange-ftp-process-verbose ange-ftp-message "Compressing %s..." call-process-region shell-file-name "-c" "compress -f -c < %s > %s" "Compressing %s...done" buffer-size 0 delete-file] 12 "\
Perform a compress command on a remote file.
Works by taking a copy of the file, compressing it and copying the file
back."])
(fset 'ange-ftp-call-uncompress #[(args) "GÁU¬…ÂÃ\"ˆ@Å!Ç@!Ç@!	Ê!ÌÍ\"Ê!ĞÑ\"ĞÓ\"ÕÖ×Ø%ˆ«†ÚÛ\"ˆÜ``Ø×ØŞĞß	#&ˆ«†Úà\"ˆá âU­’Øã!ˆ)Ö	×Ø%.\n‡" [args 1 error "ange-ftp-call-uncompress: missing filename: %s" file ange-ftp-ftp-path parsed ange-ftp-make-tmp-name tmp1 tmp2 ange-ftp-abbreviate-filename abbr ange-ftp-dired-compress-make-compressed-filename reverse nfile nabbr format "Getting %s" msg1 "Putting %s" msg2 ((byte-code "À	!ˆÀ\n!‡" [ange-ftp-del-tmp-name tmp1 tmp2] 2)) ange-ftp-copy-file-internal t nil ange-ftp-process-verbose ange-ftp-message "Uncompressing %s..." call-process-region shell-file-name "-c" "uncompress -c < %s > %s" "Uncompressing %s...done" buffer-size 0 delete-file] 12 "\
Perform an uncompress command on a remote file.
Works by taking a copy of the file, uncompressing it and copying the file
back."])
(byte-code "ÀÁMˆÂÃMˆÄÅM‡" [ange-ftp-call-chmod #[(args) "GÁW«…ÂÃ\"ˆ@ÅÆA\"ˆ)Ç‰‡" [args 2 error "ange-ftp-call-chmod: missing mode and/or filename: %s" mode mapcar #[(file) "À	!Â	!‰­´@A@ÆÇ8!É	!\nËÌEÎÏ\n\"$‰@®‹ÑÎÒ	A##-)‡" [expand-file-name file ange-ftp-ftp-path parsed host user ange-ftp-quote-string 2 path ange-ftp-abbreviate-filename abbr ange-ftp-send-cmd chmod mode format "doing chmod %s" result ange-ftp-error "chmod: %s: \"%s\""] 8] nil ange-ftp-ls-cache-file] 3] ange-ftp-dired-compress #[nil "ÀÂ Ä!ŠÆyˆÇ!)«‹ÉÊP!ˆË!ª”ÌÍPÎÏ$«…Ë!ª…Ğ!ˆÀ+‡" [nil buffer-read-only dired-get-filename from-file ange-ftp-dired-compress-make-compressed-filename to-file 0 looking-at dired-re-sym dired-log "Attempt to compress a symbolic link:\n" dired-make-relative dired-check-process "Compressing " "compress" "-f" dired-update-file-line] 5] ange-ftp-dired-uncompress #[nil "ÀÂ ÄÅ\"ÇÈPÉ#«…Ê!ª†Ë!ˆÀ+‡" [nil buffer-read-only dired-get-filename from-file ange-ftp-dired-compress-make-compressed-filename reverse to-file dired-check-process "Uncompressing " "uncompress" dired-make-relative dired-update-file-line] 4]] 2)
(fset 'ange-ftp-dired-flag-backup-files #[(&optional unflag-p) "«†	A®Â!‡" [ange-ftp-dired-host-type ange-ftp-dired-flag-backup-files-alist ange-ftp-real-dired-flag-backup-files unflag-p] 2 "\
Documented as original." "P"])
(fset 'ange-ftp-dired-copy-file #[(from to ok-flag &optional cont nowait) "À	!ˆÂ	Æ&‡" [dired-handle-overwrite to ange-ftp-copy-file-internal from ok-flag dired-copy-preserve-time nil cont nowait] 8 "\
Documented as original."])
(fset 'ange-ftp-dired-do-create-files #[(op-symbol file-creator operation arg &optional marker-char op1 how-to) "ÀÂ	&)‡" [t ange-ftp-dired-do-create-files ange-ftp-real-dired-do-create-files op-symbol file-creator operation arg marker-char op1 how-to] 8 "\
Documented as original."])
(fset 'ange-ftp-dired-create-files #[(file-creator operation fn-list name-constructor &optional marker-char) "ÀÁ!«µ	«²\n«¯Ä=«ªÅ\n@!¬‰Å\n@!!«›Ç\nÀÉ!­‚	\npË‰‰‰Ì\nG&‡Í\n\n%‡" [boundp ange-ftp-dired-do-create-files fn-list file-creator dired-copy-file ange-ftp-ftp-path name-constructor ange-ftp-dcf-1 operation target marker-char nil 0 ange-ftp-real-dired-create-files] 14 "\
Documented as original."])
(byte-code "ÀÁMˆÂÃMˆÄÅM‡" [ange-ftp-dcf-1 #[(file-creator operation fn-list name-constructor target marker-char buffer overwrite-query overwrite-backup-query failures skipped success-count total) "pÁ\nqˆ¬Ä	\n&ªô@\n\n!‰\nš«ŒÍÎÏ—\n#ˆ¬¢ĞA\nÖ\n!B	&ª°×!‰­ŠÙÛÔÜ#)¨«„ª‹«†Ş\n!ªÍàáâ+**‡" [old-buf ((set-buffer old-buf)) buffer fn-list ange-ftp-dcf-3 failures operation total skipped success-count from name-constructor to nil dired-log "Cannot %s to same file: %s\n" ange-ftp-dcf-1 file-creator target marker-char overwrite-query overwrite-backup-query dired-make-relative file-exists-p overwrite (format "Type SPC or `y' to overwrite file `%s',\nDEL or `n' to skip to next,\nESC or `q' to not overwrite any of the remaining files,\n`!' to overwrite all remaining files with no more questions." to) help-form dired-query "Overwrite `%s'?" overwrite-confirmed dired-file-marker actual-marker-char err (byte-code "	\nÄÅ	\n\n	¯Ô%‡" [file-creator from to overwrite-confirmed ange-ftp-dcf-2 nil operation fn-list name-constructor target marker-char actual-marker-char buffer overwrite overwrite-query overwrite-backup-query failures skipped success-count total t] 24) ((file-error (byte-code "ÀÁ‰\n	\n&‡" [ange-ftp-dcf-2 nil err file-creator operation fn-list name-constructor target marker-char actual-marker-char buffer to from overwrite overwrite-confirmed overwrite-query overwrite-backup-query failures skipped success-count total] 22)))] 15] ange-ftp-dcf-2 #[(result line err file-creator operation fn-list name-constructor target marker-char actual-marker-char buffer to from overwrite overwrite-confirmed overwrite-query overwrite-backup-query failures skipped success-count total) "pÁ\nqˆ¬ƒ¬šÅ!BÈÉ\n®‚%ˆªŸ«…Î!ˆTĞÑ\n$ˆÓ\"ˆÕ\nA\n&*‡" [old-buf ((set-buffer old-buf)) buffer err result dired-make-relative from failures dired-log "%s `%s' to `%s' failed:\n%s\n" operation to line overwrite dired-remove-file success-count message "%s: %d of %d" total dired-add-file actual-marker-char ange-ftp-dcf-1 file-creator fn-list name-constructor target marker-char overwrite-query overwrite-backup-query skipped] 14] ange-ftp-dcf-3 #[(failures operation total skipped success-count buffer) "pÁ\nqˆ«”ÄÅÆGÉ!&!ˆª¦\n«–ÄÅË\nGÉ!\n&!ˆªŒÅÌÉ!$ˆÎ *‡" [old-buf ((set-buffer old-buf)) buffer failures dired-log-summary message "%s failed for %d of %d file%s %s" operation total dired-plural-s skipped "%s: %d of %d file%s skipped %s" "%s: %s file%s." success-count dired-move-to-filename] 8]] 2)
(defconst ange-ftp-dired-dl-re-dir "^. [^ /]+/[ \n]" "\
Regular expression to use to search for dl directories.")
(byte-code "À	¬†À\nB	BÀ‡" [unix:dl ange-ftp-dired-re-dir-alist ange-ftp-dired-dl-re-dir] 2)
(fset 'ange-ftp-dired-dl-move-to-filename #[(&optional raise-error eol) "¬…Áˆ`ÁÃyˆÄÅ!«†`Æ\\bª‡­ƒÈÉ!)‡" [eol nil case-fold-search 0 looking-at ". [^ ]+ +\\([0-9]+\\|-\\|=\\) " 2 raise-error error "No file on this line"] 2 "\
In dired, move to the first character of the filename on this line."])
(byte-code "À	¬„Â	BÃÄMˆÀ¬„ÆBÀ‡" [unix:dl ange-ftp-dired-move-to-filename-alist (unix:dl . ange-ftp-dired-dl-move-to-filename) ange-ftp-dired-dl-move-to-end-of-filename #[(&optional no-error eol) "`À‰¬‡ŠÀˆ`)­‡ŠÆÇÈ#)‰«Œ	?­›ÊËÌ!!ª”Íwˆ`=«Š	?­†ÊÎ!ª`+‡" [nil hidden case-fold-search opoint eol selective-display search-forward "" t no-error error substitute-command-keys "File line is hidden, type \\[dired-hide-subdir] to unhide" "^ /" "No file on this line"] 5] ange-ftp-dired-move-to-end-of-filename-alist (unix:dl . ange-ftp-dired-dl-move-to-end-of-filename)] 2)
(fset 'ange-ftp-file-entry-active-p #[(sym) "ÁN‰;?®†ÂÃ	\"!)‡" [sym val file-exists-p ange-ftp-expand-symlink dir] 5 "\
If the file entry is a symlink, returns whether the file pointed to exists.
Note that DIR is dynamically bound."])
(fset 'ange-ftp-file-entry-not-ignored-p #[(sym) "ÁNÂ!‰;«›Ä	\"Ç!®ŒÈ!­†É\n\"?)ª‰	®†É\n\"?*‡" [sym val symbol-name symname ange-ftp-expand-symlink dir file file-directory-p file-exists-p string-match completion-ignored-pattern] 4 "\
If the file entry is not a directory (nor a symlink pointing to a directory)
returns whether the file (or file pointed to by the symlink) is ignored
by completion-ignored-extensions.
Note that DIR and COMPLETION-IGNORED-PATTERN are dynamically bound."])
(fset 'ange-ftp-file-name-all-completions #[(file dir) "À	!Â	!«Ã	!ˆÄ	!Å	!ÇÉ#\nËÌ\n\"*‡	Í˜«ÇÎ \"Ï	\"¤‡Ï	\"‡" [expand-file-name dir ange-ftp-ftp-path ange-ftp-barf-if-not-directory ange-ftp-real-file-name-as-directory ange-ftp-get-files tbl all-completions file ange-ftp-file-entry-active-p completions mapcar #[(file) "À	\n\"‰«’;«‰ÄÅ\"!«…	ÇPª	)‡" [ange-ftp-get-hash-entry file tbl ent file-directory-p ange-ftp-expand-symlink dir "/"] 5] "/" ange-ftp-generate-root-prefixes ange-ftp-real-file-name-all-completions] 4 "\
Documented as original."])
(fset 'ange-ftp-file-name-completion #[(file dir) "À	!Â	!«´Ã	!ˆÅš«‚Å‡Æ	!Ç	!ÉÊÌ#Î ĞÑ	Ò$®‡Ñ	Ó$,‡	Ô˜«ÕÖ ×ØÙÔ\"\"¤\"‡Ú	\"‡" [expand-file-name dir ange-ftp-ftp-path ange-ftp-barf-if-not-directory file "" ange-ftp-real-file-name-as-directory ange-ftp-get-files tbl mapconcat #[(s) ";«†Á!ÂP‡Ã‡" [s regexp-quote "$" "/"] 2] completion-ignored-extensions "\\|" completion-ignored-pattern match-data match-data ((store-match-data match-data)) ange-ftp-file-name-completion-1 ange-ftp-file-entry-not-ignored-p ange-ftp-file-entry-active-p "/" try-completion ange-ftp-generate-root-prefixes mapcar list ange-ftp-real-file-name-all-completions ange-ftp-real-file-name-completion] 8 "\
Documented as original."])
(fset 'ange-ftp-file-name-completion-1 #[(file tbl dir predicate) "À	\n#‰­®Å=«‘ÆÇ	\"!«…	ÉPª›Åª˜À\n#Å=«ÆÇ\"!«…ÉPª)‡" [try-completion file tbl predicate bestmatch t file-directory-p expand-file-name dir "/"] 5 "\
Internal subroutine for ange-ftp-file-name-completion.  Do not call this."])
(fset 'ange-ftp-quote-filename #[(file) "ÀÂÃ	#‰«‘À	OÅ	ÆOQ	Ç\\ªf)‡" [0 pos string-match "\\$" file "$" nil 2] 5 "\
Quote `$' as `$$' in FILE to get it past function `substitute-in-file-name.'"])
(fset 'ange-ftp-read-file-name-internal #[(string dir action) "À‰Ä=«GÆV­ÕÇÈ!!ªÎGÆU«‡	ª™È!Ê!Ë!‰«‡Ì		\"ª‚	«†Í\n	\"ªŸË!Î\n	\"‰«;«‰ÑP!ª‚**‡" [nil realdir name action lambda string 0 file-exists-p substitute-in-file-name dir file-name-nondirectory file-name-directory expand-file-name file-name-all-completions file-name-completion val specdir ange-ftp-quote-filename] 5 "\
Documented as original."])
(fset 'ange-ftp-re-read-dir #[(&optional dir) "«†Á!ª‡ÂÁÃ !!Ä!­ÅÇ\"ˆÉÊ\"‡" [dir expand-file-name file-name-directory buffer-string ange-ftp-ftp-path nil ange-ftp-ls-cache-file ange-ftp-del-hash-entry ange-ftp-files-hashtable ange-ftp-get-files t] 3 "\
Forces a re-read of the directory DIR.  If DIR is omitted then it defaults
to the directory part of the contents of the current buffer." nil])
(byte-code "ÀÁ!¬‚ÂÀ‡" [boundp ange-ftp-overwrite-msg "Note: This function has been modified to work with ange-ftp."] 2)
(fset 'ange-ftp-safe-documentation #[(fun) "ÀÁÂ‡" [nil (documentation fun) ((error))] 3 "\
A documentation function that isn't quite as fragile."])
(fset 'ange-ftp-overwrite-fn #[(fun) "À	!ÃÄ\nP!ÃÆ\nP!‰KÉ\n8Ëš¬ˆÌ\n8Ëš«ƒÍª‚9«ˆK‰ªuÏ!¬Š	KMˆ	MˆĞ!‰‰­ÒQ<«©ÕÖ×ˆAA‰@;«‡ ª‰@AB¡ˆ )ªªÙÕ\"Ì›«ŠÌ› ˆªŠÉ›ÕB¡ˆÛÜ\"M).‡" [symbol-name fun name intern "ange-ftp-real-" saved "ange-ftp-" new nfun 3 command-line-args "dump" 4 "../etc/" exec-directory fboundp ange-ftp-safe-documentation doc-str "\n" ange-ftp-overwrite-msg ndoc-str nil (byte-code "‰@ ‡" [nfun] 2) ((error (byte-code "À	!\n	M‡" [copy-sequence nfun new] 2))) ndoc-cdr append new-code apply make-byte-code] 5 "\
Replace FUN's function definition with ange-ftp-FUN's, saving the
original definition as ange-ftp-real-FUN.  The original documentation is
placed on the new definition suitably augmented."])
(fset 'ange-ftp-overwrite-dired #[nil "ÀÁ!¬†ÂÃ!ˆªïÂÄ!ˆÂÅ!ˆÂÆ!ˆÂÇ!ˆÂÁ!ˆÂÈ!ˆÉÊKMˆÂÃ!ˆÂË!ˆÂÌ!ˆÂÍ!ˆÂÎ!ˆÂÏ!ˆÂĞ!ˆÂÑ!ˆÂÒ!ˆÀÓ!«ŒÂÔ!ˆÂÕ!ˆÂÓ!ˆÀÖ!«†ÂÖ!ˆª’×ØKMˆØÙMˆÚÛKMˆÛÜMˆÂİ!ˆÂŞ!‡" [fboundp dired-ls ange-ftp-overwrite-fn dired-readin make-directory remove-directory diff dired-run-shell-command dired-call-process ange-ftp-dired-readin ange-ftp-tree-dired-readin dired-insert-headerline dired-move-to-filename dired-move-to-end-of-filename dired-get-filename dired-between-files dired-clean-directory dired-flag-backup-files dired-backup-diff dired-do-create-files dired-copy-file dired-create-files dired-compress-make-compressed-filename ange-ftp-real-dired-compress dired-compress ange-ftp-dired-compress ange-ftp-real-dired-uncompress dired-uncompress ange-ftp-dired-uncompress dired-find-file dired-revert] 2])
(fset 'ange-ftp-add-hook #[(hook-var hook-function) "À	!«­	J‰<«™\n@Ã=¬“\n>?­˜	\n«…\nBªLª‹\n=?­…	\nDL)‡	L‡" [boundp hook-var value lambda hook-function] 4 "\
Prepend hook-function to hook-var's value, if it is not already an element.
hook-var's value may be a single function or a list of functions."])
(byte-code "ÀÁ!«ŒÂÃ!¬‡ÄÁÅ\"ˆª‡ÆÃ!ˆÅ ˆÇÈ!«ÈK<«‡ÈK@É=¬„ÊÈ!ˆÇË!«ËK<«‡ËK@É=¬„ÊË!ˆÇÌ!«ÌK<«‡ÌK@É=¬„ÊÌ!ˆÊÍ!ˆÊÎ!ˆÊÏ!ˆÊĞ!ˆÊÑ!ˆÊÒ!ˆÊÓ!ˆÊÔ!ˆÊÕ!ˆÊÖ!ˆÊ×!ˆÊØ!ˆÊÙ!ˆÊÚ!ˆÊÛ!ˆÊÜ!ˆÊİ!ˆÊŞ!ˆÊß!ˆÊà!ˆÊá!ˆÊâ!ˆã$>¬†ã$B$À‡" [boundp dired-load-hook featurep dired ange-ftp-add-hook ange-ftp-overwrite-dired require fboundp make-directory autoload ange-ftp-overwrite-fn remove-directory diff insert-file-contents directory-files file-directory-p file-writable-p file-readable-p file-symlink-p delete-file read-file-name-internal verify-visited-file-modtime file-exists-p write-region backup-buffer copy-file rename-file file-attributes file-name-directory file-name-nondirectory file-name-as-directory directory-file-name expand-file-name file-name-all-completions file-name-completion ange-ftp-set-buffer-mode find-file-hooks] 3)
(fset 'ange-ftp-fix-path-for-vms #[(path &optional reverse) "À Â«äÄÅ\"«ÖÇ‰‰	\nË”«‰Ë”Ë•O\nÌ”«‰Ì”Ì•O	Í”«‰Í”Í•O	«ÎÏĞÑ	ËÒO\"\"	\n­…Ó\nÓQ	‰­ÓR+ªÜÔÕ\"ªÕÇ‰‰‰	\nÄ×\"«‘ËØ•SO\nØ•ÇOÙ!‰«ÎÏĞÚØÒO\"\"	Û!\n	­‹Ü\n?­İ	ŞRQ,*‡" [match-data match-data ((store-match-data match-data)) reverse string-match "^\\([^:]+:\\)?\\(\\[.*\\]\\)?\\([^][]*\\)$" path nil file dir drive 1 2 3 apply concat mapcar #[(char) "ÁU«„ÂÃ!‡Â!‡" [char 46 vector 47] 2] -1 "/" error "path %s didn't match" tmp "^/[^:]+:/" 0 file-name-directory #[(char) "ÁU«„ÂÃ!‡Â!‡" [char 47 vector 46] 2] file-name-nondirectory "[" "." "]"] 8 "\
Convert PATH from UNIX-ish to VMS.  If REVERSE given then convert from VMS
to UNIX-ish."])
(byte-code "À	¬„Â	BÀ>¬„ÀBÀ‡" [vms ange-ftp-fix-path-func-alist (vms . ange-ftp-fix-path-for-vms) ange-ftp-dumb-host-types] 2)
(fset 'ange-ftp-fix-dir-path-for-vms #[(dir-path) "Á˜«„ÂÃ!‡ÄÅ\"«„ÂÆ!‡Ç!‡" [dir-path "/" error "Cannot get listing for fictitious \"/\" directory." string-match "^/[-A-Z0-9_$]+:/$" "Cannot get listing for device." ange-ftp-fix-path-for-vms] 3 "\
Convert path from UNIX-ish to VMS ready for a DIRectory listing."])
(byte-code "À	¬„Â	BÃÄ!¬‚ÅÅ‡" [vms ange-ftp-fix-dir-path-func-alist (vms . ange-ftp-fix-dir-path-for-vms) boundp ange-ftp-vms-host-regexp nil] 2)
(fset 'ange-ftp-vms-host #[(host) "­ŠÁ ÃÄ\"*‡" [ange-ftp-vms-host-regexp match-data match-data ((store-match-data match-data)) string-match host] 3 "\
Return whether HOST is running VMS."])
(defconst ange-ftp-vms-filename-regexp (concat "\\(\\([_A-Za-z0-9$]?\\|[_A-Za-z0-9$][_A-Za-z0-9$---]*\\)\\." "[_A-Za-z0-9$---]*;+[0-9]*\\)") "\
Regular expression to match for a valid VMS file name in Dired buffer.
Stupid freaking bug! Position of _ and $ shouldn't matter but they do.
Having [A-Z0-9$_] bombs on filename _$$CHANGE_LOG$.TXT$ and $CHANGE_LOG$.TX
Other orders of $ and _ seem to all work just fine.")
(fset 'ange-ftp-parse-vms-filename #[nil "À	ÂÃ#­…Ä”Ä•{‡" [re-search-forward ange-ftp-vms-filename-regexp nil t 0] 4 "\
Extract the next filename from a VMS dired-like listing."])
(fset 'ange-ftp-parse-vms-listing #[nil "À ÁebˆÄ ÆÇ ‰«­ÈÉ\n\"«ŒÊ\nË‰”OÌ#ˆª–Ê\nÁ#ˆÈÍ\n\"«ŠÊ\nË‰”OÁ#ˆÎyˆªMÊÏÌ#ˆÊĞÌ#ˆ**‡" [ange-ftp-make-hashtable nil file tbl match-data match-data ((store-match-data match-data)) ange-ftp-parse-vms-filename string-match "\\.\\(DIR\\|dir\\);[0-9]+" ange-ftp-put-hash-entry 0 t ";[0-9]+$" 1 "." ".."] 4 "\
Parse the current buffer which is assumed to be in MultiNet FTP dir
format, and return a hashtable as the result."])
(byte-code "À	¬„Â	BÃÄMˆÀ¬„ÆBÇÈMˆÀ	¬†Ê	B	À‡" [vms ange-ftp-parse-list-func-alist (vms . ange-ftp-parse-vms-listing) ange-ftp-vms-delete-file-entry #[(path &optional dir-p) "«…Á\nÃ\"‡Ä ÆÇ\n!‰É˜«ƒÊª‚)ËÌ\"­¹ÍÎ\n!\"‰­¬Ñ‰”OÓÔ!ÌQÖØ\"ˆÙÚ\"ˆ®†Ø\"+)+‡" [dir-p ange-ftp-internal-delete-file-entry path t match-data match-data ((store-match-data match-data)) file-name-nondirectory file "" "." string-match ";[0-9]+$" ange-ftp-get-hash-entry file-name-directory ange-ftp-files-hashtable files 0 root "^" regexp-quote regexp nil versions ange-ftp-del-hash-entry mapatoms #[(sym) "À	\nÃN\"­ƒÄ‰‡" [string-match regexp sym key t versions] 4]] 4] ange-ftp-delete-file-entry-alist (vms . ange-ftp-vms-delete-file-entry) ange-ftp-vms-add-file-entry #[(path &optional dir-p) "«…Á\nÃ\"‡ÄÅ\n!\"‰­ÜÈ\n!‰	Ê˜«ƒËª‚	)	Ì ÎÏĞ	\"«Ñ	Ò‰”OÓ#ˆª¦ÔÕ	!ÖQÒÙÚ\"ˆTÑ	ÛÜ!QÓ#ˆ**Ñ	Ó#))‡" [dir-p ange-ftp-internal-add-file-entry path t ange-ftp-get-hash-entry file-name-directory ange-ftp-files-hashtable files file-name-nondirectory file "" "." match-data match-data ((store-match-data match-data)) string-match ";[0-9]+$" ange-ftp-put-hash-entry 0 nil "^" regexp-quote ";\\([0-9]+\\)$" version regexp mapatoms #[(sym) "ÁNÃ\n\"­ŒÆ\nÇ”Ç•O!]‰)‡" [sym key name string-match regexp version string-to-int 1] 5] ";" int-to-string] 6] ange-ftp-add-file-entry-alist (vms . ange-ftp-vms-add-file-entry)] 2)
(fset 'ange-ftp-add-vms-host #[(host) "À	!?­‘ÂÃ	!Ä­Æ°Ç‰‡" [ange-ftp-vms-host host "^" regexp-quote "$" ange-ftp-vms-host-regexp "\\|" nil ange-ftp-host-cache] 5 "\
Interactively adds a given HOST to ange-ftp-vms-host-regexp." (byte-code "ÀÁÂ ®†Ä=­‰­…Ç!@)\"C‡" [read-string "Host: " buffer-file-name major-mode dired-mode dired-directory name ange-ftp-ftp-path] 5)])
(byte-code "ÀÁMˆÂ¬„ÄBÀ‡" [ange-ftp-vms-file-name-as-directory #[(name) "À ÂÃÄ\"«†Æ‰”OÇ!*‡" [match-data match-data ((store-match-data match-data)) string-match "\\.\\(DIR\\|dir\\)\\(;[0-9]+\\)?$" name 0 ange-ftp-real-file-name-as-directory] 3] vms ange-ftp-file-name-as-directory-alist (vms . ange-ftp-vms-file-name-as-directory)] 2)
(defconst ange-ftp-dired-vms-re-exe "^. [^ 	.]+\\.\\(EXE\\|exe\\)[; ]" "\
Regular expression to use to search for VMS executable files.")
(defconst ange-ftp-dired-vms-re-dir "^. [^ 	.]+\\.\\(DIR\\|dir\\)[; ]" "\
Regular expression to use to search for VMS directories.")
(byte-code "À	¬†À\nB	BÀ¬†ÀBBÅÆMˆÀ¬†ÈBÀ‡" [vms ange-ftp-dired-re-exe-alist ange-ftp-dired-vms-re-exe ange-ftp-dired-re-dir-alist ange-ftp-dired-vms-re-dir ange-ftp-dired-vms-insert-headerline #[(dir) "ŠÀÁ!«ƒÂyˆÀÃ!«…`Ä•|ˆ)Å!‡" [looking-at "^  wildcard " 1 "^[ \n	]*[^\n]+\\][ 	]*\n" 0 ange-ftp-real-dired-insert-headerline dir] 2] ange-ftp-dired-insert-headerline-alist (vms . ange-ftp-dired-vms-insert-headerline)] 2)
(fset 'ange-ftp-dired-vms-move-to-filename #[(&optional raise-error eol) "À\n¬…Àˆ`ÃyˆÄ\nÆ#«…Ç”bª‡­ƒÉÊ!)‡" [nil case-fold-search eol 0 re-search-forward ange-ftp-vms-filename-regexp t 1 raise-error error "No file on this line"] 4 "\
In dired, move to first char of filename on this line.
Returns position (point) or nil if no filename on this line."])
(byte-code "À	¬„Â	BÃÄMˆÀ¬„ÆBÇÈMˆÀ	¬†Ê	B	ËÌMˆÀ¬†ÎBÏĞMˆÀ¬†ÒBÓÔMˆÀ¬†ÖBÀ‡" [vms ange-ftp-dired-move-to-filename-alist (vms . ange-ftp-dired-vms-move-to-filename) ange-ftp-dired-vms-move-to-end-of-filename #[(&optional no-error eol) "À‰‰`¬‡ŠÀˆ`)­‡ŠÆÇÈ#)‰¬‡É\nÈ#ˆ¬‘`=«ŒÌ\n«…ÍÎ!ªÏ!ˆ`=?­`+‡" [nil case-fold-search hidden opoint eol selective-display search-forward "" t re-search-forward ange-ftp-vms-filename-regexp no-error error substitute-command-keys "File line is hidden, type \\[dired-hide-subdir] to unhide" "No file on this line"] 5] ange-ftp-dired-move-to-end-of-filename-alist (vms . ange-ftp-dired-vms-move-to-end-of-filename) ange-ftp-dired-vms-between-files #[nil "ŠÀyˆgÁš®gÂš®‹ÃuˆÄÅ!®ƒgÆš)‡" [0 10 9 2 looking-at "Total of" 32] 2] ange-ftp-dired-between-files-alist (vms . ange-ftp-dired-vms-between-files) ange-ftp-vms-make-compressed-filename #[(name &optional reverse) "«¥ÁÂ\"«†Ä‰”O‡ÁÅ\"«†Ä‰”O‡ÁÆ\"«…ÄÇO‡‡ÁÅ\"«ˆÄ‰”OÈP‡ÈP‡" [reverse string-match "-Z;[0-9]+$" name 0 ";[0-9]+$" "-Z$" -2 "-Z"] 3] ange-ftp-dired-compress-make-compressed-filename-alist (vms . ange-ftp-vms-make-compressed-filename) ange-ftp-dired-vms-ls-trim #[nil "ebˆÀÂ!ˆ)Äyˆe`|ˆÅyˆ`d|‡" [nil case-fold-search re-search-forward ange-ftp-vms-filename-regexp 0 1] 2] ange-ftp-dired-ls-trim-alist (vms . ange-ftp-dired-vms-ls-trim) ange-ftp-vms-bob-version #[(name) "À ÂÃÄ\"«‡Æ‰”Oª*‡" [match-data match-data ((store-match-data match-data)) string-match ";[0-9]+$" name 0] 3] ange-ftp-bob-version-alist (vms . ange-ftp-vms-bob-version)] 2)
(fset 'ange-ftp-dired-vms-clean-directory #[(keep &optional marker msg) "À	«…Â	!ª]‰ÄW«„	[ªÀ	ÄX«ƒª	]®Ç®‚	ÊĞÑP#ˆÒÓ!ˆ‰«¸ÕÖ@A×\"B‰G‰\\V«›Z›¡ˆ@A¡ˆ*A‰¬H)ÒÚ!ˆĞÛP!-‡" [1 keep prefix-numeric-value dired-kept-versions 0 kept-old-versions msg "Cleaning" marker dired-del-marker nil file-version-assoc-list trample-marker action late-retention early-retention message " numerical backups (keeping %d late, %d old)..." dired-map-dired-file-lines ange-ftp-dired-vms-collect-file-versions fval q sort < sorted-v-list v-count ange-ftp-dired-vms-trample-file-versions " numerical backups...done"] 6 "\
Flag numerical backups for deletion.
Spares `dired-kept-versions' latest versions, and `kept-old-versions' oldest.
Positive prefix arg KEEP overrides `dired-kept-versions';
Negative prefix arg KEEP overrides `kept-old-versions' with KEEP made positive.

To clear the flags on these files, you can use \\[dired-flag-backup-files]
with a prefix argument."])
(byte-code "À	¬„Â	BÃÄMˆÅÆMˆÇÈMˆÀ	¬†Ê	B	ËÌMˆÀ¬†ÎBÀ‡" [vms ange-ftp-dired-clean-directory-alist (vms . ange-ftp-dired-vms-clean-directory) ange-ftp-dired-vms-collect-file-versions #[(fn) "ÀÁ\n!8ÄÅ\"­¼Æ‰”OÇ\n\"‰?­©É!ÊP‰GÍÎ\n!\"ĞÑ\"‰­Š\nBB‰,*)‡" [2 ange-ftp-ftp-path fn path string-match ";[0-9]+$" 0 ange-ftp-replace-path-component file-version-assoc-list file-name-nondirectory ";" base-versions bv-length file-name-all-completions file-name-directory possibilities mapcar #[(arg) "ÀÁ\n#«Ä”U«‡Å\nÆO!‡Ä‡" [string-match "[0-9]+$" arg bv-length 0 string-to-int nil] 4] versions] 5] ange-ftp-dired-vms-trample-file-versions #[(fn) "ÀÁ\n\"Ä­¢Æ\nÇO\"‰­–É\nTÄO!>?­ŠÇyˆÊË!ˆc*‡" [string-match ";[0-9]+$" fn start-vn nil base-version-list assoc 0 file-version-assoc-list string-to-int delete-char 1 trample-marker] 4] ange-ftp-dired-vms-flag-backup-files #[(&optional unflag-p) "ÀÁÂ‰«†ÈÉª…\nËÌÂ#,‡" [1 0 nil msg marker kept-old-versions dired-kept-versions unflag-p 32 "Unflagging" dired-del-marker "Cleaning" ange-ftp-dired-vms-clean-directory] 4] ange-ftp-dired-flag-backup-files-alist (vms . ange-ftp-dired-vms-flag-backup-files) ange-ftp-dired-vms-backup-diff #[(&optional switches) "ÀÁ!ÂÅÆ\"«ÚÇ‰”OÈÇ”TÂO!Â	\n\nS‰\nÇV«	¬™ÌÍ\n!QÎ!«ƒÏ	\nS‰\nª_	+«š«ŒÑÒ!Ò!#ªÑÒ!Ò!\"ª„ÓÔ\"*‡" [dired-get-filename no-dir nil bak file string-match ";[0-9]+$" 0 string-to-int found ver root ";" int-to-string file-exists-p t switches diff expand-file-name error "No previous version found for %s"] 6] ange-ftp-dired-backup-diff-alist (vms . ange-ftp-dired-vms-backup-diff)] 2)
(fset 'ange-ftp-fix-path-for-mts #[(path &optional reverse) "À Â«¼ÄÅ\"«®Ç‰	Ê”«ˆËÊ•O	Ì”«‰Ì”Ì•O	­…Í	ÍQP*ª ÎÏ\"ª™ÄĞ\"«Ê‰•OÌ”Ì•OPª‚*‡" [match-data match-data ((store-match-data match-data)) reverse string-match "^\\([^:]+:\\)?\\(.*\\)$" path nil file acct 1 0 2 "/" error "path %s didn't match" "^/\\([^:]+:\\)/\\(.*\\)$"] 4 "\
Convert PATH from UNIX-ish to MTS. If REVERSE given then convert from
MTS to UNIX-ish."])
(byte-code "À	¬„Â	BÀ‡" [mts ange-ftp-fix-path-func-alist (mts . ange-ftp-fix-path-for-mts)] 2)
(fset 'ange-ftp-fix-dir-path-for-mts #[(dir-path) "Á˜«„ÂÃ!‡Ä!‰Å˜«ƒÆªŒÇÈ\"«…ÆPª)‡" [dir-path "/" error "Cannot get listing for fictitious \"/\" directory." ange-ftp-fix-path-for-mts "" "?" string-match ":$"] 4 "\
Convert path from UNIX-ish to MTS ready for a DIRectory listing.
Remember that there are no directories in MTS."])
(byte-code "À	¬„Â	BÀ>¬„ÀBÄÅ!¬‚ÆÆ‡" [mts ange-ftp-fix-dir-path-func-alist (mts . ange-ftp-fix-dir-path-for-mts) ange-ftp-dumb-host-types boundp ange-ftp-mts-host-regexp nil] 2)
(fset 'ange-ftp-mts-host #[(host) "­ŠÁ ÃÄ\"*‡" [ange-ftp-mts-host-regexp match-data match-data ((store-match-data match-data)) string-match host] 3 "\
Return whether HOST is running MTS."])
(fset 'ange-ftp-parse-mts-listing #[nil "À ebˆÂ ÄÅÇÈ#«ÇˆÉÇxˆ`\nËÇxˆÌ`\n{Ç	#ˆ)Íyˆª[*ÌÎÈ	#ˆ	)‡" [ange-ftp-make-hashtable tbl match-data match-data ((store-match-data match-data)) re-search-forward ange-ftp-date-regexp nil t " " end "-A-Z0-9_.!" ange-ftp-put-hash-entry 1 "."] 4 "\
Parse the current buffer which is assumed to be in
mts ftp dir format."])
(byte-code "À	¬„Â	BÀ‡" [mts ange-ftp-parse-list-func-alist (mts . ange-ftp-parse-mts-listing)] 2)
(fset 'ange-ftp-add-mts-host #[(host) "À	!?­‘ÂÃ	!Ä­Æ°Ç‰‡" [ange-ftp-mts-host host "^" regexp-quote "$" ange-ftp-mts-host-regexp "\\|" nil ange-ftp-host-cache] 5 "\
Interactively adds a given HOST to ange-ftp-mts-host-regexp." (byte-code "ÀÁÂ ®†Ä=­‰­…Ç!@)\"C‡" [read-string "Host: " buffer-file-name major-mode dired-mode dired-directory name ange-ftp-ftp-path] 5)])
(fset 'ange-ftp-dired-mts-move-to-filename #[(&optional raise-error eol) "¬…Áˆ`ÂyˆÃÅ#«—ÆÁwˆÇwˆÆwˆÈÉ!«„Â•bˆ`‡\n­ƒËÌ!‡" [eol nil 0 re-search-forward ange-ftp-date-regexp t " " "0-9:" looking-at "[A-Z0-9_.]+:" raise-error error "No file on this line"] 4 "\
In dired, move to first char of filename on this line.
Returns position (point) or nil if no filename on this line."])
(byte-code "À	¬„Â	BÃÄMˆÀ¬„ÆBÀ‡" [mts ange-ftp-dired-move-to-filename-alist (mts . ange-ftp-dired-mts-move-to-filename) ange-ftp-dired-mts-move-to-end-of-filename #[(&optional no-error eol) "À‰‰`ŠÀˆ`)­‡ŠÆÇÈ#)‰¬„Éwˆ\n¬‘`=«ŒË\n«…ÌÍ!ªÎ!ˆ`=?­`+‡" [nil case-fold-search hidden opoint eol selective-display search-forward "" t "-A-Z0-9._!" no-error error substitute-command-keys "File line is hidden, type \\[dired-hide-subdir] to unhide" "No file on this line"] 5] ange-ftp-dired-move-to-end-of-filename-alist (mts . ange-ftp-dired-mts-move-to-end-of-filename)] 2)
(fset 'ange-ftp-fix-path-for-cms #[(path &optional reverse) "À Â«…ÄPªêÆÇ\"«áÈ‰•O	Ê”«ÑÊ”Ê•OË	PÌ\"Ò#@«„ª©Ì\"Ò#‰@«„ªÕÖ×	A##)+ª‚	)ªƒØÙ!*‡" [match-data match-data ((store-match-data match-data)) reverse "/" path string-match "^/\\([-A-Z0-9$*._]+\\)/\\([-A-Z0-9$._]+\\)?$" 1 minidisk 2 "cd " ange-ftp-get-process host user proc cmd file ange-ftp-raw-send-cmd msg result ange-ftp-error format "cd to minidisk %s failed: %s" error "Invalid CMS filename"] 8 "\
Convert PATH from UNIX-ish to CMS. If REVERSE is given, convert
from CMS to UNIX. Actually, CMS doesn't have a full pathname syntax,
so we fudge things by sending cd's."])
(byte-code "À	¬„Â	BÀ>¬„ÀBÀ‡" [cms ange-ftp-fix-path-func-alist (cms . ange-ftp-fix-path-for-cms) ange-ftp-dumb-host-types] 2)
(fset 'ange-ftp-fix-dir-path-for-cms #[(dir-path) "Á˜«„ÂÃ!‡ÄÅ\"«ÜÆ”Æ•OÈ	\n\"ÌPÎ”«‰Î”Î•OªĞÒ\"@«„ª§È	\n\"Ò\"‰@«„ªÔ	\nÕÖA##),‡Â×!‡" [dir-path "/" error "Cannot get listing for fictitious \"/\" directory." string-match "^/\\([-A-Z0-9$*._]+\\)/\\([-A-Z0-9$._]+\\)?$" 1 minidisk ange-ftp-get-process host user proc "cd " cmd 2 path "*" file ange-ftp-raw-send-cmd result ange-ftp-error format "cd to minidisk %s failed: " "Invalid CMS pathname"] 8 "\
Convert path from UNIX-ish to VMS ready for a DIRectory listing."])
(byte-code "À	¬„Â	BÀ‡" [cms ange-ftp-fix-dir-path-func-alist (cms . ange-ftp-fix-dir-path-for-cms)] 2)
(defvar ange-ftp-cms-host-regexp nil "\
Regular expression to match hosts running the CMS operating system.")
(fset 'ange-ftp-cms-host #[(host) "­ŠÁ ÃÄ\"*‡" [ange-ftp-cms-host-regexp match-data match-data ((store-match-data match-data)) string-match host] 3 "\
Return whether the host is running CMS."])
(fset 'ange-ftp-add-cms-host #[(host) "À	!?­‘ÂÃ	!Ä­Æ°Ç‰‡" [ange-ftp-cms-host host "^" regexp-quote "$" ange-ftp-cms-host-regexp "\\|" nil ange-ftp-host-cache] 5 "\
Interactively adds a given HOST to ange-ftp-cms-host-regexp." (byte-code "ÀÁÂ ®†Ä=­‰­…Ç!@)\"C‡" [read-string "Host: " buffer-file-name major-mode dired-mode dired-directory name ange-ftp-ftp-path] 5)])
(fset 'ange-ftp-parse-cms-listing #[nil "À ebˆÂ ÄÅÆÇÈ#«–ÉÊ”Ê•{ËÌ”Ì•{QÇ	#ˆÊyˆªcÉËÈ	#ˆ*	)‡" [ange-ftp-make-hashtable tbl match-data match-data ((store-match-data match-data)) re-search-forward "^\\([-A-Z0-9$_]+\\) +\\([-A-Z0-9$_]+\\) +[VF] +[0-9]+ " nil t ange-ftp-put-hash-entry 1 "." 2] 5 "\
Parse the current buffer which is assumed to be a CMS directory listing."])
(byte-code "À	¬„Â	BÀ‡" [cms ange-ftp-parse-list-func-alist (cms . ange-ftp-parse-cms-listing)] 2)
(defconst ange-ftp-dired-cms-re-exe "^. [-A-Z0-9$_]+ +EXEC " "\
Regular expression to use to search for CMS executables.")
(byte-code "À	¬†À\nB	BÃÄMˆÀ¬„ÆBÀ‡" [cms ange-ftp-dired-re-exe-alist ange-ftp-dired-cms-re-exe ange-ftp-dired-cms-insert-headerline #[(dir) "ÀcˆÁuˆÂ!‡" ["\n" -1 ange-ftp-real-dired-insert-headerline dir] 2] ange-ftp-dired-insert-headerline-alist (cms . ange-ftp-dired-cms-insert-headerline)] 2)
(fset 'ange-ftp-dired-cms-move-to-filename #[(&optional raise-error eol) "¬…Áˆ`ÁÃyˆÄÅÆ#«†Ã”Tbª‡­ƒÈÉ!)‡" [eol nil case-fold-search 0 re-search-forward " [-A-Z0-9$_]+ +[-A-Z0-9$_]+ +[VF] +[0-9]+ " t raise-error error "No file on this line"] 4 "\
In dired, move to the first char of filename on this line."])
(byte-code "À	¬„Â	BÃÄMˆÀ¬„ÆBÇÈMˆÀ	¬†Ê	B	ËÌMˆÀ¬†ÎBÏĞ!‡" [cms ange-ftp-dired-move-to-filename-alist (cms . ange-ftp-dired-cms-move-to-filename) ange-ftp-dired-cms-move-to-end-of-filename #[(&optional no-error eol) "`À‰¬‡ŠÀˆ`)­‡ŠÆÇÈ#)‰«Œ	?­£ÊËÌ!!ªœÍwˆÎwˆÍwˆ`=«Š	?­†ÊÏ!ª`+‡" [nil hidden case-fold-search opoint eol selective-display search-forward "" t no-error error substitute-command-keys "File line is hidden, type \\[dired-hide-subdir] to unhide" "-A-Z0-9$_" " " "No file on this line"] 5] ange-ftp-dired-move-to-end-of-filename-alist (cms . ange-ftp-dired-cms-move-to-end-of-filename) ange-ftp-cms-make-compressed-filename #[(name &optional reverse) "«ÁÂ\"«…ÄÅO‡‡ÆP‡" [reverse string-match "-Z$" name 0 -2 "-Z"] 3] ange-ftp-dired-compress-make-compressed-filename-alist (cms . ange-ftp-cms-make-compressed-filename) ange-ftp-dired-cms-get-filename #[(&optional localp no-error-if-not-filep) "À	\n\"‰­–ÄÅ\"«ÆÇ•OÈÉ”É•OQª)‡" [ange-ftp-real-dired-get-filename localp no-error-if-not-filep name string-match "^\\([^ ]+\\) +\\([^ ]+\\)$" 0 1 "." 2] 6] ange-ftp-dired-get-filename-alist (cms . ange-ftp-dired-cms-get-filename) provide ange-ftp] 2)
