;;; compiled by jwz@thalidomide on Tue Apr 21 17:55:23 1992
;;; from file /u/jwz/emacs19/lisp/tex-mode.el
;;; emacs version 19.0.2 Lucid.
;;; bytecomp version 2.05; 9-mar-92.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(byte-code "¿¡!à¬√!á" [require oshell provide tex-mode] 2)
(defvar tex-directory "./" "\
*Directory in which to run TeX subjob.  Temporary files are created here.")
(defvar tex-run-command "tex" "\
*Command used to run TeX subjob.
The name of the file will be appended to this string, separated by a space.")
(defvar latex-run-command "latex" "\
*Command used to run LaTeX subjob.
The name of the file will be appended to this string, separated by a space.")
(defvar slitex-run-command "slitex" "\
*Command used to run SliTeX subjob.
The name of the file will be appended to this string, separated by a space.")
(defvar tex-bibtex-command "bibtex" "\
*Command string used by `tex-bibtex-file' to gather bibliographic data.
The name of the file will be appended to this string, separated by a space.")
(defvar tex-dvi-print-command "lpr -d" "\
*Command string used by \\[tex-print] to print a .dvi file.")
(defvar tex-dvi-view-command nil "\
*Command string used by \\[tex-view] to display a .dvi file.")
(defvar tex-show-queue-command "lpq" "\
*Command string used by \\[tex-show-print-queue] to show the print queue.
Should show the queue that \\[tex-print] puts jobs on.")
(defvar tex-default-mode 'plain-tex-mode "\
*Mode to enter for a new file that might be either TeX or LaTeX.
This variable is used when it can't be determined whether the file
is plain TeX or LaTeX or what because the file contains no commands.
Normally set to either 'plain-tex-mode or 'latex-mode.")
(defvar tex-open-quote "``" "\
*String inserted by typing \\[tex-insert-quote] to open a quotation.")
(defvar tex-close-quote "''" "\
*String inserted by typing \\[tex-insert-quote] to close a quotation.")
(defvar tex-command nil "\
Command to run TeX.
The name of the file will be appended to this string, separated by a space.")
(defvar tex-trailer nil "\
String appended after the end of a region sent to TeX by \\[tex-region].")
(defvar tex-start-of-header nil "\
String used by \\[tex-region] to delimit the start of the file's header.")
(defvar tex-end-of-header nil "\
String used by \\[tex-region] to delimit the end of the file's header.")
(defvar tex-shell-cd-command "cd" "\
Command to give to shell running TeX to change directory.
The value of tex-directory will be appended to this, separated by a space.")
(defvar tex-zap-file nil "\
Temporary file name used for text being sent as input to TeX.
Should be a simple file name with no extension or directory specification.")
(defvar tex-last-buffer-texed nil "\
Buffer which was last TeXed.")
(defvar tex-print-file nil "\
File name that \\[tex-print] prints.
Set by \\[tex-region], \\[tex-buffer], and \\[tex-file].")
(defvar tex-mode-syntax-table nil "\
Syntax table used while in TeX mode.")
(fset 'tex-define-common-keys #[(keymap) "¿	¬√#à¿	ƒ≈#à¿	∆«#à¿	»…#à¿	 À#á" [define-key keymap "" tex-kill-job "" tex-recenter-output-buffer "" tex-show-print-queue "" tex-print "" tex-view] 4 "\
Define the keys that we want defined both in TeX mode and in the tex-shell."])
(defvar tex-mode-map nil "\
Keymap for TeX mode.")
(byte-code "¨√¡ ¬!à√ƒ≈#à√∆«#à√»…#à√ À#à√ÃÕ#à√Œœ#à√–—#à√“”#à√‘’#à√÷◊#à¡á" [tex-mode-map make-sparse-keymap tex-define-common-keys define-key "\"" tex-insert-quote "\n" tex-terminate-paragraph "}" up-list "{" tex-insert-braces "" tex-region "" tex-buffer "" tex-file "	" tex-bibtex-file "" tex-latex-block "" tex-close-latex-block] 4)
(defvar tex-shell-map nil "\
Keymap for the tex-shell.  A shell-mode-map with a few additions.")
(fset 'tex-mode #[nil "¿ââäebàƒ≈¿∆#â´í`ä»yàƒ…∆#*â¨e\n´ï	¨í À!´ã Ã!´ÉÕ™ÑŒ™Åœ)´Ñ ™É +á" [nil comment slash mode search-forward "\\" t search-end 0 "%" looking-at "documentstyle" "documentstyle{slides}" slitex-mode latex-mode plain-tex-mode tex-default-mode] 4 "\
Major mode for editing files of input for TeX, LaTeX, or SliTeX.
Tries to determine (by looking at the beginning of the file) whether
this file is for plain TeX, LaTeX, or SliTeX and calls plain-tex-mode,
latex-mode, or slitex-mode, respectively.  If it cannot be determined,
such as if there are no commands in the file, the value of tex-default-mode
is used." nil])
(byte-code "¿¡Mà¬√Má" [plain-TeX-mode plain-tex-mode LaTeX-mode latex-mode] 2)
(fset 'plain-tex-mode #[nil "¿ à¡√«…\nÀÕŒœ–#á" [tex-common-initialization "TeX" mode-name plain-tex-mode major-mode tex-run-command tex-command "%**start of header" tex-start-of-header "%**end of header" tex-end-of-header "\\bye\n" tex-trailer run-hooks text-mode-hook tex-mode-hook plain-tex-mode-hook] 4 "\
Major mode for editing files of input for plain TeX.
Makes $ and } display the characters they match.
Makes \" insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts \" only after a \\.

Use \\[tex-region] to run TeX on the current region, plus a \"header\"
copied from the top of the file (containing macro definitions, etc.),
running TeX under a special subshell.  \\[tex-buffer] does the whole buffer.
\\[tex-file] saves the buffer and then processes the file.
\\[tex-print] prints the .dvi file made by any of these.
\\[tex-view] previews the .dvi file made by any of these.
\\[tex-bibtex-file] runs bibtex on the file of the current buffer.

Use \\[validate-tex-buffer] to check buffer for paragraphs containing
mismatched $'s or braces.

Special commands:
\\{tex-mode-map}

Mode variables:
tex-run-command
	Command string used by \\[tex-region] or \\[tex-buffer].
tex-directory
	Directory in which to create temporary files for TeX jobs
	run by \\[tex-region] or \\[tex-buffer].
tex-dvi-print-command
	Command string used by \\[tex-print] to print a .dvi file.
tex-dvi-view-command
	Command string used by \\[tex-view] to preview a .dvi file.
tex-show-queue-command
	Command string used by \\[tex-show-print-queue] to show the print
	queue that \\[tex-print] put your job on.

Entering Plain-tex mode calls the value of text-mode-hook, then the value of
tex-mode-hook, and then the value of plain-tex-mode-hook.  When the special
subshell is initiated, the value of tex-shell-hook is called." nil])
(fset 'latex-mode #[nil "¿ à¡√«…\nÀÕŒœ–#á" [tex-common-initialization "LaTeX" mode-name latex-mode major-mode latex-run-command tex-command "\\documentstyle" tex-start-of-header "\\begin{document}" tex-end-of-header "\\end{document}\n" tex-trailer run-hooks text-mode-hook tex-mode-hook latex-mode-hook] 4 "\
Major mode for editing files of input for LaTeX.
Makes $ and } display the characters they match.
Makes \" insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts \" only after a \\.

Use \\[tex-region] to run LaTeX on the current region, plus the preamble
copied from the top of the file (containing \\documentstyle, etc.),
running LaTeX under a special subshell.  \\[tex-buffer] does the whole buffer.
\\[tex-file] saves the buffer and then processes the file.
\\[tex-print] prints the .dvi file made by any of these.
\\[tex-view] previews the .dvi file made by any of these.
\\[tex-bibtex-file] runs bibtex on the file of the current buffer.

Use \\[validate-tex-buffer] to check buffer for paragraphs containing
mismatched $'s or braces.

Special commands:
\\{tex-mode-map}

Mode variables:
latex-run-command
	Command string used by \\[tex-region] or \\[tex-buffer].
tex-directory
	Directory in which to create temporary files for LaTeX jobs
	run by \\[tex-region] or \\[tex-buffer].
tex-dvi-print-command
	Command string used by \\[tex-print] to print a .dvi file.
tex-dvi-view-command
	Command string used by \\[tex-view] to preview a .dvi file.
tex-show-queue-command
	Command string used by \\[tex-show-print-queue] to show the print
	queue that \\[tex-print] put your job on.

Entering Latex mode calls the value of text-mode-hook, then the value of
tex-mode-hook, and then the value of latex-mode-hook.  When the special
subshell is initiated, the value of tex-shell-hook is called." nil])
(fset 'slitex-mode #[nil "¿ à¡√«…\nÀÕŒœ–—$á" [tex-common-initialization "SliTeX" mode-name slitex-mode major-mode slitex-run-command tex-command "\\documentstyle{slides}" tex-start-of-header "\\begin{document}" tex-end-of-header "\\end{document}\n" tex-trailer run-hooks text-mode-hook tex-mode-hook latex-mode-hook slitex-mode-hook] 5 "\
Major mode for editing files of input for SliTeX.
Makes $ and } display the characters they match.
Makes \" insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts \" only after a \\.

Use \\[tex-region] to run SliTeX on the current region, plus the preamble
copied from the top of the file (containing \\documentstyle, etc.),
running SliTeX under a special subshell.  \\[tex-buffer] does the whole buffer.
\\[tex-file] saves the buffer and then processes the file.
\\[tex-print] prints the .dvi file made by any of these.
\\[tex-view] previews the .dvi file made by any of these.
\\[tex-bibtex-file] runs bibtex on the file of the current buffer.

Use \\[validate-tex-buffer] to check buffer for paragraphs containing
mismatched $'s or braces.

Special commands:
\\{tex-mode-map}

Mode variables:
slitex-run-command
	Command string used by \\[tex-region] or \\[tex-buffer].
tex-directory
	Directory in which to create temporary files for SliTeX jobs
	run by \\[tex-region] or \\[tex-buffer].
tex-dvi-print-command
	Command string used by \\[tex-print] to print a .dvi file.
tex-dvi-view-command
	Command string used by \\[tex-view] to preview a .dvi file.
tex-show-queue-command
	Command string used by \\[tex-show-print-queue] to show the print
	queue that \\[tex-print] put your job on.

Entering SliTex mode calls the value of text-mode-hook, then the value of
tex-mode-hook, then the value of latex-mode-hook, and then the value of
slitex-mode-hook.  When the special subshell is initiated, the value of
tex-shell-hook is called." nil])
(byte-code "¿¡Mà¬√Màƒ≈Má" [tex-common-initialization #[nil "¿ à¡\n!à¨‚∆» …!à W´éÀÃ\"àTâ™nÀ∆Õ\"àÀŒœ\"àÀ–—\"àÀ“—\"àÀ”‘\"àÀ’÷\"àÀ◊ÿ\"àÀŸÃ\"àÀ⁄Ã\"àÀ€Ã\"àÀ‹›\"àÀﬁœ\"àÀﬂÕ\"à)™Ñ…!à‡·!à‚!‡„!à!#‡‰!àÂ$‡Ê!àÁ&‡Ë!àÈ(‡Í!àÎ*‡Ï!à‡Ì!à‡Ó!à‡Ô!á" [kill-all-local-variables use-local-map tex-mode-map text-mode-abbrev-table local-abbrev-table tex-mode-syntax-table 0 char make-syntax-table set-syntax-table 32 modify-syntax-entry "." "w" 9 " " 10 ">" 12 36 "$$" 37 "<" 92 "/" 34 38 95 64 "_" 126 39 make-local-variable paragraph-start "^[ 	]*$\\|^[\\\\%]" paragraph-separate comment-start "%" comment-start-skip "\\(\\(^\\|[^\\]\\)\\(\\\\\\\\\\)*\\)\\(%+ *\\)" comment-indent-hook tex-comment-indent compare-windows-whitespace tex-categorize-whitespace tex-command tex-start-of-header tex-end-of-header tex-trailer] 4] tex-comment-indent #[nil "¿¡!´Çiá¬√xàn´Éƒ™ÇiT]á" [looking-at "%%%" " 	" nil 0 comment-column] 2] tex-categorize-whitespace #[(backward-limit) "¿¡ƒxà\n´º∆«!´ç»ïbà¿=´o…™k∆ !´îÀ=´áÃÕâ™[À»ïbà™R∆Œ!´áÃÕâ™GÕâ¨DƒÕwàÀ=´É…™Å*á" [null t not-finished category " 	\n" backward-limit looking-at "[ 	]+" 0 space "\n" newline par nil "+"] 3]] 2)
(fset 'tex-insert-quote #[(arg) "´Ü¡¬!!áo¨ää√uàƒ≈!)´Ñ™äh«U´É»™Ç	cá" [arg self-insert-command prefix-numeric-value -1 looking-at "\\s(\\|\\s \\|\\s>" tex-open-quote 92 34 tex-close-quote] 3 "\
Insert the appropriate quote marks for TeX.
Inserts the value of tex-open-quote (normally ``) or tex-close-quote
(normally '') depending on the context.  With prefix argument, always
inserts \" characters." "P"])
(fset 'validate-tex-buffer #[nil "`dbà¡é¬ ?≠°o?≠ù`ƒ≈∆«#à»`\"¨å…`!à À!àÃÕ!à)™Z*á" [opoint ((goto-char opoint)) input-pending-p end search-backward "\n\n" nil move tex-validate-region push-mark message "Mismatch found in pararaph starting here" sit-for 4] 4 "\
Check current buffer for paragraphs containing mismatched $'s.
As each such paragraph is found, a mark is pushed at its beginning,
and the location is displayed for a few seconds." nil])
(fset 'tex-validate-region #[(start end) "¿	\nZä¿≈∆èà)´Übà¿™Å«*á" [nil end start max-possible-sexps failure-point (byte-code "å	}àbà¬SâW´Üƒ≈!à™r)¬á" [start end 0 max-possible-sexps forward-sexp 1] 3) ((error (byte-code "`¡á" [failure-point nil] 1))) t] 3 "\
Check for mismatched braces or $'s in region.
Returns t if no mismatches.  Returns nil and moves point to suspect
area if a mismatch is found." "r"])
(fset 'tex-terminate-paragraph #[(inhibit-validation) "¨îä¡ä¬√ƒ≈#à`)`\")¨Ñ∆«!à√cá" [inhibit-validation tex-validate-region search-backward "\n\n" nil move message "Paragraph being closed appears to contain a mismatch"] 5 "\
Insert two newlines, breaking a paragraph for TeX.
Check for mismatched braces/$'s in paragraph being terminated.
A prefix arg inhibits the checking." "P"])
(fset 'tex-insert-braces #[nil "¿càä¡c)á" [123 125] 1 "\
Make a pair of braces and be poised to type inside of them." nil])
(fset 'tex-latex-block #[(name) "i¡¬\"càjàäƒcàjà≈¡∆\"!àm≠Çƒc*á" [col format "\\begin{%s}\n" name 10 insert-string "\\end{%s}"] 4 "\
Creates a matching pair of lines \\begin{NAME} and \\end{NAME} at point.
Puts point on a blank line between them." "*sLaTeX block name: "])
(fset 'tex-last-unended-begin #[nil "¿¡!≠ä¬√!≠Öƒ à™qá" [re-search-backward "\\(\\\\begin\\s *{\\)\\|\\(\\\\end\\s *{\\)" looking-at "\\\\end{" tex-last-unended-begin] 2 "\
Leave point at the beginning of the last \\begin{...} that is unended."])
(fset 'tex-close-latex-block #[nil "n¿âäƒ≈∆èài«»!à…î…ï{)	jà \n±à≠ÇÀc+á" [nil indentation text new-line-needed ERR (tex-last-unended-begin) ((error (error "Couldn't find unended \\begin"))) re-search-forward "\\\\begin\\(\\s *{[^}\n]*}\\)" 1 "\\end" 10] 3 "\
Creates an \\end{...} to match the last unclosed \\begin{...}." "*"])
(fset 'tex-start-shell #[nil "ä¿¡¬â√$qàƒ!«!à»!à… !àÀ ÃU≠ÉÕŒ!)á" [make-shell "tex-shell" nil "-v" copy-keymap shell-mode-map tex-shell-map tex-define-common-keys use-local-map run-hooks tex-shell-hook buffer-size 0 sleep-for 1] 5])
(fset 'set-buffer-directory #[(buffer directory) "¿¡\n!!√\n!¨Öƒ≈\n\"áäqà\nâ)á" [file-name-as-directory expand-file-name directory file-directory-p error "%s is not a directory" buffer default-directory] 3 "\
Set BUFFER's default directory to be DIRECTORY."])
(fset 'tex-region #[(beg end) "¿ ´Ö¡ à™É¬ à¨Éƒ ≈P∆«!» ´Ü…» !™Ç\nÀÃ!!“”‘\"\"â´í÷Ã@\"!àAâ¨n)äå~àebà◊yà`ee\nebà€›#´ôﬁyà`€‡›#´à·yà`™Ée‚#^‡â%à‚#]$›‡%à,%&qàÁ àËÈ!à&´ÖË&!àÍ\"à‚ed›‡%à+äÎÏ!qàÌÓ!à.)ÔÒ\"àÍÏ\"àÚ3ÙÈR\"àÚ5ˆ˜∞\"à,p8ÀÃ!!P9˙ﬁ!á" [tex-shell-running tex-kill-job tex-start-shell tex-zap-file tex-generate-zap-file-name ".tex" get-buffer-create " TeX-Output-Buffer" buffer-file-name file-name-directory default-directory file-name-as-directory expand-file-name tex-directory zap-directory file-dir temp-buffer tex-out-file file-name-all-completions tex-append "." list delete-file 100 hend hbeg search-end search-forward tex-start-of-header t 0 tex-end-of-header nil 1 write-region beg end tex-trailer local-tex-trailer erase-buffer insert-string "\n" set-buffer-directory get-buffer "*tex-shell*" make-local-variable tex-last-temp-file set-process-filter "tex-shell" tex-filter send-string tex-shell-cd-command " " tex-command " \"" "\"\n" tex-last-buffer-texed tex-print-file tex-recenter-output-buffer] 8 "\
Run TeX on the current region, via a temporary file.
The file's name comes from the variable `tex-zap-file' and the
variable `tex-directory' says where to put it.

If the buffer has a header, the header is given to TeX before the
region itself.  The buffer's header is all lines between the strings
defined by `tex-start-of-header' and `tex-end-of-header' inclusive.
The header must start in the first 100 lines of the buffer.

The value of `tex-trailer' is given to TeX as input after the region.

The value of `tex-command' specifies the command to use to run TeX." "r"])
(fset 'tex-filter #[(process string) "p¡\n!qà√éƒ\n!dU´Öcà™ääƒ\n!bàcà)ƒ\n!`∆ìàä«yà»…!≠® ∆\"àÃÕœ\"\"â≠ì“”@\"!àAâ¨n∆)+á" [old process-buffer proc ((byte-code "p=¨Éqà¡á" [old nil] 2)) process-mark string nil -1 looking-at "^Output written on " set-process-filter process file-name-all-completions tex-append tex-last-temp-file "." zap-directory list delete-file expand-file-name] 5])
(fset 'tex-buffer #[nil "¿ed\"á" [tex-region] 3 "\
Run TeX on current buffer.  See \\[tex-region] for more information.
Does not save the buffer, so it's useful for trying
experimental versions.  See \\[tex-file] for an alternative." nil])
(fset 'tex-file #[nil "¿ ´Ü¡¿ !™É¬√!ƒ¿ !« à» ´Ö… à™É  àÀÃ\"àÕŒ–—R\"àÕŒ”‘R\"à*p¿ ◊ÿ!á" [buffer-file-name file-name-nondirectory error "Buffer does not seem to be associated with any file" file-name-directory file-dir tex-out-file save-some-buffers tex-shell-running tex-kill-job tex-start-shell set-buffer-directory "*tex-shell*" send-string "tex-shell" tex-shell-cd-command " " "\n" tex-command " \"" "\"\n" tex-last-buffer-texed tex-print-file tex-recenter-output-buffer 0] 6 "\
Prompt to save all buffers and run TeX (or LaTeX) on current buffer's file.
This function is more useful than \\[tex-buffer] when you need the
`.aux' file of LaTeX to have the correct name." nil])
(fset 'tex-generate-zap-file-name #[nil "¿¡¬√ƒ!!≈∆ !#á" [format "#tz%d%s" process-id get-buffer-process "*tex-shell*" tex-strip-dots system-name] 5 "\
Generate a unique name suitable for use as a file name."])
(byte-code "¿¡Mà¬√Màƒ≈Má" [tex-strip-dots #[(s) "¿	!¬√	\"´à	ƒî≈Ià™r	á" [copy-sequence s string-match "\\." 0 45] 3] tex-expand-files #[(s) "¿¡ƒ≈\n#´é\n¡îOB¡ï™j\n¡U¨à\n¿OB«»ü≈#*á" [nil 0 start elts string-match ":" s mapconcat expand-file-name] 4] tex-shell-running #[nil "¿¡!≠á¬¿¡!!√=á" [get-process "tex-shell" process-status run] 3]] 2)
(fset 'tex-kill-job #[nil "¿¡!≠Ñ¬¡√\"á" [get-process "tex-shell" quit-process t] 3 "\
Kill the currently running TeX job." nil])
(fset 'tex-recenter-output-buffer #[(linenum) "¿¡!pâ¨Öƒ≈!™ü∆!à«!àdbà»	´Ü 	!™ÑÀ Ã•!à∆\n!*á" [get-buffer "*tex-shell*" old-buffer tex-shell message "No TeX output buffer" pop-to-buffer bury-buffer recenter linenum prefix-numeric-value window-height 2] 4 "\
Redisplay buffer of TeX job output so that most recent output can be seen.
The last line of the buffer is displayed on
line LINE of the window, or centered if LINE is nil." "P"])
(fset 'tex-print #[nil "¿	¬\"√pö¨ë«¿» ¬\"â¿	¬\"\"´Ç…!´ä ÃÕR!™ÉŒœ!*á" [tex-append tex-print-file ".dvi" nil test-name print-file-name-dvi tex-last-buffer-texed file-newer-than-file-p buffer-file-name file-exists-p shell-command tex-dvi-print-command " \"" "&\"\n" error "No appropriate `.dvi' file could be found"] 5 "\
Print the .dvi file made by \\[tex-region], \\[tex-buffer] or \\[tex-file].
Runs the shell command defined by tex-dvi-print-command." nil])
(fset 'tex-view #[nil "¬ )á" [tex-dvi-view-command tex-dvi-print-command tex-print] 1 "\
Preview the last `.dvi' file made by running TeX under Emacs.
This means, made using \\[tex-region], \\[tex-buffer] or \\[tex-file].
The variable `tex-dvi-view-command' specifies the shell command for preview." nil])
(fset 'tex-append #[(file-name suffix) ";´ì¡!√!\nƒ≈∆\n\"OQ)á»á" [file-name file-name-nondirectory file file-name-directory 0 string-match "\\." suffix " "] 6 "\
Append to FILENAME the suffix SUFFIX, using same algorithm TeX uses.
Scans for the first (not last) period.
No period is retained immediately before SUFFIX,
so normally SUFFIX starts with one."])
(fset 'tex-show-print-queue #[nil "¿ ´Ö¡ à™É¬ à√ƒ∆P\"à«»!á" [tex-shell-running tex-kill-job tex-start-shell send-string "tex-shell" tex-show-queue-command "\n" tex-recenter-output-buffer nil] 4 "\
Show the print queue that \\[tex-print] put your job on.
Runs the shell command defined by tex-show-queue-command." nil])
(fset 'tex-bibtex-file #[nil "¿ ´Ö¡ à™É¬ à√ƒ≈ !∆\"«≈ !	 À\"àÃÕœ–R\"àÃÕ“	”R\"à*‘’!á" [tex-shell-running tex-kill-job tex-start-shell tex-append file-name-nondirectory buffer-file-name "" file-name-directory file-dir tex-out-file set-buffer-directory "*tex-shell*" send-string "tex-shell" tex-shell-cd-command " " "\n" tex-bibtex-command " \"" "\"\n" tex-recenter-output-buffer 0] 6 "\
Run BibTeX on the current buffer's file." nil])
