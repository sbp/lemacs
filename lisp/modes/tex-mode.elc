;;; compiled by jwz@thalidomide on Tue Jul  7 12:42:50 1992
;;; from file /u/jwz/emacs19/lisp/modes/tex-mode.el
;;; emacs version 19.2.1 Lucid.
;;; bytecomp version 2.07; 17-jun-92.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(require 'comint)
(defvar tex-shell-file-name nil "\
*If non-nil, is file name to use for the subshell in which TeX is run.")
(defvar tex-directory "." "\
*Directory in which temporary files are left.
You can make this /tmp if your TEXINPUTS has no relative directories in it
and you don't try to apply \\[tex-region] or \\[tex-buffer] when there are
\\input commands with relative directories.")
(defvar tex-offer-save t "\
*If non-nil, ask about saving modified buffers before \\[tex-file] is run.")
(defvar tex-run-command "tex" "\
*Command used to run TeX subjob.
If this string contains an asterisk (*), it will be replaced by the
filename; if not, the name of the file, preceded by blank, will be added to
this string.")
(defvar latex-run-command "latex" "\
*Command used to run LaTeX subjob.
If this string contains an asterisk (*), it will be replaced by the
filename; if not, the name of the file, preceded by blank, will be added to
this string.")
(defvar standard-latex-block-names '("abstract" "array" "center" "description" "displaymath" "document" "enumerate" "eqnarray" "eqnarray*" "equation" "figure" "figure*" "flushleft" "flushright" "itemize" "letter" "list" "minipage" "picture" "quotation" "quote" "slide" "sloppypar" "tabbing" "table" "table*" "tabular" "tabular*" "thebibliography" "theindex*" "titlepage" "trivlist" "verbatim" "verbatim*" "verse") "\
Standard LaTeX block names.")
(defvar latex-block-names nil "\
*User defined LaTeX block names.
Combined with `standard-latex-block-names' for minibuffer completion.")
(defvar slitex-run-command "slitex" "\
*Command used to run SliTeX subjob.
If this string contains an asterisk (*), it will be replaced by the
filename; if not, the name of the file, preceded by blank, will be added to
this string.")
(defvar tex-bibtex-command "bibtex" "\
*Command used by `tex-bibtex-file' to gather bibliographic data.
If this string contains an asterisk (*), it will be replaced by the
filename; if not, the name of the file, preceded by blank, will be added to
this string.")
(defvar tex-dvi-print-command "lpr -d" "\
*Command used by \\[tex-print] to print a .dvi file.
If this string contains an asterisk (*), it will be replaced by the
filename; if not, the name of the file, preceded by blank, will be added to
this string.")
(defvar tex-alt-dvi-print-command "lpr -d" "\
*Command used by \\[tex-print] with a prefix arg to print a .dvi file.
If this string contains an asterisk (*), it will be replaced by the
filename; if not, the name of the file, preceded by blank, will be added to
this string.

If two printers are not enough of a choice, you can define the value
of tex-alt-dvi-print-command to be an expression that asks what you want;
for example,

    (setq tex-alt-dvi-print-command
         '(format \"lpr -P%s\" (read-string \"Use printer: \")))

would tell \\[tex-print] with a prefix argument to ask you which printer to
use.")
(defvar tex-dvi-view-command nil "\
*Command used by \\[tex-view] to display a .dvi file.
If this string contains an asterisk (*), it will be replaced by the
filename; if not, the name of the file, preceded by blank, will be added to
this string.

This can be set conditionally so that the previewer used is suitable for the
window system being used.  For example,

    (setq tex-dvi-view-command
          (if (eq window-system 'x) \"xdvi\" \"dvi2tty * | cat -s\"))

would tell \\[tex-view] use xdvi under X windows and to use dvi2tty
otherwise.")
(defvar tex-show-queue-command "lpq" "\
*Command used by \\[tex-show-print-queue] to show the print queue.
Should show the queue(s) that \\[tex-print] puts jobs on.")
(defvar tex-default-mode 'plain-tex-mode "\
*Mode to enter for a new file that might be either TeX or LaTeX.
This variable is used when it can't be determined whether the file
is plain TeX or LaTeX or what because the file contains no commands.
Normally set to either 'plain-tex-mode or 'latex-mode.")
(defvar tex-open-quote "``" "\
*String inserted by typing \\[tex-insert-quote] to open a quotation.")
(defvar tex-close-quote "''" "\
*String inserted by typing \\[tex-insert-quote] to close a quotation.")
(defvar tex-last-temp-file nil "\
Latest temporary file generated by \\[tex-region] and \\[tex-buffer].
Deleted when the \\[tex-region] or \\[tex-buffer] is next run, or when the
tex-shell goes away.")
(defvar tex-command nil "\
Command to run TeX.
The name of the file, preceded by a blank, will be added to this string.")
(defvar tex-trailer nil "\
String appended after the end of a region sent to TeX by \\[tex-region].")
(defvar tex-start-of-header nil "\
String used by \\[tex-region] to delimit the start of the file's header.")
(defvar tex-end-of-header nil "\
String used by \\[tex-region] to delimit the end of the file's header.")
(defvar tex-shell-cd-command "cd" "\
Command to give to shell running TeX to change directory.
The value of tex-directory will be appended to this, separated by a space.")
(defvar tex-zap-file nil "\
Temporary file name used for text being sent as input to TeX.
Should be a simple file name with no extension or directory specification.")
(defvar tex-last-buffer-texed nil "\
Buffer which was last TeXed.")
(defvar tex-print-file nil "\
File name that \\[tex-print] prints.
Set by \\[tex-region], \\[tex-buffer], and \\[tex-file].")
(defvar tex-mode-syntax-table nil "\
Syntax table used while in TeX mode.")
(fset 'tex-define-common-keys #[(keymap) "À	ÂÃ#ˆÀ	ÄÅ#ˆÀ	ÆÇ#ˆÀ	ÈÉ#ˆÀ	ÊË#‡" [define-key keymap "" tex-kill-job "" tex-recenter-output-buffer "" tex-show-print-queue "" tex-print "" tex-view] 4 "\
Define the keys that we want defined both in TeX mode and in the tex-shell."])
(defvar tex-mode-map nil "\
Keymap for TeX mode.")
(byte-code "¬ÃÁ Â!ˆÃÄÅ#ˆÃÆÇ#ˆÃÈÉ#ˆÃÊË#ˆÃÌÍ#ˆÃÎÏ#ˆÃĞÑ#ˆÃÒÓ#ˆÃÔÕ#ˆÃÖ×#ˆÁ‡" [tex-mode-map make-sparse-keymap tex-define-common-keys define-key "\"" tex-insert-quote "\n" tex-terminate-paragraph "}" up-list "{" tex-insert-braces "" tex-region "" tex-buffer "" tex-file "	" tex-bibtex-file "" tex-latex-block "" tex-close-latex-block] 4)
(defvar tex-shell-map nil "\
Keymap for the tex-shell.  A comint-mode-map with a few additions.")
(fset 'tex-mode #[nil "À‰‰ŠebˆÄÅÀÆ#‰«’`ŠÈyˆÄÉÆ#*‰¬e\n«•	¬’ÊË!«‹ÊÌ!«ƒÍª„ÎªÏ)«„ ªƒ +‡" [nil comment slash mode search-forward "\\" t search-end 0 "%" looking-at "documentstyle" "documentstyle{slides}" slitex-mode latex-mode plain-tex-mode tex-default-mode] 4 "\
Major mode for editing files of input for TeX, LaTeX, or SliTeX.
Tries to determine (by looking at the beginning of the file) whether
this file is for plain TeX, LaTeX, or SliTeX and calls plain-tex-mode,
latex-mode, or slitex-mode, respectively.  If it cannot be determined,
such as if there are no commands in the file, the value of tex-default-mode
is used." nil])
(byte-code "ÀÁMˆÂÃM‡" [TeX-mode tex-mode LaTeX-mode latex-mode] 2)
(fset 'plain-tex-mode #[nil "À ˆÁÃÇÉ\nËÍÎÏĞ#‡" [tex-common-initialization "TeX" mode-name plain-tex-mode major-mode tex-run-command tex-command "%**start of header" tex-start-of-header "%**end of header" tex-end-of-header "\\bye\n" tex-trailer run-hooks text-mode-hook tex-mode-hook plain-tex-mode-hook] 4 "\
Major mode for editing files of input for plain TeX.
Makes $ and } display the characters they match.
Makes \" insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts \" only after a \\.

Use \\[tex-region] to run TeX on the current region, plus a \"header\"
copied from the top of the file (containing macro definitions, etc.),
running TeX under a special subshell.  \\[tex-buffer] does the whole buffer.
\\[tex-file] saves the buffer and then processes the file.
\\[tex-print] prints the .dvi file made by any of these.
\\[tex-view] previews the .dvi file made by any of these.
\\[tex-bibtex-file] runs bibtex on the file of the current buffer.

Use \\[validate-tex-buffer] to check buffer for paragraphs containing
mismatched $'s or braces.

Special commands:
\\{tex-mode-map}

Mode variables:
tex-run-command
	Command string used by \\[tex-region] or \\[tex-buffer].
tex-directory
	Directory in which to create temporary files for TeX jobs
	run by \\[tex-region] or \\[tex-buffer].
tex-dvi-print-command
	Command string used by \\[tex-print] to print a .dvi file.
tex-alt-dvi-print-command
	Alternative command string used by \\[tex-print] (when given a prefix
	argument) to print a .dvi file.
tex-dvi-view-command
	Command string used by \\[tex-view] to preview a .dvi file.
tex-show-queue-command
	Command string used by \\[tex-show-print-queue] to show the print
	queue that \\[tex-print] put your job on.

Entering Plain-tex mode calls the value of text-mode-hook, then the value of
tex-mode-hook, and then the value of plain-tex-mode-hook.  When the special
subshell is initiated, the value of tex-shell-hook is called." nil])
(fset 'plain-TeX-mode 'plain-tex-mode)
(fset 'latex-mode #[nil "À ˆÁÃÇÉ\nËÍÎÏĞ#‡" [tex-common-initialization "LaTeX" mode-name latex-mode major-mode latex-run-command tex-command "\\documentstyle" tex-start-of-header "\\begin{document}" tex-end-of-header "\\end{document}\n" tex-trailer run-hooks text-mode-hook tex-mode-hook latex-mode-hook] 4 "\
Major mode for editing files of input for LaTeX.
Makes $ and } display the characters they match.
Makes \" insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts \" only after a \\.

Use \\[tex-region] to run LaTeX on the current region, plus the preamble
copied from the top of the file (containing \\documentstyle, etc.),
running LaTeX under a special subshell.  \\[tex-buffer] does the whole buffer.
\\[tex-file] saves the buffer and then processes the file.
\\[tex-print] prints the .dvi file made by any of these.
\\[tex-view] previews the .dvi file made by any of these.
\\[tex-bibtex-file] runs bibtex on the file of the current buffer.

Use \\[validate-tex-buffer] to check buffer for paragraphs containing
mismatched $'s or braces.

Special commands:
\\{tex-mode-map}

Mode variables:
latex-run-command
	Command string used by \\[tex-region] or \\[tex-buffer].
tex-directory
	Directory in which to create temporary files for LaTeX jobs
	run by \\[tex-region] or \\[tex-buffer].
tex-dvi-print-command
	Command string used by \\[tex-print] to print a .dvi file.
tex-alt-dvi-print-command
	Alternative command string used by \\[tex-print] (when given a prefix
	argument) to print a .dvi file.
tex-dvi-view-command
	Command string used by \\[tex-view] to preview a .dvi file.
tex-show-queue-command
	Command string used by \\[tex-show-print-queue] to show the print
	queue that \\[tex-print] put your job on.

Entering Latex mode calls the value of text-mode-hook, then the value of
tex-mode-hook, and then the value of latex-mode-hook.  When the special
subshell is initiated, the value of tex-shell-hook is called." nil])
(fset 'slitex-mode #[nil "À ˆÁÃÇÉ\nËÍÎÏĞÑ$‡" [tex-common-initialization "SliTeX" mode-name slitex-mode major-mode slitex-run-command tex-command "\\documentstyle{slides}" tex-start-of-header "\\begin{document}" tex-end-of-header "\\end{document}\n" tex-trailer run-hooks text-mode-hook tex-mode-hook latex-mode-hook slitex-mode-hook] 5 "\
Major mode for editing files of input for SliTeX.
Makes $ and } display the characters they match.
Makes \" insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts \" only after a \\.

Use \\[tex-region] to run SliTeX on the current region, plus the preamble
copied from the top of the file (containing \\documentstyle, etc.),
running SliTeX under a special subshell.  \\[tex-buffer] does the whole buffer.
\\[tex-file] saves the buffer and then processes the file.
\\[tex-print] prints the .dvi file made by any of these.
\\[tex-view] previews the .dvi file made by any of these.
\\[tex-bibtex-file] runs bibtex on the file of the current buffer.

Use \\[validate-tex-buffer] to check buffer for paragraphs containing
mismatched $'s or braces.

Special commands:
\\{tex-mode-map}

Mode variables:
slitex-run-command
	Command string used by \\[tex-region] or \\[tex-buffer].
tex-directory
	Directory in which to create temporary files for SliTeX jobs
	run by \\[tex-region] or \\[tex-buffer].
tex-dvi-print-command
	Command string used by \\[tex-print] to print a .dvi file.
tex-alt-dvi-print-command
	Alternative command string used by \\[tex-print] (when given a prefix
	argument) to print a .dvi file.
tex-dvi-view-command
	Command string used by \\[tex-view] to preview a .dvi file.
tex-show-queue-command
	Command string used by \\[tex-show-print-queue] to show the print
	queue that \\[tex-print] put your job on.

Entering SliTeX mode calls the value of text-mode-hook, then the value of
tex-mode-hook, then the value of latex-mode-hook, and then the value of
slitex-mode-hook.  When the special subshell is initiated, the value of
tex-shell-hook is called." nil])
(byte-code "ÀÁMˆÂÃMˆÄÅM‡" [tex-common-initialization #[nil "À ˆÁ\n!ˆ¬âÆÈ É!ˆÊW«ËÌ\"ˆT‰ªnËÆÍ\"ˆËÎÏ\"ˆËĞÑ\"ˆËÒÑ\"ˆËÓÔ\"ˆËÕÖ\"ˆË×Ø\"ˆËÙÌ\"ˆËÚÌ\"ˆËÛÌ\"ˆËÜİ\"ˆËŞÏ\"ˆËßÍ\"ˆ)ª„É!ˆàá!ˆâ!àã!ˆ!#àä!ˆå$àæ!ˆç&àè!ˆé(àê!ˆë*àì!ˆàí!ˆàî!ˆàï!‡" [kill-all-local-variables use-local-map tex-mode-map text-mode-abbrev-table local-abbrev-table tex-mode-syntax-table 0 char make-syntax-table set-syntax-table 32 modify-syntax-entry "." "w" 9 " " 10 ">" 12 36 "$$" 37 "<" 92 "/" 34 38 95 64 "_" 126 39 make-local-variable paragraph-start "^[ 	]*$\\|^[\\\\%]" paragraph-separate comment-start "%" comment-start-skip "\\(\\(^\\|[^\\]\\)\\(\\\\\\\\\\)*\\)\\(%+ *\\)" comment-indent-hook tex-comment-indent compare-windows-whitespace tex-categorize-whitespace tex-command tex-start-of-header tex-end-of-header tex-trailer] 4] tex-comment-indent #[nil "ÀÁ!«‚i‡ÂÃxˆn«ƒÄª‚iT]‡" [looking-at "%%%" " 	" nil 0 comment-column] 2] tex-categorize-whitespace #[(backward-limit) "ÀÁÄxˆ\n«¼ÆÇ!«È•bˆÀ=«oÉªkÆÊ!«”Ë=«‡ÌÍ‰ª[ËÈ•bˆªRÆÎ!«‡ÌÍ‰ªGÍ‰¬DÄÍwˆË=«ƒÉª*‡" [null t not-finished category " 	\n" backward-limit looking-at "[ 	]+" 0 space "\n" newline par nil "+"] 3]] 2)
(fset 'tex-insert-quote #[(arg) "«†ÁÂ!!‡o¬ŠŠÃuˆÄÅ!)«„ªŠhÇU«ƒÈª‚	c‡" [arg self-insert-command prefix-numeric-value -1 looking-at "\\s(\\|\\s \\|\\s>" tex-open-quote 92 34 tex-close-quote] 3 "\
Insert the appropriate quote marks for TeX.
Inserts the value of tex-open-quote (normally ``) or tex-close-quote
(normally '') depending on the context.  With prefix argument, always
inserts \" characters." "*P"])
(fset 'validate-tex-buffer #[nil "`dbˆÁÂ ?­¡o?­`ÄÅÆÇ#ˆÈ`\"¬ŒÉ`!ˆÊË!ˆÌÍ!ˆ)ªZ*‡" [opoint ((goto-char opoint)) input-pending-p end search-backward "\n\n" nil move tex-validate-region push-mark message "Mismatch found in pararaph starting here" sit-for 4] 4 "\
Check current buffer for paragraphs containing mismatched $'s.
As each such paragraph is found, a mark is pushed at its beginning,
and the location is displayed for a few seconds." nil])
(fset 'tex-validate-region #[(start end) "À	\nZŠÀÅÆˆ)«†bˆÀªÇ*‡" [nil end start max-possible-sexps failure-point (byte-code "Œ	}ˆbˆÂS‰W«†ÄÅ!ˆªr)Â‡" [start end 0 max-possible-sexps forward-sexp 1] 3) ((error (byte-code "`Á‡" [failure-point nil] 1))) t] 3 "\
Check for mismatched braces or $'s in region.
Returns t if no mismatches.  Returns nil and moves point to suspect
area if a mismatch is found." "r"])
(fset 'tex-terminate-paragraph #[(inhibit-validation) "¬”ŠÁŠÂÃÄÅ#ˆ`)`\")¬„ÆÇ!ˆÃc‡" [inhibit-validation tex-validate-region search-backward "\n\n" nil move message "Paragraph being closed appears to contain a mismatch"] 5 "\
Insert two newlines, breaking a paragraph for TeX.
Check for mismatched braces/$'s in paragraph being terminated.
A prefix arg inhibits the checking." "*P"])
(fset 'tex-insert-braces #[nil "ÀcˆŠÁc)‡" [123 125] 1 "\
Make a pair of braces and be poised to type inside of them." "*"])
(fset 'tex-latex-block #[(name) "iÁÂ\"cˆjˆŠÄcˆjˆÅÁÆ\"!ˆm­‚Äc*‡" [col format "\\begin{%s}\n" name 10 insert-string "\\end{%s}"] 4 "\
Creates a matching pair of lines \\begin{NAME} and \\end{NAME} at point.
Puts point on a blank line between them." (byte-code "À ˆÁÂÃÄÅ\"\"\"C‡" [barf-if-buffer-read-only completing-read "LaTeX block name: " mapcar list append standard-latex-block-names latex-block-names] 7)])
(fset 'tex-last-unended-begin #[nil "ÀÁ!­ŠÂÃ!­…Ä ˆªq‡" [re-search-backward "\\(\\\\begin\\s *{\\)\\|\\(\\\\end\\s *{\\)" looking-at "\\\\end{" tex-last-unended-begin] 2 "\
Leave point at the beginning of the last \\begin{...} that is unended."])
(fset 'tex-close-latex-block #[nil "nÀ‰ŠÀÄÅˆiÆÇ!ˆÈ”È•{)	jˆÉ\n±ˆ­‚Êc+‡" [nil indentation text new-line-needed (tex-last-unended-begin) ((error (error "Couldn't find unended \\begin"))) re-search-forward "\\\\begin\\(\\s *{[^}\n]*}\\)" 1 "\\end" 10] 3 "\
Creates an \\end{...} to match the last unclosed \\begin{...}." "*"])
(byte-code "ÀÁMˆÂÃM‡" [tex-start-shell #[nil "ŠÀÁ\n®‹ÃÄ!®†ÃÅ!®ÆÇÈ$qˆÉÁ!\nË\nÌ\"ˆÍ\n!ˆÎ!Ñ!ˆÒ!ˆÓÔ!ˆÕ ÖU­†×Ø!ˆªt*‡" [make-comint "tex-shell" tex-shell-file-name getenv "ESHELL" "SHELL" "/bin/sh" nil "-v" get-process proc set-process-sentinel tex-shell-sentinel process-kill-without-query copy-keymap comint-mode-map tex-shell-map tex-define-common-keys use-local-map run-hooks tex-shell-hook buffer-size 0 sleep-for 1] 5] tex-shell-sentinel #[(proc msg) "ÀÁ\n!!¬ˆÃ\nÄ\"ˆÅ ‡Æ\n!Ç>­‚Å ‡" [buffer-name process-buffer proc set-process-buffer nil tex-delete-last-temp-files process-status (signal exit)] 3]] 2)
(fset 'tex-set-buffer-directory #[(buffer directory) "ÀÁ\n!!Ã\n!¬…ÄÅ\n\"‡Šqˆ\n‰)‡" [file-name-as-directory expand-file-name directory file-directory-p error "%s is not a directory" buffer default-directory] 3 "\
Set BUFFER's default directory to be DIRECTORY."])
(fset 'tex-send-command #[(command &optional file background) "ŠÀ	!ÃÄ\n\"ÆÇÈ!\nÉO\n«†Ë\nPªÌ«‡\nTÍOªÌ«ƒÏªĞR\"+‡" [eval command cmd string-match "\\*" star comint-proc-query get-process "tex-shell" 0 file " " "" nil background "&\n" "\n"] 7 "\
Send COMMAND to tex-shell, substituting optional FILE for *; in background
if optional BACKGROUND is t.   If COMMAND has no *, FILE will be appended,
preceded by a blank, to COMMAND.  If FILE is nil, no substitution will be made
in COMMAND.  COMMAND can be any expression that evaluates to a command string."])
(fset 'tex-delete-last-temp-files #[nil "­Á!ÃÄ!\n\"‰­Æ\n@P!ˆA‰¬sÇ*‡" [tex-last-temp-file file-name-directory dir file-name-all-completions file-name-nondirectory list delete-file nil] 4 "\
Delete any junk files from last temp file."])
(byte-code "ÀÀ‡" [tex-delete-last-temp-files kill-emacs-hook] 1)
(fset 'tex-region #[(beg end) "À «…Á ˆªƒÂ ˆ¬ƒÄ ÅÆ!ÈÉ\n!!‰PÍ ˆŠŒ~ˆebˆÎyˆ`eeebˆÓÕ#«™Öyˆ`ÓØÕ#«ˆÙyˆ`ªƒeÚ^ÜPØ‰%ˆÚ]ÜPÕØ%ˆ,qˆà ˆáâ!ˆ«…á!ˆã\"ˆÚedÜPÕØ%ˆ+$å&\"ˆå'\"ˆ(p‰)+‡" [tex-shell-running tex-kill-job tex-start-shell tex-zap-file tex-generate-zap-file-name get-buffer-create " TeX-Output-Buffer" temp-buffer file-name-as-directory expand-file-name tex-directory zap-directory tex-out-file tex-delete-last-temp-files 100 default-directory hend hbeg search-end search-forward tex-start-of-header t 0 tex-end-of-header nil 1 write-region beg ".tex" end tex-trailer local-tex-trailer erase-buffer insert-string "\n" tex-set-buffer-directory tex-last-temp-file tex-send-command tex-shell-cd-command tex-command tex-print-file tex-last-buffer-texed] 7 "\
Run TeX on the current region, via a temporary file.
The file's name comes from the variable `tex-zap-file' and the
variable `tex-directory' says where to put it.

If the buffer has a header, the header is given to TeX before the
region itself.  The buffer's header is all lines between the strings
defined by `tex-start-of-header' and `tex-end-of-header' inclusive.
The header must start in the first 100 lines of the buffer.

The value of `tex-trailer' is given to TeX as input after the region.

The value of `tex-command' specifies the command to use to run TeX." "r"])
(fset 'tex-buffer #[nil "Àed\"‡" [tex-region] 3 "\
Run TeX on current buffer.  See \\[tex-region] for more information.
Does not save the buffer, so it's useful for trying experimental versions.
See \\[tex-file] for an alternative." nil])
(fset 'tex-file #[nil "À «†ÁÀ !ªƒÂÃ!ÄÀ !Ç ˆÈ «…É ˆªƒÊ ˆË\"ˆË\"ˆ*pÀ ‰‡" [buffer-file-name file-name-nondirectory error "Buffer does not seem to be associated with any file" file-name-directory file-dir tex-out-file save-some-buffers tex-shell-running tex-kill-job tex-start-shell tex-send-command tex-shell-cd-command tex-command tex-last-buffer-texed tex-print-file] 3 "\
Prompt to save all buffers and run TeX (or LaTeX) on current buffer's file.
This function is more useful than \\[tex-buffer] when you need the
`.aux' file of LaTeX to have the correct name." nil])
(fset 'tex-generate-zap-file-name #[nil "ÀÁÂÃÄ!!ÅÆ !#‡" [format "#tz%d%s" process-id get-buffer-process "*tex-shell*" tex-strip-dots system-name] 5 "\
Generate a unique name suitable for use as a file name."])
(byte-code "ÀÁMˆÂÃMˆÄÅM‡" [tex-strip-dots #[(s) "À	!ÂÃ	\"«ˆ	Ä”ÅIˆªr	‡" [copy-sequence s string-match "\\." 0 45] 3] tex-expand-files #[(s) "ÀÁÄÅ\n#«\nÁ”OBÁ•ªj\nÁU¬ˆ\nÀOBÇÈŸÅ#*‡" [nil 0 start elts string-match ":" s mapconcat expand-file-name] 4] tex-shell-running #[nil "ÀÁ!­‡ÂÀÁ!!Ã=‡" [get-process "tex-shell" process-status run] 3]] 2)
(fset 'tex-kill-job #[nil "ÀÁÂ!Ã\"‡" [quit-process get-process "tex-shell" t] 3 "\
Kill the currently running TeX job." nil])
(fset 'tex-recenter-output-buffer #[(linenum) "ÀÁ!p‰¬…ÄÅ!ªŸÆ!ˆÇ!ˆdbˆÈ	«†Ê	!ª„Ë Ì¥!ˆÆ\n!*‡" [get-buffer "*tex-shell*" old-buffer tex-shell message "No TeX output buffer" pop-to-buffer bury-buffer recenter linenum prefix-numeric-value window-height 2] 4 "\
Redisplay buffer of TeX job output so that most recent output can be seen.
The last line of the buffer is displayed on
line LINE of the window, or centered if LINE is nil." "P"])
(fset 'tex-print #[(&optional alt) "À	Â\"Ãpš¬ÇÀÈ Â\"‰\"«‚É!¬…ÊË!ªÌ«„ª‚Ğ#*‡" [tex-append tex-print-file ".dvi" nil test-name print-file-name-dvi tex-last-buffer-texed file-newer-than-file-p buffer-file-name file-exists-p error "No appropriate `.dvi' file could be found" tex-send-command alt tex-alt-dvi-print-command tex-dvi-print-command t] 4 "\
Print the .dvi file made by \\[tex-region], \\[tex-buffer] or \\[tex-file].
Runs the shell command defined by tex-dvi-print-command.  If prefix argument
is provided, use the alternative command, tex-alt-dvi-print-command." "P"])
(fset 'tex-view #[nil "Â )‡" [tex-dvi-view-command tex-dvi-print-command tex-print] 1 "\
Preview the last `.dvi' file made by running TeX under Emacs.
This means, made using \\[tex-region], \\[tex-buffer] or \\[tex-file].
The variable `tex-dvi-view-command' specifies the shell command for preview." nil])
(fset 'tex-append #[(file-name suffix) ";«“Á!Ã!\nÄÅÆ\n\"OQ)‡È‡" [file-name file-name-nondirectory file file-name-directory 0 string-match "\\." suffix " "] 6 "\
Append to FILENAME the suffix SUFFIX, using same algorithm TeX uses.
Scans for the first (not last) period.
No period is retained immediately before SUFFIX,
so normally SUFFIX starts with one."])
(fset 'tex-show-print-queue #[nil "À «…Á ˆªƒÂ ˆÃ!‡" [tex-shell-running tex-kill-job tex-start-shell tex-send-command tex-show-queue-command] 2 "\
Show the print queue that \\[tex-print] put your job on.
Runs the shell command defined by tex-show-queue-command." nil])
(fset 'tex-bibtex-file #[nil "À «…Á ˆªƒÂ ˆÃÄÅ !Æ\"ÇÅ !	Ê\"ˆÊ	\"*‡" [tex-shell-running tex-kill-job tex-start-shell tex-append file-name-nondirectory buffer-file-name "" file-name-directory file-dir tex-out-file tex-send-command tex-shell-cd-command bibtex-command] 3 "\
Run BibTeX on the current buffer's file." nil])
(byte-code "ÀÁ!ˆÂÃ!‡" [run-hooks tex-mode-load-hook provide tex-mode] 2)
