;;; compiled by jwz@thalidomide on Thu Jul  2 16:38:19 1992
;;; from file /u/jwz/emacs19/lisp/packages/mh-e.el
;;; emacs version 19.2.1 Lucid.
;;; bytecomp version 2.07; 17-jun-92.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(byte-code "ÀÂÃ!‡" ["$Header: /cadillac-inferno-5/cvs-master/lemacs/lisp/packages/mh-e.el,v 1.1.1.1 1992/06/29 22:30:47 devin Exp $" mh-e-RCS-id provide mh-e] 2)
(defvar mh-redist-full-contents t "\
Non-nil if the `dist' command needs whole letter for redistribution.
This is the case when `send' is compiled with the BERK option.")
(defvar mh-folder-mode-hook nil "\
Invoked in mh-folder-mode on a new folder.")
(defvar mh-letter-mode-hook nil "\
Invoked in mh-letter-mode on a new letter.")
(defvar mh-compose-letter-function nil "\
Invoked in mh-compose-and-send-mail on a draft letter.
It is passed three arguments: TO recipients, SUBJECT, and CC recipients.")
(defvar mh-before-send-letter-hook nil "\
Invoked at the beginning of the \\[mh-send-letter] command.")
(defvar mh-inc-folder-hook nil "\
Invoked after incorporating mail into a folder with \\[mh-inc-folder].")
(defvar mh-quit-hook nil "\
Invoked after quitting mh-e with \\[mh-quit].")
(defvar mh-clean-message-header nil "\
*Non-nil means clean headers of messages that are displayed or inserted.
The variables mh-visible-headers and mh-invisible-headers control what is
removed.")
(defvar mh-visible-headers nil "\
*If non-nil, contains a regexp specifying the headers to keep when cleaning.
Only used if mh-clean-message-header is non-nil. Setting this variable
overrides mh-invisible-headers.")
(defvar mhl-formfile nil "\
*Name of format file to be used by mhl to show messages.
A value of T means use the default format file.
Nil means don't use mhl to format messages.")
(defvar mh-lpr-command-format "lpr -p -J '%s'" "\
*Format for Unix command that prints a message.
The string should be a Unix command line, with the string '%s' where
the job's name (folder and message number) should appear.  The message text
is piped to this command.")
(defvar mh-print-background nil "\
*Print messages in the background if non-nil.
WARNING: do not delete the messages until printing is finished;
otherwise, your output may be truncated.")
(defvar mh-summary-height 4 "\
*Number of lines in summary window.")
(defvar mh-recenter-summary-p nil "\
*Recenter summary window when the show window is toggled off if non-nil.")
(defvar mh-ins-buf-prefix ">> " "\
*String to put before each non-blank line of a yanked or inserted message.
Used when the message is inserted in an outgoing letter.")
(defvar mh-do-not-confirm nil "\
*Non-nil means do not prompt for confirmation before some commands.
Only affects certain innocuous commands.")
(defvar mh-bury-show-buffer t "\
*Non-nil means that the displayed show buffer for a folder is buried.")
(defvar mh-delete-yanked-msg-window nil "\
*Controls window display when a message is yanked by \\[mh-yank-cur-msg].
If non-nil, yanking the current message into a draft letter deletes any
windows displaying the message.")
(defvar mh-yank-from-start-of-msg t "\
*Controls which part of a message is yanked by \\[mh-yank-cur-msg].
If non-nil, include the entire message.  If the symbol `body, then yank the
message minus the header.  If nil, yank only the portion of the message
following the point.  If the show buffer has a region, this variable is
ignored.")
(defvar mh-reply-default-reply-to nil "\
*Sets the person or persons to whom a reply will be sent.
If nil, prompt for recipient. If non-nil, then \\[mh-reply] will use this
value and it should be one of \"from\", \"to\", or \"cc\".")
(defvar mh-recursive-folders nil "\
*If non-nil, then commands which operate on folders do so recursively.")
(defvar mh-cmd-note 4 "\
Offset to insert notation.")
(defvar mh-note-repl "-" "\
String whose first character is used to notate replied to messages.")
(defvar mh-note-forw "F" "\
String whose first character is used to notate forwarded messages.")
(defvar mh-note-dist "R" "\
String whose first character is used to notate redistributed messages.")
(defvar mh-good-msg-regexp "^....[^D^]" "\
Regexp specifiying the scan lines that are 'good' messages.")
(defvar mh-deleted-msg-regexp "^....D" "\
Regexp matching scan lines of deleted messages.")
(defvar mh-refiled-msg-regexp "^....\\^" "\
Regexp matching scan lines of refiled messages.")
(defvar mh-valid-scan-line "^ *[0-9]" "\
Regexp matching scan lines for messages (not error messages).")
(defvar mh-msg-number-regexp "^ *\\([0-9]+\\)" "\
Regexp to find the number of a message in a scan line.
The message's number must be surrounded with \\( \\)")
(defvar mh-msg-search-regexp "^[^0-9]*%d[^0-9]" "\
Format string containing a regexp matching the scan listing for a message.
The desired message's number will be an argument to format.")
(defvar mh-flagged-scan-msg-regexp "^....\\D\\|^....\\^\\|^....\\+\\|^.....%" "\
Regexp matching flagged scan lines.
Matches lines marked as deleted, refiled, in a sequence, or the cur message.")
(defvar mh-cur-scan-msg-regexp "^....\\+" "\
Regexp matching scan line for the cur message.")
(defvar mh-show-buffer-mode-line-buffer-id "{%%b}  %s/%d" "\
Format string to produce mode-line-buffer-id for show buffers.
First argument is folder name.  Second is message number.")
(defvar mh-invisible-headers "^Received: \\|^Message-Id: \\|^Remailed-\\|^Via: \\|^Mail-from: \\|^Return-Path: \\|^In-Reply-To: \\|^Resent-" "\
Regexp matching lines in a message header that are not to be shown.
If mh-visible-headers is non-nil, it is used instead to specify what to keep.")
(defvar mh-rejected-letter-start "^   ----- Unsent message follows -----$" "\
Regexp specifying the beginning of the wrapper around a returned letter.
This wrapper is generated by the mail system when rejecting a letter.")
(defvar mh-to-field-choices '((116 . "To:") (115 . "Subject:") (99 . "Cc:") (98 . "Bcc:") (102 . "Fcc:")) "\
A-list of (character . field name) strings for mh-to-field.")
(defvar mh-user-path "" "\
User's mail folder.")
(defvar mh-last-destination nil "\
Destination of last refile or write command.")
(defvar mh-folder-mode-map (make-keymap) "\
Keymap for MH folders.")
(defvar mh-letter-mode-map (copy-keymap text-mode-map) "\
Keymap for composing mail.")
(defvar mh-pick-mode-map (make-sparse-keymap) "\
Keymap for searching folder.")
(defvar mh-letter-mode-syntax-table nil "\
Syntax table used while in mh-e letter mode.")
(byte-code "¬Á\n!Ã!ˆÄÅÆ#ˆÁ‡" [mh-letter-mode-syntax-table make-syntax-table text-mode-syntax-table set-syntax-table modify-syntax-entry 37 "."] 4)
(defvar mh-folder-list nil "\
List of folder names for completion.")
(defvar mh-draft-folder nil "\
Name of folder containing draft messages.
NIL means do not use draft folder.")
(defvar mh-unseen-seq nil "\
Name of the unseen sequence.")
(defvar mh-previous-window-config nil "\
Window configuration before mh-e command.")
(defvar mh-previous-seq nil "\
Name of the sequence to which a message was last added.")
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇM‡" [mh-push (macro . #[(v l) "À	Â	EE‡" [setq l cons v] 5]) mh-when (macro . #[(pred &rest body) "À	\nBD‡" [cond pred body] 3]) with-mh-folder-updating (macro . #[(save-modification-flag-p &rest body) "@ÁÂÃÄÅ\"«ƒÇªÈEE‡" [save-modification-flag-p let ((folder-updating-mod-flag (buffer-modified-p))) prog1 append (let ((buffer-read-only nil) (buffer-file-name nil))) body (mh-set-folder-modified-p folder-updating-mod-flag) (mh-set-folder-modified-p nil)] 6]) mh-mapc #[(func list) "­Œ	@!ˆA‰¬uÂ‡" [list func nil] 3]] 2)
(fset 'mh-rmail #[(&optional arg) "À ˆ	«„ÂÃ!‡Ä ‡" [mh-find-path arg call-interactively mh-visit-folder mh-inc-folder] 2 "\
Inc(orporate) new mail (no arg) or scan a MH mail box (arg given).
This front end uses the MH mail system, which uses different conventions
>from the usual mail system." "P"])
(fset 'mh-smail #[nil "À ˆÁÂ!‡" [mh-find-path call-interactively mh-send] 2 "\
Send mail using the MH mail system." nil])
(fset 'mh-smail-other-window #[nil "À ˆÁÂ!‡" [mh-find-path call-interactively mh-send-other-window] 2 "\
Send mail in other window using the MH mail system." nil])
(fset 'mh-burst-digest #[nil "ÀÁ!Ã!ˆÅÁ!ˆÆÇ!ˆÈÉ\nÊ$ˆËÌÍ\"\"ˆÆÏ!)‡" [mh-get-msg-num t digest mh-process-or-undo-commands mh-current-folder mh-set-folder-modified-p message "Bursting digest..." mh-exec-cmd "burst" "-inplace" mh-scan-folder format "%d-last" mh-first-msg-num "Bursting digest...done"] 5 "\
Burst apart the current message, which should be a digest.
The message is replaced by its table of contents and the letters from the
digest are inserted into the folder after that message." nil])
(fset 'mh-copy-msg #[(prefix-provided msg-or-seq dest) "ÀÁ\nÃÄ&ˆ«‡È\nÉ\n#‡Ë\nÉ\n#‡" [mh-exec-cmd "refile" msg-or-seq "-link" "-src" mh-current-folder dest prefix-provided mh-notate-seq 67 mh-cmd-note mh-notate] 7 "\
Copy specified MESSAGE(s) to another FOLDER without deleting them.
Default is the displayed message.  If (optional) prefix argument is
provided, then prompt for the message sequence." (byte-code "‰­„ÁÂÃ\"ÄÅÆÃ#E‡" [current-prefix-arg mh-read-seq-default "Copy" t mh-prompt-for-folder "Copy to" ""] 6)])
(fset 'mh-delete-msg #[(msg-or-seq) "§«†Á!ˆª…ÂÁ\"ˆÃ ‡" [msg-or-seq mh-delete-a-msg mh-map-to-seq-msgs mh-next-msg] 3 "\
Mark the specified MESSAGE(s) for subsequent deletion and move to the next.
Default is the displayed message.  If (optional) prefix argument is
provided, then prompt for the message sequence." (byte-code "«†ÁÂÃ\"ªƒÄÃ!C‡" [current-prefix-arg mh-read-seq-default "Delete" t mh-get-msg-num] 3)])
(fset 'mh-delete-msg-no-motion #[(msg-or-seq) "§«„Á!‡ÂÁ\"‡" [msg-or-seq mh-delete-a-msg mh-map-to-seq-msgs] 3 "\
Mark the specified MESSAGE(s) for subsequent deletion.
Default is the displayed message.  If (optional) prefix argument is
provided, then prompt for the message sequence." (byte-code "«†ÁÂÃ\"ªƒÄÃ!C‡" [current-prefix-arg mh-read-seq-default "Delete" t mh-get-msg-num] 3)])
(fset 'mh-delete-msg-from-seq #[(prefix-provided msg-or-seq &optional from-seq) "«„Á\n!‡Ã\n\"‡" [prefix-provided mh-remove-seq msg-or-seq mh-remove-msg-from-seq from-seq] 3 "\
Delete MESSAGE (default: displayed message) from SEQUENCE.
If (optional) prefix argument provided, then delete all messages from a
sequence." (byte-code "‰‰«†ÂÃÄ\"ªƒÅÄ!	?­„ÂÆÄ\"E)‡" [current-prefix-arg argp mh-read-seq-default "Delete" t mh-get-msg-num "Delete from"] 6)])
(fset 'mh-edit-again #[(msg) "Â «˜	š«“ÅÆ!!ˆÈÉÊ\"!ˆË ªˆÌÍÆ!Î#ĞeÑÎ#ˆebˆÒÎ!ˆÓÔ	Î‰‰‰‰‰&\n+‡" [mh-current-folder from-folder current-window-configuration config mh-draft-folder find-file mh-msg-filename msg rename-buffer format "draft-%d" buffer-name mh-read-draft "clean-up" nil draft mh-clean-msg-header "^Date:\\|^Received:\\|^Message-Id:\\|^From:" set-buffer-modified-p mh-compose-and-send-mail ""] 11 "\
Clean-up a draft or a message previously sent and make it resendable." (byte-code "ÀÁ!C‡" [mh-get-msg-num t] 2)])
(fset 'mh-execute-commands #[nil "«ƒÁ ˆÂ!ˆÄ ˆÅ ˆÆ ˆÇ‡" [mh-narrowed-to-seq mh-widen mh-process-commands mh-current-folder mh-set-scan-mode mh-goto-cur-msg mh-make-folder-mode-line t] 2 "\
Process outstanding delete and refile requests." nil])
(fset 'mh-extract-rejected-mail #[(msg) "Á ÂÃÄ!Æ#	ebˆÊÆÌ#«Íuˆe`|ˆÎeÏÆ#ˆª„ĞÑ!ˆebˆÒÆ!ˆÓÔ	ÕÖ!Õ×!ÕØ!Æ‰&\n+‡" [mh-current-folder current-window-configuration mh-read-draft "extraction" mh-msg-filename msg nil draft config from-folder re-search-forward mh-rejected-letter-start t 1 mh-clean-msg-header "^Date:\\|^Received:\\|^Message-Id:\\|^From:\\|^Sender:" message "Does not appear to be a rejected letter." set-buffer-modified-p mh-compose-and-send-mail "" mh-get-field "To" "From" "cc"] 11 "\
Extract a letter returned by the mail system and make it resendable.
Default is the displayed message." (byte-code "ÀÁ!C‡" [mh-get-msg-num t] 2)])
(fset 'mh-forward #[(prefix-provided msg-or-seq to cc) "Â ÄÅ\"È!«…ÉÊ!«ËÌÍ$ˆÏĞÑ#ÒÓÕ$ˆ×Ø!ˆª†ÏĞØ#ebˆÚÛ!ˆÜyˆ`d}ˆŠİŞ!)àá\"\"Šİã!)$\"«‰å\"SO~ˆŠÒãæç$#\"ˆ)è ˆ)«‹êë!ìÑ#ˆª‡êìÑ#ˆíĞ	.ï&\n.‡" [mh-current-folder folder current-window-configuration config expand-file-name "draft" mh-user-path draft-name file-exists-p y-or-n-p "The file 'draft' exists.  Discard it? " mh-exec-cmd "forw" "-build" msg-or-seq mh-read-draft "" t mh-insert-fields "To:" to "Cc:" cc set-buffer-modified-p nil draft re-search-forward "^------- Forwarded Message" -1 mh-get-field "From:" subject string-match "<" trim "Subject:" forw-subject 0 format "[%s: %s]" delete-other-windows prefix-provided mh-add-msgs-to-seq mh-seq-to-msgs forwarded mh-compose-and-send-mail mh-note-forw "Forwarded:"] 11 "\
Forward MESSAGE(s) (default: displayed message).
If (optional) prefix argument provided, then prompt for the message sequence." (byte-code "‰«†ÁÂÃ\"ªƒÄÃ!ÅÆ!ÅÇ!F‡" [current-prefix-arg mh-read-seq-default "Forward" t mh-get-msg-num read-string "To: " "Cc: "] 5)])
(fset 'mh-goto-msg #[(number &optional no-error-if-no-message dont-show) "ÀÁ!`Â!‰«†U¬¬«W«‡ÇÁÈ#¬›«V«‡ÉÁÈ#¬ŠebˆÇÁÈ#«Êyˆ¬„Ì!ˆÈªbˆ¬…ÎÏ\"ˆÁ+‡" [mh-get-msg-num nil mh-msg-search-pat number msg-pattern starting-place cur-msg re-search-forward t re-search-backward 0 dont-show mh-maybe-show no-error-if-no-message error "No message %d"] 5 "\
Position the cursor at message NUMBER.
Non-nil second argument means do not signal an error if message does not exist.
Non-nil third argument means not to show the message.
Return non-nil if cursor is at message." "NMessage number? "])
(fset 'mh-inc-folder #[(&optional maildrop-name) "À \n¬œÃÄ!¬‰ÅÄ!ˆ	ªpÃÄ!=¬‡ÇÄ!ˆ	)È\n!ˆÉÊ!‡" [current-window-configuration config maildrop-name get-buffer "+inbox" mh-make-folder mh-previous-window-config switch-to-buffer mh-get-new-mail run-hooks mh-inc-folder-hook] 3 "\
Inc(orporate) new mail into +inbox.
Optional prefix argument specifies an alternate maildrop from the default.
If this is given, mail is incorporated into the current folder, rather
than +inbox.  Run mh-inc-folder-hook after incorporating new mail." (byte-code "­†ÁÂÃ\"!C‡" [current-prefix-arg expand-file-name read-file-name "inc mail from file: " mh-user-path] 4)])
(fset 'mh-kill-folder #[nil "¬ˆÁÂÃ\"!«ÆÇ!ˆÈÉ\"ˆÊ!ˆËÌ\"ˆÆÍ!ˆÎ!)‡ËÏ!‡" [mh-do-not-confirm yes-or-no-p format "Remove folder %s? " mh-current-folder folder mh-set-folder-modified-p t mh-exec-cmd-daemon "rmf" mh-remove-folder-from-folder-list message "Folder %s removed" nil kill-buffer "Folder not removed"] 4 "\
Remove the current folder." nil])
(fset 'mh-list-folders #[nil "ÀŠÁÀ!ˆÂ ˆÃÄ!ˆÅÆÇ\"ˆebˆÃÈ!)‘‡" [" *mh-temp*" switch-to-buffer erase-buffer message "Listing folders..." mh-exec-cmd-output "folders" t "Listing folders...done"] 4 "\
List mail folders." nil])
(fset 'mh-msg-is-in-seq #[(msg) "ÀÁ\nÃÄÅÆ\n!!Ç##‡" [message "Message %d is in sequences: %s" msg mapconcat concat mh-list-to-string mh-seq-containing-msg " "] 8 "\
Display the sequences that contain MESSAGE (default: displayed message)." (byte-code "ÀÁ!C‡" [mh-get-msg-num t] 2)])
(fset 'mh-narrow-to-seq #[(seq) "dÁ Ã‰Æ!«œÈ\"ˆd}ˆÉÊ!!ˆËÃ!ˆ‰ª‡ÍÎÊ!\"*Ï\n!ˆ*‡" [eob buffer-modified-p folder-updating-mod-flag nil buffer-file-name buffer-read-only mh-seq-to-msgs seq mh-copy-seq-to-point mh-make-folder-mode-line symbol-name mh-recenter mh-narrowed-to-seq error "No messages in sequence `%s'" mh-set-folder-modified-p] 4 "\
Restrict display of this folder to just messages in a sequence.
Reads which sequence.  Use \\[mh-widen] to undo this command." (byte-code "ÀÁÂ\"C‡" [mh-read-seq "Narrow to" t] 3)])
(fset 'mh-next-undeleted-msg #[(&optional arg) "À	!yˆÂÄÆÇ	$«†ÇyˆÈ ‡ÉyˆÊ!­„Ì!‡" [prefix-numeric-value arg forward mh-next-direction re-search-forward mh-good-msg-regexp nil 0 mh-maybe-show -1 get-buffer mh-show-buffer delete-windows-on] 5 "\
Move to next undeleted message in window." "P"])
(fset 'mh-pack-folder #[(range) "À	!ˆÂ ˆÃÄ!‡" [mh-pack-folder-1 range mh-goto-cur-msg message "Packing folder...done"] 2 "\
Renumber the messages of a folder to be 1..n.
First, offer to execute any outstanding commands for the current folder.
If (optional) prefix argument provided, prompt for the range of messages
to display after packing.  Otherwise, show the entire folder." (byte-code "«…ÁÂ!ªÃC‡" [current-prefix-arg read-msg-range "Range [all]? " "all"] 2)])
(fset 'mh-pipe-msg #[(prefix-provided command) "Šqˆebˆ	¬„ÂÃ!ˆÄ`dÆ$)‡" [mh-show-buffer prefix-provided search-forward "\n\n" shell-command-on-region command nil] 5 "\
Pipe the current message through the given shell COMMAND.
If (optional) prefix argument is provided, send the entire message.
Otherwise just send the message's body." (byte-code "ÁÂ!D‡" [current-prefix-arg read-string "Shell command on message: "] 3)])
(fset 'mh-refile-msg #[(prefix-provided msg-or-seq dest) "À	B«‰ÄÅ	#ˆª†Å	\"ˆÇ ‡" [refile dest mh-last-destination prefix-provided mh-map-to-seq-msgs mh-refile-a-msg msg-or-seq mh-next-msg] 4 "\
Refile MESSAGE(s) (default: displayed message) in FOLDER.
If (optional) prefix argument provided, then prompt for message sequence." (byte-code "‰«†ÁÂÃ\"ªƒÄÃ!ÅÆÇ@É=«‡ÊA!ªËÃ#!E‡" [current-prefix-arg mh-read-seq-default "Refile" t mh-get-msg-num intern mh-prompt-for-folder "Destination" mh-last-destination refile symbol-name ""] 7)])
(fset 'mh-refile-or-write-again #[(msg) "¬„ÁÂ!ˆ@Ã=«ÄA\"ˆÆÇA\"ˆªŒÈA\"ˆÆÉA\"ˆÊ ‡" [mh-last-destination error "No previous refile or write" refile mh-refile-a-msg msg message "Destination folder: %s" mh-write-msg-to-file "Destination: %s" mh-next-msg] 3 "\
Re-execute the last refile or write command on the given MESSAGE.
Default is the displayed message.  Use the same folder or file as the
previous refile or write command." (byte-code "ÀÁ!C‡" [mh-get-msg-num t] 2)])
(fset 'mh-reply #[(prefix-provided msg) "À\n®†ÃÄÅÆÇ$	Ê ÏĞ!ˆÑš¬†Òš«—ÓÔÕÖ×ÙÚ­ƒÜİD&	ˆªÀŞš«—ÓÔÕÖ×ßŞ­ƒÜİD&	ˆª£àš¬†Úš«—ÓÔÕÖ×ßÚÙá­ƒÜİD&ˆâãäã%\"Ç#&ç ˆèÆ!ˆéê!éë!éì!-./ebˆğñ!ˆ¬‡ò\"ˆóôÇ#ˆÏõ!ˆö&Ò/.-7ø&\n.	‡" ["from => Sender only\nto => Sender and primary recipients\ncc or all => Sender and all recipients" minibuffer-help-form mh-reply-default-reply-to completing-read "Reply to whom: " (("from") ("to") ("cc") ("all")) nil t mh-current-folder mh-show-buffer current-window-configuration config show-buffer folder reply-to message "Composing a reply..." "from" "" apply mh-exec-cmd "repl" "-build" "-nodraftfolder" msg "-nocc" "all" prefix-provided "-filter" "mhl.reply" "to" "-cc" "cc" "me" mh-read-draft "reply" expand-file-name mh-user-path draft delete-other-windows set-buffer-modified-p mh-get-field "To:" "Subject:" "Cc:" cc subject to mh-goto-header-end 1 mh-display-msg mh-add-msgs-to-seq answered "Composing a reply...done" mh-compose-and-send-mail mh-note-repl "Replied:"] 13 "\
Reply to a MESSAGE (default: displayed message).
If (optional) prefix argument provided, then include the message in the reply." (byte-code "ÁÂ!D‡" [current-prefix-arg mh-get-msg-num t] 3)])
(fset 'mh-quit #[nil "«„Á!ˆÂÃ!‡" [mh-previous-window-config set-window-configuration run-hooks mh-quit-hook] 2 "\
Restore the previous window configuration, if one exists.
Finish by running mh-quit-hook." nil])
(fset 'mh-page-digest #[nil "ŠÀ ˆÁÂ!ˆÃÅÆÃÇ#«‡ÅÈÃÇ#¬ˆÉÊ!ˆËÌ!ˆ)ÍÆÃÇ#ˆÎyˆÏÂ!ˆÉÊ!)‡" [mh-show-message-in-other-window move-to-window-line 0 nil case-fold-search search-forward "\n\n" t "From:" other-window -1 error "No more messages" search-backward 2 mh-recenter] 4 "\
Advance displayed message to next digested message." nil])
(fset 'mh-page-digest-backwards #[nil "ŠÀ ˆÁÂ!ˆÃÂyˆÅÆÃÇ#«‡ÅÈÃÇ#¬ˆÉÊ!ˆËÌ!ˆ)ÅÆÃÇ#ˆÍyˆÎÂ!ˆÉÊ!)‡" [mh-show-message-in-other-window move-to-window-line 0 nil case-fold-search search-backward "\n\n" t "From:" other-window -1 error "No more messages" 2 mh-recenter] 4 "\
Back up displayed message to previous digested message." nil])
(fset 'mh-page-msg #[(&optional arg) "À	!‡" [scroll-other-window arg] 2 "\
Page the displayed message forwards.
Scrolls ARG lines or a full screen if no argument is supplied." "P"])
(fset 'mh-previous-page #[(&optional arg) "ŠÀ ˆÁÂ!*‡" [mh-show-message-in-other-window ((other-window -1)) scroll-down arg] 2 "\
Page the displayed message backwards.
Scrolls ARG lines or a full screen if no argument is supplied." "P"])
(fset 'mh-previous-undeleted-msg #[(&optional arg) "ÀÂyˆÃÅÂ$«ƒÇ ‡È	!­„Ê	!‡" [backward mh-next-direction 0 re-search-backward mh-good-msg-regexp nil arg mh-maybe-show get-buffer mh-show-buffer delete-windows-on] 5 "\
Move to previous undeleted message in window." "p"])
(fset 'mh-print-msg #[(prefix-provided msg-or-seq) "«†ÁÂ!ˆª„ÁÃ!ˆ«·ÄÅÆÇÉ#ÊË\";«‡ÄÎ\"ªÏĞ!Ä«‡ÄÒ\"ª‡ÄÔ#\"&ª®ÄÕÊË\"Ö!;«‡ÄÎ\"ªÏÄ«‡ÄÒ\"ª‡ÄÔ#\"%«ŠÙÛ#ˆªŒÜİ‰‰Û&ˆ«ŠŞß #ˆªˆáß #ˆâãä#ˆ«…Áå!ªƒÁæ!)‡" [prefix-provided message "Printing sequence..." "Printing message..." format "(scan -clear %s ; %s -nobell -clear %s %s) | %s" mapconcat (lambda (msg) msg) msg-or-seq " " expand-file-name "mhl" mh-lib mhl-formfile "-form %s" "" mh-msg-filenames mh-lpr-command-format "Sequence from %s" mh-current-folder "%s/%d" "%s -nobell -clear %s %s | %s" mh-msg-filename print-command mh-print-background mh-exec-cmd-daemon shell-file-name "-c" call-process nil mh-notate-seq 80 mh-cmd-note mh-notate mh-add-msgs-to-seq printed t "Printing sequence...done" "Printing message...done"] 12 "\
Print MESSAGE(s) (default: displayed message) on a line printer.
If (optional) prefix argument provided, then prompt for the message sequence." (byte-code "‰«ŠÁÂÃÄÅ\"!!ªƒÆÅ!D‡" [current-prefix-arg reverse mh-seq-to-msgs mh-read-seq-default "Print" t mh-get-msg-num] 6)])
(fset 'mh-put-msg-in-seq #[(prefix-provided from to) "Â\"‡" [to mh-previous-seq mh-add-msgs-to-seq from] 3 "\
Add MESSAGE(s) (default: displayed message) to SEQUENCE.
If (optional) prefix argument provided, then prompt for the message sequence." (byte-code "‰«ˆÁÂÃÄ\"!ªƒÅÄ!ÂÆÇ\"E‡" [current-prefix-arg mh-seq-to-msgs mh-read-seq-default "Add messages from" t mh-get-msg-num "Add to" nil] 5)])
(fset 'mh-rescan-folder #[(range) "ÀÂ®Å\"‡" [forward mh-next-direction mh-scan-folder mh-current-folder range "all"] 3 "\
Rescan a folder after optionally processing the outstanding commands.
If (optional) prefix argument is provided, prompt for the range of
messages to display.  Otherwise show the entire folder." (byte-code "­ƒÁÂ!C‡" [current-prefix-arg read-msg-range "Range [all]? "] 2)])
(fset 'mh-redistribute #[(to cc msg) "À‹‡" [((byte-code "ÁÂ­ƒÄ!Æ#ÉÊ!ˆËÍ±ˆÏš¬‡ĞÍ±ˆÑeÒÆ#ˆÓ ˆÔÕ!ˆ«—Ö×ÆÊÆØÙÚÛ Üİ\"Û $&ˆª˜Ö×ÆÊÆØÙßÄ\"Üİ\"Û $&ˆà!âãäÙå#&ˆæ!ˆÔç!*‡" [mh-current-folder mh-read-draft "redistribution" mh-redist-full-contents mh-msg-filename msg nil draft folder mh-goto-header-end 0 "Resent-To: " to "\n" cc "" "Resent-cc: " mh-clean-msg-header "^Message-Id:\\|^Received:\\|^Return-Path:\\|^Sender:\\|^Date:\\|^From:" save-buffer message "Redistributing..." call-process "/bin/sh" "-c" format "mhdist=1 mhaltmsg=%s %s -push %s" buffer-file-name expand-file-name "send" mh-progs "mhdist=1 mhaltmsg=%s mhannotate=1 %s -push %s" mh-annotate-msg mh-note-dist "-component" "Resent:" "-text" "\"%s %s\"" kill-buffer "Redistributing...done"] 12))] 1 "\
Redistribute a letter.
Depending on how your copy of MH was compiled, you may need to change the
setting of the variable mh-redist-full-contents.  See its documentation." (byte-code "ÀÁ!ÀÂ!ÃÄ!E‡" [read-string "Redist-To: " "Redist-Cc: " mh-get-msg-num t] 4)])
(fset 'mh-write-msg-to-file #[(msg file) "À	!Â!ÆBŠÈÉ!qˆÊ ˆË!ˆÌed#+‡" [mh-msg-filename msg mh-expand-file-name file output-file file-name write mh-last-destination get-buffer-create " *mh-temp*" erase-buffer insert-file-contents append-to-file] 4 "\
Append MESSAGE to the end of a FILE." (byte-code "ÀÁ!\n@Ã=«†Ä\nA!ªÇÈÉÊ\"#)D‡" [mh-get-msg-num t mh-last-destination write file-name-directory default-directory default-dir read-file-name "Save message in file: " expand-file-name "mail.out"] 7)])
(fset 'mh-search-folder #[(folder) "ÀÁ!ˆÂ ÃU¬…ÄÅ!¬…Æ ˆª„ÇÈ!ˆ	‰\n‡" [switch-to-buffer-other-window "pick-pattern" buffer-size 0 y-or-n-p "Reuse pattern? " mh-make-pick-template message "" folder mh-searching-folder] 2 "\
Search FOLDER for messages matching a pattern." (byte-code "ÀÁ\nÃ#C‡" [mh-prompt-for-folder "Search" mh-current-folder t] 4)])
(fset 'mh-send #[(to cc subject) "À Â ˆÃ	$)‡" [current-window-configuration config delete-other-windows mh-send-sub to cc subject] 5 "\
Compose and send a letter." "sTo: \nsCc: \nsSubject: "])
(fset 'mh-send-other-window #[(to cc subject) "ÀÂÆ $)‡" [t pop-up-windows mh-send-sub to cc subject current-window-configuration] 5 "\
Compose and send a letter in another window.." "sTo: \nsCc: \nsSubject: "])
(fset 'mh-send-sub #[(to cc subject config) "ÁÂ!ÅÆ!ˆÇÈÉÊË\"!«‡ÊË\"ª“ÉÊË\"!«‡ÊË\"ªƒÎÏ!Â#ÑÒÔÖ&ˆØÂ!ˆdbˆÅÙ!ˆÚÛÂ‰&\n+‡" [mh-current-folder mh-get-msg-num nil msg-num folder message "Composing a message..." mh-read-draft "message" file-exists-p expand-file-name "components" mh-user-path mh-lib error "Can't find components file" draft mh-insert-fields "To:" to "Subject:" subject "Cc:" cc set-buffer-modified-p "Composing a message...done" mh-compose-and-send-mail "" config] 11 "\
Do the real work of composing and sending a letter.
Expects the TO, CC, and SUBJECT fields as arguments.
CONFIG is the window configuration before sending mail."])
(fset 'mh-show #[(&optional msg) "¬„ÁÂ!ÂÄÅ!ˆÆÇ !È =¬ƒÉ ˆ\nÌ ˆÍ\"ˆ)ÎÏ!ˆĞÑ Z!ˆÓÔ!ˆ>?­‡B‰‡" [msg mh-get-msg-num t mh-showing mh-set-mode-name "mh-e show" next-window minibuffer-window selected-window delete-other-windows mh-current-folder folder mh-show-message-in-other-window mh-display-msg other-window -1 shrink-window window-height mh-summary-height mh-recenter nil mh-seen-list] 3 "\
Show MESSAGE (default: displayed message).
Forces a two-window display with the folder window on top (size
mh-summary-height) and the show buffer below it." nil])
(fset 'mh-sort-folder #[nil "À	!ˆÂÄÅ!ˆÆÇ!ˆÈÉ	\"ˆÆÊ!ˆË	Ì\"‡" [mh-process-or-undo-commands mh-current-folder forward mh-next-direction mh-set-folder-modified-p t message "Sorting folder..." mh-exec-cmd "sortm" "Sorting folder...done" mh-scan-folder "all"] 3 "\
Sort the messages in the current folder by date." ""])
(fset 'mh-toggle-showing #[nil "«ƒÁ ‡Â ‡" [mh-showing mh-set-scan-mode mh-show] 1 "\
Toggle the scanning mode/showing mode of displaying messages." nil])
(fset 'mh-undo #[(prefix-provided msg-or-seq) "ÀyˆÁ\n!«®«’ÄÅÆ!\"ˆÈÉ\n#ˆªÈË\"ÍÎÏ#ˆĞÉ\n#ˆª¯Á!«©«’ÄÒÆ!\"ˆÈÉ\n#ˆªÄÓ\"ˆĞÉ\n#ˆÄÕ\"ˆÖ ?­ƒ×Ø!‡" [0 looking-at mh-deleted-msg-regexp prefix-provided mh-mapc #[(msg) "À	\n\"Ã	ÄÅ#‡" [delq msg mh-delete-list mh-remove-msg-from-seq deleted t] 4] mh-seq-to-msgs msg-or-seq mh-notate-seq 32 mh-cmd-note delq mh-delete-list mh-remove-msg-from-seq deleted t mh-notate mh-refiled-msg-regexp #[(msg) "ÀÁ\n\"‡" [mh-mapc #[(dest) "À	\nÃ#‡" [mh-remove-msg-from-seq msg dest t] 4] mh-refile-list] 3] #[(dest) "À	\nÃ#‡" [mh-remove-msg-from-seq msg-or-seq dest t] 4] mh-refile-list #[(elt) "À	!?­†Â	\"‰‡" [mh-seq-to-msgs elt delq mh-refile-list] 3] mh-outstanding-commands-p mh-set-folder-modified-p nil] 4 "\
Undo the deletion or refile of the specified MESSAGE(s).
Default is the displayed message.  If (optional) prefix argument is
provided, then prompt for the message sequence." (byte-code "‰«†ÁÂÃ\"ªƒÄÃ!D‡" [current-prefix-arg mh-read-seq-default "Undo" t mh-get-msg-num] 4)])
(fset 'mh-undo-folder #[(&rest ignore) "¬…ÁÂ!«ÃÃÃÇÉ \nÃ‰ÍÎ!*ÏÃ!ˆ)‡ĞÑ!ˆÒÓ!‡" [mh-do-not-confirm yes-or-no-p "Undo all commands in folder? " nil mh-delete-list mh-refile-list mh-seq-list forward mh-next-direction buffer-modified-p folder-updating-mod-flag buffer-file-name buffer-read-only mh-unmark-all-headers t mh-set-folder-modified-p message "Commands not undone." sit-for 2] 3 "\
Undo all commands in current folder." ""])
(fset 'mh-visit-folder #[(folder &optional range) "À Â®Å\"ˆ	‰)‡" [current-window-configuration config mh-scan-folder folder range "all" mh-previous-window-config] 3 "\
Visit FOLDER and display RANGE of messages." (byte-code "ÀÁÂÃ#ÄÅ!D‡" [mh-prompt-for-folder "Visit" "+inbox" t read-msg-range "Range [all]? "] 4)])
(fset 'mh-widen #[nil "À Â‰ed|ˆ~ˆÅ ˆ*Æ	!ˆ)Â‰‡" [buffer-modified-p folder-updating-mod-flag nil buffer-file-name buffer-read-only mh-make-folder-mode-line mh-set-folder-modified-p mh-narrowed-to-seq] 2 "\
Remove restrictions from the current folder, thereby showing all messages." ""])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑMˆÒÓMˆÔÕMˆÖ×MˆØÙM‡" [mh-delete-a-msg #[(msg) "ŠÀ	ÂÃ#ˆÄ!«…ÆÇ	\"ˆÄ!?­–ÉÃ!ˆ	\nB\nË	ÌÃ#ˆÍ	Î#)‡" [mh-goto-msg msg nil t looking-at mh-refiled-msg-regexp error "Message %d is refiled.  Undo refile before deleting." mh-deleted-msg-regexp mh-set-folder-modified-p mh-delete-list mh-add-msgs-to-seq deleted mh-notate 68 mh-cmd-note] 4] mh-refile-a-msg #[(msg destination) "ŠÀ	ÂÃ#ˆÄ!«‡ÆÇ	\"ˆª›Ä!«•ÉÊ	\"ˆËÌÍÃ!ÎÏÑ!&ˆÓÃ!ˆ>¬‡B	Õ!>¬‡Ö	Ã#ˆ×	Ø#)‡" [mh-goto-msg msg nil t looking-at mh-deleted-msg-regexp error "Message %d is deleted.  Undo delete before moving." mh-refiled-msg-regexp message "Message %d is already refiled.  Copying..." mh-exec-cmd "refile" mh-get-msg-num "-link" "-src" mh-current-folder symbol-name destination mh-set-folder-modified-p mh-refile-list mh-seq-to-msgs mh-add-msgs-to-seq mh-notate 94 mh-cmd-note] 8] mh-display-msg #[(msg-num folder) "qˆ	\nÅ!	\nÏ\n!¬†ĞÑ\"ˆÒ	!ˆ«„Ôp!ˆ\nš?­îÖ ˆ× ˆØÙ ˆ«;«ÚÛÜİŞ\n&ˆªÚÛÜİ\n$ˆª…ß\n!ˆebˆ«àe#ˆebˆª‘á\"ãäØá#ˆåyˆæå!ˆ)çØ!ˆ\nèØ!ˆé*#C‰+.‡" [folder mhl-formfile mh-clean-message-header mh-invisible-headers mh-visible-headers mh-msg-filename msg-num mh-show-buffer mh-current-folder show-buffer msg-filename visible-headers invisible-headers clean-message-header formfile file-exists-p error "Message %d does not exist" switch-to-buffer mh-bury-show-buffer bury-buffer buffer-file-name clear-visited-file-modtime unlock-buffer nil erase-buffer mh-exec-lib-cmd-output "mhl" "-nobell" "-noclear" "-form" insert-file-contents mh-clean-msg-header t case-fold-search re-search-forward "^To:\\|^From:\\|^Subject:\\|^Date:" 0 mh-recenter set-buffer-modified-p set-mark format mh-show-buffer-mode-line-buffer-id mode-line-buffer-identification] 7] mh-invalidate-show-buffer #[nil "À	!­ˆŠ	qˆÂ‰)‡" [get-buffer mh-show-buffer nil buffer-file-name] 2] mh-show-message-in-other-window #[nil "Â	!ˆ­ƒÄp!)‡" [mh-show-buffer buffer switch-to-buffer-other-window mh-bury-show-buffer bury-buffer] 2] mh-clean-msg-header #[(start invisible-headers visible-headers) "ÀŒ\nbˆÃÄÅÀ#«„ÆÇ!ˆ\n`}ˆebˆ«­`dW«ÅÉyˆÊ!«ËyˆÊÌ!«jËyˆªvÍË!ˆÊÌ!«\\ÉyˆÍË!ˆªrÎÅÀ#«•ÉyˆÍË!ˆÊÌ!«lÉyˆÍË!ˆªrĞ *‡" [t case-fold-search start search-forward "\n\n" nil backward-char 2 visible-headers 0 looking-at 1 "^[ 	]+" mh-delete-line re-search-forward invisible-headers unlock-buffer] 4] mh-delete-line #[(lines) "`Šyˆ`)|‡" [lines] 2] mh-read-draft #[(use initial-contents delete-contents-file) "«—	ÃÄÅ Æ\"!ˆÇÈÉÊ \"!ˆ\n)ªÀËÌ\"ÃÌ!ˆÏ «ĞÑ!«†ÒÓ!ˆª„ÔÕ!ˆ× ˆØ ˆÙ!«‘š¬ŠÛ!ˆÜ!ˆ)« İ ŞU¬‰ĞÈß \"!¬‘á ˆÛ!ˆ\"«…Ü!ˆãä!ˆ«ƒå ˆÊ ‡" [mh-draft-folder default-directory orig-default-dir pop-to-buffer find-file-noselect mh-new-draft-name t rename-buffer format "draft-%s" buffer-name expand-file-name "draft" mh-user-path draft-name buffer-modified-p y-or-n-p "Draft has been modified; kill anyway? " set-buffer-modified-p nil error "Draft preserved" buffer-file-name clear-visited-file-modtime unlock-buffer file-exists-p initial-contents insert-file-contents delete-file buffer-size 0 "A draft exists.  Use for %s? " use erase-buffer delete-contents-file auto-save-mode 1 save-buffer] 4] mh-new-draft-name #[nil "ŠÀÁ!qˆÂ ˆÃÄÅÇ$ˆ`È S{)‡" [get-buffer-create " *mh-temp*" erase-buffer mh-exec-cmd-output "mhpath" nil mh-draft-folder "new" mark] 5] mh-next-msg #[nil "Á=«„ÂÃ!‡ÄÃ!‡" [mh-next-direction forward mh-next-undeleted-msg 1 mh-previous-undeleted-msg] 2] mh-set-scan-mode #[nil "À	!«„Â	!ˆÃÄ!ˆÅ­ƒÈÅ!‡" [get-buffer mh-show-buffer delete-windows-on mh-set-mode-name "mh-e scan" nil mh-showing mh-recenter-summary-p mh-recenter] 2] mh-maybe-show #[(&optional msg) "­ƒÁ\n!‡" [mh-showing mh-show msg] 2] mh-set-mode-name #[(mode-name-string) "ŠÂ qˆ)ÃÄ !‡" [mode-name-string mode-name other-buffer set-buffer-modified-p buffer-modified-p] 2]] 2)
(defvar mh-current-folder nil "\
Name of current folder, a string.")
(defvar mh-show-buffer nil "\
Buffer that displays mesage for this folder.")
(defvar mh-folder-filename nil "\
Full path of directory for this folder.")
(defvar mh-showing nil "\
If non-nil, show the message in a separate window.")
(defvar mh-next-seq-num nil "\
Index of free sequence id.")
(defvar mh-delete-list nil "\
List of msg numbers to delete.")
(defvar mh-refile-list nil "\
List of folder names in mh-seq-list.")
(defvar mh-seq-list nil "\
Alist of (seq . msgs) numbers.")
(defvar mh-seen-list nil "\
List of displayed messages.")
(defvar mh-next-direction 'forward "\
Direction to move to next message.")
(defvar mh-narrowed-to-seq nil "\
Sequence display is narrowed to.")
(defvar mh-first-msg-num nil "\
Number of first msg in buffer.")
(defvar mh-last-msg-num nil "\
Number of last msg in buffer.")
(byte-code "ÀÁMˆÂÃÄÅ#‡" [mh-make-folder #[(name) "À	!ˆÂÄ ˆÅÆ ˆÇÂ!ˆ	ÊË!‡" [switch-to-buffer name nil buffer-read-only erase-buffer t mh-folder-mode mh-set-folder-modified-p mh-folder-filename buffer-file-name mh-set-mode-name "mh-e scan"] 2] put mh-folder-mode mode-class special] 4)
(fset 'mh-folder-mode #[nil "À ˆÁ\n!ˆÃÅÆ!ˆÇÈÉ ÊËÌÉ \"ÍÎÏÉ !!ĞÑÒÓÔÑÕÑÖÑ×ÑØÙÚÑÛÑÜÑİÑ&ˆŞß!ˆà!âã!ˆä#âå!ˆæ%çè!‡" [kill-all-local-variables use-local-map mh-folder-mode-map mh-folder-mode major-mode mh-set-mode-name "mh-e folder" make-local-vars mh-current-folder buffer-name mh-show-buffer format "show-%s" mh-folder-filename file-name-as-directory mh-expand-file-name mh-showing nil mh-next-seq-num 0 mh-delete-list mh-refile-list mh-seq-list mh-seen-list mh-next-direction forward mh-narrowed-to-seq mh-first-msg-num mh-last-msg-num mh-previous-window-config auto-save-mode -1 t buffer-offer-save make-local-variable write-file-hooks (mh-execute-commands) revert-buffer-function mh-undo-folder run-hooks mh-folder-mode-hook] 29 "\
Major mode for \"editing\" an MH folder scan listing.
Messages can be marked for refiling and deletion.  However, both actions
are deferred until you request execution with \\[mh-execute-commands].
\\{mh-folder-mode-map}
  A prefix argument (\\[universal-argument]) to delete, refile, list, or undo
applies the action to a message sequence.

Variables controlling mh-e operation are (defaults in parentheses):

 mh-bury-show-buffer (t)
    Non-nil means that the buffer used to display message is buried.
    It will never be offered as the default other buffer.

 mh-clean-message-header (nil)
    Non-nil means remove header lines matching the regular expression
    specified in mh-invisible-headers from messages.

 mh-visible-headers (nil)
    If non-nil, it contains a regexp specifying the headers that are shown in
    a message if mh-clean-message-header is non-nil.  Setting this variable
    overrides mh-invisible-headers.

 mh-do-not-confirm (nil)
    Non-nil means do not prompt for confirmation before executing some
    non-recoverable commands such as mh-kill-folder and mh-undo-folder.

 mhl-formfile (nil)
    Name of format file to be used by mhl to show messages.
    A value of T means use the default format file.
    Nil means don't use mhl to format messages.

 mh-lpr-command-format (\"lpr -p -J '%s'\")
    Format for command used to print a message on a system printer.

 mh-recenter-summary-p (nil)
    If non-nil, then the scan listing is recentered when the window displaying
    a messages is toggled off.

 mh-summary-height (4)
    Number of lines in the summary window.

 mh-ins-buf-prefix (\">> \")
    String to insert before each non-blank line of a message as it is
    inserted in a draft letter.

The value of mh-folder-mode-hook is called when a new folder is set up."])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑMˆÒÓMˆÔÕM‡" [make-local-vars #[(&rest pairs) "­”Á@!ˆ@A@LˆAA‰¬mÂ‡" [pairs make-variable-buffer-local nil] 3] mh-scan-folder #[(folder range) "À	!¬†Â	!ˆªˆÃ	!ˆÄ	!ˆÅ!ˆÇed\"ÈU«˜Éš«‡ÊË	\"ˆª‡ÊÌ	#ˆÍÎ!ˆÏ ‡" [get-buffer folder mh-make-folder mh-process-or-undo-commands switch-to-buffer mh-regenerate-headers range count-lines 0 "all" message "Folder %s is empty" "No messages in %s, range %s" sit-for 5 mh-goto-cur-msg] 4] mh-regenerate-headers #[(range) "ÂÃ	\"ˆÄ Æ‰É ˆÊËÆÌÍÎÏ 	&ˆebˆÑÒ!«‡Ó!ˆªŠÑÕ!¬…Ó!ˆÖ×!ˆØ	Æ\"Ú ˆÛÜš?­İ!ˆ*ŞÆ!ˆ)Âß	\")‡" [mh-current-folder folder message "Scanning %s..." buffer-modified-p folder-updating-mod-flag nil buffer-file-name buffer-read-only erase-buffer mh-exec-cmd-output "scan" "-noclear" "-noheader" "-width" window-width range looking-at "scan: no messages in" keep-lines mh-valid-scan-line "scan: " mh-delete-seq-locally cur mh-read-folder-sequences mh-seq-list mh-notate-user-sequences mh-make-folder-mode-line "all" "select" mh-set-folder-modified-p "Scanning %s...done"] 9] mh-get-new-mail #[(maildrop-name) "`ÁÅ Ç‰	Ê«ˆÌÍ#ª„ÌÎ\"!ˆÏÇ!ˆĞdbˆ`«’ÓÔÇÕÖ!×Ø Ù&ˆªˆÓÔÇ×Ø $ˆÊ«ˆÌÚ#ª„ÌÛ\"!ˆbˆÜİ!«ŸŞ!ˆbˆÊà«ƒáªâ«„ªâ#ˆª§ãäÇÁ#«†åæ!ˆªšçè!ˆéÁ\"*ë ˆŞ!ˆì ˆí ˆÁ)\n*î!ˆ,‡" [mh-current-folder t return-value folder point-before-inc buffer-modified-p folder-updating-mod-flag nil buffer-file-name buffer-read-only message maildrop-name format "inc %s -file %s..." "inc %s..." mh-unmark-all-headers forward mh-next-direction start-of-inc mh-exec-cmd-output "inc" "-file" expand-file-name "-width" window-width "-truncate" "inc %s -file %s...done" "inc %s...done" looking-at "inc: no mail" keep-lines mh-valid-scan-line "No new mail%s%s" " in " "" re-search-forward "^inc:" error "inc error" mh-delete-seq-locally cur mh-read-folder-sequences mh-seq-list mh-notate-user-sequences mh-make-folder-mode-line mh-goto-cur-msg mh-set-folder-modified-p] 9] mh-make-folder-mode-line #[(&optional annotation) "ŠebˆÀÁ!dbˆÃT‰ÅW«ÀÁ!‰¬…Çyˆªk)Èed\"	ÊË«‡ÊÍ\"ªÎ	‰ÃU«ƒÏª’	ĞV«ˆÊÑ\n#ª„ÊÒ\n\"$C‰*‡" [mh-get-msg-num nil mh-first-msg-num 0 lines-checked 5 mh-last-msg-num -1 count-lines lines format "{%%b%s}  %d msg%s" annotation "/%s" "" "s" 1 "s (%d-%d)" " (%d)" mode-line-buffer-identification] 8] mh-unmark-all-headers #[(remove-all-flags) "ŠÀd	ZÀebˆ`X­¨	uˆg«\nÆ=¬\nÇ=¬Š\nÈ=¬…\nÉ=«‡ÊË!ˆÌcˆÀyˆªS,‡" [nil mh-cmd-note char last-line case-fold-search remove-all-flags 68 94 37 43 delete-char 1 " "] 3] mh-goto-cur-msg #[nil "ÀÁ!@‰«—Ã\nÄÅ#«ÆÅÇ#ˆÉÊ!ˆË\n!ª‰dbˆÌyˆÍÎ!)‡" [mh-seq-to-msgs cur cur-msg mh-goto-msg t nil mh-notate 43 mh-cmd-note mh-recenter 0 mh-maybe-show -1 message "No current message"] 5] mh-pack-folder-1 #[(range) "À	!ˆÂÃ!ˆÄÅ!ˆŠÆÇÈ	É$ˆ)Ê!‡" [mh-process-or-undo-commands mh-current-folder message "Packing folder..." mh-set-folder-modified-p t mh-exec-cmd-quiet " *mh-temp*" "folder" "-pack" mh-regenerate-headers range] 5] mh-process-or-undo-commands #[(folder) "qˆÁ «\n¬…ÃÄ!«„Å!‡Æ ‡Ç ‡" [folder mh-outstanding-commands-p mh-do-not-confirm y-or-n-p "Process outstanding deletes and refiles (or lose them)? " mh-process-commands mh-undo-folder mh-invalidate-show-buffer] 2] mh-process-commands #[(folder) "ÀÁ\n\"ˆ\nqˆÃ Å‰«É\n!«‡Ë\n\"ˆÌÍ\"ˆ«ĞÑÒ\n$ˆÓ!ˆÔ ÕV«‹Ö×ØÅ!®ÙC\"ˆÚ ˆÅÅÛÅ\"ÅŞß!ˆà ˆÀá\n\"*âÅ!ˆ)‡" [message "Processing deletes and refiles for %s..." folder buffer-modified-p folder-updating-mod-flag nil buffer-file-name buffer-read-only mh-seen-list mh-seq-to-msgs mh-unseen-seq mh-undefine-sequence mh-mapc #[(dest) "À	!‰­ÃÄÅÆÈ	!\n&ˆÉ\n!)‡" [mh-seq-to-msgs dest msgs apply mh-exec-cmd "refile" "-src" folder symbol-name mh-delete-scan-msgs] 8] mh-refile-list mh-delete-list apply mh-exec-cmd "rmm" mh-delete-scan-msgs buffer-size 0 mh-define-sequence cur mh-get-msg-num "last" mh-invalidate-show-buffer mh-read-folder-sequences mh-current-folder mh-seq-list mh-unmark-all-headers t mh-notate-user-sequences "Processing deletes and refiles for %s...done" mh-set-folder-modified-p] 5] mh-delete-scan-msgs #[(msgs) "À	Â\"Šebˆ	­¡`dW­œÃÄ!	@U«`ŠÄyˆ`)|ˆ	A‰ªbÄyˆª\\)‡" [sort msgs < mh-get-msg-num nil] 4]] 2)
(fset 'mh-set-folder-modified-p #[(flag) "À	!‡" [set-buffer-modified-p flag] 2 "\
Mark current folder as modified or unmodified according to FLAG."])
(fset 'mh-outstanding-commands-p #[nil "®	‡" [mh-delete-list mh-refile-list] 1])
(defvar mh-sent-from-folder nil "\
Folder of msg associated with this letter.")
(defvar mh-sent-from-msg nil "\
Number of msg associated with this letter.")
(defvar mh-send-args nil "\
Extra arguments to pass to \"send\" command.")
(defvar mh-annotate-char nil "\
Character to use to annotate mh-sent-from-msg.")
(defvar mh-annotate-field nil "\
Field name for message annotation.")
(fset 'mh-letter-mode #[nil "À ˆÁÂ!ˆÃ\nPÁÄ!ˆÃPÁÅ!ˆÁÆ!ˆÁÇ!ˆÁÈ!ˆÁÉ!ˆÁÊ!ˆË!ˆÍÏĞ!ˆÑ!ˆÓÔÕ\"‡" [kill-all-local-variables make-local-variable paragraph-start "^[ 	]*[-_][-_][-_]+$\\|" paragraph-separate mh-send-args mh-annotate-char mh-annotate-field mh-previous-window-config mh-sent-from-folder mh-sent-from-msg use-local-map mh-letter-mode-map mh-letter-mode major-mode mh-set-mode-name "mh-e letter" set-syntax-table mh-letter-mode-syntax-table run-hooks text-mode-hook mh-letter-mode-hook] 3 "\
Mode for composing letters in mh-e.
When you have finished composing, type \\[mh-send-letter] to send the letter.

Variables controlling this mode (defaults in parentheses):

 mh-delete-yanked-msg-window (nil)
    If non-nil, \\[mh-yank-cur-msg] will delete any windows displaying
    the yanked message.

 mh-yank-from-start-of-msg (t)
    If non-nil, \\[mh-yank-cur-msg] will include the entire message.
    If `body', just yank the body (no header).
    If nil, only the portion of the message following the point will be yanked.
    If there is a region, this variable is ignored.

Upon invoking mh-letter-mode, text-mode-hook and mh-letter-mode-hook are
invoked with no args, if those values are non-nil.

\\{mh-letter-mode-map}" nil])
(fset 'mh-to-field #[nil "À ˆÁÂÄ\"\"AÆÉÆ\"«ŠÊË!?­¢ÌcªebˆÍÎ!ˆÏyˆÊĞ!«…ÏyˆªvÑÒ\"cˆÓÏ!*‡" [expand-abbrev assoc logior last-input-char 96 mh-to-field-choices t case-fold-search target mh-position-on-field looking-at "[ 	]" " " re-search-forward "^To:" 1 "^[ 	]" format "%s \n" backward-char] 4 "\
Move point to the end of a specified header field.
The field is indicated by the previous keystroke.  Create the field if
it does not exist.  Set the mark to point before moving." ""])
(fset 'mh-to-fcc #[nil "À ˆŠÁÂÃÄÅÆ#ÇÈO\")‡" [expand-abbrev mh-insert-fields "Fcc:" mh-prompt-for-folder "Fcc" "" t 1 nil] 6 "\
Insert a Fcc: field in the current message.
Prompt for the field name with a completion list of the current folders." nil])
(fset 'mh-insert-signature #[nil "ÀÁ!ˆÂÃ !‡" [insert-file-contents "~/.signature" set-buffer-modified-p buffer-modified-p] 2 "\
Insert the file ~/.signature at the current point." ""])
(fset 'mh-check-whom #[nil "À ÂÃ!ˆÄ ˆÅÆ!ˆÇÈ!ˆÉp!ˆÊ ˆËÌÃ	#ˆÍÎ!ˆÅÏ!)‡" [buffer-file-name file-name set-buffer-modified-p t save-buffer message "Checking recipients..." switch-to-buffer-other-window "*Mail Recipients*" bury-buffer erase-buffer mh-exec-cmd-output "whom" other-window -1 "Checking recipients...done"] 4 "\
Verify recipients of the current letter." nil])
(defvar mh-searching-folder nil "\
Folder this pick is searching.")
(fset 'mh-make-pick-template #[nil "À ˆÁ ˆÂÃ!ˆÄÅÆÇÈÉ±ˆÊ ˆË!ˆebˆÍ‡" [erase-buffer kill-all-local-variables make-local-variable mh-searching-folder "From: \n" "To: \n" "Cc: \n" "Date: \n" "Subject: \n" "---------\n" mh-letter-mode use-local-map mh-pick-mode-map nil] 6])
(fset 'mh-do-pick-search #[nil "À 	Â‰‰ŠÈ!«qˆÉÊ#ª‰Í!ˆÎÏ)ĞÑ!ˆebˆÒ!‰«—ÓÔÕBÖ×Ø¯¤#×ªaĞÚ!ˆ«‰Û\"ˆª…Ü!ˆİ ˆŞÔß T#-‡" [buffer-name mh-searching-folder nil new-buffer pattern range searching-buffer pattern-buffer get-buffer format "%d-%d" mh-first-msg-num mh-last-msg-num mh-make-folder "all" t message "Searching..." mh-next-pick-field mh-seq-from-command search "pick" "-sequence" "search" "-list" msgs "Searching...done" mh-scan-folder switch-to-buffer delete-other-windows mh-notate-seq 37 mh-cmd-note] 9 "\
Find messages that match the qualifications in the current pattern buffer.
Messages are searched for in the folder named in mh-searching-folder.
Put messages found in a sequence named `search'." nil])
(byte-code "ÀÁMˆÂÃM‡" [mh-next-pick-field #[(buffer) "qˆÁm«ƒÃªÈÄÅÃÁ#«ÆÇÈ”È•{—\"	Ê”Ê•{Èyˆ	*Dª¤ÄÌÃÁ#«œÈuˆ`d{‰GÎV­‹Ïš?­„ĞD)ªÃ)‡" [buffer t case-fold-search nil re-search-forward "^\\([a-z].*\\):[ 	]*\\([a-z0-9].*\\)$" format "--%s" 1 component 2 pat "^-*$" body 0 "\n" "-search"] 5] mh-compose-and-send-mail #[(draft send-args sent-from-folder sent-from-msg to subject cc annotate-char annotate-field config) "À	!ˆÂ ˆ	\nÏCÑÒ!­´ÒJ­°ÒJ‰<«@Ô=¬—­œ@#ˆA‰ªk#)‡" [pop-to-buffer draft mh-letter-mode sent-from-folder mh-sent-from-folder sent-from-msg mh-sent-from-msg send-args mh-send-args annotate-char mh-annotate-char annotate-field mh-annotate-field config mh-previous-window-config "{%b}" mode-line-buffer-identification boundp mh-compose-letter-function value lambda to subject cc] 5]] 2)
(fset 'mh-send-letter #[(&optional arg) "ÀÁ!ˆÂÃ!ˆÄ ˆÅÆ!ˆpÇ 	\n««ÍÎ!ˆÏ ˆ«ÑÒÃÓÔÕ\n&ˆª‹ÑÒÃÓÔÕ\n&ˆqˆª˜«ŒÖÒÕ×\n%ˆªˆÖÒÕ×\n$ˆ«—ÙÜŞßàáâ!áã!#&ˆ«…äå!«æ!ˆ	«…ç	!ˆÅè!+‡" [run-hooks mh-before-send-letter-hook set-buffer-modified-p t save-buffer message "Sending..." buffer-file-name mh-previous-window-config config file-name draft-buffer arg pop-to-buffer "MH mail delivery" erase-buffer mh-send-args mh-exec-cmd-output "send" "-watch" "-nopush" "-nodraftfolder" mh-exec-cmd-daemon "-noverbose" mh-annotate-char mh-annotate-msg mh-sent-from-msg mh-sent-from-folder "-component" mh-annotate-field "-text" format "\"%s %s\"" mh-get-field "To:" "Cc:" y-or-n-p "Kill draft buffer? " kill-buffer set-window-configuration "Sending...done"] 12 "\
Send the draft letter in the current buffer.
If (optional) prefix argument is provided, monitor delivery.
Run mh-before-send-letter-hook before doing anything." "P"])
(fset 'mh-insert-letter #[(prefix-provided folder msg) "Œ``}ˆe	Âš«„Ã!ÅÆÇÈÉ	Ê!\"$ˆ?­Í#ˆĞ!ˆÑ!*‡" [start msg "" int-to-string mh-sent-from-msg mh-exec-lib-cmd-output "mhl" "-nobell" "-noclear" expand-file-name mh-expand-file-name folder prefix-provided mh-clean-msg-header mh-invisible-headers mh-visible-headers set-mark mh-insert-prefix-string mh-ins-buf-prefix] 8 "\
Insert a message from any folder into the current letter.
Removes the message's headers using mh-invisible-headers.
Prefixes each non-blank line with mh-ins-buf-prefix (default \">> \").
If (optional) prefix argument provided, do not indent and do not delete
headers.
Leaves the mark before the letter and point after it." (byte-code "ÁÂÄ#ÅÆÇ«‡ÆÉ\"ªÊ\"!E‡" [current-prefix-arg mh-prompt-for-folder "Message from" mh-sent-from-folder nil read-input format "Message number%s: " mh-sent-from-msg " [%d]" ""] 8)])
(fset 'mh-yank-cur-msg #[nil "«Ø	«Õ`pqˆ«…Å!ˆqˆÇ «†`Ç {ªÉ=«‹ŠÊË!ˆ`)d{ªŒ«…ed{ªƒ`d{\nqˆ‰}ˆÍ ˆcˆÎ!ˆĞcˆ~+‡ÑÒ!‡" [mh-sent-from-folder mh-sent-from-msg to-buffer to-point mh-delete-yanked-msg-window delete-windows-on mh-show-buffer mark mh-yank-from-start-of-msg body mh-goto-header-end 1 mh-ins-str push-mark mh-insert-prefix-string mh-ins-buf-prefix "\n" error "There is no current message"] 2 "\
Insert the current message into the draft buffer.
Prefix each non-blank line in the message with the string in
mh-ins-buf-prefix.  If a region is set in the message's buffer, then
only the region will be inserted.  Otherwise, the entire message will
be inserted if mh-yank-from-start-of-msg is non-nil.  If this variable
is nil, the portion of the message following the point will be yanked.
If mh-delete-yanked-msg-window is non-nil, any window displaying the
yanked message will be deleted." nil])
(fset 'mh-insert-prefix-string #[(ins-string) "ebˆm?­ˆcˆÁyˆªt‡" [ins-string 1] 1])
(fset 'mh-fully-kill-draft #[nil "ÀÁ!«¢\nÄÅ !«…ÆÅ !ˆÇÈ!ˆÉÊ !ˆËÌ!ˆ­ƒÍ!)‡ÎÏ!‡" [y-or-n-p "Kill draft message? " mh-previous-window-config config file-exists-p buffer-file-name delete-file set-buffer-modified-p nil kill-buffer buffer-name message "" set-window-configuration error "Message not killed"] 2 "\
Kill the draft message file and the draft message buffer.
Use \\[kill-buffer] if you don't want to delete the draft message file." ""])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉM‡" [mh-recenter #[(arg) "Àp!Á =­‰Â«ƒªÄ!‡" [get-buffer-window selected-window recenter arg (t)] 2] mh-make-seq #[(name msgs) "	B‡" [name msgs] 2] mh-seq-name (macro . #[(pair) "À	D‡" [car pair] 2]) mh-seq-msgs (macro . #[(pair) "À	D‡" [cdr pair] 2]) mh-find-seq #[(name) "À	\n\"‡" [assoc name mh-seq-list] 3]] 2)
(fset 'mh-seq-to-msgs #[(seq) "À	!A‡" [mh-find-seq seq] 2 "\
Return a list of the messages in SEQUENCE."])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑMˆÒÓMˆÔÕMˆÖ×M‡" [mh-seq-containing-msg #[(msg) "Á‰«“@A>«†@@\nBA‰¬m\n*‡" [mh-seq-list nil seqs l msg] 3] mh-msg-to-seq #[(msg) "À	!@‡" [mh-seq-containing-msg msg] 2] mh-read-seq-default #[(prompt not-empty) "À	\n®#‡" [mh-read-seq prompt not-empty mh-narrowed-to-seq mh-previous-seq] 4] mh-read-seq #[(prompt not-empty &optional default) "ÀÁÂÄ«†ÁÆ\"ªÇ$È	!\"‰\nËš«‡ÌÍÎ!!ª\nÇš«ƒª„Ï\n!Ñ!‰¬Œ«ˆÔÁÕ\"!ˆ+‡" [completing-read format "%s %s %s" prompt "sequence:" default "[%s] " "" mh-seq-names mh-seq-list input "%" mh-msg-to-seq mh-get-msg-num t intern seq mh-seq-to-msgs msgs not-empty error "No messages in sequence `%s'"] 9] mh-read-folder-sequences #[(folder define-sequences) "À\n«‰Ã!ˆÅÆ\"ˆŠÇÈÉ\nË$ˆebˆÌÍÀÎ#«ÏĞÑ”Ñ•{!Ò \"	Bªie`|ˆ)	)‡" [nil seqs define-sequences mh-define-sequences mh-seq-list mh-mapc #[(seq) "À	@!­…	\nB‰‡" [mh-folder-name-p seq seqs] 2] mh-exec-cmd-quiet " *mh-temp*" "mark" folder "-list" re-search-forward "^[a-zA-Z]+" t mh-make-seq intern 0 mh-read-msg-list] 5] mh-seq-names #[(seq-list) "ÀÁ\n\"‡" [mapcar #[(entry) "À	@!C‡" [symbol-name entry] 2] seq-list] 3] mh-seq-from-command #[(folder seq seq-command) "À‰ÁŠÅ‹ˆqˆŸÇ\"	B	,‡" [nil t case-fold-search msgs msg ((byte-code "ÀÁÂ#ˆebˆÄ @‰«‹BÇyˆªnÀ‡" [apply mh-exec-cmd-quiet " *mh-temp*" seq-command mh-read-msg-list msg msgs 1] 4)) folder mh-make-seq seq mh-seq-list] 3] mh-read-msg-list #[nil "ÀŠÀˆ`)ÀÄÅ\nÆ#«ÉÇÈ”È•{!ÉÊ!«±ËuˆÄÅ\nÆ#ˆÇÈ”È•{!‰	W«‡ÍÎ	#ˆ	X«Š	B	T‰ªq)ª;	ÈU¬6	Bª0+‡" [nil num end-of-line msgs re-search-forward "[0-9]+" t string-to-int 0 looking-at "-" 1 num2 error "Bad message range: %d-%d"] 5] mh-remove-seq #[(seq) "ÀÁ\nÃT\n%ˆÅ\nÆC\"ˆÇ\n!‡" [mh-map-to-seq-msgs mh-notate-if-in-one-seq seq 32 mh-cmd-note mh-undefine-sequence "all" mh-delete-seq-locally] 6] mh-delete-seq-locally #[(seq) "À	!Ã\n\"‰)‡" [mh-find-seq seq entry delq mh-seq-list] 3] mh-remove-msg-from-seq #[(msg seq &optional internal-flag) "À	!‰­›ÃÅT\n@$ˆ¬†È	C\"ˆ\nÉ\nA\"¡)‡" [mh-find-seq seq entry mh-notate-if-in-one-seq msg 32 mh-cmd-note internal-flag mh-undefine-sequence delq] 6] mh-add-msgs-to-seq #[(msgs seq &optional internal-flag) "À	!«‡:¬ƒC\n¬‰Ä	\"Bª‹«ˆ\nÆ\nA\"¡ˆ?­ŒÈ	\"ˆÉ	ÊT#)‡" [mh-find-seq seq entry msgs mh-make-seq mh-seq-list append internal-flag mh-add-to-sequence mh-notate-seq 37 mh-cmd-note] 4]] 2)
(fset 'mh-rename-seq #[(seq new-name) "À	!‰«†\n ˆª…ÄÅ	\"ˆÆ	\nA\"ˆÇ\nA\")‡" [mh-find-seq seq old-seq new-name error "Sequence %s does not exists" mh-undefine-sequence mh-define-sequence] 4 "\
Rename a SEQUENCE to have a new NAME." "SOld sequence name: \nSNew name: "])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑMˆÒÓMˆÔÕMˆÖ×MˆØÙMˆÚÛMˆÜİMˆŞßMˆàáMˆâãMˆäåMˆæçMˆèéMˆêëMˆìíM‡" [mh-notate-user-sequences #[nil "Á‰­˜@@Ä\n!¬ˆÅ\nÆT#ˆA‰¬iÁ*‡" [mh-seq-list nil name seqs mh-internal-seq mh-notate-seq 37 mh-cmd-note] 5] mh-internal-seq #[(name) "Á>®ˆ\n=®ƒÃ!‡" [name (answered cur deleted forwarded printed) mh-unseen-seq mh-folder-name-p] 2] mh-folder-name-p #[(name) "9«ˆÁ!ÂHÃ=‡ÂHÃ=‡" [name symbol-name 0 43] 2] mh-notate-seq #[(seq notation offset) "ÀÁ\n$‡" [mh-map-to-seq-msgs mh-notate seq notation offset] 5] mh-notate-if-in-one-seq #[(msg notation offset seq) "À	!\n@=­‹\nA?­†Ä	#)‡" [mh-seq-containing-msg msg in-seqs seq mh-notate notation offset] 4] mh-map-to-seq-msgs #[(func seq &rest args) "ŠÀ	!‰­˜Ã\n@Ä‰#«‰Å\n@#ˆ\nA‰¬iÈ*‡" [mh-seq-to-msgs seq msgs mh-goto-msg t apply func args nil] 5] mh-map-over-seqs #[(func seq-list) "­	@@@A\"ˆA‰¬qÂ‡" [seq-list func nil] 4] mh-define-sequences #[(seq-list) "ÀÁ\n\"‡" [mh-map-over-seqs mh-define-sequence seq-list] 3] mh-add-to-sequence #[(seq msgs) "À	!?­\n­ÃÄÅÇÈ	!É\n&‡" [mh-folder-name-p seq msgs apply mh-exec-cmd "mark" mh-current-folder "-sequence" symbol-name "-add"] 8] mh-define-sequence #[(seq msgs) "­˜Á\n!?­’ŠÃÄÅÇÈ\n!ÉÊË!&)‡" [msgs mh-folder-name-p seq apply mh-exec-cmd "mark" mh-current-folder "-sequence" symbol-name "-add" "-zero" mh-list-to-string] 10] mh-undefine-sequence #[(seq msgs) "ÀÁÂÄÅ!Ç&‡" [apply mh-exec-cmd "mark" mh-current-folder "-sequence" symbol-name seq "-delete" msgs] 8] mh-copy-seq-to-point #[(seq location) "ÀÁ\n#‡" [mh-map-to-seq-msgs mh-copy-line-to-point seq location] 4] mh-copy-line-to-point #[(msg location) "Àyˆ`ÂyˆÃ	`\"ˆbˆÅ ˆ	b)‡" [0 beginning-of-line 1 copy-region-as-kill location yank] 3] mh-exec-cmd #[(command &rest args) "ŠÀqˆÁ ˆÂÃÄ\"ÇÈÇÉ\n!&ˆË ÌV­‚Í‹)‡" [" *mh-temp*" erase-buffer apply call-process expand-file-name command mh-progs nil t mh-list-to-string args buffer-size 0 ((byte-code "ÀÁ!ˆÂÃ!‡" [switch-to-buffer-other-window " *mh-temp*" sit-for 5] 2))] 8] mh-exec-cmd-quiet #[(buffer command &rest args) ";«†qˆÁ ˆÂÃÄ\"ÇÇ&‡" [buffer erase-buffer apply call-process expand-file-name command mh-progs nil args] 7] mh-exec-cmd-output #[(command display &rest args) "À`Á\"ˆÂÃÄ\"ÇÁÉ\n!&ˆË ‡" [push-mark t apply call-process expand-file-name command mh-progs nil display mh-list-to-string args exchange-point-and-mark] 8] mh-exec-cmd-daemon #[(command &rest args) "ŠÀÁ!qˆÂ ˆ)ÃÄÆÇ\"É\n!%ÌÍ\")‡" [get-buffer-create " *mh-temp*" erase-buffer apply start-process command nil expand-file-name mh-progs mh-list-to-string args process set-process-filter mh-process-daemon] 7] mh-process-daemon #[(process output) "ÀÁ!qˆÂ!ˆÄÁ!‡" [get-buffer-create " *mh-temp*" insert-before-markers output display-buffer] 2] mh-exec-lib-cmd-output #[(command &rest args) "À`Á\"ˆÂÃÄ\"ÇÁÇÈ	!&ˆÊ ‡" [push-mark t apply call-process expand-file-name command mh-lib nil mh-list-to-string args exchange-point-and-mark] 8] mh-list-to-string #[(l) "À\n«Í\n@«Ã\n@9«‰Ã\n@!	Bªµ\n@§«‰Ä\n@!	Bª§\n@Åš¬¡\n@;«‡\n@	Bª•\n@<«ŠÆ\n@!Ÿ	¤ª†ÇÈ\n@\"ˆ\nA‰¬3	Ÿ)‡" [nil new-list l symbol-name int-to-string "" mh-list-to-string error "Bad element in mh-list-to-string: %s"] 4] mh-annotate-msg #[(msg buffer note &rest args) "ÀÁÂ%ˆŠqˆ9«ŠÆT#ªˆÉT#)‡" [apply mh-exec-cmd "anno" buffer msg args mh-notate-seq note mh-cmd-note mh-notate] 6] mh-notate #[(msg notation offset) "Š«‡ÁÂ‰#­Ã Å‰Èyˆ	uˆÊË!ˆc*Í!ˆ))‡" [msg mh-goto-msg t buffer-modified-p folder-updating-mod-flag nil buffer-file-name buffer-read-only 0 offset delete-char 1 notation mh-set-folder-modified-p] 4] mh-prompt-for-folder #[(prompt default can-create) "ÀÁ\nÄš«ƒÅª„ÀÆ\"#Ç	¬„Ê 	Ë\n	Ç‰Ì%‰«‹Äš«…Äš¬hÄš¬†Ìš«…ªÍ!¬‡ÀÎ\"ÏĞ!!?‰«µÒÀÓ\"!«¬ÔÕ\"ˆÖ×Ç‰‰Ğ!%ˆÔØ\"ˆC	B	ÙÇOC	B	ª§«ˆÚÛ\"ˆª›Ü	\"¬“C	B	ÙÇOC	B	)*‡" [format "%s folder%s" prompt default "" "? " " [%s]? " nil name mh-folder-list mh-make-folder-list completing-read "+" mh-folder-name-p "+%s" file-exists-p mh-expand-file-name new-file-p y-or-n-p "Folder %s does not exist. Create it? " message "Creating %s" call-process "mkdir" "Creating %s...done" 1 error "Folder %s is not created" assoc] 8]] 2)
(fset 'mh-make-folder-list #[nil "ÀÁ!ˆÂ‹‡" [message "Collecting folder names..." ((byte-code "ÀÁÂÃ«ƒÅªÆ$ˆebˆÇ‰	m¬–`ÊyˆËÌ`S{\"C	B	ªgÍÎ!ˆ	*‡" [mh-exec-cmd-quiet " *mh-temp*" "folders" "-fast" mh-recursive-folders "-recurse" "-norecurse" nil start list 1 format "+%s" message "Collecting folder names...done"] 5))] 2 "\
Return a list of the user's folders.
Result is in a form suitable for completing read." nil])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËM‡" [mh-remove-folder-from-folder-list #[(folder) "ÀÁ\nÃÄO\"\"‰‡" [delq assoc folder 1 nil mh-folder-list] 5] read-msg-range #[(prompt) "À	!‰GÄÆW«•È\n#‰	@B	A)ªfŸ,‡" [read-string prompt buf buf-size 0 start nil input read-from-string next] 5] mh-get-msg-num #[(error-if-no-message) "ŠÀyˆÁ\n!«‰ÃÄ”Ä•{!ª‰«…ÆÇ!ªÈ)‡" [0 looking-at mh-msg-number-regexp string-to-int 1 error-if-no-message error "Cursor not pointing to message" nil] 3] mh-msg-search-pat #[(n) "À	\n\"‡" [format mh-msg-search-regexp n] 3] mh-msg-filename #[(msg &optional folder) "ÀÁ\n!«…Ä!ª\"‡" [expand-file-name int-to-string msg folder mh-expand-file-name mh-folder-filename] 4] mh-msg-filenames #[(msgs &optional folder) "ÀÁ\nÃ#‡" [mapconcat #[(msg) "À	\n\"‡" [mh-msg-filename msg folder] 3] msgs " "] 4]] 2)
(fset 'mh-expand-file-name #[(filename &optional default) "À	!«ˆÂ	ÃÄO\"‡Â	\"‡" [mh-folder-name-p filename expand-file-name 1 nil mh-user-path default] 4 "\
Just like expand-file-name, but also handles MH folder names.
Assumes that any filename that starts with '+' is a folder name."])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊ!ˆÌÍÎ#ˆÌÏÎ#ˆÌĞÑ#ˆÌÒÓ#ˆÌÔÕ#ˆÌÖ×#ˆÌØÙ#ˆÌÚÛ#ˆÌÜİ#ˆÌŞß#ˆÌàá#ˆÌâã#ˆÌäå#ˆÌæç#ˆÌèé#ˆÌêë#ˆÌìí#ˆÌîï#ˆÌğñ#ˆÌòó#ˆÌôõ#ˆÌö÷#ˆÌøù#ˆÌúû#ˆÌüı#ˆÌşÿ#ˆÌ@ ÿ#ˆÌA B #ˆÌC D #ˆÌE F #ˆÌG F #ˆÌH I #ˆÌJ K #ˆÌL K #ˆÌM N #ˆÌO P #ˆÌQ R #ˆÌS T #ˆÌU V #ˆÌW X #ˆÌY Z #ˆÌ[ \\ #ˆÌ] ^ #ˆÌ_ ` #ˆÌab c #ˆÌad c #ˆÌae c #ˆÌaf c #ˆÌag c #ˆÌah c #ˆÌai c #ˆÌaj c #ˆÌak c #ˆÌal c #ˆÌam n #ˆÌao p #ˆÌaq r #ˆÌas t #ˆÌau v #ˆÌaw x #ˆÌyw z #ˆÌyb c #ˆÌyd c #ˆÌye c #ˆÌyf c #ˆÌyg c #ˆÌyh c #ˆÌyi c #ˆÌyj c #ˆÌyk c #ˆÌyl c #ˆÌyo p #‡" [mh-find-path #[nil "ŠÀÁÂ!®Ã!Å!¬…ÆÇ\"ˆÈÉ!qˆÊ ˆË!ˆÌÍ!‰Ïš«…ĞªÑ!¬‡ÒÓ\"ÌÔ!‰Ïš«ƒÖ×ÀÀØ!\"!«ÅÙ!!¬†ÆÚ\"ˆÌÛ!‰Ïš«†İ‰ª‡Ş!‰*‡" [expand-file-name getenv "MH" "~/.mh_profile" profile file-exists-p error "Cannot find MH profile %s" get-buffer-create " *mh-temp*" erase-buffer insert-file-contents mh-get-field "Draft-Folder:" mh-draft-folder "" nil mh-folder-name-p format "+%s" "Path:" mh-user-path "Mail" file-name-as-directory "~" mh-expand-file-name "Draft folder %s does not exist.  Create it and try again." "Unseen-Sequence:" mh-unseen-seq unseen intern] 6] mh-get-field #[(field) "ÀebˆÂÄÀ#¬ƒÅªºÆÇ!«ƒÅª²ÈÉÄÀ#ˆÊ”Ê•{`ÄyˆÆÌ!«…ÊyˆªvÍÊ!ˆ`X«ƒªˆÎÏ`{#*)‡" [t case-fold-search search-forward field nil "" looking-at "[	 ]*$" re-search-forward "[	 ]*\\([^	 \n].*\\)$" 1 end-of-match "[ 	]" backward-char format "%s%s"] 5] mh-insert-fields #[(&rest name-values) "À\n­µ\n@\nA@Åš¬¢ebˆÆÇÈ\"ÉÀ#¬ÊË!ˆÌÍ±ˆªˆÉˆÌ±ˆ\nAA*ªH)‡" [t case-fold-search name-values value field-name "" re-search-forward format "^%s" nil mh-goto-header-end 0 " " "\n"] 4] mh-position-on-field #[(field set-mark) "À\n«ƒÃ ˆebˆÄÅ!ˆÆÇÈ	\"ÊÀ#­„ÊˆÀ)‡" [t case-fold-search set-mark push-mark mh-goto-header-end 0 re-search-backward format "^%s" field nil] 4] mh-goto-header-end #[(arg) "ÀÁÂ‰#­‚y‡" [re-search-forward "^$\\|^-+$" nil arg] 4] suppress-keymap mh-folder-mode-map define-key "q" mh-quit "b" "?" mh-msg-is-in-seq "%" mh-put-msg-in-seq "|" mh-pipe-msg "a" mh-edit-again "%" mh-delete-msg-from-seq "n" mh-narrow-to-seq "w" mh-widen "b" mh-burst-digest "u" mh-undo-folder " " mh-page-digest "" mh-page-digest-backwards "e" mh-extract-rejected-mail "f" mh-visit-folder "k" mh-kill-folder "l" mh-list-folders "p" mh-pack-folder "s" mh-search-folder "r" mh-rescan-folder "l" mh-print-msg "t" mh-toggle-showing "c" mh-copy-msg ">" mh-write-msg-to-file "i" mh-inc-folder "x" mh-execute-commands "e" "r" mh-redistribute "f" mh-forward "s" mh-send "m" "a" mh-reply "j" mh-goto-msg "g" "" mh-previous-page " " mh-page-msg "." mh-show "u" mh-undo "!" mh-refile-or-write-again "^" mh-refile-msg "d" mh-delete-msg "" mh-delete-msg-no-motion "p" mh-previous-undeleted-msg "n" mh-next-undeleted-msg mh-letter-mode-map "" mh-to-field "" "" "" "" "b" "c" "f" "s" "t" "" mh-fully-kill-draft "" mh-check-whom "	" mh-insert-letter "" mh-yank-cur-msg "" mh-insert-signature "" mh-send-letter mh-pick-mode-map mh-do-pick-search] 4)
