;;; compiled by jwz@thalidomide on Wed Dec 16 10:03:02 1992
;;; from file /u/jwz/emacs19/lisp/ilisp/ilisp.el
;;; emacs version 19.4 Lucid.
;;; bytecomp version 2.08; 27-aug-92.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(byte-code "ÀÁ!ˆÀÂ!ˆÀÃ!ˆÀÄ!‡" [require symlink comint comint-ipc ilisp-ext] 2)
(defvar ilisp-locals '(comint-prompt-regexp input-ring-size comint-get-old-input comint-input-sentinel comint-input-filter comint-input-sender comint-eol-on-send comint-send-newline comint-always-scroll comint-fix-error comint-continue comint-interrupt-regexp comint-error-regexp comint-output-filter comint-interrupt-start comint-handler comint-update-status comint-prompt-status comint-abort-hook) "\
List of ilisp local variables.")
(fset 'lisp-deflocal #[(local) "	>?­…	B‰‡" [local ilisp-locals] 2])
(fset 'deflocal '(macro . #[(variable default &optional documentation) "ÀÁÂDDÄFE‡" [progn lisp-deflocal quote variable defvar default documentation] 6 "\
Define an ilisp local variable."]))
(defvar ilisp-prefix "" "\
Prefix sequence for ilisp commands.")
(lisp-deflocal 'ilisp-program)
(defvar ilisp-program nil "\
*Program and arguments for invoking an inferior LISP.  The program
can be an rsh to run on a remote machine.  If there is not a common
file system, the interface files will be sent down the pipe instead.
The value of this variable is set from DIALECT-program, or inherited
from a less specific dialect if DIALECT-program is nil.")
(defvar ilisp-motd "ILISP V%s  Use M-x ilisp-bug for problems and suggestions." "\
*Message of the day format string for ILISP given VERSION. To
prevent any message from being printed, set this to nil.")
(defvar lisp-wait-p nil "\
*T if LISP eval/compile commands should wait for the result.  A
minus prefix to the command will change the sense of this switch for
just the next command.")
(defvar lisp-no-popper nil "\
*T if you want all output in the inferior LISP rather than in a
pop-up window.  You should probably also set comint-always-scroll to T
as well so that output is always visible.")
(defvar lisp-show-status t "\
*Set to nil to stop showing process status in lisp-mode buffers.")
(defvar ilisp-prefix-match nil "\
*Set to T to match only as a prefix when completing through the
inferior LISP.  This will speed up completion, but you no longer get
partial completion.")
(lisp-deflocal 'ilisp-filter-regexp)
(defvar ilisp-filter-regexp nil "\
*What not to save on an inferior LISP's input history.
Input matching this regexp is not saved on the input history in ilisp
mode.")
(lisp-deflocal 'ilisp-filter-length)
(defvar ilisp-filter-length 3 "\
*Do not save strings less than this in the command history.")
(lisp-deflocal 'ilisp-other-prompt)
(defvar ilisp-other-prompt nil "\
*Regexp to recognise prompts in the inferior LISP that are prompts
of non-(read/eval/print) top-levels so that bol-ilisp skips them.")
(lisp-deflocal 'ilisp-raw-echo)
(defvar ilisp-raw-echo nil "\
*Set this to T to cause echoing in raw keyboard mode.")
(lisp-deflocal 'ilisp-load-no-compile-query)
(defvar ilisp-load-no-compile-query nil "\
*Set this to T to stop load querying about compile.")
(defvar ilisp-site-hook nil "\
Hook for site customization of ilisp mode when it is loaded.")
(defvar ilisp-load-hook nil "\
Hook for customizing ilisp mode when it is loaded.")
(defvar ilisp-mode-hook nil "\
Hook for customizing ilisp mode.")
(lisp-deflocal 'ilisp-init-hook)
(defvar ilisp-init-hook nil "\
Hook of functions to call on first prompt in inferior LISP.")
(lisp-deflocal 'ilisp-reset)
(defvar ilisp-reset nil "\
String for resetting the top-level of the inferior LISP.")
(lisp-deflocal 'ilisp-load-or-send-command)
(defvar ilisp-load-or-send-command nil "\
Format string for loading BINARY if possible otherwise loading
FILE.  If you can't load either, return NIL.")
(lisp-deflocal 'ilisp-package-regexp)
(defvar ilisp-package-regexp nil "\
Regular expression for finding a package specification in a buffer.
The entire sexp starting with this pattern will be passed to
ilisp-package-command to find the package.")
(lisp-deflocal 'ilisp-package-command)
(defvar ilisp-package-command nil "\
Format string to find the package given PACKAGE.")
(lisp-deflocal 'ilisp-package-name-command)
(defvar ilisp-package-name-command nil "\
Format string to return the name of the current package.")
(lisp-deflocal 'ilisp-in-package-command)
(defvar ilisp-in-package-command nil "\
Format string to set the package given PACKAGE.")
(lisp-deflocal 'ilisp-last-command)
(defvar ilisp-last-command nil "\
Format string for getting the last returned value.")
(lisp-deflocal 'ilisp-save-command)
(defvar ilisp-save-command nil "\
Format string for saving result history given FORM.")
(lisp-deflocal 'ilisp-restore-command)
(defvar ilisp-restore-command nil "\
Format string for restoring result history.")
(lisp-deflocal 'ilisp-block-command)
(defvar ilisp-block-command nil "\
Format string for grouping FORMS into one.")
(lisp-deflocal 'ilisp-eval-command)
(defvar ilisp-eval-command nil "\
Format string for evaluating FORM in PACKAGE from FILE.")
(lisp-deflocal 'ilisp-defvar-regexp)
(defvar ilisp-defvar-regexp nil "\
Regular expression for identifying a defvar form.")
(lisp-deflocal 'ilisp-defvar-command)
(defvar ilisp-defvar-command nil "\
Format string for re-evaluating DEFVAR in PACKAGE from FILE.")
(lisp-deflocal 'ilisp-describe-command)
(defvar ilisp-describe-command nil "\
Format string for describing FORM in PACKAGE.")
(lisp-deflocal 'ilisp-inspect-command)
(defvar ilisp-inspect-command nil "\
Format string for inspecting FORM in PACKAGE.")
(lisp-deflocal 'ilisp-arglist-command)
(defvar ilisp-arglist-command nil "\
Format string for arglist of SYMBOL in PACKAGE.")
(lisp-deflocal 'ilisp-documentation-types)
(defvar ilisp-documentation-types nil "\
((\"type\") ...) possible LISP documentation types.")
(lisp-deflocal 'ilisp-documentation-command)
(defvar ilisp-documentation-command nil "\
Format string for documentation given SYMBOL in PACKAGE and TYPE.")
(lisp-deflocal 'ilisp-macroexpand-1-command)
(defvar ilisp-macroexpand-1-command nil "\
Format string for top-level macroexpand given FORM and PACKAGE.")
(lisp-deflocal 'ilisp-macroexpand-command)
(defvar ilisp-macroexpand-command nil "\
Format string for macroexpand given FORM and PACKAGE.")
(lisp-deflocal 'ilisp-complete-command)
(defvar ilisp-complete-command nil "\
Format string for finding possibly matching symbols given SYMBOL,
PACKAGE, FUNCTIONP, EXTERNALP and PARTIAL-MATCHP.  It should print
((string) (string) ...).")
(lisp-deflocal 'ilisp-callers-command)
(defvar ilisp-callers-command nil "\
Format for finding the callers of SYMBOL in PACKAGE.  The function
should print out callers with one per line.")
(lisp-deflocal 'ilisp-trace-command)
(defvar ilisp-trace-command nil "\
Format for tracing SYMBOL in PACKAGE.")
(lisp-deflocal 'ilisp-untrace-command)
(defvar ilisp-untrace-command nil "\
Format for untracing SYMBOL in PACKAGE.")
(lisp-deflocal 'ilisp-directory-command)
(defvar ilisp-directory-command nil "\
Format for getting default DIRECTORY.")
(lisp-deflocal 'ilisp-set-directory-command)
(defvar ilisp-set-directory-command nil "\
Format for setting default DIRECTORY.")
(lisp-deflocal 'ilisp-binary-command)
(defvar ilisp-binary-command nil "\
Command to return the extension for binary files.")
(lisp-deflocal 'ilisp-binary-extension)
(defvar ilisp-binary-extension nil "\
*The extension to use for LISP binaries.  If there is an
ilisp-binary-command, this string will be determined at initilization time.")
(lisp-deflocal 'ilisp-init-binary-command)
(defvar ilisp-init-binary-command nil "\
Command to return the extension for initialization binary files.")
(lisp-deflocal 'ilisp-init-binary-extension)
(defvar ilisp-init-binary-extension nil "\
The extension for initialization binary files.  If there is an
ilisp-init-binary-command, this string will be determined at
initilization time.")
(lisp-deflocal 'ilisp-load-command)
(defvar ilisp-load-command nil "\
Format string for loading a file in LISP given FILE.")
(lisp-deflocal 'ilisp-compile-file-command)
(defvar ilisp-compile-file-command nil "\
Format string for compiling a file in LISP given FILE and EXTENSION.")
(lisp-deflocal 'ilisp-source-types)
(defvar ilisp-source-types nil "\
Alist of strings for source types.  The strings can be either
symbols or list expressions since the input accepts symbols or open
ended lists as type specifiers.")
(lisp-deflocal 'ilisp-find-source-command)
(defvar ilisp-find-source-command nil "\
Format string for finding the source file that defined SYMBOL in
PACKAGE.  It should return NIL if no source is found.")
(lisp-deflocal 'ilisp-locator)
(defvar ilisp-locator nil "\
Function (SYMBOL TYPE FIRST-P BACK-P) that finds the next SYMBOL TYPE
definition in the current buffer.  FIRST-P is T the first time it is
called in a buffer.  BACK-P is T to move backwards.")
(lisp-deflocal 'ilisp-calls-locator)
(defvar ilisp-calls-locator nil "\
Function (SYMBOL TYPE FIRST-P BACK-P ) that finds calls to SYMBOL
in the current buffer.  FIRST-P is T the first time it is called in a
buffer.  BACK-P is T to move backwards.")
(lisp-deflocal 'ilisp-use-map)
(defvar ilisp-use-map nil "\
Keymap to use in ILISP mode.")
(defvar ilisp-bugs-to "ccm@cs.cmu.edu" "\
Who to send bug reports to.")
(defvar ilisp-modes '(ilisp-mode) "\
List of all inferior ilisp modes.")
(defvar lisp-source-modes '(lisp-mode scheme-mode) "\
Used to determine if a buffer contains Lisp source code.
If it's loaded into a buffer that is in one of these major modes, it's
considered a lisp source file by find-file-lisp, load-file-lisp and
compile-file-lisp. Used by these commands to determine defaults.")
(lisp-deflocal 'ilisp-no-newline)
(defvar ilisp-no-newline nil "\
Set to T to stop ilisp from inserting a newline after a command.")
(lisp-deflocal 'ilisp-error-filter)
(defvar ilisp-error-filter nil "\
Function to filter error output.")
(lisp-deflocal 'ilisp-error-regexp)
(defvar ilisp-error-regexp nil "\
Regular expression to match error.")
(lisp-deflocal 'ilisp-symbol-delimiters)
(defvar ilisp-symbol-delimiters nil "\
Delimiters found around symbols.")
(defvar ilisp-epoch-running (byte-code "ÀÁ!­	‡" [boundp epoch::version] 2) "\
Non-nil if epoch is running.")
(defvar ilisp-version "4.12" "\
Interface version.")
(defvar ilisp-directory nil "\
The directory that ilisp is found in.")
(defvar ilisp-mode-map nil "\
Key map for ILISP.")
(defvar ilisp-raw-map nil "\
Keyboard map for sending characters directly to the inferior LISP.")
(defvar ilisp-raw-message "Raw keyboard mode until C-g" "\
Message for how to stop raw mode.")
(defvar ilisp-buffer nil "\
Name of selected ilisp buffer.")
(defvar ilisp-status nil "\
Status string for selected ilisp buffer.")
(defvar ilisp-buffers nil "\
List of ILISP buffers.")
(defvar ilisp-dialects nil "\
List of ILISP dialects.")
(lisp-deflocal 'ilisp-load-inits)
(defvar ilisp-load-inits nil "\
Alist of dialect files to load when initializing an inferior LISP.
By default the file will be loaded from the ilisp-directory.")
(lisp-deflocal 'ilisp-dialect)
(defvar ilisp-dialect nil "\
List of the dialects that defined the current inferior LISP.")
(defvar ilisp-initialized nil "\
List of buffer names that have been initialized.")
(lisp-deflocal 'ilisp-initializing)
(defvar ilisp-initializing nil "\
Set to T while waiting for inferior LISP to get initialized.")
(lisp-deflocal 'ilisp-load-files)
(defvar ilisp-load-files nil "\
List of files being loaded.")
(defvar lisp-changes nil "\
List of markers for changed forms.")
(lisp-deflocal 'ilisp-pending-changes)
(defvar ilisp-pending-changes nil "\
List of changes that are pending, but have not been confirmed yet.")
(defvar ilisp-complete nil "\
T if in minibuffer completion mode.")
(defvar ilisp-no-complete nil "\
T if incomplete symbols are allowed.")
(defvar ilisp-table nil "\
Completion table for ilisp readers.")
(defvar ilisp-paren nil "\
T if paren is allowed in ilisp readers.")
(defvar ilisp-completion-package nil "\
Package of buffer requesting completion.")
(defvar ilisp-completion-function-p nil "\
T if only symbols with function values are allowed.")
(defvar ilisp-mini-prefix nil "\
Package and qualification from minibuffer.")
(defvar ilisp-original nil "\
Original string for ilisp completion.")
(defvar ilisp-original-function-p nil "\
Function-p for ilisp completion.")
(defvar ilisp-original-table nil "\
Completion table for ilisp-original.")
(fset 'lisp-memk #[(item list key) "À	\nÃ#‡" [lisp-mem item list #[(x y) "	\n!š‡" [x key y] 3]] 4 "\
Test to see if ITEM is in LIST using KEY on each item in LIST
before comparing it to ITEM."])
(fset 'lisp-del #[(item list &optional test) "®Á\nÃ‰«©¬¦@\"«’È«ˆA¡ˆªc\nAª^A‰¬W\n,‡" [test equal list nil done prev element item t] 5 "\
Delete ITEM from LIST using TEST comparison and return the result.
Default test is equal."])
(fset 'lisp-last #[(list) "A«†A‰ªw@‡" [list] 2 "\
Return the last element of LIST."])
(fset 'lisp-pop-to-buffer #[(buffer) "«…Á\n!ªƒÃ\n!‰«†Å!ˆª“«ŒÆÇÈ\n\"@®‚É !ˆÊ\n!ˆ)\nq‡" [ilisp-epoch-running epoch::get-buffer-window buffer get-buffer-window ilisp-window select-window epoch::select-screen symbol-buffer-value allowed-screens epoch::current-screen pop-to-buffer] 5 "\
Like pop-to-buffer, but select a screen that buffer was shown in."])
(fset 'lisp-symbol #[(package delimiter name) "‰­„	®ÂE‡" [package delimiter "::" name] 3 "\
Create a LISP symbol."])
(fset 'lisp-symbol-name #[(symbol) "AA@‡" [symbol] 1 "\
Return the name of SYMBOL."])
(fset 'lisp-symbol-package #[(symbol) "@‡" [symbol] 1 "\
Return the package of SYMBOL."])
(fset 'lisp-symbol-delimiter #[(symbol) "A@‡" [symbol] 1 "\
Return the qualifier of SYMBOL."])
(fset 'lisp-symbol= #[(symbol1 symbol2) "À	!À\n!˜­Ã	!Ã\n!˜­‡Ä	!Ä\n!˜‡" [lisp-symbol-name symbol1 symbol2 lisp-symbol-package lisp-symbol-delimiter] 3 "\
Return T is SYMBOL1 is equal to SYMBOL2."])
(fset 'lisp-prefix-p #[(s1 s2) "G‰\nGX­æÃ‰ÄÅ	ÊË	#‰«º	O\n‰	Z\\O˜« Ã•	ÊÌ	O!\n#«‡Ã•‰ªŠÄ‰ª„Ä‰¬;­		O\n‰		Z\\O˜,)‡" [s1 len1 s2 0 nil t match end start2 start string-match "[^a-zA-Z0-9]" regexp-quote] 7 "\
Returns t if S1 is a prefix of S2 considering all non alphanumerics
as word delimiters."])
(fset 'lisp-last-line #[(string) "ÀÂÃ	#«…Å•ªt	ÆOÀ	O)B‡" [0 position string-match "\\(\n+\\)[^\n]" string 1 nil] 4 "\
Return the last line of STRING with everything else."])
(fset 'lisp-show-send #[(string) "ŠÀ «…Áqˆª„ÂÃ!ˆÄ ˆcˆ)‡" [ilisp-buffer "*ilisp-send*" error "You must start an inferior LISP with run-ilisp." erase-buffer string] 2 "\
Show STRING in the *ilisp-send* buffer."])
(fset 'lisp-slashify #[(string) "ŠÀ	!ˆÂqˆebˆÃÄÅÆ#«‰ÇÈ!ˆÉcˆªpebˆÃÊÅÆ#«‹Ë ˆÌcˆÅuˆªned{)‡" [lisp-show-send string "*ilisp-send*" search-forward "\\" nil t delete-char -1 "\\\\" "\"" backward-char 92] 4 "\
Put string in the *ilisp-send* buffer, put backslashes before
quotes and backslashes and return the resulting string."])
(fset 'ilisp-directory #[(file &optional dirs) "®ƒÁ\nB‰@‰«’ÄÅ\"!¬‰A‰@‰¬n*‡" [dirs "" load-path dir file-exists-p expand-file-name file] 5 "\
Return the directory of DIRS that FILE is found in.  By default
load-path is used for the directories."])
(fset 'lisp-file-extension #[(file extension) "ÁÂÃ\"OÄQ‡" [file 0 string-match ".[^.]*$" "." extension] 5 "\
Return FILE with new EXTENSION."])
(fset 'ilisp-buffer #[nil "	>«‚p‡\n­Ã\n!®˜ÃÄ\nÅ\nGSOÇ#ÈÉ@@\"‰!‰\n®ƒËÌ!)‡" [major-mode ilisp-modes ilisp-buffer get-buffer lisp-del 1 ilisp-buffers #[(s1 s2) "	@˜‡" [s1 s2] 2] format "*%s*" buffer error "You must start an inferior LISP with run-ilisp."] 6 "\
Return the current ILISP buffer."])
(fset 'ilisp-process #[nil "ÀÁ !‡" [get-buffer-process ilisp-buffer] 2 "\
Return the current ILISP process."])
(fset 'ilisp-value #[(variable &optional no-error-p) "ŠÀ qˆÁ\n!‰«ƒªˆ?­„ÅÆ\n\"*‡" [ilisp-buffer eval variable value no-error-p error "%s is not defined."] 4 "\
Return the value of VARIABLE in the ILISP buffer.
If NO-ERROR-P is NIL, then an error will be signalled if VARIABLE is nil."])
(fset 'set-ilisp-value #[(variable value) "ŠÀ qˆ	\nL)‡" [ilisp-buffer variable value] 2 "\
Set the value of VARIABLE in the ILISP buffer."])
(fset 'select-ilisp #[nil "À	«‹ÂÃ	Ä	GSO\"ªÅÇÈ$‰	GÊU?­‡ÂË	\"‰)‡" [completing-read ilisp-buffer format "Buffer [%s]: " 1 "Buffer: " ilisp-buffers nil t new 0 "*%s*"] 7 "\
Select the current ILISP buffer." nil])
(defvar ilisp-last-buffer nil "\
The last used LISP buffer.")
(fset 'switch-to-lisp #[(eob-p &optional ilisp-only) "¬Œ	«‰\n>«„Ä	!‡\n>¬‚pÄÅ !ˆ­‚db‡" [ilisp-only ilisp-last-buffer major-mode ilisp-modes lisp-pop-to-buffer ilisp-buffer eob-p] 2 "\
If in an ILISP buffer, switch to the buffer that last switched to
an ILISP otherwise, switch to the current ILISP buffer.  With
argument, positions cursor at end of buffer.  If you don't want to
split windows, set pop-up-windows to NIL." "P"])
(fset 'abort-commands-lisp #[(&optional message) "À	Â\"«„ÃÄ!‡Å ˆÃ®Æ!ˆÇÈ !‡" [ilisp-value comint-aborting t message "Already aborted commands" beep "Aborted commands" comint-abort-sends ilisp-process] 3 "\
Abort the commands sent to the current ilisp." nil])
(fset 'panic-lisp #[nil "ŠÀÁ!«ŠÂ qˆÃÄ!ˆÅÆ!)ªƒÅÇ!)‡" [y-or-n-p "Panic reset LISP? " ilisp-buffer comint-setup-ipc t message "LISP is reset, state is unknown" ""] 2 "\
Panic reset for the inferior LISP." nil])
(fset 'interrupt-subjob-ilisp #[nil "	=¬œÂÃ!«…Ä ˆª’ÅÆ!ˆ	=¬‰Ç ˆÈÉ!ˆªrÅÊ!ˆË ‡" [comint-send-queue comint-end-queue y-or-n-p "Abort commands before interrupting top level? " abort-commands-lisp message "Waiting for commands to finish" accept-process-output sit-for 0 "Interrupted top level" comint-interrupt-subjob] 2 "\
Interrupt the current top level command in the inferior LISP." nil])
(fset 'status-lisp #[(showp) "ŠÀ qˆÁ\n!)‡" [ilisp-buffer comint-current-send showp] 2 "\
Show the message of the current command being executed in the
inferior LISP.  With a prefix show pending sends as well." "P"])
(defvar buffer-package 'not-yet-computed "\
Cached package name.")
(defvar buffer-mode-name nil "\
Original mode name.")
(defvar lisp-buffer-package nil "\
T if in lisp-buffer-package.")
(fset 'lisp-buffer-package #[nil "Á=¬‚‡\n«‚\n‡¬‹>¬†>¬‚Ç‡ÈÀ!ˆÈÉ!ˆÊÌÌÎÏÌ\"‰­˜ŠebˆÑÇÌ#­‹Ò”Ò”bˆÓ ˆ`{)‰­‹ÕÖÎ×!\"ØÙ#ÎÛÌ\"«‹Ü!ˆİŞ!ˆª”«ßà\"«‰á”á•Oâã!ˆ«	®…$‰	åQ$-‡" [buffer-package not-yet-computed ilisp-completion-package lisp-buffer-package major-mode ilisp-modes lisp-source-modes nil make-local-variable buffer-mode-name ilisp-status mode-line-process t case-fold-search ilisp-value ilisp-package-regexp regexp re-search-forward 0 forward-sexp spec ilisp-send format ilisp-package-command "Finding buffer package" pkg package comint-errorp lisp-display-output error "No package" string-match "[ \n	:\"]*\\([^ \n	\"]\\)*" 1 message "" mode-name ":"] 5 "\
Return the package for this buffer.  The package name is a string.
If there is none, return NIL.  This caches the package, so calling
this more than once is cheap."])
(fset 'package-lisp #[nil "ÀÁÂÃÄ!ÅÆ#\"‡" [message "Inferior LISP package is %s" ilisp-send ilisp-value ilisp-package-name-command "Finding inferior LISP package" pkg] 6 "\
Show current inferior LISP package." nil])
(fset 'set-package-lisp #[(package) "«“ÁÂÃÄ!\"ÂÅÆÇ !#ÈÉ$‡ÊË!‡" [package ilisp-send format ilisp-value ilisp-in-package-command "Set %s's package to %s" buffer-name ilisp-buffer pkg dispatch error "No package"] 6 "\
Set inferior LISP to package of buffer or a named package with prefix." (byte-code "À \n¬ƒ	¬˜ÃÄÅÀ \"Æ\"‰Æš«ƒ	ª‚)Cª‚	C)‡" [lisp-buffer-package default current-prefix-arg read-string format "Package [%s]: " "" name] 5)])
(fset 'set-buffer-package-lisp #[(package) "«Œ\n®ÄQ‰‡ÅÆ ‡" [package buffer-package buffer-mode-name mode-name ":" not-yet-computed lisp-buffer-package] 3 "\
Reset the current package of the current buffer.  With prefix
specify manually." (byte-code "«…ÁÂ!C‡ÃC‡" [current-prefix-arg read-from-minibuffer "Package: " nil] 2)])
(fset 'ilisp-get-old-input #[nil "ŠÀ ÂÃp!!`W­†ŠÅˆ`)ÅÅÅÉÊˆ­„	{.‡" [lisp-defun-begin begin process-mark get-buffer-process pmark nil once end done (byte-code "¬›`dW«–Á ˆ`ÃÄwˆ«l`Y«gÆ‰«eÄ‡" [done forward-sexp end " 	\n" nil once t] 3) ((error (byte-code "ÀÀ‡" [nil end] 1)))] 3 "\
Snarf the sexp starting at the nearest previous prompt, or NIL if none."])
(fset 'ilisp-input-filter #[(str) "À	\n\"?­„\nGV‡" [string-match ilisp-filter-regexp str ilisp-filter-length] 3 "\
Don't save anything matching ilisp-filter-regexp or less than
ilisp-filter-length long."])
(fset 'ilisp-error-filter #[(output) "ÀÁÂ!\"«‡Ä”Ä•O‡‡" [string-match ilisp-value ilisp-error-regexp output 0] 3 "\
Keep from OUTPUT only what matches ilisp-error-regexp or everything
if there is no match."])
(byte-code "ÀÁ!¬‚ÂÀÃ!¬‚ÂÂ‡" [boundp ilisp-last-message nil ilisp-last-prompt] 2)
(fset 'lisp-display-output #[(output) "­ÃÁÂÃ\"«†ÁÄ!!«±pÆ ÉÊË !ˆp=¬„Í­…ÏĞQÑ!ĞR!ˆÓ‰+‡Ô!‡" [output ilisp-value comint-errorp t ilisp-error-filter lisp-no-popper selected-window window buffer ((byte-code "À	!«‡Â	!ˆqˆÀ‡" [window-point window select-window buffer] 2)) lisp-pop-to-buffer ilisp-buffer ilisp-last-buffer comint-insert ilisp-last-message ";;; " "\n" comint-remove-whitespace ilisp-last-prompt nil comint-display-output] 5 "\
Display OUTPUT in a popper window unless lisp-no-popper is T."])
(fset 'ilisp-handler #[(error-p wait-p message output prompt) "«‘	«Œ	¬…Æ!ˆÈ‡„Û É!‰ƒÛ \n¬ˆËÌ\"ƒÛ Í \n«‡!ª‚\n«ŒÑ ¬ˆÒÓÔ#ª†ÒÕÖ#ÚU«ŸÁÛ!ˆ«‘Üİ!«„ª‚!ˆªƒß ˆàª×Šáâ!qˆ«„ed|ˆdbˆ	cˆãcˆcˆäcˆ)«ƒÈåU«ŠÁæ!ˆç ˆàª¡èU«–é*‰‰	ÌÌ°!ˆÁë!ˆÈª…Áì!ˆà,‡à‡" [lisp-no-popper message ilisp-last-message prompt ilisp-last-prompt wait-p lisp-display-output output nil comint-remove-whitespace error-p string-match "\n" popper-output-buffer buffer ilisp-error-filter out comint-interrupted comint-handle-error "SPC-scroll, I-ignore, K-keep, A-abort sends and keep or B-break: " (105 107 97 98) "SPC-scroll, I-ignore, K-keep or A-abort sends and keep: " (105 107 97) key comint-queue-emptied clear 105 "Ignore message" boundp temp-buffer-show-function temp-buffer-show-hook popper-bury-output t get-buffer-create "*Errors*" 10 "\n\n" 97 "Abort pending commands and keep in *Errors*" comint-abort-sends 98 comint-insert comment-start "Preserve break" "Keep error in *Errors* and continue"] 9 "\
Given ERROR-P, WAIT-P, MESSAGE, OUTPUT and PROMPT, show the message
and output if there is an error or the output is multiple lines and
let the user decide what to do."])
(fset 'ilisp-update-status #[(status) "­„ÁÂ\"Å!‡" [lisp-show-status format " :%s" status ilisp-status comint-update-status] 3 "\
Update process STATUS of the current buffer and let all lisp mode
buffers know as well."])
(fset 'ilisp-abort-handler #[nil "ÀÀÀ«‘@>¬…@BA‰¬o¤‰)‡" [nil ilisp-initializing ilisp-load-files add ilisp-pending-changes lisp-changes] 3 "\
Handle when the user aborts commands."])
(fset 'ilisp-initialized #[nil "ÀÁ !\n>‡" [buffer-name ilisp-buffer ilisp-initialized] 2 "\
Return T if the current inferior LISP has been initialized."])
(fset 'ilisp-compile-inits #[nil "ÀÁ!ˆÂÃÁ\"‰­•ÅÆ@A\"ÂÈÁ\"\"ˆA‰¬lÉ)‡" [ilisp-init t ilisp-value ilisp-load-inits files compile-file-lisp expand-file-name ilisp-directory ilisp-init-binary-extension nil] 6 "\
Compile the initialization files for the current inferior LISP
dialect." nil])
(fset 'ilisp-load-or-send #[(file) "ÀÁÂ!ÃÁÅÆ\"\"#ÈÉÁÉÆ\"C¤\"ˆÊË ÆÌÍÀÎ\"Ï&)‡" [format ilisp-value ilisp-load-or-send-command lisp-file-extension file ilisp-init-binary-extension t command set-ilisp-value ilisp-load-files comint-send ilisp-process nil load "Loading %s" #[(error wait message output last) "À	!Ãp!Å«ÊÈÉÊ!@\"«ÀË\n!Í\n!ŠqˆÏ )¬…Ñ!ˆÒ˜«ˆÓÔÕ\n\"!ª’ÖÔ\"ÅØÙÔÚ\n\"Û&+ª—«İ %ˆá\n	\"‰+‡" [lisp-last ilisp-load-files file get-buffer-process process t case-fold-search output string-match "nil" lisp-last-line get-file-buffer old-buffer find-file-noselect buffer buffer-string string kill-buffer "" abort-commands-lisp format "Can't find file %s" comint-send ilisp-block-command nil send "Sending %s" #[(error wait message output last) "«Á\n!ˆÃÄÅÆ!\"!‡ÈÆ!\"‰‡" [error comint-display-error output abort-commands-lisp format "Error sending %s" lisp-last ilisp-load-files delq] 5] error ilisp-handler wait message last delq] 9]] 9 "\
Try to load FILE into the inferior LISP.  If the file is not
accessible in the inferior LISP as determined by
ilisp-load-or-send-command, then visit the file and send the file over
the process interface."])
(fset 'ilisp-load-init #[(dialect file) "À	\n\"«’«…¡ª“\n	BC¤‰ª‰­†Å\n\"‰)‡" [assoc dialect ilisp-load-inits old file delq] 3 "\
Add FILE to the files to be loaded into the inferior LISP when
dialect is initialized.  If FILE is NIL, the entry will be removed."])
(fset 'ilisp-binary #[(init var) "À	Â\"?­ÀÂ\"‰­•ÅÆ ÂÇÄÇÈÉÊËÌÍ	ÎEFE&)‡" [ilisp-value var t init binary comint-send ilisp-process nil lambda (error wait message output last) if (or error (not (string-match "\"[^\"]*\"" output))) (progn (lisp-display-output output) (abort-commands-lisp "No binary")) setq (substring output (1+ (match-beginning 0)) (1- (match-end 0)))] 16 "\
Initialize VAR to the result of INIT if VAR is NIL."])
(fset 'ilisp-done-init #[nil "«‡ÁÂp!Ã\"‡­’ÅÆ@\"ˆÈÉp!\nB‰\n‡" [ilisp-load-files comint-send-code get-buffer-process ilisp-done-init ilisp-initializing message "Finished initializing %s" ilisp-dialect nil buffer-name ilisp-initialized] 3 "\
Make sure that initialization is done and if not dispatch another check."])
(fset 'ilisp-init-internal #[(&optional sync) "À	«‰ÂÃ ÄÅÆ‰%ˆÇÈÉ\"ˆÇÊË\"ˆÌÃ Í\"ˆÎÏĞ\")‡" [((byte-code "ÀÁÂ\"¬ƒÃ ˆÀ‡" [ilisp-value ilisp-initializing t abort-commands-lisp] 3)) sync comint-sync ilisp-process "\"Start sync\"" "[ 	\n]*\"Start sync\"" "\"End sync\"" ilisp-binary ilisp-binary-command ilisp-binary-extension ilisp-init-binary-command ilisp-init-binary-extension comint-send-code #[nil "ÁÄ¬ƒ«ÇÈ@A	\"!ˆA‰¬pÊË Ì\"ˆÍ‰+‡" [ilisp-load-inits nil done files ((byte-code "¬…ÁÃ ˆÁ‡" [done nil ilisp-initializing abort-commands-lisp] 1)) ilisp-init-binary-extension ilisp-binary-extension ilisp-load-or-send expand-file-name ilisp-directory comint-send-code ilisp-process ilisp-done-init t] 5] set-ilisp-value ilisp-initializing t] 6 "\
Send all of the stuff necessary to initialize."])
(fset 'ilisp-init #[(&optional waitp forcep sync) "¬…Á ?­²ÂÃ!ˆ¬ÄÅ\"®…ÄÇ\"ÈÉÊ\"¬…Ë!ˆ­ÈÉÊ\"­‰Î ˆÏĞ!ˆªq‡" [forcep ilisp-initialized message "Started initializing ILISP" ilisp-directory "ilisp.elc" load-path "ilisp.el" ilisp-value ilisp-initializing t ilisp-init-internal sync waitp accept-process-output sit-for 0] 3 "\
Initialize the current inferior LISP if necessary by loading the
files in ilisp-load-inits.  Optional WAITP waits for initialization to
finish.  When called interactively, force reinitialization.  With a
prefix, get the binary extensions again." (byte-code "­‹ÁÂÃ\"ˆÁÄÃ\"ˆÃÅD‡" [current-prefix-arg set-ilisp-value ilisp-init-binary-extension nil ilisp-binary-extension t] 3)])
(fset 'ilisp-init-and-sync #[nil "ÀÁ‰Â#‡" [ilisp-init nil t] 4 "\
Synchronize with the inferior LISP and then initialize."])
(fset 'ilisp-send #[(string &optional message status and-go handler) "ÀÁ!ˆÂ Ä=«ÆÇ«†ÈPª‚\"ˆÉ\nË>«¢ÌÉ‰&ˆĞ=«†ÑÉ!ˆª…ÒÁ‰\"ˆÉªÑÓÔÁ\"Ì«ˆÖ\"ª‚Á?­×&«ÌÓÙÁ\"ÁÉÚÛÁ‰&ˆ?­“A¬‰Üİ!ˆŞ ˆªrß@!**‡" [ilisp-init t ilisp-process and-go dispatch process message "%s" "Started " nil ilisp-original (t call) comint-send string status handler call call-defun-lisp switch-to-lisp ilisp-value ilisp-save-command save format wait result ilisp-restore-command restore "Restore" sit-for 0 accept-process-output comint-remove-whitespace] 9 "\
Send STRING to the ILISP buffer, print MESSAGE set STATUS and
return the result if AND-GO is NIL, otherwise switch to ilisp if
and-go is T and show message and results.  If AND-GO is 'dispatch,
then the command will be executed without waiting for results.  If
AND-GO is 'call, then a call will be generated. If this is the first
time an ilisp command has been executed, the lisp will also be
initialized from the files in ilisp-load-inits.  If there is an error,
comint-errorp will be T and it will be handled by HANDLER."])
(fset 'return-ilisp #[nil "Àp!‰¬†ÂÃ!‚Ÿ Ä	!Æ ‰«ÜÈ 	`Y«…dbˆª‡bˆcˆ\n¬ƒËcˆ!«—Í	!¬ŠÎ	Ï\"˜¬‡Ğ	\"ˆ!ˆÒ	\"ˆÄ	!`Ò“ˆ`Ò“ˆdb)ªªdU«™Ö\n¬ƒËcˆÄ	!`Ò“ˆ	Ø\")ªŒËcˆŒd}ˆ )*)‡" [get-buffer-process proc error "Current buffer has no process" process-mark pmark ilisp-get-old-input input get-input-ring input-ring ilisp-no-newline 10 comint-input-filter ring-empty-p ring-ref 0 ring-insert-new comint-input-sentinel nil ilisp-original comint-input-sender comint-last-input-end t comint-send-newline "" indent-line-function] 4 "\
Grab the current expression with comint-get-old-input.  If we have
a complete sexp, send it.  Otherwise, indent appropriately." nil])
(fset 'close-and-send-lisp #[nil "À ˆ	\n>«ƒÃ ‡Ä ‡" [reindent-lisp major-mode ilisp-modes return-ilisp eval-defun-lisp] 2 "\
Close and indent the current sexp then send it to the inferior
LISP." nil])
(fset 'raw-keys-ilisp #[nil "¬³Á Ã\n!«‡Ä\nÅ\"ˆª›ÆÆÈW«’É\nÊË\"Å#ˆT‰ªj)É\nÌÍ#ˆ\n)Î!ˆÏ!‡" [ilisp-raw-map make-keymap map vectorp fillarray ilisp-send-char 0 i 128 define-key make-string 1 "" interactive-keys-ilisp use-local-map message ilisp-raw-message] 6 "\
Start using raw keyboard mode to send each character typed to the
inferior LISP until a key bound to interactive-keys-ilisp is
encountered.  See also io-bridge-ilisp." nil])
(fset 'interactive-keys-ilisp #[nil "À	!ˆÂÃ!‡" [use-local-map ilisp-use-map message "Interactive keyboard mode"] 2 "\
Go back to interactive keyboard interactions in the inferior LISP." nil])
(fset 'ilisp-send-char #[nil "ÀÁÂ\"«”dbˆcˆÄÅ !`Æ“ˆ`Æ“ˆÈÅ ÉÊ\"\"ˆË!‡" [ilisp-value ilisp-raw-echo t last-input-char process-mark ilisp-process nil comint-last-input-end process-send-string make-string 1 message ilisp-raw-message] 5 "\
Send the last typed character to the current inferior LISP echoing
if ilisp-raw-echo is T." nil])
(fset 'ilisp-raw-handler #[(process output) "À ‡" [raw-keys-ilisp] 1 "\
Turn on raw keyboard mode."])
(fset 'ilisp-interactive-handler #[(process output) "À ‡" [interactive-keys-ilisp] 1 "\
Turn on interactive keyboard mode."])
(fset 'io-bridge-ilisp #[nil "ÀÁ!ˆÂ ˆÃÄBB‰‡" [require bridge install-bridge ("1" . ilisp-raw-handler) ("0" . ilisp-interactive-handler) bridge-handlers] 3 "\
Set up so that the inferior LISP can turn on EMACS raw mode by
sending ^[1^] and turn it off by sending ^[0^]." nil])
(fset 'delete-char-or-pop-ilisp #[(arg &optional killflag) "m«ŒÀÁ!ˆÂÃ ÄÅ!\"‡ÆÇ	D\"‡" [message "Pop LISP one level" comint-simple-send ilisp-process ilisp-value comint-fix-error call-interactively delete-char arg killflag] 4 "\
Delete ARG characters, or pop break level if at end of buffer.  
Optional second arg KILLFLAG non-nil means kill instead (save in kill ring).
Interactively, ARG is the prefix arg, and KILLFLAG is set if
ARG was explicitly specified." "p"])
(fset 'reset-ilisp #[nil "ÀÁ!ˆÂÃ ÄÅ!\"‡" [message "Reset LISP to top level" comint-simple-send ilisp-process ilisp-value ilisp-reset] 4 "\
Reset the inferior LISP top level." nil])
(fset 'ilisp-display-choices #[(symbol choices) "ÀÁÂÃÄ!\"Ç\"!‘‡" [" *Completions*" display-completion-list sort all-completions lisp-symbol-name symbol choices string-lessp] 6 "\
Display the possible choices for SYMBOL in alist CHOICES."])
(fset 'ilisp-can-complete #[(symbol function-p) "­¡Á!Á\n!˜­˜Ã!Ã\n!˜­ÄÅ!Å\n!\"­…=‡" [ilisp-original lisp-symbol-package symbol lisp-symbol-delimiter lisp-prefix-p lisp-symbol-name function-p ilisp-original-function-p] 4 "\
Return T if ilisp completion can complete SYMBOL from the current table."])
(fset 'ilisp-complete #[(symbol &optional function-p) "ÀÁÂÃ!Ä!Æ!È!É˜\n&?­ŠÌ­ÍÎ!QÏ#ÂÑÒ\"«Ó!ˆÔÕÎ!\"ˆªÖ!‰×=?­‚‰)‡" [ilisp-send format ilisp-value ilisp-complete-command lisp-symbol-name symbol lisp-symbol-package function-p lisp-symbol-delimiter ":" ilisp-prefix-match ilisp-complete "Complete " "function " lisp-buffer-symbol complete choices comint-errorp t lisp-display-output error "Error completing %s" read NIL ilisp-original ilisp-original-function-p ilisp-original-table] 9 "\
Return a list of the possible completions for symbol from the
inferior LISP.  If FUNCTION-P is T, only symbols with function
bindings will be considered.  If no package is specified the buffer
package will be used."])
(fset 'ilisp-completion-table #[(symbol function-p) "À	\n\"«‚‡Ä	\n\"‡" [ilisp-can-complete symbol function-p ilisp-original-table ilisp-complete] 3 "\
Return the completion table for SYMBOL trying to use the current
one.  If FUNCTION-P is T, only symbols with function cells will be
returned."])
(fset 'ilisp-restore-prefix #[nil "­‹ŠebˆcˆÁ‰)‡" [ilisp-mini-prefix nil] 2 "\
Restore the prefix from ilisp-mini-prefix at the start of the
minibuffer."])
(fset 'ilisp-current-choice #[nil "«†ÁfÂ=«§Ã ‰@Æ\"*ŠÉÊxˆe`{e`|ˆ)?­ŒÌ‰‡Ê‰‡" [ilisp-table 1 40 lisp-previous-symbol symbol-info symbol ilisp-completion-table ilisp-completion-function-p minibuffer-completion-table "^: (" nil ilisp-mini-prefix ((" ")) minibuffer-completion-predicate] 4 "\
Set up the minibuffer completion table for the current symbol.
If there is a paren at the start of the minibuffer, or there is not an
ilisp-table, this will be from the inferior LISP.  Otherwise, it will
be the ilisp-table."])
(byte-code "ÀÁ!¬…ÂÄ\"À‡" [boundp ilisp-completion-help lookup-key minibuffer-local-must-match-map "?"] 3)
(fset 'ilisp-completion-help #[nil "À ˆ	 ˆÂ ‡" [ilisp-current-choice ilisp-completion-help ilisp-restore-prefix] 1 "\
Inferior LISP minibuffer completion help." nil])
(byte-code "ÀÁ!¬…ÂÄ\"À‡" [boundp ilisp-completion lookup-key minibuffer-local-must-match-map "	"] 3)
(fset 'ilisp-completion #[nil "À ˆ	 ˆÂ ‡" [ilisp-current-choice ilisp-completion ilisp-restore-prefix] 1 "\
Inferior LISP minibuffer complete." nil])
(byte-code "ÀÁ!¬…ÂÄ\"À‡" [boundp ilisp-completion-word lookup-key minibuffer-local-must-match-map " "] 3)
(fset 'ilisp-completion-word #[nil "ÀfÁ=«ƒÂc‡Ã ˆ ˆÅ ‡" [1 40 " " ilisp-current-choice ilisp-completion-word ilisp-restore-prefix] 2 "\
Inferior LISP minibuffer complete word." nil])
(fset 'ilisp-completion-paren #[nil "«‘	Â=¬†ÃfÂ=«ƒ	c‡Ä ‡Ä ‡" [ilisp-paren last-input-char 40 1 beep] 2 "\
Only allow a paren if ilisp-paren is T." nil])
(byte-code "ÀÁ!¬…ÂÄ\"À‡" [boundp ilisp-completion-exit lookup-key minibuffer-local-must-match-map "\n"] 3)
(fset 'ilisp-completion-exit #[nil "ÀfÁ=«‡ÂÃ!ˆÄ ‡«ƒÄ ‡edU«ƒÄ ‡Æ ˆÇ )‡" [1 40 find-unbalanced-lisp nil exit-minibuffer ilisp-no-complete ilisp-current-choice ((ilisp-restore-prefix)) ilisp-completion-exit] 2 "\
Inferior LISP completion complete and exit." nil])
(fset 'ilisp-completer #[(symbol function-p) "À	!Ã	\"‰­„Æ\n\"‰È=«‡	‰ÉÈFªÜ\n˜«Š	‰Ê\n\"ÉFªÌ«—ËÌ	!Í	!#‰‰Ê\"ÉF)ª±?­¬­©Ï\nÉĞ!$ËÌ	!Í	!@#ËÌ	!Í	!A@#AA)BB+‡" [lisp-symbol-name symbol name ilisp-completion-table function-p table try-completion choice t nil all-completions lisp-symbol lisp-symbol-package lisp-symbol-delimiter ilisp-prefix-match completer regexp-quote completer-words matches] 7 "\
Complete SYMBOL from the inferior LISP using only function symbols
if FUNCTION-P is T.  Return (SYMBOL LCS-SYMBOL CHOICES UNIQUEP)."])
(fset 'lisp-string-to-symbol #[(string) "ÀÁ\n\"‰­‚Ä•«˜ÆÄU«ƒÇª„\nÄO\nO\nÈO#ªÉ \nÆ\n‰­Ë\n#)*‡" [string-match ":+" string start 0 end lisp-symbol "" nil lisp-buffer-package package "::"] 7 "\
Convert STRING to a symbol, (package delimiter symbol) where the
package is either package:symbol or from the current buffer."])
(fset 'lisp-symbol-to-string #[(symbol) "ÀÁ\n\"‡" [apply concat symbol] 3 "\
Convert SYMBOL to a string."])
(fset 'lisp-buffer-symbol #[(symbol) "À	!Â	!Ã	!Ç ˜«„ª—È˜«†ÉPªŒ«‡Qª‚+‡" [lisp-symbol-name symbol lisp-symbol-package lisp-symbol-delimiter delimiter pkg symbol-name lisp-buffer-package "" ":"] 4 "\
Return SYMBOL as a string qualified for the current buffer."])
(fset 'lisp-previous-symbol #[(&optional stay) "Š	>«‰`ÂÃp!!U®ŒÄÅxˆo®…`SfÆ>?­ÕÇÈ!	\n¬…	Åwˆ`	Åxˆ`o?­ƒS‰­fÎ=¬“fÏ=­o?­ŒSfĞ=­„ÑÒ!?Ô{!E-B)‡" [major-mode ilisp-modes process-mark get-buffer-process " 	\n" nil (41 34) ilisp-value ilisp-symbol-delimiters delimiters stay end start prefix 40 39 35 looking-at "[^: 	\n]*:*\\*[^ 	\n]" function-p lisp-string-to-symbol] 5 "\
Return the immediately preceding symbol as ((package delimiter symbol)
function-p start end).  If STAY is T, the end of the symbol will be point."])
(fset 'lisp-previous-sexp #[(&optional prefix) "ŠÀÁÂ)‡" [nil (byte-code "	>­‡`ÂÃp!!U?­§m¬‰`fÄ>¬ƒÅ ˆÆÇxˆ`É ˆÊÇxˆ¬„ÌÇwˆ`{)‡" [major-mode ilisp-modes process-mark get-buffer-process (32 41 10 9) forward-sexp " 	\n" nil point backward-sexp "^ 	\n(\"," prefix "#'"] 4) ((error))] 3 "\
Return the previous sexp.  If PREFIX is T, then prefix like ' or #'
are allowed."])
(fset 'lisp-def-name #[(&optional namep) "ÀÂÃ!­¹Ä”Ä•{Æ•«™?­‡È”È•{ÉPÊÆ”Æ•{ÉË°ª•È•«?­‡È”È•{ÉPPª))‡" [t case-fold-search looking-at "\\(\\((\\(def[^ 	\n]*\\)[ 	\n]+\\(\\((\\(setf\\)[ 	\n]+\\)\\|(?\\)\\)\\|(?\\)\\([^ 	\n)]*\\)" 7 symbol 6 namep 3 " " "(" ")"] 6 "\
Return the name of a definition assuming that you are at the start
of the sexp.  If the form starts with DEF, the form start and the next
symbol will be returned.  Optional NAMEP will return only the name without the defining symbol."])
(fset 'lisp-function-name #[nil "ŠÀ ‰A@«„	@ª„ÂÃÄ*‡" [lisp-previous-symbol symbol nil (byte-code "	>­‡`ÂÃp!!U?­‘ÄÅ!ˆÆÅ!ˆÇ`ÈÅ!ˆ`{!‡" [major-mode ilisp-modes process-mark get-buffer-process backward-up-list 1 down-list lisp-string-to-symbol forward-sexp] 4) ((error))] 4 "\
Return the previous function symbol.  This is either after a #' or
at the start of the current sexp.  If there is no current sexp, return
nil."])
(fset 'lisp-minus-prefix #[nil "­•9«„ÁÂ‡Ã!‰ÄW­„[Â‡" [current-prefix-arg nil t prefix-numeric-value 0] 2 "\
Set current-prefix-arg to its absolute value if numeric and return
T if it is a negative."])
(defvar ilisp-completion-map nil "\
Keymap for reading ilisp readers.")
(fset 'ilisp-completion-map #[nil "¬ãÁÂ\"«Ä ÅÀ\"ˆÆ\"ˆª…È!ÉÊË#ˆÉÌÍ#ˆÉÎÏ#ˆÉĞÍ#ˆÉÑÒ#ˆÉÓÒ#ˆÉÔÕ#ˆÉÖ×#ˆÉØ×#ˆÉÙÚ#ˆÉÛÚ#ˆÉÜÚ#ˆ‡" [ilisp-completion-map string-match "Lucid" emacs-version make-keymap set-keymap-name set-keymap-parent lisp-mode-map copy-keymap define-key " " ilisp-completion-word "	" ilisp-completion "?" ilisp-completion-help "‰" "\n" ilisp-completion-exit "" "" abort-recursive-edit "(" ilisp-completion-paren ")" "'" nil "#" "\""] 4 "\
Set up the ilisp-completion-map from lisp-mode-map for the ilisp
readers and return it."])
(fset 'ilisp-read #[(prompt &optional initial-contents) "À‰‰Á ÆÉ #,‡" [t lisp-buffer-package ilisp-completion-package ilisp-no-complete ilisp-paren ilisp-complete read-from-minibuffer prompt initial-contents ilisp-completion-map] 4 "\
PROMPT in the minibuffer with optional INITIAL-CONTENTS and return
the result.  Completion of symbols though the inferior LISP is
allowed."])
(defvar lisp-program-map nil "\
Minibuffer map for reading a program and arguments.")
(fset 'lisp-read-program #[(prompt &optional initial) "¬–Á\n!ÃÄÅ#ˆÃÆÅ#ˆÃÇÈ#ˆÉ\n#‡" [lisp-program-map copy-keymap minibuffer-local-map define-key "‰" comint-dynamic-complete "	" "?" comint-dynamic-list-completions read-from-minibuffer prompt initial] 4 "\
Read a program with PROMPT and INITIAL.  TAB or Esc-TAB will complete
filenames."])
(fset 'ilisp-read-symbol #[(prompt &optional default function-p no-complete) "À\nÄ È	ÊË #‰Íš«„ª„Ï!-‡" [t ilisp-complete no-complete ilisp-no-complete lisp-buffer-package ilisp-completion-package function-p ilisp-completion-function-p read-from-minibuffer prompt nil ilisp-completion-map string "" default lisp-string-to-symbol] 5 "\
PROMPT in the minibuffer with optional DEFAULT and return a symbol
from the inferior LISP.  If FUNCTION-P is T, only symbols with
function values will be returned.  If NO-COMPLETE is T, then
uncompleted symbols will be allowed."])
(fset 'ilisp-completing-read #[(prompt table &optional default) "À\nÄ \nÆ‰«–¬’@@ÉœÊUA‰¬j*ÌÆÎ #‰Ğ˜«„ª‚-‡" [t ilisp-complete table ilisp-table lisp-buffer-package ilisp-completion-package nil done entry 0 40 ilisp-paren read-from-minibuffer prompt ilisp-completion-map string "" default] 5 "\
Read with PROMPT from an alist of TABLE.  No input returns DEFAULT.
Symbols are from table, other specs are in parentheses."])
(fset 'lisp-at-start #[nil "Š`ÁyˆÂ ˆ`U­*‡" [point 0 comint-skip-prompt] 2 "\
Return the point if you are at the start of an input expression in
an inferior Lisp."])
(fset 'lisp-input-start #[nil "ÀÁp!!`\nY«„\nbªÃˆÄeÆ#«„Ç ª`)‡" [process-mark get-buffer-process pmark nil re-search-backward comint-prompt-regexp stay comint-skip-prompt] 4 "\
Go to the start of the input region."])
(fset 'lisp-defun-region-and-name #[nil "ŠÀ Á \nÄ E+‡" [lisp-defun-end lisp-defun-begin begin end lisp-def-name] 3 "\
Return the region of the current defun and the name starting it."])
(fset 'lisp-defun-name #[nil "ŠÀ ˆÁÂÃ!!)‡" [lisp-defun-begin lisp-string-to-symbol lisp-def-name t] 3 "\
Return the name of the current defun."])
(fset 'lisp-region-name #[(start end) "ŠbˆÁÂÄ#«ƒÅuˆ`bˆÆÂÇ#ˆÈˆÉÈxˆ`^bˆ`fÊU«„Ë ª†`Ì ˆ`{bˆ`SfÎU«•Ï ˆ`U«„ª—ĞÑË RªĞÑŠÏ ˆ`)`S{R*‡" [start re-search-forward "^[ 	]*[^;\n]" end t -1 re-search-backward move nil " 	" 40 lisp-def-name forward-sexp from 41 backward-sexp "from " " to "] 5 "\
Return a name for the region from START to END."])
(fset 'bol-ilisp #[(arg) "Àyˆ	?­ŒÂ ®ˆ­…Â )‡" [0 arg comint-skip-prompt ilisp-other-prompt comint-prompt-regexp] 1 "\
Goes to the beginning of line, then skips past the prompt, if any.
If a prefix argument is given (\\[universal-argument]), then no prompt skip 
-- go straight to column 0.

The prompt skip is done by skipping text matching the regular expression
comint-prompt-regexp or ilisp-other-prompt, both buffer local variables." "P"])
(fset 'beginning-of-defun-lisp #[(&optional stay) "	>«“`?­‹\nÄ U­…ÅyˆÄ )‡Æ ‡" [major-mode ilisp-modes point stay lisp-input-start -1 beginning-of-defun] 2 "\
Go to the next left paren that starts at the left margin or after a
prompt in an ILISP buffer.  If optional STAY, then do not move to
prior defun if at the start of one in an ilisp mode." nil])
(fset 'end-of-defun-lisp #[nil "`	\n>«†ÃÄ!ˆª—Å ¬ÆyˆÇÈÉÄ#ˆÊ ˆn¬„ÃÄ!ˆËÄ!ˆ`U­Ÿ	\n>«‰ÇdÄ#ˆª„Íd!ˆm®„`fÎU?­ƒËÄ!)‡" [point major-mode ilisp-modes beginning-of-defun-lisp t lisp-in-string 0 re-search-forward "^[ 	\n]*[^; 	\n]" nil back-to-indentation lisp-end-defun-text comint-prompt-regexp lisp-skip 10] 4 "\
Go to the next left paren that starts at the left margin or after a
prompt in an ILISP buffer and go to the end of the expression." nil])
(fset 'newline-and-indent-lisp #[nil "«ƒÁ ‡Â`dU«¥>« Æ ‰«šÇ ?	\n	\"ˆË	!`Â“*ªŒ>«‡ŠÌ )d}ˆÍ ))‡" [ilisp-complete exit-minibuffer nil input major-mode ilisp-modes ilisp-get-old-input ilisp-process comint-send-newline process comint-input-sender process-mark lisp-input-start newline-and-indent] 3 "\
If at the end of the buffer, send the string back to the process
mark with no newline.  Otherwise, insert a newline, then indent.  In
an ilisp buffer the region is narrowed first.  See newline-and-indent
for more information." "*"])
(fset 'match-ring #[(ring regexp start) "ÀÁ\n!‰W«ÅÇ\n\"\"¬†T‰ªlU?­*‡" [0 ring-length ring len n string-match regexp ring-ref] 6 "\
Return the index in RING of REGEXP starting at START."])
(fset 'lisp-match-ring #[(regexp string &optional no-insert) "­†ÁÂ Ã#‰«±Å ˆ`ÇÂ \"cˆŠG\\bˆÉÊwˆ`)Ë!ˆÌ)Ğª‘­?­ˆÅ ˆcˆĞ)‡" [regexp match-ring get-input-ring 0 n comint-kill-input point ring-ref string "^ 	\n)" nil push-mark comint-previous-similar-input this-command input-ring-index comint-last-similar-string t no-insert] 5 "\
Match REGEXP in the input-ring of the current buffer and set the
ring variables to look like comint-previous-similar-input if found.
If not found insert STRING, unless NO-INSERT."])
(fset 'call-defun-lisp #[(arg) "ŠÀ ˆÁÂ!)ƒ— Ã Å!Ç!­†ÈÇ!ÉQ\nËÌ\"ËÎ\"ĞÑ‰\"ˆ«Ò”Ò•OÓ?­‡Õ\nÖR×P\"ªÁ«Ó?­…\nP\"ª­ØPÚ!Ó?­‡Ø\nÛR?#®‹ÓØ\nÜR\")-‡ŠÀ İÑ!{)ĞÑ‰\"ˆß ˆc)‡" [lisp-defun-begin looking-at "(def" lisp-defun-name symbol lisp-symbol-name name lisp-symbol-package "\\(" ":+\\)?" package string-match "^\\*" variablep "(setf \\([^)]+\\)" setfp switch-to-lisp t 1 lisp-match-ring arg "(setf[ 	\n]*(" "[ 	\n]" "(setf (" "(" fun regexp-quote "[ 	\n)]" "[^ 	\n]*-*" lisp-end-defun-text form comint-kill-input] 5 "\
Put a call of the current defun in the inferior LISP and go there.
If it is a (def* name form, look up reasonable forms of name in the
input history unless called with prefix ARG. If not found, use (name
or *name* as the call.  If is not a def* form, put the whole form in
the buffer." "P"])
(fset 'describe-lisp #[(sexp) "ÀÁÂÃ!Ä!Æ #ÇPÈ#	Ê	!)‡" [ilisp-send format ilisp-value ilisp-describe-command lisp-slashify sexp lisp-buffer-package "Describe " describe result lisp-display-output] 5 "\
Describe the current sexp using ilisp-describe-command.  With a
negative prefix, prompt for the expression.  If in an ILISP buffer,
and there is no current sexp, describe ilisp-last-command." (byte-code "À «ˆÁÂÃÄ!\"ª¢>«™`ÇÈp!!U«‹ÉÊÄ\"®ËÌ!ªˆÃÄ!ªƒÃÄ!C‡" [lisp-minus-prefix ilisp-read "Describe: " lisp-previous-sexp t major-mode ilisp-modes process-mark get-buffer-process ilisp-value ilisp-last-command error "No sexp to describe."] 4)])
(fset 'inspect-lisp #[(sexp) "ÀÁÂÃ!Ä!Æ #ÇPÈÉ$‡" [ilisp-send format ilisp-value ilisp-inspect-command lisp-slashify sexp lisp-buffer-package "Inspect " inspect t] 5 "\
Inspect the current sexp using ilisp-inspect-command.  With a
prefix, prompt for the expression.  If in an ILISP buffer, and there
is no current sexp, inspect ilisp-last-command." (byte-code "«ˆÁÂÃÄ!\"ª¢>«™`ÇÈp!!U«‹ÉÊÄ\"®ËÌ!ªˆÃÄ!ªƒÃÄ!C‡" [current-prefix-arg ilisp-read "Inspect: " lisp-previous-sexp t major-mode ilisp-modes process-mark get-buffer-process ilisp-value ilisp-last-command error "No sexp to inspect."] 4)])
(fset 'arglist-lisp #[(symbol) "¬„ÁÂ!‡ÃÄÅÆ!Ç!È!#ÉÊ!PË#ÍÎ\"ÅĞÑ\"¬š«–«’`TÔOcˆb)ªÕ«ˆÔOª‚!*‡" [symbol error "No symbol" ilisp-send format ilisp-value ilisp-arglist-command lisp-symbol-name lisp-symbol-package "Arglist " lisp-buffer-symbol args arglist string-match "(" position comint-errorp t current-prefix-arg temp nil lisp-display-output] 6 "\
Return the arglist of the currently looked at function.  With a
numeric prefix, the arglist will be inserted.  With a negative one,
the symbol will be prompted for." (byte-code "À Â «ŒÃÄÅÆ	!\"	Ç#ª	)C‡" [lisp-function-name function lisp-minus-prefix ilisp-read-symbol format "Arglist [%s]: " lisp-buffer-symbol t] 5)])
(fset 'documentation-lisp #[(symbol type) "ÀÁÂÃÄ!Å!Ç!$ÂÉÊ!#Ë#!‡" [lisp-display-output ilisp-send format ilisp-value ilisp-documentation-command lisp-symbol-name symbol lisp-symbol-package type "Documentation %s %s" lisp-buffer-symbol doc] 8 "\
Return the documentation of the previous symbol using
ilisp-documentation-command.  If the symbol is at the start of a list,
it is assumed to be a function, otherwise variable documentation is
searched for.  With a minus prefix, prompt for the symbol and type.
With a numeric prefix always return the current function call
documentation." (byte-code "À «ÌÁ ‰@ÄÅÆÇ!\"\"\nA@«ƒÉªÊÌÍÎ\"‰­’Ğ«‡ÅÑ\"ªÒ#;«†Ô!ª‚.D‡«…Ö ÉD‡Á ‰@\nA@«ƒÉªÊ)D‡" [lisp-minus-prefix lisp-previous-symbol symbol-info symbol ilisp-read-symbol format "Documentation [%s]: " lisp-buffer-symbol doc function variable default ilisp-value ilisp-documentation-types t types ilisp-completing-read "Type [%s]: " "Type: " type read current-prefix-arg lisp-function-name] 6)])
(fset 'lisp-macroexpand-form #[nil "ŠÀÁwˆ`Ã ˆ`\n{Æ «†ÇÈ\"ª,C‡" [" 	\n" nil begin forward-sexp end form lisp-minus-prefix ilisp-read "Macroexpand: "] 3 "\
Return the next form for macroexpanding."])
(fset 'macroexpand-lisp #[(form &optional top) "ÀÁ\n\"«ÄÃ«ƒÅªÆ\nÇ”Ç•OQÈ	\nËÌÍ«ƒÎªÏ!Ğ\n!Ñ Ò $\nÓ#	«ŠÕ ˆÖcˆ	c)ª„×	!*‡ØÙ\n\"‡" [string-match "(\\([^ 	\n)]*\\)" form "Macroexpand" top "-1 " " " 1 nil result message ilisp-send format ilisp-value ilisp-macroexpand-1-command ilisp-macroexpand-command lisp-slashify lisp-buffer-package buffer-file-name expand current-prefix-arg forward-sexp 10 lisp-display-output error "Not a form: %s"] 6 "\
Macroexpand the next sexp until it is no longer a macro.  With a
prefix, insert into buffer." (lisp-macroexpand-form)])
(fset 'macroexpand-1-lisp #[(form) "À	Â\"‡" [macroexpand-lisp form t] 3 "\
Macroexpand the next sexp once.  With a prefix, insert into buffer." (lisp-macroexpand-form)])
(autoload 'complete "completion" "\
Complete previous symbol." t)
(fset 'complete-lisp #[(mode) "À	!ÂW«ƒÃ ‡ŠÄÅxˆ`fÆU)‰«…È ˆªÑÉ ‰\n@Ì!Î	?­„\nA@\"Ğ@!ĞA@!AA@AAA@ÕÅxˆÖ×Ø!&ˆ.ÚÛ!)‡" [prefix-numeric-value mode 0 completer-undo "^ 	\n" nil 34 filep comint-dynamic-complete lisp-previous-symbol symbol-info symbol lisp-symbol-name name ilisp-completer choice lisp-buffer-symbol match lcs choices unique " 	\n" completer-goto ilisp-value ilisp-symbol-delimiters completer-words message "Completed"] 8 "\
Complete the current symbol using information from the current
ILISP buffer.  If in a string, complete as a filename.  If called with
a positive prefix force all symbols to be considered.  If called with
a negative prefix, undo the last completion.  Partial completion is
allowed unless ilisp-prefix-match is T.  If a symbol starts after a
left paren or #', then only function symbols will be considered.
Package specifications are also allowed and the distinction between
internal and exported symbols is considered." "P"])
(fset 'trace-defun-lisp #[(function) "«°ÁÂ«…ÄÅ!ªƒÄÆ!Ç!È!#ÂÉ«ƒÊªËÌ!#«ƒÍªÎ?­Ğ$‡ÑÒ«ƒÓªÔ\"‡" [function ilisp-send format current-prefix-arg ilisp-value ilisp-untrace-command ilisp-trace-command lisp-symbol-name lisp-symbol-package "%srace %s" "Unt" "T" lisp-buffer-symbol untrace trace lisp-wait-p dispatch error "No function to %strace" "un" ""] 7 "\
Trace FUNCTION without arg, untrace with.  Prompt for function with
negative prefix.  Default function is the current defun." (byte-code "À Â «“ÃÄ«ƒÆªÇÈ	!\"	É#Cª‚	C)‡" [lisp-defun-name function lisp-minus-prefix ilisp-read-symbol format current-prefix-arg "Untrace [%s]: " "Trace [%s]: " lisp-buffer-symbol t] 5)])
(fset 'default-directory-lisp #[(&optional buffer) "¬²	\n>«­ÃÄÅ!ÆÇ!È#ÄÉÊ\"«ŠË!ˆÌÍ!ªÎ!‰ĞBÒÓ\")‡Š®pqˆ)ÃÆÄÕ!\"ÆÖ×Ø !#È?­Ú$)‡" [buffer major-mode ilisp-modes ilisp-send ilisp-value ilisp-directory-command format "Getting LISP directory" dir comint-errorp t lisp-display-output error "Error getting directory" read default-directory nil lisp-prev-l/c-dir/file message "Default directory is %s" directory ilisp-set-directory-command "Set %s's directory to %s" buffer-name ilisp-buffer lisp-wait-p dispatch] 7 "\
Set the inferior LISP default directory to the default directory of
optional BUFFER.  If you are in an inferior LISP buffer, set the
default directory to the current directory of the LISP." nil])
(autoload 'lisp-directory "ilisp-src" "\
Select directories to search." t)
(autoload 'next-definition-lisp "ilisp-src" "\
Edit the next definition." t)
(autoload 'edit-definitions-lisp "ilisp-src" "\
Edit definitions." t)
(autoload 'search-lisp "ilisp-src" "\
Search for pattern in source files." t)
(autoload 'replace-lisp "ilisp-src" "\
Relace pattern in source files." t)
(autoload 'who-calls-lisp "ilisp-src" "\
Show callers of a function." t)
(autoload 'next-caller-lisp "ilisp-src" "\
Edit the next caller of a function." t)
(autoload 'edit-callers-lisp "ilisp-src" "\
Edit the callers of a function." t)
(fset 'lisp-send-region #[(start end switch message status format &optional handler) "	U«„ÂÃ!ˆÄ	ÅÆ$	{ÉÊ	!ËÌU«„ª‡ÉÊÍ!\"!Î Ï $ĞÔ>«„ª•Ö =«Š¬†Ø=«ƒÙªÚ%‰«¯«Š	bˆÜcˆc)ª ÊİŞ\"¬‡ßà\"«†á!ªâŞ!ˆÑã\"ª‚+‡" [start end error "Region is empty" lisp-count-pairs 40 41 string sexp format ilisp-value lisp-slashify 1 ilisp-block-command lisp-buffer-package buffer-file-name ilisp-send message status switch (t call) lisp-wait-p lisp-minus-prefix current-prefix-arg result nil dispatch handler 10 comint-errorp t string-match "\n" lisp-display-output popper-bury-output "%s"] 7 "\
Given START, END, SWITCH, MESSAGE, STATUS, FORMAT and optional
HANDLER send the region between START and END to the lisp buffer and
execute the command defined by FORMAT on the region, its package and
filename.  If called with a positive prefix, the results will be
inserted at the end of the region.  If SWITCH is T, the command will
be sent and the buffer switched to the inferior LISP buffer.  if
SWITCH is 'call, a call will be inserted.  If SWITCH is 'result the
result will be returned without being displayed.  Otherwise the
results will be displayed in a popup window if lisp-wait-p is T and
the current-prefix-arg is not '- or if lisp-wait-p is nil and the
current-prefix-arg is '-.  If not displayed in a pop-up window then
comint-handler will display the results in a pop-up window if they are
more than one line long, or they are from an error.  STATUS will be
the process status when the command is actually executing.  MESSAGE is
a message to let the user know what is going on."])
(fset 'eval-region-lisp #[(start end &optional switch message status handler) "®†ÁÂ\"PÅÆÇ\"‰«±ŠbˆÉÊwˆÇÌ!)­ŠÍ ˆÉwˆ`U)«’Î®ÈÑ&ªÎ®ÓÔ&)‡" [message "Evaluate " lisp-region-name start end ilisp-value ilisp-defvar-regexp t defvar " 	\n" nil case-fold-search looking-at forward-sexp lisp-send-region switch status ilisp-defvar-command handler eval ilisp-eval-command] 9 "\
Evaluate the current region." "r"])
(fset 'eval-next-sexp-lisp #[(&optional switch) "À‰Š`Ã ˆ`)Ä\n	ÆÇ\n	{\"$*‡" [nil end start forward-sexp eval-region-lisp switch format "Evaluate %s"] 8 "\
Evaluate the next sexp." nil])
(fset 'eval-defun-lisp #[(&optional switch) "À Â	@	A@ÄÅ	AA@\"$)‡" [lisp-defun-region-and-name form eval-region-lisp switch format "Evaluate %s"] 7 "\
Evaluate the current form." nil])
(fset 'eval-region-and-go-lisp #[(start end) "À	\nÃ#‡" [eval-region-lisp start end t] 4 "\
Evaluate the current region and switch to the current ILISP buffer." "r"])
(fset 'eval-next-sexp-and-go-lisp #[(&optional switch) "ÀÁ!‡" [eval-next-sexp-lisp t] 2 "\
Evaluate the next sexp and switch to the current ILISP buffer." nil])
(fset 'eval-defun-and-go-lisp #[nil "À	«…ÂÃªÄ!‡" [eval-defun-lisp current-prefix-arg nil call t] 2 "\
Evaluate the current defun and switch to the current ILISP buffer.
With prefix, insert a call as well." nil])
(fset 'compile-region-lisp #[(start end &optional switch message status handler) "À	\n®†ÅÆ	\n\"P®ÈÉ\n&‡" [lisp-send-region start end switch message "Compile " lisp-region-name status compile ilisp-compile-command handler] 8 "\
Compile the current region." "r"])
(fset 'compile-defun-lisp #[(&optional switch) "À ‰@	A@\nU«œ>«—ŠÆÇ \"Éqˆed|ˆ	cˆÊ *ªË\nÍÎ	AA@\"$+‡" [lisp-defun-region-and-name form start end major-mode ilisp-modes ring-ref get-input-ring input-ring-index "*ilisp-send*" compile-defun-lisp compile-region-lisp switch format "Compile %s"] 8 "\
Compile the current defun or the last command in the input-ring of
an ILISP buffer if no current defun." nil])
(fset 'compile-region-and-go-lisp #[(start end) "À	\nÃ#‡" [compile-region-lisp start end t] 4 "\
Compile the current region and switch to the current ILISP buffer." "r"])
(fset 'compile-defun-and-go-lisp #[nil "À	«…ÂÃªÄ!‡" [compile-defun-lisp current-prefix-arg nil call t] 2 "\
Compile the current defun and switch to the current ILISP buffer." nil])
(autoload 'mark-change-lisp "ilisp-bat" "\
Mark the current defun as changed." t)
(autoload 'list-changes-lisp "ilisp-bat" "\
List the current LISP changes." t)
(autoload 'clear-changes-lisp "ilisp-bat" "\
Clear the list of LISP changes." t)
(autoload 'eval-changes-lisp "ilisp-bat" "\
Evaluate the list of LISP changes." t)
(autoload 'compile-changes-lisp "ilisp-bat" "\
Compile the list of LISP changes." t)
(defvar lisp-prev-l/c-dir/file nil "\
Saves the (directory . file) pair used in the last find-file-lisp,
load-file-lisp or compile-file-lisp command. Used for determining the
default in the next one.")
(defvar lisp-buffer-file nil "\
Cons of buffer-file-name and the expanded name.")
(make-variable-buffer-local 'lisp-buffer-file)
(fset 'lisp-find-file #[(file &optional pop no-name) "À ÂÄÆ!É\n¬”ÌÍ#«…Â•ªsÉO\n	«ÊŠ	@qˆ?­‚Î Ğ ‰@˜«„ªŠÆ!B‰A«‡\n˜¬‡˜«ˆÉªƒ	A,ª3-«‡ÕÖ!!‡×!‡" [buffer-list buffers 0 position t expand-symlinks expand-file-name file expanded nil filename no-name string-match "/" buffer-name name buffer-file-name buffer-file lisp-buffer-file buffer-expanded pop lisp-pop-to-buffer find-file-noselect find-file] 5 "\
Find FILE, optionally POPping.  If optional NO-NAME is nil, and
there is a buffer with a name that is the same as the final pathname
component, select that instead of reading the file associated with the
full path name.  If the expanded name of FILE and buffer match, select
that buffer."])
(fset 'find-file-lisp #[(file-name) "À	!Â	!BÄ	ÅÆ#‡" [file-name-directory file-name file-name-nondirectory lisp-prev-l/c-dir/file lisp-find-file nil t] 4 "\
Find a file.  If point is on a string that points to an existing
file, that will be the default.  If the buffer is one of
lisp-source-modes, the buffer file will be the default.  Otherwise,
the last file used in a lisp-source-mode will be used." (comint-get-source "Find file: " lisp-prev-l/c-dir/file lisp-source-modes nil)])
(fset 'load-file-lisp #[(file-name) "À	!ˆÂ	!Ã	!BÅÆ!ˆÇÈÆ\"	Ê		\"ŠÌ qˆ=¬ÏĞ!«…Ñ ˆª”ÒÓ!ˆ=¬‰Ô ˆÕÖ!ˆªp×@!@«ÏØ!«™Ù@!Û ˆA¬‰Ô ˆÕÖ!ˆªr))Ü	\"«š¬Ÿ	«›ÏŞ!«–Òß!ˆà	!ˆª‰á!«ƒâÆ‰\"ˆãä åÇæ!	\"\"ˆÒç	\"*‡" [comint-check-source file-name file-name-directory file-name-nondirectory lisp-prev-l/c-dir/file ilisp-init t ilisp-value ilisp-binary-extension extension lisp-file-extension binary ilisp-buffer comint-send-queue comint-end-queue y-or-n-p "Abort commands before loading? " abort-commands-lisp message "Waiting for commands to finish" accept-process-output sit-for 0 comint-send-variables "Interrupt top level? " comint-send-results result interrupt-subjob-ilisp file-newer-than-file-p ilisp-load-no-compile-query "Compile first? " "" compile-file-lisp file-readable-p switch-to-lisp comint-sender ilisp-process format ilisp-load-command "Loading %s"] 5 "\
Load a lisp file into the current inferior LISP and go there." (comint-get-source "Load Lisp file: " lisp-prev-l/c-dir/file lisp-source-modes nil)])
(fset 'compile-file-lisp #[(file-name &optional extension) "À	!ˆÂ	!Ã	!BÅÆ!ˆÇÈÉÊ!	®ƒÉÌ!#Í	PÎÆ$‡" [comint-check-source file-name file-name-directory file-name-nondirectory lisp-prev-l/c-dir/file ilisp-init t ilisp-send format ilisp-value ilisp-compile-file-command extension ilisp-binary-extension "Compile " compile] 6 "\
Compile a Lisp file in the current inferior LISP and go there." (comint-get-source "Compile Lisp file: " lisp-prev-l/c-dir/file lisp-source-modes nil)])
(fset 'lisp-add-dialect #[(dialect) "À	\nÃ#?­†	C\nB‰‡" [lisp-memk dialect ilisp-dialects car] 4 "\
Add DIALECT as a supported ILISP dialect."])
(fset 'ilisp-start-dialect #[(buffer program setup) "Á=«‚Âp«‡ÄÅ\"ª‚!ˆ®Œ«‡ÉÊ\"ª‚Ì!‡" [current-prefix-arg 0 nil ilisp-last-buffer read-from-minibuffer "Buffer: " buffer setup program lisp-read-program "Program: " ilisp-program ilisp] 3])
(fset 'defdialect '(macro . #[(dialect full-name parent &rest body) "ÀÁÂ\"!ÀÁÄ\"!ÀÁÅ\"!ÁÆ\"	\nËÌ	ÍÁÎ\"FÌÍÁĞ\"FÑÒ\nCÓÁÔ\"ÀÁÕ\"!DØÙÚÙEÛÜİDÛE¯ŞİÀÁÄ\"!DDD&ßàÁá\"âãÚäEÈİ\nDFØÙE¯åD¯,‡" [read format "setup-%s" dialect "%s-hook" "%s-program" "%s" dialects program hook setup progn defvar nil "*Inferior %s hook." full-name "*Inferior %s default program." append (defun) ((buffer)) "Set up for interacting with %s." "(setup-%s buffer)" parent body setq ilisp-program or ilisp-dialect cons quote run-hooks defun (&optional buffer program) "Create an inferior %s.  With prefix, prompt for buffer and program." (interactive (list nil nil)) ilisp-start-dialect buffer lisp-add-dialect] 16 "\
Define a new ILISP dialect.  DIALECT is the name of the function to
invoke the inferior LISP. The hook for that LISP will be called
DIALECT-hook.  The default program will be DIALECT-program.  FULL-NAME
is a string that describes the inferior LISP.  PARENT is the name of
the parent dialect."]))
(fset 'setup-ilisp #[(buffer) "ÀÁ!qˆÂ ˆÃ ˆÄÅ\"À!qˆÈ	ÊÌÍ!ˆ«”Ô@!ˆ@ÕLˆA‰¬l«„«„+ÖØÚÜŞà!Í\"Í#Õ$å&ç(é*ë,í-î/ğ1ò2ó456÷8ù:û<ı=ş?@ AB CD EF GH I !‡" [get-buffer-create "*ilisp-send*" kill-all-local-variables lisp-mode format "*%s*" buffer ilisp-buffer ilisp-mode major-mode "ILISP" mode-name lisp-mode-variables t ilisp-binary-extension ilisp-init-binary-extension ilisp-locals vars init binary make-local-variable nil "^[^<> ]*>+:? *" comint-prompt-regexp 200 input-ring-size ilisp-get-old-input comint-get-old-input ignore comint-input-sentinel ilisp-input-filter comint-input-filter comint-default-send comint-input-sender comint-eol-on-send comint-send-newline comint-always-scroll " *Output*" comint-output-buffer " *Error Output*" comint-error-buffer "^\"ILISP:" comint-error-regexp identity comint-output-filter comint-interrupt-start ilisp-handler comint-handler ilisp-update-status comint-update-status comint-prompt-status ilisp-abort-handler comint-abort-hook ilisp-mode-map ilisp-use-map ((lambda nil (ilisp-init nil nil t))) ilisp-init-hook "\\`\\s *\\(:\\(\\w\\|\\s_\\)*\\)?\\s *\\'" ilisp-filter-regexp 3 ilisp-filter-length ilisp-error-filter ".*" ilisp-error-regexp "^ 	\n('\"#.)<>" ilisp-symbol-delimiters "lisp" ilisp-program lisp-locate-ilisp ilisp-locator lisp-locate-calls ilisp-calls-locator run-hooks ilisp-mode-hook] 4 "\
Set up for interacting with an inferior LISP."])
(fset 'run-ilisp #[nil "ÀÁ\nÃÄ$‰GÆU?­…ÇÈ!!)‡" [completing-read "Dialect: " ilisp-dialects nil t dialect 0 call-interactively read] 6 "\
Create an inferior LISP prompting for dialect.  With prefix, prompt
for buffer name as well." nil])
(defvar clisp-hook nil "\
*Inferior Common LISP hook.")
(defvar clisp-program nil "\
*Inferior Common LISP default program.")
(fset 'setup-clisp #[(buffer) "À	!ˆÂÃ!¬„ÄÅ!ˆÆ™«…ÃªƒÃ	ÊÌÍÎ\"ˆÏÑÓÕ×ÙÛİß á\"ã$å&ç(é*ë,í.ï0ñ2ó4õ6÷8ù:û<ı>ÿ@A BC DE FG HI®‚JJÍKBKL M !‡" [setup-ilisp buffer fboundp common-lisp-indent-function load "cl-indent" "19" emacs-version lisp-indent-function lisp-indent-hook "(or (and (load \"%s\" :if-does-not-exist nil) t)\n             (and (load \"%s\" :if-does-not-exist nil) t))" ilisp-load-or-send-command ilisp-load-init clisp "clisp.lisp" "^[ 	]*(in-package[ 	\n]*" ilisp-package-regexp "(let ((*package* *package*)) %s (package-name *package*))" ilisp-package-command "(package-name *package*)" ilisp-package-name-command "(in-package \"%s\")" ilisp-in-package-command "*" ilisp-last-command "(progn (ILISP:ilisp-save) %s\n)" ilisp-save-command "(ILISP:ilisp-restore)" ilisp-restore-command "(progn %s\n)" ilisp-block-command "(ILISP:ilisp-eval \"%s\" \"%s\" \"%s\")" ilisp-eval-command "(defvar[ 	\n]" ilisp-defvar-regexp "(ILISP:ilisp-eval \"(let ((form '%s)) (progn (makunbound (second form)) (eval form)))\" \"%s\" \"%s\")" ilisp-defvar-command "(ILISP:ilisp-compile \"%s\" \"%s\" \"%s\")" ilisp-compile-command "(ILISP:ilisp-describe \"%s\" \"%s\")" ilisp-describe-command "(ILISP:ilisp-inspect \"%s\" \"%s\")" ilisp-inspect-command "(ILISP:ilisp-arglist \"%s\" \"%s\")" ilisp-arglist-command (("function") ("variable") ("structure") ("type") ("setf") ("class") ("(qualifiers* (class ...))")) ilisp-documentation-types "(ILISP:ilisp-documentation \"%s\" \"%s\" \"%s\")" ilisp-documentation-command "(ILISP:ilisp-macroexpand-1 \"%s\" \"%s\")" ilisp-macroexpand-1-command "(ILISP:ilisp-macroexpand \"%s\" \"%s\")" ilisp-macroexpand-command "(ILISP:ilisp-matching-symbols \"%s\" \"%s\" %s %s %s)" ilisp-complete-command lisp-locate-clisp ilisp-locator (("function") ("macro") ("variable") ("structure") ("type") ("setf") ("class") ("(qualifiers* (class ...))")) ilisp-source-types "(ILISP:ilisp-callers \"%s\" \"%s\")" ilisp-callers-command "(ILISP:ilisp-trace \"%s\" \"%s\")" ilisp-trace-command "(ILISP:ilisp-untrace \"%s\" \"%s\")" ilisp-untrace-command "(namestring *default-pathname-defaults*)" ilisp-directory-command "(setq *default-pathname-defaults* (parse-namestring \"%s\"))" ilisp-set-directory-command "(load \"%s\")" ilisp-load-command "(ILISP:ilisp-compile-file \"%s\" \"%s\")" ilisp-compile-file-command clisp-program ilisp-program ilisp-dialect run-hooks clisp-hook] 3 "\
Set up for interacting with Common LISP."])
(fset 'clisp #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "clisp" program setup-clisp ilisp-program clisp-program] 4 "\
Create an inferior Common LISP.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(lisp-add-dialect "clisp")
(fset 'allegro-check-prompt #[(old new) "«ÁÂ\"Ã=«ˆÄÃÅO!ªÆÁÂ\"Ã=«‰ÄÃÅO!ªÆ‰	X*‡" [old string-match "[0-9]+" 1 string-to-int nil 0 old-level new new-level] 5 "\
Compare the break level printed at the beginning of the prompt."])
(defvar allegro-hook nil "\
*Inferior Allegro Common LISP hook.")
(defvar allegro-program nil "\
*Inferior Allegro Common LISP default program.")
(fset 'setup-allegro #[(buffer) "À	!ˆÂÃÄ\"ˆÅÇÉ\nËÍÏÑÓÕ×\"ØÚ®‚ÃBßà!‡" [setup-clisp buffer ilisp-load-init allegro "allegro.lisp" ":pop" comint-fix-error ":reset" ilisp-reset ":cont" comint-continue "Error: [^\n]* interrupt)" comint-interrupt-regexp #[(old line) "À	\nÃ#‡" [comint-prompt-status old line allegro-check-prompt] 4] comint-prompt-status "^\\(\\[[0-9]*c*\\] \\|\\)\\(<\\|\\)[^>]*> " comint-prompt-regexp "\\(ILISP:[^\"]*\\)\\|\\(Error:[^\n]*\\)\\|\\(Break:[^\n]*\\)" ilisp-error-regexp "excl:*fasl-default-type*" ilisp-binary-command append ilisp-source-types (("any")) "(ILISP:ilisp-source-files \"%s\" \"%s\" \"%s\")" ilisp-find-source-command "(let ((ext (or #+m68k \"68fasl\"\n		        #+sparc \"sfasl\"\n		        #+iris4d \"ifasl\"\n                        #+dec3100 \"pfasl\"\n                        excl:*fasl-default-type*)))\n           #+allegro-v4.0 (setq ext (concatenate 'string ext \"4\"))\n           ext)" ilisp-init-binary-command allegro-program ilisp-program ilisp-dialect run-hooks allegro-hook] 3 "\
Set up for interacting with Allegro Common LISP."])
(fset 'allegro #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "allegro" program setup-allegro ilisp-program allegro-program] 4 "\
Create an inferior Allegro Common LISP.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(byte-code "ÀÁ!ˆ\n¬‚ÃÀ‡" [lisp-add-dialect "allegro" allegro-program "cl"] 2)
(fset 'lucid-check-prompt #[(old new) "«ÁÂ\"Ã=«‡Ã•Ã”ZªÃÁÂ\"Ã=«‡Ã•Ã”ZªÃ‰X*‡" [old string-match "\\(->\\)+" 0 old-level new new-level] 4 "\
Compare the break level printed at the beginning of the prompt."])
(defvar lucid-hook nil "\
*Inferior Lucid Common LISP hook.")
(defvar lucid-program nil "\
*Inferior Lucid Common LISP default program.")
(fset 'setup-lucid #[(buffer) "À	!ˆÂÃÄ\"ˆÅÇÉ\nËÍÏÑÓÕ\"ÖØ®‚ÃBİŞ!‡" [setup-clisp buffer ilisp-load-init lucid "lucid.lisp" "^\\(->\\)+ \\|^[^> ]*> " comint-prompt-regexp ":a" comint-fix-error ":a :t" ilisp-reset ":c" comint-continue ">>Break: Keyboard interrupt" comint-interrupt-regexp #[(old line) "À	\nÃ#‡" [comint-prompt-status old line lucid-check-prompt] 4] comint-prompt-status "ILISP:[^\"]*\\|>>[^\n]*" ilisp-error-regexp append ilisp-source-types (("any")) "(ILISP:ilisp-source-files \"%s\" \"%s\" \"%s\")" ilisp-find-source-command "(first (last lucid::*load-binary-pathname-types*))" ilisp-binary-command lucid-program ilisp-program ilisp-dialect run-hooks lucid-hook] 3 "\
Set up for interacting with Lucid Common LISP."])
(fset 'lucid #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "lucid" program setup-lucid ilisp-program lucid-program] 4 "\
Create an inferior Lucid Common LISP.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(byte-code "ÀÁ!ˆ\n¬‚ÃÀ‡" [lisp-add-dialect "lucid" lucid-program "lisp"] 2)
(fset 'kcl-check-prompt #[(old new) "­„ÁÂ\"‰«‡Ä•Ä”ZªÄÁÂ\"‰«‡Ä•Ä”ZªÄ‰X,‡" [old string-match ">+" was-in-break 0 old-level new is-in-break new-level] 4 "\
Compare the break level printed at the beginning of the prompt."])
(defvar kcl-hook nil "\
*Inferior Kyoto Common LISP hook.")
(defvar kcl-program nil "\
*Inferior Kyoto Common LISP default program.")
(fset 'setup-kcl #[(buffer) "À	!ˆÂÄÆÈ	ÊÌ®‚ĞBÒÓ!‡" [setup-clisp buffer "^>+" comint-prompt-regexp "Error: " ilisp-error-regexp "o" ilisp-binary-extension ":q" comint-fix-error ":r" comint-continue #[(old line) "À	\nÃ#‡" [comint-prompt-status old line kcl-check-prompt] 4] comint-prompt-status kcl-program ilisp-program kcl ilisp-dialect run-hooks kcl-hook] 2 "\
Set up for interacting with Kyoto Common LISP."])
(fset 'kcl #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "kcl" program setup-kcl ilisp-program kcl-program] 4 "\
Create an inferior Kyoto Common LISP.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(byte-code "ÀÁ!ˆ\n¬‚ÁÀ‡" [lisp-add-dialect "kcl" kcl-program] 2)
(defvar akcl-hook nil "\
*Inferior Austin Kyoto Common LISP hook.")
(defvar akcl-program nil "\
*Inferior Austin Kyoto Common LISP default program.")
(fset 'setup-akcl #[(buffer) "À	!ˆ\n®ÄBÆÇ!‡" [setup-kcl buffer akcl-program ilisp-program akcl ilisp-dialect run-hooks akcl-hook] 2 "\
Set up for interacting with Austin Kyoto Common LISP."])
(fset 'akcl #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "akcl" program setup-akcl ilisp-program akcl-program] 4 "\
Create an inferior Austin Kyoto Common LISP.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(byte-code "ÀÁ!ˆ\n¬‚ÁÀ‡" [lisp-add-dialect "akcl" akcl-program] 2)
(defvar ibcl-hook nil "\
*Inferior Ibuki Common LISP hook.")
(defvar ibcl-program nil "\
*Inferior Ibuki Common LISP default program.")
(fset 'setup-ibcl #[(buffer) "À	!ˆÂÄÆÈ	Ê®‚ÎBĞÑ!‡" [setup-kcl buffer "^[-A-Z]*>+\\|^[-A-Z]* ->" comint-prompt-regexp ">>Condition: Terminal Interrupt" comint-interrupt-regexp ":q" comint-continue ":q!" ilisp-reset ">>Error:" ilisp-error-regexp ibcl-program ilisp-program ibcl ilisp-dialect run-hooks ibcl-hook] 2 "\
Set up for interacting with Ibuki Common LISP."])
(fset 'ibcl #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "ibcl" program setup-ibcl ilisp-program ibcl-program] 4 "\
Create an inferior Ibuki Common LISP.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(byte-code "ÀÁ!ˆ\n¬‚ÁÀ‡" [lisp-add-dialect "ibcl" ibcl-program] 2)
(fset 'cmulisp-check-prompt #[(old new) "­„ÁÂ\"‰«‡Ä•Ä”ZªÄÁÂ\"‰«‡Ä•Ä”ZªÄ‰X,‡" [old string-match "]+" was-in-break 0 old-level new is-in-break new-level] 4 "\
Compare the break level printed at the beginning of the prompt."])
(defvar cmulisp-hook nil "\
*Inferior CMU Common LISP hook.")
(defvar cmulisp-program nil "\
*Inferior CMU Common LISP default program.")
(fset 'setup-cmulisp #[(buffer) "À	!ˆÂÃÄ\"ˆÅÇÉ\nËÍÏÑÓÕ×®‚ÛBİŞ!‡" [setup-clisp buffer ilisp-load-init cmu "cmulisp.lisp" "^\\([0-9]+\\]+\\|\\*\\) " comint-prompt-regexp #[(old line) "À	\nÃ#‡" [comint-prompt-status old line cmulisp-check-prompt] 4] comint-prompt-status "ILISP:[^\"]*\\|Error [^\n]*" ilisp-error-regexp "(ILISP:arglist \"%s\" \"%s\")" ilisp-arglist-command "(ILISP:source-file \"%s\" \"%s\" \"%s\")" ilisp-find-source-command ":pop" comint-fix-error ":go" comint-continue ":q" ilisp-reset "Software Interrupt" comint-interrupt-regexp "fasl" ilisp-binary-extension cmulisp-program ilisp-program cmulisp ilisp-dialect run-hooks cmulisp-hook] 3 "\
Set up for interacting with CMU Common LISP."])
(fset 'cmulisp #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "cmulisp" program setup-cmulisp ilisp-program cmulisp-program] 4 "\
Create an inferior CMU Common LISP.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(lisp-add-dialect "cmulisp")
(defvar scheme-hook nil "\
*Inferior Scheme hook.")
(defvar scheme-program nil "\
*Inferior Scheme default program.")
(fset 'setup-scheme #[(buffer) "À	!ˆÂÄ®‚È	B	ÊË!‡" [setup-ilisp buffer "(begin \n%s)" ilisp-block-command "(load \"%s\")" ilisp-load-command scheme-program ilisp-program scheme ilisp-dialect run-hooks scheme-hook] 2 "\
Set up for interacting with Scheme."])
(fset 'scheme #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "scheme" program setup-scheme ilisp-program scheme-program] 4 "\
Create an inferior Scheme.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(byte-code "ÀÁ!ˆ\n¬‚ÁÀ‡" [lisp-add-dialect "scheme" scheme-program] 2)
(defvar oaklisp-hook nil "\
*Inferior Oaklisp Scheme hook.")
(defvar oaklisp-program nil "\
*Inferior Oaklisp Scheme default program.")
(fset 'setup-oaklisp #[(buffer) "À	!ˆÂÄÆÈ	\n®‚ÌBÎÏ!‡" [setup-scheme buffer ">+ " comint-prompt-regexp "(ret 0)" comint-fix-error "*" ilisp-last-command "(describe %s)" ilisp-describe-command oaklisp-program ilisp-program oaklisp ilisp-dialect run-hooks oaklisp-hook] 2 "\
Set up for interacting with Oaklisp Scheme."])
(fset 'oaklisp #[(&optional buffer program) "À	®ÂÄ#ˆ‰‡" [ilisp-start-dialect buffer "oaklisp" program setup-oaklisp ilisp-program oaklisp-program] 4 "\
Create an inferior Oaklisp Scheme.  With prefix, prompt for buffer and program." (byte-code "À‰D‡" [nil] 2)])
(lisp-add-dialect "oaklisp")
(defvar ilisp-documentation "Major mode for interacting with an inferior LISP process.  Runs a\nLISP interpreter as a subprocess of Emacs, with LISP I/O through an\nEmacs buffer.  If you have problems, use M-x ilisp-bug in the buffer\nwhere you are having a problem to send a bug report.\n\nTo start a LISP use M-x run-ilisp, or a specific dialect like M-x\nallegro.  If called with a prefix you will be prompted for a buffer\nname and a program to run.  The default buffer name is the name of the\ndialect.  The default program for a dialect will be the value of\nDIALECT-program or the value of ilisp-program inherited from a less\nspecific dialect.  If there are multiple LISP's, use the dialect name\nor select-ilisp (\\[select-ilisp]) to select the current ILISP\nbuffer.\n\nCurrently supported LISP dialects include:\n clisp\n   allegro\n   lucid\n   kcl\n     akcl\n     ibcl\n   cmulisp\n scheme\n   oaklisp\n\nCustomization: Starting a dialect runs the hooks on comint-mode-hook\nand ilisp-mode-hook and then DIALECT-hooks specific to dialects in the\nnesting order above.  On the very first prompt in the inferior LISP,\nthe hooks on ilisp-init-hook are run.  For more information on\ncreating a new dialect or variables to set in hooks, see ilisp.el.\n\nMost of these key bindings work in both Lisp Mode and ILISP mode.\nThere are a few additional and-go bindings found in Lisp Mode.\n\\{ilisp-use-map}\nThere are also a few bindings found in global-map including:\n  \\[popper-bury-output] popper-bury-output\n  \\[popper-scroll-output] popper-scroll-output\n  \\[popper-other-window] popper-other-window\n  \\[popper-grow-output] popper-grow-output\n  \\[previous-buffer-lisp] previous-buffer-lisp\n  \\[switch-to-lisp] switch-to-lisp\n\nILISP uses a dynamically sized pop-up window that can be buried and\nscrolled from any window for displaying output.  See the file\npopper.el or the ILISP info node for information on customizing popper\nwindows.  (\\[popper-other-window]) skips the popper window.  If\ncalled with a C-u prefix, the popper window will be selected.\npopper-bury-output (\\[popper-bury-output]) buries the output window.\npopper-scroll-output (\\[popper-scroll-output]) scrolls the output\nwindow if it is already showing, otherwise it pops it up.  If it is\ncalled with a negative prefix, it will scroll backwards.\npopper-grow-output (\\[popper-grow-output]) will grow the output\nwindow if showing by the prefix number of lines.  Otherwise, it will\npop the window up.\n\nIf you are running epoch, the popper window will be in a separate\nX window that is not automatically grown or shrunk.  The variable\npopper-screen-properties can be used to set window properties for that\nwindow. \n\nAn alternative to popper windows is to always have the inferior LISP\nbuffer visible and have all output go there.  Setting lisp-no-popper\nto T will cause all output to go to the inferior LISP buffer.\nSetting comint-always-scroll to T will cause process output to always\nbe visible.  If a command gets an error, you will be left in the break\nloop.\n\nEach ILISP buffer has a command history associated with it.  Commands\nthat do not match ilisp-filter-regexp and that are longer than\nilisp-filter-length and that do not match the immediately prior\ncommand will be added to this history.  comint-previous-input\n(\\[comint-previous-input]) and comint-next-input\n(\\[comint-next-input]) cycle through the input history.\ncomint-previous-similar-input (\\[comint-previous-similar-input])\ncycles through input that has the string typed so far as a prefix.\n\nSee comint-mode documentation for more information on comint commands.\n\nA number of commands refer to \"defun\".  A \"defun\" is a list that\nstarts at the left margin in a LISP buffer, or after a prompt in the\nILISP buffer.  So the commands refer to the \"defun\" that contains\npoint.\n\nThere are two keyboard modes for interacting with the inferior LISP,\n\"interactive\" and \"raw\".  Normally you are in interactive mode\nwhere keys are interpreted as commands to EMACS and nothing is sent to\nthe inferior LISP unless a specific command does so.  In raw mode, all\ncharacters are passed directly to the inferior LISP without any\ninterpretation as EMACS commands.  Keys will not be echoed unless\nilisp-raw-echo is T.  Raw mode can be turned on interactively by\nraw-keys-ilisp (\\[raw-keys-ilisp]) and will continue until you type\nC-g.  Raw mode can also be turned on/off by inferior LISP functions if\nio-bridge-ilisp (\\[io-bridge-ilisp]) has been executed in the\ninferior LISP interactively or on a hook.  To turn on raw mode, a\nfunction should print ^[1^] and to turn it off should print ^[0^].\n\nWhen you send something to LISP, the status light will reflect the\nprogress of the command.  If you type top-level forms ahead of the\nprocessing, the status may indicate ready when the LISP is actually\nrunning.  In a lisp mode buffer the light will reflect the status of\nthe currently selected inferior LISP unless lisp-show-status is nil.\nIf you want to find out what command is currently running, use the\ncommand status-lisp (\\[status-lisp]).  If you call it with a prefix,\nthe pending commands will be displayed as well.\n\nIf you are want to abort the last command you can use\n(\\[keyboard-quit]).  If you want to abort all commands, you should\nuse the command abort-commands-lisp (\\[abort-commands-lisp]).\nCommands that are aborted will be put in the buffer *Aborted Commands*\nso that you can see what was aborted.  If you want to abort the\ncurrently running top-level command, use interrupt-subjob-ilisp\n(\\[interrupt-subjob-ilisp]).  As a last resort, \\[panic-lisp] will\nreset the ILISP state without affecting the inferior LISP so that you\ncan see what is happening.\n\nbol-ilisp (\\[bol-ilisp]) will go after the prompt as defined by\ncomint-prompt-regexp or ilisp-other-prompt or to the left margin with\na prefix.\n\nreturn-ilisp (\\[return-ilisp]) knows about prompts and sexps.  If an\nsexp is not complete, it will indent properly.  When an entire sexp is\ncomplete, it is sent to the inferior LISP together with a new line.\nIf you edit old input, the input will be copied to the end of the\nbuffer first.\n\nclose-and-send-lisp (\\[close-and-send-lisp]) will close the current\nsexp, indent it, then send it to the current inferior LISP.\n\nindent-line-ilisp (\\[indent-line-ilisp]) indents for LISP.  With\nprefix, shifts rest of expression rigidly with the current line.\n\nnewline-and-indent-lisp (\\[newline-and-indent-lisp]) will insert a\nnew line and then indent to the appropriate level.  If you are at the\nend of the inferior LISP buffer and an sexp, the sexp will be sent to\nthe inferior LISP without a trailing newline.\n\nindent-sexp-ilisp (\\[indent-sexp-ilisp]) will indent each line in\nthe next sexp.\n\nbackward-delete-char-untabify (\\[backward-delete-char-untabify])\nconverts tabs to spaces as it moves back.\n\ndelete-char-or-pop-ilisp (\\[delete-char-or-pop-ilisp]) will delete\nprefix characters unless you are at the end of an ILISP buffer in\nwhich case it will pop one level in the break loop.\n\nreset-ilisp, (\\[reset-ilisp]) will reset the current inferior LISP's\ntop-level so that it will no longer be in a break loop.\n\nswitch-to-lisp (\\[switch-to-lisp]) will pop to the current ILISP\nbuffer or if already in an ILISP buffer, it will return to the buffer\nthat last switched to an ILISP buffer.  With a prefix, it will also go\nto the end of the buffer.  If you do not want it to pop, set\npop-up-windows to nil.  \n\ncall-defun-lisp (\\[call-defun-lisp]) will put a call to the current\ndefun in the inferior LISP and go there.  If it is a (def* name form,\nit looks up reasonable forms of name in the input history unless\ncalled with a prefix. If not found, (name or *name* will be inserted.\nIf it is not a def* form, the whole defun will be put in the buffer.\n\nreposition-window-lisp (\\[reposition-window-lisp]) will scroll the\ncurrent window to show as much of the current defun and its\nintroductory comments as possible without moving the point.  If called\nwith a prefix, the point will be moved if necessary to show the start\nof the defun.  If called more than once with the first line of the\ndefun showing, the introductory comments will be shown or suppressed.\n\nprevious-buffer-lisp (\\[previous-buffer-lisp]) will switch to the\nlast visited buffer in the current window or the Nth previous buffer\nwith a prefix.\n\nfind-unbalanced-lisp (\\[find-unbalanced-lisp]) will find unbalanced\nparens in the current buffer.  When called with a prefix it will look\nin the current region.\n\nclose-all-lisp (\\[close-all-lisp]) will close all outstanding\nparens back to the containing form, or a previous left bracket\nwhich will be converted to a left parens.  If there are too many\nparens, they will be deleted unless there is text between the\nlast paren and the end of the defun.  If called with a prefix,\nall open left brackets will be closed.\n\nreindent-lisp (\\[reindent-lisp]) will reindent the current paragraph\nif in a comment or string.  Otherwise it will close the containing\ndefun and reindent it.\n\ncomment-region-lisp (\\[comment-region-lisp]) will put prefix copies of\ncomment-start before and comment-end's after the lines in region.  To\nuncomment a region, use a minus prefix.\n\nThe very first inferior LISP command executed may send some forms to\ninitialize the inferior LISP.\n\nEach time an inferior LISP command is executed, the last form sent can be\nseen in the *ilisp-send* buffer.\n\nThe first time an inferior LISP mode command is executed in a Lisp\nMode buffer, the package will be determined by using the regular\nexpression ilisp-package-regexp to find a package sexp and then\npassing that sexp to the inferior LISP through ilisp-package-command.\nFor the clisp dialect, this will find the first (in-package PACKAGE)\nform in the file.  A buffer's package will be displayed in the mode\nline.  set-buffer-package-lisp (\\[set-buffer-package-lisp]) will\nupdate the current package from the buffer.  If it is called with a\nprefix, the package can be set manually.  If a buffer has no\nspecification, forms will be evaluated in the current inferior LISP\npackage.  package-lisp (\\[package-lisp]) will show the current\npackage of the inferior LISP.  set-package-lisp\n(\\[set-package-lisp]) will set the inferior LISP package to the\ncurrent buffer's package or to a manually entered package with a\nprefix.\n\ndescribe-lisp, inspect-lisp, arglist-lisp, documentation-lisp,\nmacroexpand-1-lisp, macroexpand-lisp, edit-definitions-lisp,\nwho-calls-lisp, edit-callers-lisp and trace-defun-lisp will switch\nwhether they prompt for a response or use a default when called with a\nnegative prefix.  If they are prompting, there is completion through\nthe inferior LISP by using TAB or M-TAB.  When you are entering an\nexpression in the minibuffer, all of the normal ilisp commands like\narglist-lisp also work.\n\nCommands that work on a function will use the nearest previous\nfunction symbol.  This is either a symbol after a #' or the symbol at\nthe start of the current list.\n\ndescribe-lisp (\\[describe-lisp]) will describe the previous sexp.\ninspect-lisp (\\[inpsect-lisp]) will inspect the previous sexp.If\nthere is no previous-sexp and you are in an ILISP buffer, the previous\nresult will be described or inspected.\n\narglist-lisp (\\[arglist-lisp]) will return the arglist of the\ncurrent function.  With a numeric prefix, the leading paren will be\nremoved and the arglist will be inserted into the buffer.\n\ndocumentation-lisp (\\[documentation-lisp]) infers whether function\nor variable documentation is desired.  With a negative prefix, you can\nspecify the type of documentation as well.  With a positive prefix the\ndocumentation of the current function call is returned.\n\nIf the Franz online Common LISP manual is available, fi:clman\n(\\[fi:clman]) will get information on a specific symbol.\nfi:clman-apropos (\\[fi:clman-apropos]) will get information apropos\na specific string.  Some of the documentation is specific to the\nallegro dialect, but most of it is for standard Common LISP.\n\nmacroexpand-lisp (\\[macroexpand-lisp]) and macroexpand-1-lisp\n(\\[macroexpand-1-lisp]) will be applied to the next sexp.  They will\ninsert their result into the buffer if called with a numeric prefix.\n\ncomplete-lisp (\\[complete-lisp]) will try to complete the previous\nsymbol in the current inferior LISP.  Partial completion is supported\nunless ilisp-prefix-match is set to T.  (If you set it to T, inferior\nLISP completions will be faster.)  With partial completion, \"p--n\"\nwould complete to \"position-if-not\" in Common LISP.  If the symbol\nfollows a left paren or a #', only symbols with function cells will be\nconsidered.  If the symbol starts with a * or you call with a\npositive prefix all possible completions will be considered.  Only\nexternal symbols are considered if there is a package qualification\nwith only one colon.  The first time you try to complete a string the\nlongest common substring will be inserted and the cursor will be left\non the point of ambiguity.  If you try to complete again, you can see\nthe possible completions.  If you are in a string, then filename\ncompletion will be done instead.  And if you try to complete a\nfilename twice, you will see a list of possible completions.  Filename\ncomponents are completed individually, so /u/mi/ could expand to\n/usr/misc/.  If you complete with a negative prefix, the most recent\ncompletion (symbol or filename) will be undone.\n\ncomplete (\\[complete]) will complete the current symbol to the most\nrecently seen symbol in Emacs that matches what you have typed so far.\nExecuting it repeatedly will cycle through potential matches.  This is\nfrom the TMC completion package and there may be some delay as it is\ninitially loaded.\n\ntrace-defun-lisp (\\[trace-defun-lisp]) traces the current defun.\nWhen called with a numeric prefix the function will be untraced.\n\ndefault-directory-lisp (\\[default-directory-lisp]) sets the default\ninferior LISP directory to the directory of the current buffer.  If\ncalled in an inferior LISP buffer, it sets the Emacs default-directory\nthe LISP default directory.\n\nThe eval/compile commands evaluate or compile the forms specified.  If\nany of the forms contain an interactive command, then the command will\nnever return.  To get out of this state, you need to use\nabort-commands-lisp (\\[abort-commands-lisp]).  The eval/compile\ncommands verify that their expressions are balanced and then send the\nform to the inferior LISP.  If called with a positive prefix, the\nresult of the operation will be inserted into the buffer after the\nform that was just sent.  If lisp-wait-p is t, then EMACS will display\nthe result of the command in the minibuffer or a pop-up window.  If\nlisp-wait-p is nil, (the default) the send is done asynchronously and\nthe results will be brought up only if there is more than one line or\nthere is an error.  In this case, you will be given the option of\nignoring the error, keeping it in another buffer or keeping it and\naborting all pending sends.  If there is not a command already running\nin the inferior LISP, you can preserve the break loop.  If called with\na negative prefix, the sense of lisp-wait-p will be inverted for the\nnext command.  The and-go versions will perform the operation and then\nimmediately switch to the ILISP buffer where you will see the results\nof executing your form.  If eval-defun-and-go-lisp\n(\\[eval-defun-and-go-lisp]) or compile-defun-and-go-lisp\n(\\[compile-defun-and-go-lisp]) is called with a prefix, a call for\nthe form will be inserted as well.\n\nWhen an eval is done of a single form matching ilisp-defvar-regexp,\nthe corresponding symbol will be unbound and the value assigned again.\n\nWhen compile-defun-lisp (\\[compile-defun-lisp]) is called in an\ninferior LISP buffer with no current form, the last form typed to the\ntop-level will be compiled.\n\nThe following commands all deal with finding things in source code.\nThe first time that one of these commands is used, there may be some\ndelay while the source module is loaded.  When searching files, the\nfirst applicable rule is used: 1) try the inferior LISP, 2) try a tags\nfile if defined, 3) try all buffers in one of lisp-source-modes or all\nfiles defined using lisp-directory.\n\nlisp-directory (\\[lisp-directory]) defines a set of files to be\nsearched by the source code commands.  It prompts for a directory and\nsets the source files to be those in the directory that match entries\nin auto-mode-alist for modes in lisp-source-modes.  With a positive\nprefix, the files are appended.  With a negative prefix, all current\nbuffers that are in one of lisp-source-modes will be searched.  This\nis also what happens by default.  Using this command stops using a\ntags file.\n\nedit-definitions-lisp (\\[edit-definitions-lisp]) will find a\nparticular type of definition for a symbol.  It tries to use the rules\ndescribed above.  The files to be searched are listed in the buffer\n*Edit-Definitions*.  If lisp-edit-files is nil, no search will be\ndone if not found through the inferior LISP.  The variable\nilisp-locator contains a function that when given the name and type\nshould be able to find the appropriate definition in the file.  There\nis often a flag to cause your LISP to record source files that you\nwill need to set in the initialization file for your LISP.  The\nvariable is *record-source-files* in both allegro and lucid.  Once a\ndefinition has been found, next-definition-lisp\n(\\[next-definition-lisp]) will find the next definition.  (Or the\nprevious definition with a prefix.)\n\nedit-callers-lisp (\\[edit-callers-lisp]) will generate a list of all\nof the callers of a function in the current inferior LISP and edit the\nfirst caller using edit-definitions-lisp.  Each successive call to\nnext-caller-lisp (\\[next-caller-lisp]) will edit the next caller.\n(Or the previous caller with a prefix.)  The list is stored in the\nbuffer *All-Callers*.  You can also look at the callers by doing\nwho-calls-lisp (\\[who-calls-lisp]).\n\nsearch-lisp (\\[search-lisp]) will search the current tags files,\nlisp directory files or buffers in one of lisp-source-modes for a\nstring or a regular expression when called with a prefix.\n(\\[next-definition-lisp]) will find the next definition.  (Or the\nprevious definition with a prefix.)\n\nreplace-lisp (\\[replace-lisp]) will replace a string (or a regexp\nwith a prefix) in the current tags files, lisp directory files or\nbuffers in one of lisp-source-modes.\n\nThe following commands all deal with making a number of changes all at\nonce.  The first time one of these commands is used, there may be some\ndelay as the module is loaded.  The eval/compile versions of these\ncommands are always executed asynchronously.\n\nmark-change-lisp (\\[mark-change-lisp]) marks the current defun as\nbeing changed.  A prefix causes it to be unmarked.  clear-changes-lisp\n(\\[clear-changes-lisp]) will clear all of the changes.\nlist-changes-lisp (\\[list-changes-lisp]) will show the forms\ncurrently marked. \n\neval-changes-lisp (\\[eval-changes-lisp]), or compile-changes-lisp\n(\\[compile-changes-lisp]) will evaluate or compile these changes as\nappropriate.  If called with a positive prefix, the changes will be\nkept.  If there is an error, the process will stop and show the error\nand all remaining changes will remain in the list.  All of the results\nwill be kept in the buffer *Last-Changes*.\n\nFile commands in lisp-source-mode buffers keep track of the last used\ndirectory and file.  If the point is on a string, that will be the\ndefault if the file exists.  If the buffer is one of\nlisp-source-modes, the buffer file will be the default.  Otherwise,\nthe last file used in a lisp-source-mode will be used.\n\nfind-file-lisp (\\[find-file-lisp]) will find a file.  If it is in a\nstring, that will be used as the default if it matches an existing\nfile.  Symbolic links are expanded so that different references to the\nsame file will end up with the same buffer.\n\nload-file-lisp (\\[load-file-lisp]) will load a file into the inferior\nLISP.  You will be given the opportunity to save the buffer if it has\nchanged and to compile the file if the compiled version is older than\nthe current version.\n\ncompile-file-lisp (\\[compile-file-lisp]) will compile a file in the\ncurrent inferior LISP." "\
Documentation string for ILISP mode.")
(fset 'ilisp-set-doc #[(function string) "K‰:« 	AA	@	A@E\n@;¬…\n@§«„\nAª\n¤M)ª¦Ä	Å\"Ç›«‰Ç› ˆª‰È›ÅB¡ˆÉÊ\"M))‡" [function old-function old-doc string append nil code-as-list 4 3 apply make-byte-code] 5 "\
Set the documentation of the symbol FUNCTION to STRING."])
(byte-code "ÀÁMˆÂÀ\"ˆÂÄ\"‡" [ilisp-mode #[nil "À ‡" [run-ilisp] 1 nil nil] ilisp-set-doc ilisp-documentation lisp-mode] 3)
(fset 'lisp-command-args #[(string) "GÁ‰ÂW«—HÇ=«ŠOBTT‰ªdÈOB!‰,‡" [string 0 nil args arg position len 32 reverse] 5 "\
Break up STRING into (command args ...)."])
(fset 'ilisp #[(name) "qˆÁ!„– \n@Æ!È	ÊË\"ÈÏĞ@ÈA%ˆÑ ˆÒÔ@× ˆØ\"ÚÜ#¬ˆCBİ!ˆŞß !dbˆÊà\"cˆáâ !`È“ˆ#Î!ˆ$«åÊ$&\"!ˆçß \"ˆ(¬„éê!ˆ.ª„İ!ˆë,!ˆíì,\"‡" [ilisp-buffer comint-check-proc ilisp-dialect dialect ilisp-program program lisp-command-args args nil process-connection-type format "%s" name names start apply make-comint comint-setup-ipc ilisp-mode major-mode "ILISP" mode-name comint-send-queue #[nil "ÀÁ!‡" [run-hooks ilisp-init-hook] 2] lisp-del ilisp-initialized lisp-memk ilisp-buffers car lisp-pop-to-buffer window-start selected-window "Starting %s ...\n" process-mark ilisp-process comint-update-status ilisp-motd lisp-display-output ilisp-version set-window-start ilisp-prefix-match require completer use-local-map ilisp-use-map set-default] 6 "\
Run an inferior LISP process NAME, input and output via buffer *name*.
If there is a process already running in *name*, just switch to that buffer.
Takes the program name from the variable ilisp-program.
(Type \\[describe-mode] in the process buffer for a list of commands.)"])
(autoload 'fi:clman "fi/clman" "\
Look up SYMBOL in the online manual with completion." t)
(autoload 'fi:clman-apropos "fi/clman" "\
Do an apropos search in online manual for STRING." t)
(autoload 'install-bridge "bridge" "\
Install process bridge." t)
(fset 'ilisp-bug #[nil "ÀÁÂÃp!\"!­p‰«„Å ¬Æ«ƒÇªÈ!ˆÉ ‚\ncˆËÌÌQ!ˆÎcˆÏcˆĞcˆÑyˆÒ cˆÁÓ#cˆŠqˆ)×Ø‰>¬‡>«ÁßPŠqˆà ®)áâ#\"ˆŠqˆ`ä åæ!'()Áê(')d('{&,cˆëì!ˆÁíîï !\"cˆ>¬‡>«¼à «¸ğñòæ\">«°ñó!A¬ªÁôõöŠqˆ÷ )øæ‰ù%@!\"cˆÁúõöŠqˆ÷ )ûæ‰ù%@!\"cˆücˆebˆış!ˆØˆÆÿ!,)‡" [y-or-n-p format "Is %s the buffer where the error occurred? " buffer-name buffer mail message "Can't send bug report until mail buffer is empty." "Switch to the buffer where the error occurred." beep ilisp-bugs-to search-forward "\n" mail-header-separator "\nYour problem: \n\n" "Type C-c C-c to send\n" "======= Emacs state below: for office use only =======\n" 1 emacs-version "\nWindow System: %s %s" window-system window-system-version major-mode "popper-\\|completer-" nil string val-buffer match mode lisp-source-modes ilisp-modes "ilisp-\\|comint-\\|lisp-" ilisp-buffer mapcar #[(dialect) "ÀÁ\n@\"P‰‡" [format "%s-\\|" dialect match] 3] ilisp-dialects lisp-defun-begin lisp-end-defun-text t end start point "\nMode: %s\nStart: %s\nEnd: %s\nPoint: %s\nPoint-max: %s\nCode: %s" mapatoms #[(symbol) "À	!­¤ÂÄÅ	\"\"­›	Æ=?­•Šqˆ	J)‰­‡ÄÉ	#c)‡" [boundp symbol string-match match format "%s" ilisp-documentation val-buffer val "\n%s: %s"] 6] "\nLossage: %s" key-description recent-keys clisp ilisp-value ilisp-dialect comint-send-queue "\nLISP: %s" comint-remove-whitespace comint-send ilisp-process "(lisp-implementation-version)" version "\n*FEATURES*: %s" "(let ((*print-length* nil)\n				       (*print-level* nil))\n				   (print *features*)\n				   nil)" 10 re-search-forward "^Subject" "Send with sendmail or your favorite mail program."] 10 "\
Generate an ilisp bug report." nil])
(byte-code "ÀÁÂÃ	\"\"ˆÂÄ\"À‡" [set-default auto-mode-alist append (("\\.cl$" . lisp-mode) ("\\.lisp$" . lisp-mode)) (".68fasl" ".sfasl" ".ifasl" ".pfasl" ".68fasl4" ".sfasl4" ".ifasl4" ".pfasl4" ".sbin") completion-ignored-extensions] 5)
(fset 'ilisp-defkey #[(keymap key command) "À	\n\"Ä!¬‡Å	\nÆ #Å#)‡" [lookup-key keymap ilisp-prefix prefix-map keymapp define-key make-sparse-keymap key command] 4 "\
Define KEYMAP ilisp-prefix+KEY as command."])
(fset 'lisp-bindings #[(keymap &optional inferior-p) "« Á\nÃÄ#ˆÁ\nÅÆ#ˆÁ\nÇÈ#ˆÁ\nÉÊ#ˆË\nÌÍ#ˆªŒË\nÎÏ#ˆÁ\nÃĞ#ˆÁ\nÑÒ#ˆÁ\nÓÔ#ˆÁ\nÕÖ#ˆÁ\n×Ø#ˆÁ\nÙĞ#ˆÁ\nÚÛ#ˆË\nÜİ#ˆË\nŞß#ˆÁ\nàá#ˆÁ\nâã#ˆÁ\näå#ˆË\næç#ˆË\nèé#ˆË\nêë#ˆË\nìí#ˆË\nîï#ˆË\nğñ#ˆÁ\nòó#ˆÁ\nôõ#ˆÁ\nö÷#ˆÁ\nøù#ˆË\núû#ˆÁ\nüı#ˆÁ\nşÿ#ˆÁ\n@ A #ˆË\nB C #ˆÁ\nD E #ˆË\nF E #ˆË\nG H #ˆË\nI J #ˆË\nK L #ˆË\nM N #ˆË\nO P #ˆË\nQ R #ˆË\nS T #ˆË\nU V #ˆË\nW X #ˆË\nY Z #ˆË\n[ \\ #ˆË\n] ^ #ˆ_` P_Ë\na b #ˆË\nF c #ˆË\nO d #ˆË\ne f #ˆ)Ë\ng h #ˆË\ni j #ˆË\nk l #ˆË\nm n #ˆË\no p #ˆË\nq r #ˆÁ\ns t #ˆË\na u #ˆË\nv w #ˆË\nx y #ˆË\nz { #‡" [inferior-p define-key keymap "" return-ilisp "" bol-ilisp "" interrupt-subjob-ilisp "" delete-char-or-pop-ilisp ilisp-defkey "#" raw-keys-ilisp "" compile-defun-and-go-lisp newline-and-indent-lisp "]" close-all-lisp "ñ" reindent-lisp "" close-and-send-lisp "	" indent-line-ilisp "\n" "‘" indent-sexp-ilisp ";" comment-region-lisp ")" find-unbalanced-lisp "" beginning-of-defun-lisp "…" end-of-defun-lisp "’" reposition-window-lisp "i" describe-lisp "I" inspect-lisp "a" arglist-lisp "d" documentation-lisp "m" macroexpand-1-lisp "M" macroexpand-lisp "¬" next-definition-lisp "®" edit-definitions-lisp "¿" search-lisp "¢" replace-lisp "^" edit-callers-lisp "à" next-caller-lisp "‰" complete-lisp "" complete "r" eval-region-lisp "˜" eval-defun-lisp "e" "n" eval-next-sexp-lisp "p" package-lisp "P" set-package-lisp "w" compile-region-lisp "c" compile-defun-lisp "" eval-region-and-go-lisp "" eval-defun-and-go-lisp "" eval-next-sexp-and-go-lisp "" compile-region-and-go-lisp "t" trace-defun-lisp "!" default-directory-lisp " " mark-change-lisp ilisp-prefix "*" "l" list-changes-lisp eval-changes-lisp compile-changes-lisp "0" clear-changes-lisp "b" switch-to-lisp "y" call-defun-lisp "z" reset-ilisp "g" abort-commands-lisp "s" status-lisp "S" select-ilisp "" find-file-lisp load-file-lisp "k" compile-file-lisp "A" fi:clman-apropos "D" fi:clman] 4 "\
Set up the bindings for interacting with an inferior LISP in
KEYMAP."])
(fset 'ilisp-bindings #[nil "À	!Ã\nÄÅ#ˆÃ\nÆÅ#ˆÇÈ!«†È\n!ˆª‹ÇÉ!«†É\n\n\"ˆË\nÌ\"ˆÍÎ!«…Ë!ˆÍÏ!«…Ë!ˆĞÒÓ#ˆĞÕÖ#ˆĞ×Ø#ˆĞÙÚ#ˆĞÛÜ#ˆÍİ!¬„Ş Ğßà#ˆĞáâ#‡" [full-copy-sparse-keymap comint-mode-map ilisp-mode-map define-key "" nil "" fboundp lisp-mode-commands set-keymap-parent shared-lisp-mode-map lisp-bindings t boundp lisp-mode-map scheme-mode-map ilisp-defkey emacs-lisp-mode-map ";" comment-region-lisp global-map "b" switch-to-lisp "1" popper-bury-output "v" popper-scroll-output "G" popper-grow-output fi:clman-mode-map make-sparse-keymap "D" fi:clman "A" fi:clman-apropos] 4 "\
Set up the key bindings for LISP and ILISP buffers."])
(fset 'defkey-ilisp #[(key command &optional inferior-only) "¬ƒÁ ˆÂ#ˆÂ#‡" [ilisp-mode-map ilisp-bindings define-key key command lisp-mode-map] 4 "\
Define KEY as COMMAND in ilisp-mode-map and lisp-mode-map unless
optional INFERIOR-ONLY is T.  If the maps do not exist they will be
created.  This should only be called after ilisp-prefix is set to the
desired prefix."])
(byte-code "ÀÁ!ˆÂÃ!ˆÂÄ!ˆ¬“ÆÇ!«Š«†ÈÉ!ˆª„ÈÊ!ˆ¬ƒÌ ˆÀ‡" [provide ilisp run-hooks ilisp-site-hook ilisp-load-hook lisp-no-popper boundp epoch::version require epoch-pop popper ilisp-mode-map ilisp-bindings] 2)
