;;; compiled by jwz@thalidomide on Fri Jan  1 18:01:28 1993
;;; from file /cadillac-th/jwz/emacs19/lisp/prim/subr.el
;;; emacs version 19.4.1 Lucid.
;;; bytecomp version 2.09; 29-dec-92.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(defvar kill-buffer-hook nil "\
Function or functions to be called when a buffer is killed.
The value of this variable may be buffer-local.
The buffer about to be killed is current when this hook is run.")
(fset 'generate-new-buffer #[(name) "ÀÁ\n!!‡" [get-buffer-create generate-new-buffer-name name] 3 "\
Create and return a buffer with a name based on NAME.
Choose the buffer's name using `generate-new-buffer-name'."])
(fset 'one-window-p #[(&optional nomini) "À ÁÀ \n­Â\"=‡" [selected-window next-window nomini] 4 "\
Returns non-nil if there is only one window.
Optional arg NOMINI non-nil means don't count the minibuffer
even if it is active."])
(fset 'walk-windows #[(proc &optional minibuf all-screens) "À ‰Ã\n#\n!ˆ\n	=?­‚ªm*‡" [selected-window walk-windows-start walk-windows-current next-window minibuf all-screens proc] 5 "\
Cycle through all visible windows, calling PROC for each one.
PROC is called with a window as argument.
Optional second arg MINIBUF t means count the minibuffer window
even if not active.  If MINIBUF is neither t nor nil it means
not to count the minibuffer even if it is active.
Optional third arg ALL-SCREENS t means include all windows in all screens;
otherwise cycle within the selected screen."])
(fset 'read-quoted-char #[(&optional prompt) "À‰ÁÅW«ßÀUÁ«†ÉÊ\"ˆË «ƒÁ*\n«[Í\nX«¢\nÎX«Ï_\nÍZ\\T«BÉĞÑ\n#‰!ˆª4ÀV«ŒÒ\nÓ \"Õ‰ª$\nÕ‰ªÖ×\"+‡" [0 nil char code count 3 help-form inhibit-quit prompt message "%s-" read-char quit-flag 48 55 8 format "%s %c" character-to-event allocate-event unread-command-event 259 logand 255] 6 "\
Like `read-char', except that if the first character read is an octal
digit, we read up to two more octal digits and return the character
represented by the octal number consisting of those digits.
Optional argument PROMPT specifies a string to use to prompt the user."])
(fset 'error #[(&rest args) "ÀÁÂÃ\"C\"ˆªu" [signal error apply format args] 5 "\
Signal an error, making error message by passing all args to `format'."])
(fset 'undefined #[nil "À ‡" [ding] 1 nil nil])
(defun baud-rate nil "\
Obsolete function returning the value of the `baud-rate' variable." baud-rate)
(put 'undefined 'suppress-keymap t)
(fset 'suppress-keymap #[(map &optional nodigits) "ÀÁ\n\"ˆ®ªÄÅÆ\"È	ÊË#ˆÌHÍX­”È	Î#ˆÌÌHTIˆªd)‡" [map-keymap #[(key binding) "Á=­‡ÂÄ!Æ#‡" [binding self-insert-command define-key map vector key undefined] 4] global-map nodigits make-string 1 48 string define-key map "-" negative-argument 0 57 digit-argument] 4 "\
Make MAP override all normally self-inserting keys to be undefined.
Normally, as an exception, digits and minus-sign are set to make prefix args,
but optional second arg NODIGITS non-nil treats them like other chars."])
(fset 'substitute-key-definition #[(olddef newdef keymap) "ÀÁ\n\"‡" [map-keymap #[(key binding) "	=­…Â#‡" [binding olddef define-key keymap key newdef] 4] keymap] 3 "\
Replace OLDDEF with NEWDEF for any keys in KEYMAP now defined as OLDDEF.
In other words, OLDDEF is replaced with NEWDEF where ever it appears.
Prefix keymaps reached from KEYMAP are not checked recursively;
perhaps they ought to be."])
(fset 'save-match-data '(macro . #[(&rest body) "ÀÁÂÃBÅEE‡" [let ((_match_data_ (match-data))) unwind-protect progn body (store-match-data _match_data_)] 5 "\
Execute the BODY forms, restoring the global value of the match data."]))
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑMˆÒÓMˆÔÕMˆÖ×MˆØÙMˆÚÛMˆÜİMˆŞßMˆàáMˆâãMˆäåMˆæçMˆèéMˆêëMˆìíMˆîïMˆğñKMˆòóKM‡" [ignore (lambda (&rest ignore)) make-syntax-table copy-syntax-table dot point dot-marker point-marker dot-min point-min dot-max point-max window-dot window-point set-window-dot set-window-point read-input read-string send-string process-send-string send-region process-send-region show-buffer set-window-buffer buffer-flush-undo buffer-disable-undo string= string-equal string< string-lessp mod % move-marker set-marker eql eq not null rplaca setcar rplacd setcdr beep ding indent-to-column indent-to backward-delete-char delete-backward-char search-forward-regexp re-search-forward search-backward-regexp re-search-backward] 2)
(fset 'run-hooks #[(&rest hooklist) "­¬@Â	!«œ	J«˜	J‰<«@Ä=¬‡ÅÆ\"ˆªƒ ˆ))A‰¬UÇ‡" [hooklist sym boundp value lambda mapcar funcall nil] 4 "\
Takes hook names and runs each one in turn.  Major mode functions use this.
Each argument should be a symbol, a hook variable.
These symbols are processed in the order specified.
If a hook symbol has a non-nil value, that value may be a function
or a list of functions to be called to run the hook.
If the value is a function, it is called with no arguments.
If it is a list, the elements are called, in order, with no arguments."])
(defconst run-hooks 'run-hooks "\
Variable by which C primitives find the function `run-hooks'.
Don't change it.")
(fset 'add-hook #[(hook-var function &optional at-end) "À	!¬„	ÂLˆ	J‰<«†@Ä=«ƒC?­	«†C¤ªƒBL)‡" [boundp hook-var nil old lambda function at-end] 4 "\
Add a function to a hook.
First argument HOOK-VAR (a symbol) is the name of a hook, second
 argument FUNCTION is the function to add.
Third (optional) argument AT-END means to add the function at the end
 of the hook list instead of the beginning.  If the function is already
 present, this has no effect.
Returns nil if FUNCTION was already present in HOOK-VAR, else new
 value of HOOK-VAR."])
(fset 'remove-hook #[(hook-var function) "ÀÂ!¬ƒÀª—J‰=«…À‰ªŠ	:­†Å	\"L)‡" [nil val boundp hook-var function delq] 4 "\
Remove a function from a hook, if it is present.
First argument HOOK-VAR (a symbol) is the name of a hook, second
 argument FUNCTION is the function to remove (compared with `eq')."])
(fset 'momentary-string-display #[(string pos &optional exit-char message) "¬‚ÁÂÃ ÂÉŠ\nbˆÂË!ˆ`)Í®ÎÏ!\"ˆĞÑ !Ó!=®…‰.‡" [exit-char 32 nil buffer-modified-p buffer-file-name insert-end name modified buffer-read-only ((byte-code "«†Š	|ˆ)\nÄ!‡" [insert-end pos name buffer-file-name set-buffer-modified-p modified] 2)) pos insert-before-markers string message "Type %s to continue editing." single-key-description next-command-event allocate-event event event-to-character unread-command-event] 4 "\
Momentarily display STRING in the buffer at POS.
Display remains until next character is typed.
If the char is EXIT-CHAR (optional third arg, default is SPC) it is swallowed;
otherwise it is then available as input (as a command if nothing else).
Display MESSAGE (optional fourth arg) in the echo area.
If MESSAGE is nil, instructions to type EXIT-CHAR are displayed there."])
(fset 'start-process-shell-command #[(name buffer &rest args) "Á=«ˆÂÃ$‡ÃÈÉÊËÌ#P%‡" [system-type vax-vms apply start-process name buffer args shell-file-name "-c" "exec " mapconcat identity " "] 10 "\
Start a program in a subprocess.  Return the process object for it.
Args are NAME BUFFER COMMAND &rest COMMAND-ARGS.
NAME is name for process.  It is modified if necessary to make it unique.
BUFFER is the buffer or (buffer-name) to associate with the process.
 Process output goes at end of that buffer, unless you specify
 an output stream or filter function to handle the output.
 BUFFER may be also nil, meaning that this process is not associated
 with any buffer
Third arg is command name, the name of a shell command.
Remaining arguments are the arguments for the command.
Wildcards and redirection are handle as usual in the shell."])
(fset 'user-original-login-name #[nil "ÀÁ!®‡ÀÂ!®‚Ã ‡" [getenv "LOGNAME" "USER" user-login-name] 2 "\
Return user's login name from original login.
This tries to remain unaffected by `su', by looking in environment variables."])
(fset 'redraw-mode-line #[(&optional all) "«†ŠÁ qˆ)ÂÃ !‡" [all other-buffer set-buffer-modified-p buffer-modified-p] 2 "\
Force the mode-line of the current buffer to be redisplayed.
With optional non-nil ALL then force then force redisplay of all mode-lines."])
(fset 'force-mode-line-update 'redraw-mode-line)
(fset 'local-key-binding #[(keys) "À ‰­„Â	\")‡" [current-local-map map lookup-key keys] 4 "\
Return the binding for command KEYS in current local keymap only.
KEYS is a string, a vector of events, or a vector of key-description lists
as described in the documentation for the `define-key' function.
The binding is probably a symbol with a function definition; see
the documentation for `lookup-key' for more information."])
(fset 'global-key-binding #[(keys) "ÀÁ \n\"‡" [lookup-key current-global-map keys] 3 "\
Return the binding for command KEYS in current global keymap only.
KEYS is a string or vector of events, a sequence of keystrokes.
The binding is probably a symbol with a function definition; see
the documentation for `lookup-key' for more information."])
(fset 'global-set-key #[(keys function) "ÀÁ \n#‡" [define-key current-global-map keys function] 4 "\
Give KEY a global binding as COMMAND.
COMMAND is a symbol naming an interactively-callable function.
KEYS is a string, a vector of events, or a vector of key-description lists
as described in the documentation for the `define-key' function.
Note that if KEY has a local binding in the current buffer
that local binding will continue to shadow any global binding." "kSet key globally: \nCSet key %s to command: "])
(fset 'local-set-key #[(keys function) "À ¬…ÁÂ !ˆÃÀ #‡" [current-local-map use-local-map make-sparse-keymap define-key keys function] 4 "\
Give KEY a local binding as COMMAND.
COMMAND is a symbol naming an interactively-callable function.
KEYS is a string, a vector of events, or a vector of key-description lists
as described in the documentation for the `define-key' function.
The binding goes in the current buffer's local map,
which is shared with other buffers in the same major mode." "kSet key locally: \nCSet key %s locally to command: "])
(fset 'global-unset-key #[(keys) "À	Â\"‡" [global-set-key keys nil] 3 "\
Remove global binding of KEY.
KEYS is a string, a vector of events, or a vector of key-description lists
as described in the documentation for the `define-key' function." "kUnset key globally: "])
(fset 'local-unset-key #[(keys) "À ­†ÁÀ \nÃ#‡" [current-local-map define-key keys nil] 4 "\
Remove local binding of KEY.
KEYS is a string, a vector of events, or a vector of key-description lists
as described in the documentation for the `define-key' function." "kUnset key locally: "])
(fset 'define-prefix-command #[(name &optional mapvar) "À Â	\"ˆ	Mˆ¬†	Lˆª‰Å=¬„	Lˆ)‡" [make-sparse-keymap map set-keymap-name name mapvar t] 3 "\
Define COMMAND as a prefix command.
A new sparse keymap is stored as COMMAND's function definition.
If second optional argument MAPVAR is not specified,
 COMMAND's value (as well as its function definition) is set to the keymap.
If a second optional argument MAPVAR is given and is not `t',
  the map is stored as its value.
Regardless of MAPVAR, COMMAND's function-value is always set to the keymap."])
