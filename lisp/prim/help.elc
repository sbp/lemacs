;;; compiled by jwz@thalidomide on Sun Jan 17 16:08:27 1993
;;; from file /cadillac-th/jwz/emacs19/lisp/prim/help.el
;;; emacs version 19.4.1 Lucid.
;;; bytecomp version 2.09; 16-jan-93.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(defvar help-map (make-sparse-keymap) "\
Keymap for characters following the Help key.")
(byte-code "À	MˆÂ	ÃÄ#ˆÂ	ÅÄ#ˆÂ	ÆÇ#ˆÂ	ÈÉ#ˆÂ	ÊË#ˆÂ	ÌÍ#ˆÂ	ÎÏ#ˆÂ	ĞÑ#ˆÂ	ÒÓ#ˆÂ	ÔÕ#ˆÂ	Ö×#ˆÂ	Ø×#ˆÂ	ÙÚ#ˆÂ	ÛÜ#ˆÂ	İŞ#ˆÂ	ßà#ˆÂ	áà#ˆÂ	âã#ˆÂ	äå#ˆÂ	æç#ˆÂ	èé#ˆêëM‡" [help-command help-map define-key (control h) help-for-help "?" "" describe-copying "" describe-distribution "" describe-no-warranty "a" command-apropos "b" describe-bindings "p" describe-pointer "c" describe-key-briefly "k" describe-key "d" describe-function "f" "i" info "l" view-lossage "m" describe-mode "" view-emacs-news "n" "s" describe-syntax "t" help-with-tutorial "w" where-is "v" describe-variable deprecated-help-command #[nil "ÀÁ!Â=«‰ÃÄÅ \"‰‡Ç ‡" [key-binding "" help-command character-to-event 8 allocate-event unread-command-event help-for-help] 3 nil nil]] 4)
(fset 'help-with-tutorial #[nil "ÀÁ!Ã ˆÄ\n!«‡ÅÄ\n!!ª¾ÅÆ\n!!ˆ\nÀÈ!	ÊÌÀÍ\"!ˆebˆÏĞ!ˆÑyˆ`Êˆ`|ˆÒÓÔ !Õe`\"ZÖZ!ˆebˆ×Ê!)‡" [expand-file-name "~/TUTORIAL" file delete-other-windows get-file-buffer switch-to-buffer create-file-buffer buffer-file-name "~/" default-directory nil buffer-auto-save-file-name insert-file-contents "TUTORIAL" exec-directory search-forward "\n<<" 0 newline window-height selected-window count-lines 6 set-buffer-modified-p] 5 "\
Select the Emacs learn-by-doing tutorial." nil])
(fset 'describe-key-briefly #[(key) "À	!‰«„\n¨«ˆÃÄÅ	!\"ªÃÆÅ	!\n9«ƒ\nªƒÇ\n!#)‡" [key-binding key defn message "%s is undefined" key-description "%s runs the command %s" prin1-to-string] 6 "\
Print the name of the function KEY invokes.  KEY is a string." "kDescribe key briefly: "])
(fset 'print-help-return-message #[(&optional function) "À	!?­—\n®ÃÄÅÆ!«Š«ƒÈª„ÉªÊ!!‡" [get-buffer-window standard-output function message substitute-command-keys one-window-p t pop-up-windows "Type \\[delete-other-windows] to remove help window." "Type \\[switch-to-buffer] RET to remove help window." "Type \\[switch-to-buffer-other-window] RET to restore old contents of help window."] 4 "\
Display or return message saying how to restore windows after help command.
Computes a message and applies the argument FUNCTION to it.
If FUNCTION is nil, applies `message' to it, thus printing it."])
(fset 'describe-key #[(key) "ÀÂ!«¾GÄU«¸ÅÆH!«±ÆHÈ!É!D‰@Ê=«„	A@	¢Ë=«„	A@	:«‡	A¬ƒ	@)ª„Ì!	«„	¨«ˆÍÎÏ!\"ªÑĞÑ	!ˆÒÓ!ˆ	;¬…Â	!«ªÌ	!ÒÕ!ˆ«šÒÖ!ˆÒ!ˆÒ×!ˆØ!«‡ÒØ!!ˆ)ª‘Ø	!«ˆÒØ	!!ˆª„ÒÙ!ˆÚ ‘)‡" [nil defn vectorp key 1 menu-event-p 0 event event-function event-object eval call-interactively key-binding message "%s is undefined" key-description "*Help*" prin1 princ ":\n" cmd "a keyboard macro" " which runs the command " ":\n\n" documentation "not documented" print-help-return-message] 5 "\
Display documentation of the function KEY invokes.  
KEY is a string, or vector of events.  When called interactvely, key may
also be a menu selection." "kDescribe key: "])
(fset 'where-is #[(definition) "À	Â Ã‰‰%‰«ÅÆ	ÇÈÉÊ\"Ë##ˆª…ÅÌ	\"ˆ)Ã‡" [where-is-internal definition current-local-map nil keys message "%s is on %s" mapconcat key-description sort (lambda (x y) (< (length x) (length y))) ", " "%s is not on any keys"] 9 "\
Print message listing key sequences that invoke specified command.
Argument is a command definition, usually a symbol with a function definition." "CWhere is command: "])
(fset 'describe-mode #[nil "ÀÁ\n!ˆÁÃ!ˆÁÄ!!ˆÆ ‘‡" ["*Help*" princ mode-name " Mode:\n" documentation major-mode print-help-return-message] 4 "\
Display documentation of current major mode." nil])
(fset 'describe-distribution #[nil "ÀÁÂ\"!‡" [find-file-read-only expand-file-name "DISTRIB" exec-directory] 4 "\
Display info on how to obtain the latest version of GNU Emacs." nil])
(fset 'describe-copying #[nil "ÀÁÂ\"!ˆeb‡" [find-file-read-only expand-file-name "COPYING" exec-directory] 4 "\
Display info on how you may redistribute copies of GNU Emacs." nil])
(fset 'describe-pointer #[nil "ÀÁ!‡" [describe-bindings t] 2 "\
Show a list of all defined mouse buttons, and their definitions.
This is the same as \\[universal-argument] \\[describe-bindings]." nil])
(fset 'describe-no-warranty #[nil "À ˆÁÃÄ!ˆÅÆ!)‡" [describe-copying nil case-fold-search search-forward "NO WARRANTY" recenter 0] 2 "\
Display info on all the kinds of warranty Emacs does NOT have." nil])
(fset 'view-emacs-news #[nil "ÀÁÂ\"!‡" [find-file-read-only expand-file-name "NEWS" exec-directory] 4 "\
Display info on recent changes to Emacs." nil])
(fset 'view-lossage #[nil "ÀÁÂÃ !!ˆŠqˆebˆÅÆ!ˆm¬‹ÇÈÉÊ#ˆËcˆªn)Ì ‘‡" ["*Help*" princ key-description recent-keys standard-output move-to-column 50 search-forward " " nil t "\n" print-help-return-message] 5 "\
Display last 100 input keystrokes." nil])
(fset 'help-for-help #[nil "À	!Â‰ÆÇÈ!\"ˆÉÊ !Ë!®‰š¬ŠÌš¬…Íš«ƒÎ‹ˆÏÑ!«…Ò!ª„Ó—!\"‰«†Õ!ª‚Ö ,‡" [copy-event last-command-event nil char event help-key message "A B C F I K L M N P S T V W C-c C-d C-n C-w.  Type %s again for more help: " single-key-description next-command-event allocate-event event-to-character 8 63 ((byte-code "ÀÁ!ˆÂ ˆÃÄ!cˆebˆš¬…Ç>«²È>«ƒÉ ˆÊ>«ƒË ˆÌÍÎd!«ƒÏªĞ\"ˆÑÓ!Õ!®‚)ªCÀ‡" [switch-to-buffer "*Help*" erase-buffer documentation help-for-help char help-key (8 63 22 32 127 246) (22 32) scroll-up (127 246) scroll-down message "A B C F I K L M N P S T V W C-c C-d C-n C-w%s: " pos-visible-in-window-p "" " or Space to scroll" t cursor-in-echo-area next-command-event event event-to-character] 4)) lookup-key help-map eventp vector char-to-string defn call-interactively ding] 5 "\
You have typed C-h, the help character.  Type a Help option:

A  command-apropos.   Give a substring, and see a list of commands
              (functions interactively callable) that contain
	      that substring.  See also the  apropos  command.
B  describe-bindings.  Display table of all key bindings.
C  describe-key-briefly.  Type a command key sequence;
	      it prints the function name that sequence runs.
F  describe-function.  Type a function name and get documentation of it.
I  info. The  info  documentation reader.
K  describe-key.  Type a command key sequence;
	      it displays the full documentation.
L  view-lossage.  Shows last 100 characters you typed.
M  describe-mode.  Print documentation of current major mode,
	      which describes the commands peculiar to it.
N  view-emacs-news.  Shows emacs news file.
P  describe-pointer.  Display table of all mouse-button bindings.
S  describe-syntax.  Display contents of syntax table, plus explanations
T  help-with-tutorial.  Select the Emacs learn-by-doing tutorial.
V  describe-variable.  Type name of a variable;
	      it displays the variable's documentation and value.
W  where-is.  Type command name; it prints which keystrokes
	      invoke that command.
C-c print Emacs copying permission (General Public License).
C-d print Emacs ordering information.
C-n print news of recent Emacs changes.
C-w print information on absence of warranty for GNU Emacs." nil])
(fset 'function-called-at-point #[nil "ÀÁÂ‡" [nil (byte-code "ŠŒe`ÀZ]d}ˆÁÂ!ˆÂuˆÃÅp!‰9­†Æ!­+‡" [1000 backward-up-list 1 nil obj read fboundp] 4) ((error))] 3])
(defvar describe-function-show-arglist t "\
*If true, then describe-function will show its arglist if the function is
not an autoload.")
(fset 'describe-function #[(function) "ÀÁ\n\"ˆÄ ˆŠqˆÅ )‘‡" ["*Help*" describe-function-1 function standard-output print-help-return-message buffer-string] 4 "\
Display the full documentation of FUNCTION (a symbol)." (byte-code "À ÂÄ	«†ÅÆ	\"ªÇÉÂ$)‰\nËš«ƒ	ª„Ì\n!*C‡" [function-called-at-point fn t enable-recursive-minibuffers completing-read format "Describe function (default %s): " "Describe function: " obarray fboundp val "" intern] 6)])
(byte-code "ÀÁMˆÂÃM‡" [describe-function-1 #[(function stream) "À	\n\"ˆÃÄ\n\"ˆ	Æ	!®ÇÉ\nÉ9«£	=¬˜\n«Œ\nÌÍ!ÎR\nªˆÏÍ!ÎQ\nK‰ªZ«Í¢Ñ=¬Ç¢Ò=«ŒÃA@®Ó\n\"ˆª°Ô!«ŒÃÕH®Ó\n\"ˆªŸÖ!«Ÿ×Ø\"«˜ÃÙ”Ù•O\n\"ˆÕ‰”OÃÚ\n\"ˆ\n«†Ã\n\n\"ˆÛ;¬…İ!«ŠÃŞ\n\"ˆßªóÖ!«‡à!ˆªçÔ!«‡á!ˆªÛ9«ŒÃâãä!\"\n\"ˆªË¢Ò=«‡å!ˆª¾¢æ=«‡Ãç\n\"ˆª±¢è=«‡Ãé\n\"ˆª¤¢Ñ=«ê!ˆÃëœ«ƒìªí\n\"ˆÃî\n\"ˆÀÙœ\n\"ˆ)ï ˆ«¨Ãğ\n\"ˆÃñ!\n\"ˆò!‰­šÃó\n\"ˆÃ\n\"ˆÃô\n\"ˆõ\n\"ª…Ã\n\",‡" [prin1 function stream princ ": " def documentation "not documented" doc nil aliases kbd-macro-p "\n     which is an alias for " symbol-name ", " "an alias for " describe-function-show-arglist autoload lambda "()" compiled-function-p 0 subrp string-match "[\n	 ]*\narguments: ?\\((.*)\\)\n?\\'" 1 "\n  -- " #[(string) "ÀÁ\n!«ƒÃªÄ\"ˆÀ\"‡" [princ commandp def "an interactive " "a " stream string] 3] int vectorp "a keyboard macro." t "built-in function." "compiled Lisp function." format "alias for `%s'." prin1-to-string "Lisp function." macro "a Lisp macro." mocklisp "a mocklisp function." "autoloaded Lisp " 4 "macro" "function" "\n  -- loads from " terpri "These characters are executed:\n\n	" key-description key-binding "\n\nwhich executes the command " ".\n\n" describe-function-1] 6] variable-at-point #[nil "ÀÁÂ‡" [nil (byte-code "ŠÀÁ!ˆÂÃwˆÄp!‰9­†Æ!­*‡" [forward-sexp -1 "'" nil read obj boundp] 3) ((error))] 3]] 2)
(fset 'describe-variable #[(variable) "ÀÁ\n!ˆÃÄ!ˆÅ\n!¬†ÃÆ!ˆª…Á\nJ!ˆÇ ˆÇ ˆÃÈ!ˆÇ ˆÉ\nÊ\"‰«‰ÃÌ!!ˆª„ÃÍ!ˆ)Î ‘‡" ["*Help*" prin1 variable princ "'s value is " boundp "void." terpri "Documentation:" documentation-property variable-documentation doc substitute-command-keys "not documented as a variable." print-help-return-message] 5 "\
Display the full documentation of VARIABLE (a symbol)." (byte-code "À ÁÂÆ«†ÇÈ\"ªÉ\nËÁ$‰Ìš«ƒªƒÍ!+C‡" [variable-at-point t nil val enable-recursive-minibuffers v completing-read format "Describe variable (default %s): " "Describe variable: " obarray boundp "" intern] 6)])
(fset 'command-apropos #[(string) "ÀÁ!ÃÄ!)ÆÈÉ#ˆ­ƒÅ!)‡" [get-buffer-create "*Help*" standard-output print-help-return-message identity message apropos string t commandp] 4 "\
Like apropos but lists only symbols that are names of commands
(interactively callable functions).  Argument REGEXP is a regular expression
that is matched against command symbol names.  Returns list of symbols and
documentation found." "sCommand apropos (regexp): "])
(fset 'locate-library #[(library &optional nosuffix) "À	\n?­Ä#‰«‡ÆÇ\"ˆª…ÆÈ	\"ˆ)‡" [locate-file library load-path nosuffix ".elc:.el:" file message "Library is file %s" "No library %s in search path"] 5 "\
Show the full path name of Emacs library LIBRARY.
This command searches the directories in `load-path' like  M-x load-library
to find the file that  M-x load-library RET LIBRARY RET  would load.
Optional prefix arg NOSUFFIX non-nil means don't add suffixes `.elc' or `.el'
to the specified name LIBRARY - a la calling (load LIBRARY nil nil t)." "sLocate library: \nP"])
