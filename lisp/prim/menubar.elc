;;; compiled by jwz@thalidomide on Mon Dec 28 16:06:33 1992
;;; from file /cadillac-th/jwz/emacs19/lisp/prim/menubar.el
;;; emacs version 19.4.1 Lucid.
;;; bytecomp version 2.08; 13-dec-92.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(byte-code "ÀÂ‡" [(("File" ["New Screen" x-new-screen t] ["Open File..." find-file t] ["Save Buffer" save-buffer t nil] ["Save Buffer As..." write-file t] ["Revert Buffer" revert-buffer t nil] "-----" ["Print Buffer" lpr-buffer t nil] "-----" ["Delete Screen" delete-screen t] ["Kill Buffer" kill-this-buffer t nil] ["Exit Emacs" save-buffers-kill-emacs t]) ("Edit" ["Undo" advertised-undo t] ["Cut" x-kill-primary-selection t] ["Copy" x-copy-primary-selection t] ["Paste" x-yank-clipboard-selection t] ["Clear" x-delete-primary-selection t]) ("Buffers" "") nil ("Help" ["Info" info t] ["Describe Mode" describe-mode t] ["Command Apropos..." command-apropos t] ["List Keybindings" describe-bindings t] ["Describe Key..." describe-key t] ["Describe Function..." describe-function t] ["Describe Variable..." describe-variable t] "-----" ["Unix Manual..." manual-entry t] ["Emacs Tutorial" help-with-tutorial t] ["Emacs News" view-emacs-news t])) default-menubar nil] 1)
(fset 'kill-this-buffer #[nil "Àp!‡" [kill-buffer] 2 "\
Kills the current buffer." nil])
(fset 'x-new-screen #[(&optional screen-name) "ÀÁ\n­„Ã\nBC!!ˆÄÅÆ!!ˆÇÈ!­†­‚É ‡" [select-screen x-create-screen screen-name name switch-to-buffer get-buffer-create "*scratch*" boundp evi-install-undo-list evi-mode] 4 "\
Creates a new emacs screen (that is, a new X window.)" nil])
(fset 'set-menubar #[(menubar) "ÀÁÂ!\"ˆÄ ‡" [set-default current-menubar copy-sequence menubar set-menubar-dirty-flag] 4 "\
Set the default menubar to be menubar."])
(fset 'set-buffer-menubar #[(menubar) "ÀÁ!ˆÂ!Ä ‡" [make-local-variable current-menubar copy-sequence menubar set-menubar-dirty-flag] 2 "\
Set the buffer-local menubar to be menubar."])
(fset 'find-menu-item #[(menubar path &optional parent) "¬…ÁÂ\":??­óÅ‰«»@«®@È@!«‡@ÉHª@;«…@ª„@@—š«‹@Å‰ªKA‰¬EA«¦:«‹ÊAA#ªš«‰ËÌÍD\"ªËÌÎ@D\"ª„B*‡" [parent mapcar downcase path menubar nil result rest vectorp 0 find-menu-item signal error "not a submenu" "no such submenu"] 5])
(fset 'disable-menu-item #[(path) "Â	\"‰@A¬ÇÈ«ƒÉªÊD\"ˆ:«„ÈË!ˆÌÍIˆÎ ˆ,‡" [current-menubar menubar find-menu-item path pair item menu signal error "No such menu item" "No such menu" "can't disable menus, only menu items" 2 nil set-menubar-dirty-flag] 5 "\
Make the named menu item be unselectable.
PATH is a list of strings which identify the position of the menu item in 
the menu hierarchy.  (\"File\" \"Save\") means the menu item called \"Save\"
under the toplevel \"File\" menu.  (\"Menu\" \"Foo\" \"Item\") means the 
menu item called \"Item\" under the \"Foo\" submenu of \"Menu\"."])
(fset 'enable-menu-item #[(path) "Â	\"‰@A¬ÇÈ«ƒÉªÊD\"ˆ:«…ÈË\"ˆÌÍIˆÎ ˆ,‡" [current-menubar menubar find-menu-item path pair item menu signal error "No such menu item" "No such menu" "%S is a menu, not a menu item" 2 t set-menubar-dirty-flag] 5 "\
Make the named menu item be selectable.
PATH is a list of strings which identify the position of the menu item in 
the menu hierarchy.  (\"File\" \"Save\") means the menu item called \"Save\"
under the toplevel \"File\" menu.  (\"Menu\" \"Foo\" \"Item\") means the 
menu item called \"Item\" under the \"Foo\" submenu of \"Menu\"."])
(fset 'add-menu-item-1 #[(item-p menu-path item-name item-data enabled-p before) "«ƒ—	ÃÄÅ‰<«‹ÇAC\"@ª‡ÉÊËD\"¬Ş\n‰«Ó\n=«‹Ç@C\"@ªŠÇA@C\"@‰¬§‰A«A@«ˆA‰ªo@C‰CA¤¡ˆ)A‰¬-*¬ƒ\n¬ó«ŒÒ#ª‡B«ˆÇC\"@Ã«¢A@=«’AB¡ˆÃÖªbA‰¬^¬Ÿ\n=«’@=«‹B‰ª‡C¤ˆ*«’×IˆØ??IˆªŒ ˆ¡ˆÙ ˆ+‡" [before current-menubar menubar nil (byte-code "À	\n\"@‡" [find-menu-item menubar menu-path] 3) ((error)) menu find-menu-item item-name signal error "not a submenu" menu-path item so-far rest rest2 item-p vector item-data enabled-p added-before t 1 2 set-menubar-dirty-flag] 5])
(fset 'add-menu-item #[(menu-path item-name function enabled-p &optional before) "¬„ÁÂ!ˆ¬„ÁÄ!ˆÅÆ	&‡" [menu-path error "must specify a menu path" item-name "must specify an item name" add-menu-item-1 t function enabled-p before] 7 "\
Add a menu item to some menu, creating the menu first if necessary.
If the named item exists already, it is changed.
MENU-PATH identifies the menu under which the new menu item should be inserted.
 It is a list of strings; for example, (\"File\") names the top-level \"File\"
 menu.  (\"File\" \"Foo\") names a hypothetical submenu of \"File\".
ITEM-NAME is the string naming the menu item to be added.
FUNCTION is the command to invoke when this menu item is selected.
 If it is a symbol, then it is invoked with `call-interactively', in the same
 way that functions bound to keys are invoked.  If it is a list, then the 
 list is simply evaluated.
ENABLED-P controls whether the item is selectable or not.
BEFORE, if provided, is the name of a menu item before which this item should
 be added, if this item is not on the menu already.  If the item is already
 present, it will not be moved."])
(fset 'delete-menu-item #[(path) "Â	\"‰@A®	??­˜=«ˆÇ\"ª†Ç\"ˆÈ ˆ,‡" [current-menubar menubar find-menu-item path pair item menu delq set-menubar-dirty-flag] 4 "\
Remove the named menu item from the menu hierarchy.
PATH is a list of strings which identify the position of the menu item in 
the menu hierarchy.  (\"File\" \"Save\") means the menu item called \"Save\"
under the toplevel \"File\" menu.  (\"Menu\" \"Foo\" \"Item\") means the 
menu item called \"Item\" under the \"Foo\" submenu of \"Menu\"."])
(fset 'relabel-menu-item #[(path new-name) ";¬‡ÁÂÃD\"Æ\"‰@	A\n	¬ÁË\n«ƒÌªÍD\"ˆ	:«	@;«‡	 ˆª†	ÎIˆÏ ˆ	,‡" [new-name signal wrong-type-argument stringp current-menubar menubar find-menu-item path pair item menu error "No such menu item" "No such menu" 0 set-menubar-dirty-flag] 5 "\
Change the string of the specified menu item.
PATH is a list of strings which identify the position of the menu item in 
the menu hierarchy.  (\"File\" \"Save\") means the menu item called \"Save\"
under the toplevel \"File\" menu.  (\"Menu\" \"Foo\" \"Item\") means the 
menu item called \"Item\" under the \"Foo\" submenu of \"Menu\".
NEW-NAME is the string that the menu item will be printed as from now on."])
(fset 'add-menu #[(menu-path menu-name menu-items &optional before) "¬„ÁÂ!ˆ¬„ÁÄ!ˆÅÆÈ	&‡" [menu-name error "must specify a menu name" menu-items "must specify some menu items" add-menu-item-1 nil menu-path t before] 7 "\
Add a menu to the menubar or one of its submenus.
If the named menu exists already, it is changed.
MENU-PATH identifies the menu under which the new menu should be inserted.
 It is a list of strings; for example, (\"File\") names the top-level \"File\"
 menu.  (\"File\" \"Foo\") names a hypothetical submenu of \"File\".
 If MENU-PATH is nil, then the menu will be added to the menubar itself.
MENU-NAME is the string naming the menu to be added.
MENU-ITEMS is a list of menu item descriptions.
 Each menu item should be a vector of three elements:
   - a string, the name of the menu item;
   - a symbol naming a command, or a form to evaluate;
   - and t or nil, whether this item is selectable.
BEFORE, if provided, is the name of a menu before which this menu should
 be added, if this menu is not on its parent already.  If the menu is already
 present, it will not be moved."])
(byte-code "ÀÁ!¬‚ÂÀ‡" [boundp put-buffer-names-in-file-menu t] 2)
(fset 'sensitize-file-and-edit-menus-hook #[nil "À	Â\"@AÀ	Ä\"@AÀÆ\"@ÀÈ\"@	ÀÊ\"@ÀÌ\"@ÀÎ\"@ÀĞ\"@ÀÒ\"@ÀÔ\"@ÀÖ\"@ÀØ\"@®…ÀÙ\"@Û İ ßà!!â#â$%æ=?­“'Ú=­èé!­‚)$â‰%??*â+â,«ŠíH=?®Ù«ŠíH=?®Ë«ŠíH=?®½«Š!íH=?®¯«Šî íH=?®¡	«Œ/??	íH=?®‘­ğâ‰æ#ñ =íH=23«ÄGôU«ŠõIˆæ2	GôU«Š	õIˆæ2GôU«ŠõIˆæ2GôU«ŠõIˆæ2«‡íî Iˆ	«‰	í/??Iˆ«íğâ‰æ#ñ =?Iˆ«‡íIˆ«‡íIˆ«‡íIˆ«‡í!Iˆ'Ú=«ö+èé!­‚)??,ª™÷+%æ=?­%®‡èé!­‚)??,8«ƒâ,«£+ùHš«‰,íH=¬‘ù+Iˆí,Iˆæ22.?‡" [find-menu-item current-menubar ("File") file-menu ("Edit") edit-menu ("Save Buffer") save ("Revert Buffer") rvt ("Delete Screen") del ("Print Buffer") print ("Kill Buffer") kill ("Cut") cut ("Copy") copy ("Paste") paste ("Clear") clear ("Undo") ("Undo More") undo buffer-name name x-selection-owner-p emacs-owns-selection-p x-selection-exists-p CLIPBOARD clipboard-exists-p nil undo-available undoing-more buffer-undo-list t last-command boundp pending-undo-list undo-info-available undo-name undo-state 2 buffer-modified-p buffer-file-name next-screen selected-screen change-p put-buffer-names-in-file-menu 4 3 "Undo More" "Undo" buffer-read-only 0] 6 "\
For use as a value of activate-menubar-hook.
This function changes the sensitivity of these File and Edit menu items:

  Cut    sensitive only when emacs owns the primary X Selection.
  Copy   sensitive only when emacs owns the primary X Selection.
  Clear  sensitive only when emacs owns the primary X Selection.
  Paste  sensitive only when there is an owner for the X Clipboard Selection.
  Undo   sensitive only when there is undo information.
         While in the midst of an undo, this is changed to \"Undo More\".

  Kill Buffer    has the name of the current buffer appended to it.
  Print Buffer   has the name of the current buffer appended to it.
  Save Buffer    has the name of the current buffer appended to it, and is
                 sensitive only when the current buffer is modified.
  Revert Buffer  has the name of the current buffer appended to it, and is
                 sensitive only when the current buffer has a file.
  Delete Screen  sensitive only when there is more than one visible screen."])
(fset 'format-buffers-menu-line #[(buffer) "ÀÁÂ!\"?­¦ŠqˆÄ ÆÇÈ «ƒÉªÊ«ƒÌªÊÂ Î ®Ï&*‡" [string-match "\\` " buffer-name buffer buffer-size size format "%s%s %-19s %6s %-15s %s" buffer-modified-p "*" " " buffer-read-only "%" mode-name buffer-file-name ""] 8 "\
Returns a string to represent the given buffer in the Buffer menu.
nil means the buffer shouldn't be listed.  You can redefine this."])
(fset 'format-buffers-menu-line #[(buffer) "ÀÁÂ!‰\"?­‡" [string-match "\\` " buffer-name buffer] 4])
(defvar buffers-menu-max-size 10 "\
*Maximum number of entries which may appear on the \"Buffers\" menu.
If this is 10, then only the ten most-recently-selected buffers will be
shown.  If this is nil, then all buffers will be shown.  Setting this to
a large number or nil will slow down menu responsiveness.")
(defvar complex-buffers-menu-p nil "\
*If true, the buffers menu will contain several commands, as submenus
of each buffer line.  If this is false, then there will be only one command:
select that buffer.")
(defvar buffers-menu-switch-to-buffer-function 'switch-to-buffer "\
*The function to call to select a buffer from the buffers menu.
`switch-to-buffer' is a good choice, as is `pop-to-buffer'.")
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÄÇÈ#‡" [buffer-menu-save-buffer #[(buffer) "ŠqˆÁ )‡" [buffer save-buffer] 1] buffer-menu-write-file #[(buffer) "ŠqˆÁÂÃÄp!ÅQ!!)‡" [buffer write-file read-file-name "Write " buffer-name " to file: "] 5] build-buffers-menu-internal #[(buffers) "À‰Ã«ƒÅªÆ\"*‡" [nil line name mapcar complex-buffers-menu-p #[(buffer) "À	!‰­´\nÃÄÆ	!‰DÈ#É	!«Ê	!«ŠÃËÌDÈ#ªÍÃÎÏDÈ#ÃĞÑDÈ#¯‡" [format-buffers-menu-line buffer line vector "Switch to Buffer" buffers-menu-switch-to-buffer-function buffer-name name t buffer-modified-p buffer-file-name "Save Buffer" buffer-menu-save-buffer ["Save Buffer" nil nil] "Save Buffer As..." buffer-menu-write-file "Kill Buffer" kill-buffer] 8] #[(buffer) "À	!‰­‰Ã\nÅ	!DÆ#‡" [format-buffers-menu-line buffer line vector buffers-menu-switch-to-buffer-function buffer-name t] 5] buffers] 3] put byte-optimizer byte-compile-inline-expand] 4)
(fset 'build-buffers-menu-hook #[nil "À	Â\"@Ã‰‰??­ÇÇ ¨«”ÉV«GV«‡›Ã¡ˆÃ‰\nË«ƒÍªÎ\"+ÏÃ\"Ğ¤‰Aš«ƒÑª†¡ˆÃ+‡" [find-menu-item current-menubar ("Buffers") nil buffers name buffer-menu buffer-list buffers-menu-max-size 1 line mapcar complex-buffers-menu-p #[(buffer) "À	!‰­´\nÃÄÆ	!‰DÈ#É	!«Ê	!«ŠÃËÌDÈ#ªÍÃÎÏDÈ#ÃĞÑDÈ#¯‡" [format-buffers-menu-line buffer line vector "Switch to Buffer" buffers-menu-switch-to-buffer-function buffer-name name t buffer-modified-p buffer-file-name "Save Buffer" buffer-menu-save-buffer ["Save Buffer" nil nil] "Save Buffer As..." buffer-menu-write-file "Kill Buffer" kill-buffer] 8] #[(buffer) "À	!‰­‰Ã\nÅ	!DÆ#‡" [format-buffers-menu-line buffer line vector buffers-menu-switch-to-buffer-function buffer-name t] 5] delq ("----" ["List All Buffers" list-buffers t]) t] 4 "\
For use as a value of activate-menubar-hook.
This function changes the contents of the \"Buffers\" menu to correspond
to the current set of buffers.  Only the most-recently-used few buffers
will be listed on the menu, for efficiency reasons.  You can control how
many buffers will be shown by setting `buffers-menu-max-size'.
You can control the text of the menu items by redefining the function
`format-buffers-menu-line'."])
(byte-code "ÀÁÂ\"ˆÀÁÃ\"ˆÄ!‡" [add-hook activate-menubar-hook build-buffers-menu-hook sensitize-file-and-edit-menus-hook set-menubar default-menubar] 3)
(fset 'yes-or-no-p-dialog-box #[(prompt) "À ÁÄÆB!ˆÇÈ*‡" [allocate-event 0 echo-keystrokes event popup-dialog-box prompt (["Yes" yes t] ["No" no t] nil ["Abort" abort t]) ynp-done (byte-code "À	!ˆÂ	!«Ã	!Ä=«‡ÅÆÇ\"ˆªiÂ	!«Ã	!È=«‡ÅÆÉ\"ˆªVÂ	!«•Ã	!Ê=¬‡Ã	!Ë=«‡ÌÍÉ\"ˆª<Î	!¬7Ï ˆĞÑ!ˆª." [next-command-event event menu-event-p event-object yes throw ynp-done t no nil abort menu-no-selection-hook signal quit button-release-event-p beep message "please answer the dialog box"] 3)] 3 "\
Ask user a \"y or n\" question with a popup dialog box.
Returns t if answer is \"yes\".
Takes one argument, which is the string to display to ask the question."])
(fset 'yes-or-no-p-maybe-dialog-box #[(prompt) "À	!¬ŠÂ	!¬…Ã	!«„Ä!‡Æ!‡" [button-press-event-p last-command-event button-release-event-p menu-event-p yes-or-no-p-dialog-box prompt yes-or-no-p-minibuf] 2 "\
Ask user a yes-or-no question.  Return t if answer is yes.
The question is asked with a dialog box or the minibuffer, as appropriate.
Takes one argument, which is the string to display to ask the question.
It should end in a space; `yes-or-no-p' adds `(yes or no) ' to it.
The user must confirm the answer with RET,
and can edit it until it as been confirmed."])
(fset 'y-or-n-p-maybe-dialog-box #[(prompt) "À	!¬ŠÂ	!¬…Ã	!«„Ä!‡Æ!‡" [button-press-event-p last-command-event button-release-event-p menu-event-p yes-or-no-p-dialog-box prompt y-or-n-p-minibuf] 2 "\
Ask user a \"y or n\" question.  Return t if answer is \"y\".
Takes one argument, which is the string to display to ask the question.
The question is asked with a dialog box or the minibuffer, as appropriate.
It should end in a space; `y-or-n-p' adds `(y or n) ' to it.
No confirmation of the answer is requested; a single character is enough.
Also accepts Space to mean yes, or Delete to mean no."])
(byte-code "ÀÁ!«ˆÂÃMˆÄÅMˆÆÇ!‡" [fboundp popup-dialog-box yes-or-no-p yes-or-no-p-maybe-dialog-box y-or-n-p y-or-n-p-maybe-dialog-box provide menubar] 2)
