;;; compiled by jwz@thalidomide on Sat Dec 28 16:57:03 1991
;;; from file /wg1/emacs-base/lisp/vm/timer.el
;;; emacs version 19.39.
;;; bytecomp version 2.03; 29-oct-91.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(provide 'timer)
(defvar timer-list nil "\
List of all active timers.")
(defvar timer-process nil "\
Process that drives all timers.")
(defvar timer-process-next-wakeup 1 "\
Timer process will wakeup to service running timers within this
many seconds.")
(defvar timer-edit-map nil "\
Keymap used when in Timer Edit mode.")
(byte-code "¬¿Á ÂÃÄ#ˆÂÅÆ#ˆÂÇÈ#ˆÂÉÊ#ˆÂËÌ#ˆÂÍÌ#ˆÂÎÏ#ˆÂĞÑ#ˆÂÒÓ#ˆÂÔÕ#ˆÖ×!¬ƒØÙÚMˆÛÜMˆİŞM‡" [timer-edit-map make-sparse-keymap define-key "s" timer-edit-set-field "d" timer-edit-delete-timer "q" timer-edit-quit "	" timer-edit-next-field " " next-line "n" "p" previous-line "" timer-edit-previous-field "x" start-timer "?" timer-edit-help boundp timer-edit-start-marker nil decrement (macro . #[(variable) "À	Â	DE‡" [setq variable 1-] 4]) increment (macro . #[(variable) "À	Â	DE‡" [setq variable 1+] 4]) signum (macro . #[(n) "ÀÁ\nÃEÄÀÅ\nDÃÆFF‡" [if > n 0 1 zerop -1] 7])] 4)
(fset 'check-timer '(macro . #[(var) "À	ÂÃ	D	ÄÅÆÇ	EEFE‡" [setq var if timerp signal 'wrong-type-argument list 'timerp] 10 "\
If VAR is not bound to a timer, signal wrong-type-argument.
This is a macro."]))
(fset 'check-timer-coerce-string '(macro . #[(var) "À	ÂÃ	D	DÄ	DÅ	DDÆÇÈÉÊ	EEDFE‡" [setq var cond timerp stringp get-timer t signal 'wrong-type-argument list 'string-or-timer-p] 11 "\
If VAR is not bound to a string, look up the timer that it names and
bind VAR to it.  Otherwise if VAR is not bound to a timer, signal
wrong-type-argument.  This is a macro."]))
(fset 'check-natnumber '(macro . #[(var) "À	ÂÃ	D	ÄÅÆÇ	EEFE‡" [setq var if natnump signal 'wrong-type-argument list 'natnump] 10 "\
If VAR is not bound to a non-negative number, signal wrong-type-argument.
This is a macro."]))
(fset 'check-string '(macro . #[(var) "À	ÂÃ	D	ÄÅÆÇ	EEFE‡" [setq var if stringp signal 'wrong-type-argument list 'stringp] 10 "\
If VAR is not bound to a string, signal wrong-type-argument.
This is a macro."]))
(fset 'timerp #[(obj) ":­‰@;­„GÁ=‡" [obj 4] 2 "\
Returns non-nil iff OBJ is a timer."])
(fset 'timer-name #[(timer) "À	!«ƒ	ª†ÂÃÀ	D\"‰@‡" [timerp timer signal wrong-type-argument] 5 "\
Returns the name of TIMER."])
(fset 'timer-value #[(timer) "À	!«ƒ	ª†ÂÃÀ	D\"‰A@‡" [timerp timer signal wrong-type-argument] 5 "\
Returns the number of seconds until TIMER expires."])
(fset 'timer-restart #[(timer) "À	!«ƒ	ª†ÂÃÀ	D\"Ä	8‡" [timerp timer signal wrong-type-argument 2] 4 "\
Returns the value to which TIMER will be set at restart.
nil is returned if this timer doesn't restart."])
(fset 'timer-function #[(timer) "À	!«ƒ	ª†ÂÃÀ	D\"Ä	8‡" [timerp timer signal wrong-type-argument 3] 4 "\
Returns the function of TIMER.
This function is called each time TIMER expires."])
(fset 'set-timer-value #[(timer value &optional nowakeup) "À	!«ƒ	ª†ÂÃÀ	D\"Ä!«ƒª†ÂÃÄD\"Æ¬™	W«“ÊË	!!«ŒÌ ˆ	A ˆÌ ¬…	A ˆ)‡" [timerp timer signal wrong-type-argument natnump value t inhibit-quit nowakeup timer-process-next-wakeup get-timer timer-name timer-process-wakeup] 4 "\
Set the timeout value of TIMER to be VALUE.
Timer will expire is this many seconds.
Returns VALUE."])
(fset 'set-timer-restart #[(timer restart) "À	!«ƒ	ª†ÂÃÀ	D\"«Å!«ƒª†ÂÃÅD\"«‹ÆW«†ÂÇC\"ˆ	AA ‡" [timerp timer signal wrong-type-argument restart natnump 1 args-out-of-range] 4 "\
Set the restart value of TIMER to be RESTART.
If RESTART is nil, TIMER is will not restart when it expires.
Returns RESTART."])
(fset 'set-timer-function #[(timer function) "À	!«ƒ	ª†ÂÃÀ	D\"‰AAA ‡" [timerp timer signal wrong-type-argument function] 5 "\
Set the function of TIMER to be FUNCTION.
FUNCTION will be called when timer expires.
Returns FUNCTION."])
(fset 'get-timer #[(name) ";«ƒª†ÁÂÃD\"Ä\"‡" [name signal wrong-type-argument stringp assoc timer-list] 4 "\
Return timer named NAME, or nil if there is none."])
(fset 'read-timer #[(prompt &optional initial-input) "ÀÁ\nÄÅ%!‡" [get-timer completing-read prompt timer-list nil confirm initial-input] 7 "\
Read the name of a timer from the minibuffer and return the timer
associated with that name.  The user is prompted with PROMPT.
Optional second arg INITIAL-INPUT non-nil is inserted into the
  minibuffer as initial user input."])
(fset 'delete-timer #[(timer) "À	!«ƒ	ª	;«…Â	!ª†ÃÄÅ	D\"Æ	\"‰‡" [timerp timer get-timer signal wrong-type-argument string-or-timer-p delq timer-list] 4 "\
Deletes TIMER.  TIMER may be a timer or the name of one."])
(fset 'start-timer #[(name function value &optional restart) ";«ƒª†ÁÂÃD\"Ä!«ƒª†ÁÂÄD\"«“Ä!«„ª‡ÁÂÄD\"Ç	Ê!«	ËÌRTªl*«…Î ˆªƒÏ ˆĞFBW«ƒÎ ˆ)@‡" [name signal wrong-type-argument stringp natnump value restart 2 num oname get-timer "<" ">" timer-process timer-process-wakeup timer-process-start t inhibit-quit function timer-list timer-process-next-wakeup] 4 "\
Start a timer.
Args are NAME, FUNCTION, VALUE &optional RESTART.
NAME is an identifier for the timer.  It must be a string.  If a timer
  already exists with this name, NAME will be modified slightly to until
  it is unique.
FUNCTION should be a function (or symbol naming one) of no arguments.  It
  will be called each time the timer expires.  The function can access
  timer that invoked it through the variable `current-timer'.
VALUE is the number of seconds until this timer expires.
Optional fourth arg RESTART non-nil means that this timer should be
  restarted automatically after its function is called.  Normally a timer
  is deleted at expiration after its function has returned. 
  If non-nil RESTART should be a number indicating the value at which the
  timer should be set at restart time.
Returns the newly created timer." (byte-code "ÀÁ\n\"ÃÀÄÆ#!ÇÉ!¬ŠÊËÇ‰Ì$ªp)ÌÉ!¬‹ÊÎÇ‰Ì$‰¬o)F‡" [completing-read "Start timer: " timer-list read "Timer function: " obarray fboundp nil value natnump read-from-minibuffer "Timer value: " t restart "Timer restart: "] 9)])
(fset 'list-timers #[nil "ÀÁ!`\nÅ!\nqˆÈ ˆÉ\nË ˆÌÍ±ˆ¬ƒ`«µÏĞ!ˆÑÒ@!!ˆÓ ˆÑÔ@!!ˆÓ ˆÑÕ@!!ˆÓ ˆÑÖ@!!ˆA‰¬Kbˆ`W«„bˆ×\nØ\n!,‡" [get-buffer-create "*Timer List*" buf opoint standard-output reverse timer-list timers timer-edit-mode nil buffer-read-only erase-buffer "Name                  Value     Restart   Function\n" "----                  -----     -------   --------" timer-edit-start-marker newline 1 prin1 timer-name tab-to-tab-stop timer-value timer-restart timer-function t display-buffer] 4 "\
Pop up a buffer containing a list of all timers.
The major mode of the buffer is Timer Edit mode.  This major mode provides
commands to manipulate timers; see the documentation for
`timer-edit-mode' for more information." nil])
(fset 'edit-timers #[nil "«ƒÁ ˆÂ ˆÃÄÅ!!ˆbˆ«‡ÈÉ!ˆÊ ˆËÌ!‡" [timer-process timer-process-wakeup list-timers select-window get-buffer-window "*Timer List*" timer-edit-start-marker timer-list forward-sexp 2 backward-sexp message "type q to quit, ? for help"] 3 "\
Display a list of all timers and select it for editing.
The major mode of the buffer containing the listing is Timer Edit mode.
This major mode provides commands to manipulate timers; see the documentation
for `timer-edit-mode' for more information." nil])
(fset 'timer-edit-mode #[nil "À ˆÁÂ!ˆÃÅÇÉÊË!ˆÌË!ˆÍp!ˆÎ!ˆĞ!‡" [kill-all-local-variables make-local-variable tab-stop-list timer-edit-mode major-mode "Timer Edit" mode-name t truncate-lines (22 32 42) abbrev-mode 0 auto-fill-mode buffer-flush-undo use-local-map timer-edit-map set-syntax-table lisp-mode-syntax-table] 2 "\
Major mode for manipulating timers.
Atrributes of running timers are changed by moving the cursor to the
desired field and typing `s' to set that field.  The field will then be
set to the value read from the minibuffer.

Commands:
TAB    move forward a field
DEL    move backward a field
s      set a field
d      delete the selected timer
x      start a new timer
?      help"])
(put 'timer-edit-mode 'mode-class 'special)
(fset 'timer-edit-help #[nil "Á=«ƒÂ ‡ÃÄ!‡" [last-command timer-edit-help describe-mode message "TAB, DEL select fields, (s)et field, (d)elete timer   (type ? for more help)"] 2 "\
Help function for Timer Edit." nil])
(fset 'timer-edit-quit #[nil "Àp!ˆÁÂ!«†ÃÄp!!‡Å ‡" [bury-buffer one-window-p t switch-to-buffer other-buffer delete-window] 3 "\
End Timer Edit." nil])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉMˆÊËMˆÌÍMˆÎÏMˆĞÑM‡" [timer-edit-set-field #[nil "`X«„ÁÂ!ˆÃ‰ÂŠÇyˆÈÉp!!)ŠÊ ˆ`ÇÇyˆ`Y«”ÍW«ÎÏ!ˆĞ ˆTªfÑ=«…ÁÒ!ª™Ï=«ƒÓªÔ=«ƒÕª‡Í=­Ö+‰Ó=«•×Ù!¬ŠÚÃ‰Û$ªq)ªÈÕ=«™Ü«Ù!¬‹ÚÃ‰Û$‰¬p)ªªÖ=«¥İ9«…Ş!¬˜:«†@ß>¬Éà!ŞÃ$!‰ª`)âãä!P!\"ˆÊ ˆÃ‰%&çÑ!ˆè`éÃwˆ`\"ˆêp\"ˆl¬ƒë ˆĞ -‡" [timer-edit-start-marker error "" nil field-value field timer 0 get-timer read timer-edit-beginning-of-field n opoint 4 forward-sexp 2 backward-sexp 1 "Cannot change timer name." value 3 restart function "Set timer value: " prompt natnump read-from-minibuffer t "Set timer restart: " "Set timer function: " fboundp (lambda macro) completing-read obarray intern "set-timer-" symbol-name kill-ring buffer-read-only kill-sexp kill-region " 	" prin1 tab-to-tab-stop] 7 nil nil] timer-edit-delete-timer #[nil "`X«„ÁÂ!ˆÃÄÅŠÆyˆÇp!)\"!ˆÈ ‡" [timer-edit-start-marker error "" delete-timer read-timer "Delete timer: " 0 read list-timers] 5 nil nil] timer-edit-next-field #[(count) "À ˆ	ÂV«ƒÃª‰	ÂU«ƒÂªÄÂV«©	ÂU?­ÙÅ ˆm«‡bˆÅ ˆÅ ˆÇ ˆn«‡ÅÈ!ˆÇ ˆ	S‰ªX	ÂV«ƒÃª‰	ÂU«ƒÂªÄÂW­¡	ÂU?­›Ç ˆn«ƒÇ ˆ`X«†dbˆÇ ˆ	T‰ª`‡" [timer-edit-beginning-of-field count 0 1 -1 forward-sexp timer-edit-start-marker backward-sexp 2] 3 nil "p"] timer-edit-previous-field #[(count) "À	[!‡" [timer-edit-next-field count] 2 nil "p"] timer-edit-beginning-of-field #[nil "ŠÀ ˆÁ ˆ`)ŠÁ ˆ`)‰\n=«„Á ªŠ`=«ƒÄª‚Á *‡" [forward-sexp backward-sexp back forw-back t] 3] timer-process-filter #[(process string) "ÀÁ\n\"¬…ÃÄ\n\"‡«õÆ\n!ÇÈ	\nÍ«Ô@\nÏ\nĞÑ\n!Z]È#ˆÑ\n!ĞV«‹Ñ\n!^ª¥ÒÓÔˆÕ\n!¬‡Ö\n!ˆª“Ï\nÕ\n!È#ˆÑ\n!^A‰¬,Ø=«ƒÙ ˆ,ªƒÍÚÜ!İP\"‡" [string-match "^[0-9]" string message "timer process gave odd output: %s" timer-list string-to-int nil t inhibit-quit timer timers time-elapsed 600 timer-process-next-wakeup set-timer-value 0 timer-value condition-data (byte-code "ÂÂÂÂÂÇ	! ˆ.Â‡" [timer current-timer nil timers time-elapsed quit-flag inhibit-quit timer-function] 2) ((error (byte-code "ÀÁÂ!Ä!#‡" [message "timer \"%s\" signaled: %s" timer-name timer prin1-to-string condition-data] 5)) (quit (byte-code "ÀÁÂ!\"‡" [message "timer \"%s\" quit" timer-name timer] 4))) timer-restart delete-timer major-mode timer-edit-mode list-timers process-send-string timer-process int-to-string "\n"] 6] timer-process-sentinel #[(process message) "ÀÂ!Ä=«…Å!ªœÆ!ˆÇ	??­ÊË!ˆÌÍÎÏO\"ˆĞ )‡" [t inhibit-quit process-status process stop continue-process delete-process nil timer-process timer-list sit-for 2 message "timer process %s... respawning." 0 -1 timer-process-start] 5] timer-process-start #[nil "ÀÁÄÅÁÅ#Ç!ˆÈÉ\"ˆÊË\"ˆÌÎÏ\"*‡" [t nil process-connection-type inhibit-quit start-process "timer" timer-process process-kill-without-query set-process-filter timer-process-filter set-process-sentinel timer-process-sentinel 1 timer-process-next-wakeup process-send-string "1\n"] 4] timer-process-wakeup #[nil "À	!ˆÂ ‡" [interrupt-process timer-process accept-process-output] 2]] 2)
