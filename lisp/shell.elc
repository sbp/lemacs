;;; compiled by jwz@thalidomide on Wed Aug 14 22:31:19 1991
;;; from file /wg1/emacs-base/lisp/shell.el
;;; emacs version 19.60.
;;; bytecomp version 2.01 beta; 13-aug-91.
;;; optimization is on.
;;; this file uses opcodes which do not exist in Emacs18.

(if (and (boundp 'emacs-version)
	 (or (and (boundp 'epoch::version) epoch::version)
	     (string-lessp emacs-version "19")))
    (error "This file was compiled for Emacs19."))

(byte-code "ÀÁ!ˆÂÃ!ˆÄÅÆÇ#‡" [require comint provide shell put shell-prompt-pattern variable-documentation "Regexp to match prompts in the inferior shell.\nDefaults to \"^[^#$%>]*[#$%>] *\", which works pretty well.\nThis variable is used to initialise comint-prompt-regexp in the \nshell buffer.\n\nThis is a fine thing to set in your .emacs file."] 4)
(defvar shell-popd-regexp "popd" "\
*Regexp to match subshell commands equivalent to popd.")
(defvar shell-pushd-regexp "pushd" "\
*Regexp to match subshell commands equivalent to pushd.")
(defvar shell-cd-regexp "cd" "\
*Regexp to match subshell commands equivalent to cd.")
(defvar explicit-shell-file-name nil "\
*If non-nil, is file name to use for explicitly requested inferior shell.")
(defvar explicit-csh-args (byte-code "Á=«‚Â‡Ã‡" [system-type hpux ("-i" "-T") ("-i")] 2) "\
*Args passed to inferior shell by M-x shell, if the shell is csh.
Value is a list of strings, which may be nil.")
(defvar shell-dirstack nil "\
List of directories saved by pushd in this buffer's shell.")
(defvar shell-dirstack-query "dirs" "\
Command used by shell-resync-dirlist to query shell.")
(byte-code "ÀÁ!¬‚Â	¬–Ã!Å	ÆÇ#ˆÅ	ÈÇ#ˆÅ	ÉÊ#ˆÂ‡" [boundp shell-mode-map nil full-copy-sparse-keymap comint-mode-map define-key "‰" comint-dynamic-complete "	" "¿" comint-dynamic-list-completions] 4)
(defvar shell-mode-hook nil "\
*Hook for customising shell mode")
(fset 'shell-mode #[nil "À ˆ	ÃÅÇ!ˆÉÊ!ˆË\nÉÌ!ˆÍÎĞÑ!‡" [comint-mode shell-prompt-pattern comint-prompt-regexp shell-mode major-mode "shell" mode-name use-local-map shell-mode-map make-local-variable shell-dirstack nil shell-dirtrackp t shell-directory-tracker comint-input-sentinel run-hooks shell-mode-hook] 2 "\
Major mode for interacting with an inferior shell.
Return after the end of the process' output sends the text from the 
    end of process to the end of the current line.
Return before end of process output copies rest of line to end (skipping
    the prompt) and sends it.
M-x send-invisible reads a line of text without echoing it, and sends it to
    the shell.

If you accidentally suspend your process, use \\[comint-continue-subjob]
to continue it.

cd, pushd and popd commands given to the shell are watched by Emacs to keep
this buffer's default directory the same as the shell's working directory.
M-x shell-resync-dirs queries the shell and resyncs Emacs' idea of what the 
    current directory stack is.
M-x shell-dirtrack-toggle turns directory tracking on and off.

\\{shell-mode-map}
Customisation: Entry to this mode runs the hooks on comint-mode-hook and
shell-mode-hook (in that order).

Variables shell-cd-regexp, shell-pushd-regexp and shell-popd-regexp are used
to match their respective commands." nil])
(fset 'shell #[nil "ÀÁ!¬É\n®‹ÃÄ!®†ÃÅ!®ÆÈ!	Ê	PÌÍ	ÎQ!ĞÑÒÓ!­‚«‹Ô!«…JªÕ%qˆÖ ˆ,×Á!‡" [comint-check-proc "*shell*" explicit-shell-file-name getenv "ESHELL" "SHELL" "/bin/sh" prog file-name-nondirectory name "~/.emacs_" startfile intern-soft "explicit-" "-arguments" xargs-name apply make-comint "shell" file-exists-p boundp ("-i") shell-mode switch-to-buffer] 7 "\
Run an inferior shell, with I/O through buffer *shell*.
If buffer exists but shell process is not running, make new shell.
If buffer exists and shell process is running, 
 just switch to buffer *shell*.
Program used comes from variable explicit-shell-file-name,
 or (if that is nil) from the ESHELL environment variable,
 or else from SHELL if there is no ESHELL.
If a file ~/.emacs_SHELLNAME exists, it is given as initial input
 (Note that this may lose due to a timing error if the shell
  discards input when it starts up.)
The buffer is put in shell-mode, giving commands for sending input
and controlling the subjobs of the shell.  See shell-mode.
See also variable shell-prompt-pattern.

The shell file name (sans directories) is used to make a symbol name
such as `explicit-csh-arguments'.  If that symbol is a variable,
its value is used as a list of arguments when invoking the shell.
Otherwise, one argument `-i' is passed to the shell.

(Type \\[describe-mode] in the shell buffer for a list of commands.)" nil])
(fset 'shell-front-match #[(regexp str start) "Á\n#=‡" [start string-match regexp str] 5])
(fset 'shell-directory-tracker #[(str) "­ÁÁÂ\"ˆÄ•ÅÈ	#‰«†Ê!ª¢È#‰«†Ì!ªÈ#‰­„Î!*‡" [shell-dirtrackp string-match "^\\s *" str 0 nil x bos shell-match-cmd-w/optional-arg shell-popd-regexp shell-process-popd shell-pushd-regexp shell-process-pushd shell-cd-regexp shell-process-cd] 4 "\
Tracks cd, pushd and popd commands issued to the shell.
This function is called on each input passed to the shell.
It watches for cd, pushd and popd commands and sets the buffer's
default directory to track these commands.

You may toggle this tracking on and off with M-x shell-dirtrack-toggle.
If emacs gets confused, you can resync with the shell with M-x shell-resync-dirs.

See variables shell-cd-regexp, shell-pushd-regexp, and shell-popd-regexp."])
(byte-code "ÀÁMˆÂÃMˆÄÅMˆÆÇMˆÈÉM‡" [shell-match-cmd-w/optional-arg #[(cmd str start) "À	\n#­Ä•ÀÆ\n#«ƒÇªÀÈ\n#«ˆ\nÉ”É•OªÊ)‡" [shell-front-match cmd str start 0 eoc "\\s *\\(;\\|$\\)" "" "\\s +\\([^ 	;]+\\)\\s *\\(;\\|$\\)" 1 nil] 4] shell-process-popd #[(arg) "GÁU«ƒÁªƒÂ!‰«­GW«§ÁU«†ÅÆÇªŸÅBÉZ›‰\n‰AA¡ˆAË *ªƒÌÍ!)‡" [arg 0 shell-extract-num num shell-dirstack nil (byte-code "À	@!ˆ	AÂ ‡" [comint-cd shell-dirstack shell-dirstack-message] 2) ((error (message "Couldn't cd."))) ds 1 cell shell-dirstack-message message "Bad popd."] 4] shell-process-cd #[(arg) "ÀÁÂ‡" [nil (byte-code "À	GÂU«…ÃÄ!ª	!ˆÅ ‡" [comint-cd arg 0 getenv "HOME" shell-dirstack-message] 3) ((error (message "Couldn't cd.")))] 3] shell-process-pushd #[(arg) "GÁU«…ÂÃÄ‡Å!‰«¼GV«…ÈÉ!ª¸\nB‰G›ÎZÎ!›!Ğ\"ÂÒÓ-ª‰\nÂÕÖ))‡" [arg 0 nil (byte-code "«	Ã@!ˆ\nABÄ )‡ÅÆ!‡" [shell-dirstack default-directory old comint-cd shell-dirstack-message message "Directory stack empty."] 2) ((message "Couldn't cd.")) shell-extract-num num shell-dirstack message "Directory stack not that deep." default-directory ds dslen front reverse back append new-ds (byte-code "À	@!ˆ	AÃ ‡" [comint-cd new-ds shell-dirstack shell-dirstack-message] 2) ((error (message "Couldn't cd."))) old-wd (byte-code "À	!ˆ\nBÄ ‡" [comint-cd arg old-wd shell-dirstack shell-dirstack-message] 2) ((error (message "Couldn't cd.")))] 5] shell-extract-num #[(str) "ÀÁ\n\"­ƒÃ\n!‡" [string-match "^\\+[1-9][0-9]*$" str string-to-int] 3]] 2)
(fset 'shell-dirtrack-toggle #[nil "?ÁÂ«ƒÃªÄ\"‡" [shell-dirtrackp message "directory tracking %s." "ON" "OFF"] 3 "\
Turn directory tracking on and off in a shell buffer." nil])
(fset 'shell-resync-dirs #[nil "Àp!Â	!‰bˆcˆÅcˆÆÇ!ˆÈ	\"ˆÈ	Å\"ˆ`É“ˆ`\nÅcˆËÌ!ˆÍÎ!¬ŠÏ	!ˆ\nbˆªq)bˆĞÌ!ˆÇ”Ç•ÌZ{‰GÉÇÇW«›ÕÖ#ˆÌ”Ì•OBÇ•‰ª`×!ÉØÙ.‡" [get-buffer-process proc process-mark pmark shell-dirstack-query "\n" sit-for 0 comint-send-string nil pt backward-char 1 looking-at ".+\n" accept-process-output delete-char dl dl-len ds i string-match "\\s *\\(\\S +\\)\\s *" reverse (byte-code "À	@!ˆ	AÃ ‡" [comint-cd ds shell-dirstack shell-dirstack-message] 2) ((error (message "Couldn't cd.")))] 5 "\
Resync the buffer's idea of the current directory stack.
This command queries the shell with the command bound to 
shell-dirstack-query (default \"dirs\"), reads the next
line output and parses it to form the new directory stack.
DON'T issue this command unless the buffer is at a shell prompt.
Also, note that if some other subprocess decides to do output
immediately after the query, its output will be taken as the
new directory stack -- you lose. If this happens, just do the
command again." nil])
(fset 'comint-cd #[(d) "ÀÁ\n!!‡" [cd substitute-in-file-name d] 3 "\
Substitute environment variables before calling cd."])
(fset 'shell-dirstack-message #[nil "À	\nB«¨@ÆÇÈÉÊ!\"\"«ˆËÌ•ÍOPË˜«‚ÎÏQA)ªUĞ!*‡" ["" default-directory shell-dirstack ds msg dir string-match format "^%s\\(/\\|$\\)" getenv "HOME" "~/" 0 nil "~" " " message] 5])
(defvar shell-load-hook nil "\
This hook is run when shell is loaded in.
This is a good place to put keybindings.")
(run-hooks 'shell-load-hook)
