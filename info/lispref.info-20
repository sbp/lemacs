This is Info file ../../info/lispref.info, produced by Makeinfo-1.56
from the input file lispref.texinfo.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Read Only Buffers,  Next: The Buffer List,  Prev: Modification Time,  Up: Buffers

Read-Only Buffers
=================

   A buffer may be designated as "read-only".  This means that the
buffer's contents may not be modified, although you may change your view
of the contents by scrolling, narrowing, or widening, etc.

   Read-only buffers are used in two kinds of situations:

   * A buffer visiting a file is made read-only if the file is
     write-protected.

     Here, the purpose is to show the user that editing the buffer with
     the aim of saving it in the file may be futile or undesirable.
     The user who wants to change the buffer text despite this can do
     so after clearing the read-only flag with the function
     `toggle-read-only'.

   * Modes such as Dired and Rmail make buffers read-only when altering
     the contents with the usual editing commands is probably a mistake.

     The special commands of the mode in question bind
     `buffer-read-only' to `nil' (with `let') around the places where
     they change the text.

 - Variable: buffer-read-only
     This buffer-local variable specifies whether the buffer is
     read-only.  The buffer is read-only if this variable is non-`nil'.

 - Variable: inhibit-read-only
     If this variable is non-`nil', then read-only buffers and read-only
     characters may be modified.  The value of `buffer-read-only' does
     not matter when `inhibit-read-only' is non-`nil'.

     If `inhibit-read-only' is `t', all `read-only' text properties
     have no effect (*note Special Properties::.).  If
     `inhibit-read-only' is a list, then `read-only' text properties
     are ignored if they are members of the list (comparison is done
     with `eq').

 - Command: toggle-read-only
     This command changes whether the current buffer is read-only.  It
     is intended for interactive use; don't use it in programs.  At any
     given point in a program, you should know whether you want the
     read-only flag on or off; so you can set `buffer-read-only'
     explicitly to the proper value, `t' or `nil'.

 - Function: barf-if-buffer-read-only
     This function signals a `buffer-read-only' error if the current
     buffer is read-only.  *Note Interactive Call::, for another way to
     signal an error if the current buffer is read-only.


File: lispref.info,  Node: The Buffer List,  Next: Creating Buffers,  Prev: Read Only Buffers,  Up: Buffers

The Buffer List
===============

   The "buffer list" is a list of all buffers that have not been
killed.  The order of the buffers in the list is based primarily on how
recently each buffer has been displayed in the selected window.  Several
functions, notably `other-buffer', make use of this ordering.

   Every screen has its own order for the buffer list.  Switching to a
new buffer inside of a particular screen changes the buffer list order
for that screen, but does not affect the buffer list order of any other
screens.  In addition, there is a global, non-screen buffer list order
that is independent of the buffer list orders for any particular screen.

   Note that the different buffer lists all contain the same elements.
It is only the order of those elements that is different.

 - Function: buffer-list &optional SCREEN
     This function returns a list of all buffers, including those whose
     names begin with a space.  The elements are actual buffers, not
     their names.  The order of the list is specific to SCREEN, which
     defaults to the current screen.  If SCREEN is `t', the global,
     non-screen ordering is returned instead.

          (buffer-list)
               => (#<buffer buffers.texi>
                   #<buffer  *Minibuf-1*> #<buffer buffer.c>
                   #<buffer *Help*> #<buffer TAGS>)
          
          ;; Note that the name of the minibuffer
          ;;   begins with a space!
          
          (mapcar (function buffer-name) (buffer-list))
              => ("buffers.texi" " *Minibuf-1*"
                   "buffer.c" "*Help*" "TAGS")

     Buffers appear earlier in the list if they were current more
     recently.

     This list is a copy of a list used inside Emacs; modifying it has
     no effect on the buffers.

 - Function: other-buffer &optional BUFFER-OR-NAME SCREEN
     This function returns the first buffer in the buffer list other
     than BUFFER-OR-NAME, in SCREEN's ordering for the buffer list.
     (sCREEN defaults to the current screen.  If SCREEN is `t', then
     the global, non-screen ordering is used.) Usually this is the
     buffer most recently shown in the selected window, aside from
     BUFFER-OR-NAME.  Buffers are moved to the front of the list when
     they are selected and to the end when they are buried.  Buffers
     whose names start with a space are not even considered.

     If BUFFER-OR-NAME is not supplied (or if it is not a buffer), then
     some interesting buffer is returned.

     Note that the SCREEN argument has a different interpretation in
     FSF Emacs 19.

     If no suitable buffer exists, the buffer `*scratch*' is returned
     (and created, if necessary).

 - Command: list-buffers &optional FILES-ONLY
     This function displays a listing of the names of existing buffers.
     It clears the buffer `*Buffer List*', then inserts the listing
     into that buffer and displays it in a window.  `list-buffers' is
     intended for interactive use, and is described fully in `The GNU
     Emacs Manual'.  It returns `nil'.

 - Command: bury-buffer &optional BUFFER-OR-NAME
     This function puts BUFFER-OR-NAME at the end of the buffer list
     without changing the order of any of the other buffers on the list.
     This buffer therefore becomes the least desirable candidate for
     `other-buffer' to return, and appears last in the list displayed by
     `list-buffers'.

     If BUFFER-OR-NAME is `nil' or omitted, this means to bury the
     current buffer.  In addition, this switches to some other buffer
     (obtained using `other-buffer') in the selected window.  If the
     buffer is displayed in a window other than the selected one, it
     remains there.

     If you wish to remove a buffer from all the windows that display
     it, you can do so with a loop that uses `get-buffer-window'.
     *Note Buffers and Windows::.


File: lispref.info,  Node: Creating Buffers,  Next: Killing Buffers,  Prev: The Buffer List,  Up: Buffers

Creating Buffers
================

   This section describes the two primitives for creating buffers.
`get-buffer-create' creates a buffer if it finds no existing buffer;
`generate-new-buffer' always creates a new buffer, and gives it a
unique name.

   Other functions you can use to create buffers include
`with-output-to-temp-buffer' (*note Temporary Displays::.) and
`create-file-buffer' (*note Visiting Files::.).

 - Function: get-buffer-create NAME
     This function returns a buffer named NAME.  If such a buffer
     already exists, it is returned.  If such a buffer does not exist,
     one is created and returned.  The buffer does not become the
     current buffer--this function does not change which buffer is
     current.

     An error is signaled if NAME is not a string.

          (get-buffer-create "foo")
               => #<buffer foo>

     The major mode for the new buffer is set by the value of
     `default-major-mode'.  *Note Auto Major Mode::.

 - Function: generate-new-buffer NAME
     This function returns a newly created, empty buffer, but does not
     make it current.  If there is no buffer named NAME, then that is
     the name of the new buffer.  If that name is in use, this function
     adds suffixes of the form `<N>' are added to NAME, where N is an
     integer.  It tries successive integers starting with 2 until it
     finds an available name.

     An error is signaled if NAME is not a string.

          (generate-new-buffer "bar")
               => #<buffer bar>
          (generate-new-buffer "bar")
               => #<buffer bar<2>>
          (generate-new-buffer "bar")
               => #<buffer bar<3>>

     The major mode for the new buffer is set by the value of
     `default-major-mode'.  *Note Auto Major Mode::.

     See the related function `generate-new-buffer-name' in *Note
     Buffer Names::.


File: lispref.info,  Node: Killing Buffers,  Next: Current Buffer,  Prev: Creating Buffers,  Up: Buffers

Killing Buffers
===============

   "Killing a buffer" makes its name unknown to Emacs and makes its
space available for other use.

   The buffer object for the buffer which has been killed remains in
existence as long as anything refers to it, but it is specially marked
so that you cannot make it current or display it.  Killed buffers retain
their identity, however; two distinct buffers, when killed, remain
distinct according to `eq'.

   If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This means
that killing a buffer can in general change the current buffer.
Therefore, when you kill a buffer, you should also take the precautions
associated with changing the current buffer (unless you happen to know
that the buffer being killed isn't current).  *Note Current Buffer::.

   The `buffer-name' of a killed buffer is `nil'.  You can use this
feature to test whether a buffer has been killed:

     (defun killed-buffer-p (buffer)
       "Return t if BUFFER is killed."
       (not (buffer-name buffer)))

 - Command: kill-buffer BUFFER-OR-NAME
     This function kills the buffer BUFFER-OR-NAME, freeing all its
     memory for use as space for other buffers.  (Emacs version 18 and
     older was unable to return the memory to the operating system.)
     It returns `nil'.

     Any processes that have this buffer as the `process-buffer' are
     sent the `SIGHUP' signal, which normally causes them to terminate.
     (The usual meaning of `SIGHUP' is that a dialup line has been
     disconnected.)  *Note Deleting Processes::.

     If the buffer is visiting a file when `kill-buffer' is called and
     the buffer has not been saved since it was last modified, the user
     is asked to confirm before the buffer is killed.  This is done
     even if `kill-buffer' is not called interactively.  To prevent the
     request for confirmation, clear the modified flag before calling
     `kill-buffer'.  *Note Buffer Modification::.

     Just before actually killing the buffer, after asking all
     questions, `kill-buffer' runs the normal hook `kill-buffer-hook'.
     The buffer to be killed is current when the hook functions run.
     *Note Hooks::.

     Killing a buffer that is already dead has no effect.

          (kill-buffer "foo.unchanged")
               => nil
          (kill-buffer "foo.changed")
          
          ---------- Buffer: Minibuffer ----------
          Buffer foo.changed modified; kill anyway? (yes or no) `yes'
          ---------- Buffer: Minibuffer ----------
          
               => nil


File: lispref.info,  Node: Current Buffer,  Prev: Killing Buffers,  Up: Buffers

The Current Buffer
==================

   There are, in general, many buffers in an Emacs session.  At any
time, one of them is designated as the "current buffer".  This is the
buffer in which most editing takes place, because most of the primitives
for examining or changing text in a buffer operate implicitly on the
current buffer (*note Text::.).  Normally the buffer that is displayed
on the screen in the selected window is the current buffer, but this is
not always so: a Lisp program can designate any buffer as current
temporarily in order to operate on its contents, without changing what
is displayed on the screen.

   The way to designate a current buffer in a Lisp program is by calling
`set-buffer'.  The specified buffer remains current until a new one is
designated.

   When an editing command returns to the editor command loop, the
command loop designates the buffer displayed in the selected window as
current, to prevent confusion: the buffer that the cursor is in, when
Emacs reads a command, is the one to which the command will apply.
(*Note Command Loop::.)  Therefore, `set-buffer' is not usable for
switching visibly to a different buffer so that the user can edit it.
For this, you must use the functions described in *Note Displaying
Buffers::.

   However, Lisp functions that change to a different current buffer
should not leave it to the command loop to set it back afterwards.
Editing commands written in Emacs Lisp can be called from other programs
as well as from the command loop.  It is convenient for the caller if
the subroutine does not change which buffer is current (unless, of
course, that is the subroutine's purpose).  Therefore, you should
normally use `set-buffer' within a `save-excursion' that will restore
the current buffer when your program is done (*note Excursions::.).
Here is an example, the code for the command `append-to-buffer' (with
the documentation string abridged):

     (defun append-to-buffer (buffer start end)
       "Append to specified buffer the text of the region..."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))

This function binds a local variable to the current buffer, and then
`save-excursion' records the values of point, the mark, and the
original buffer.  Next, `set-buffer' makes another buffer current.
Finally, `insert-buffer-substring' copies the string from the original
current buffer to the new current buffer.

   If the buffer appended to happens to be displayed in some window,
then the next redisplay will show how its text has changed.  Otherwise,
you will not see the change immediately on the screen.  The buffer
becomes current temporarily during the execution of the command, but
this does not cause it to be displayed.

   Changing the current buffer between the binding and unbinding of a
buffer-local variable can cause it to be bound in one buffer, and then
unbound in another!  You can avoid this problem by using save-excursion
to make sure that the buffer from which the variable was bound is
current again whenever the variable is unbound.

     (let (buffer-read-only)
       (save-excursion
         (set-buffer ...)
         ...))

 - Function: current-buffer
     This function returns the current buffer.

          (current-buffer)
               => #<buffer buffers.texi>

 - Function: set-buffer BUFFER-OR-NAME
     This function makes BUFFER-OR-NAME the current buffer.  However,
     it does not display the buffer in the currently selected window or
     in any other window.  This means that the user cannot necessarily
     see the buffer, but Lisp programs can in any case work on it.

     This function returns the buffer identified by BUFFER-OR-NAME.  An
     error is signaled if BUFFER-OR-NAME does not identify an existing
     buffer.


File: lispref.info,  Node: Windows,  Next: Screens,  Prev: Buffers,  Up: Top

Windows
*******

   This chapter describes most of the functions and variables related to
Emacs windows.  See *Note Display::, for information on how text is
displayed in windows.

* Menu:

* Basic Windows::          Basic information on using windows.
* Splitting Windows::      Splitting one window into two windows.
* Deleting Windows::       Deleting a window gives its space to other windows.
* Selecting Windows::      The selected window is the one that you edit in.
* Cyclic Window Ordering:: Moving around the existing windows.
* Buffers and Windows::    Each window displays the contents of a buffer.
* Displaying Buffers::     Higher-lever functions for displaying a buffer
                             and choosing a window for it.
* Choosing Window::	   How to choose a window for displaying a buffer.
* Window Point::           Each window has its own location of point.
* Window Start::           The display-start position controls which text
                             is on-screen in the window.
* Vertical Scrolling::     Moving text up and down in the window.
* Horizontal Scrolling::   Moving text sideways on the window.
* Size of Window::         Accessing the size of a window.
* Resizing Windows::       Changing the size of a window.
* Coordinates and Windows::Converting coordinates to windows.
* Window Configurations::  Saving and restoring the state of the screen.


File: lispref.info,  Node: Basic Windows,  Next: Splitting Windows,  Up: Windows

Basic Concepts of Emacs Windows
===============================

   A "window" is the physical area of the screen in which a buffer is
displayed.  The term is also used to refer to a Lisp object which
represents that screen area in Emacs Lisp.  It should be clear from the
context which is meant.

   There is always at least one window displayed on the screen, and
there is exactly one window that we call the "selected window".  The
cursor is in the selected window.  The selected window's buffer is
usually the current buffer (except when `set-buffer' has been used.)
*Note Current Buffer::.

   For all intents, a window only exists while it is displayed on the
terminal.  Once removed from the display, the window is effectively
deleted and should not be used, *even though there may still be
references to it* from other Lisp objects.  Restoring a saved window
configuration is the only way for a window no longer on the screen to
come back to life.  (*Note Deleting Windows::.)

   Each window has the following attributes:

   * containing screen

   * window height

   * window width

   * window edges with respect to the screen or screen

   * the buffer it displays

   * position within the buffer at the upper left of the window

   * the amount of horizontal scrolling, in columns

   * point

   * the mark

   * how recently the window was selected

   Applications use multiple windows for a variety of reasons, but most
often to give different views of the same information.  In Rmail, for
example, you can move through a summary buffer in one window while the
other window shows messages one at a time as they are reached.

   The term "window" in Emacs means something similar to what it means
in the context of general purpose window systems such as X, but not
identical.  The X Window System subdivides the screen into X windows;
Emacs uses one or more X windows, called "screens" in Emacs
terminology, and subdivides each of them into (nonoverlapping) Emacs
windows.  When you use Emacs on an ordinary display terminal, Emacs
subdivides the terminal screen into Emacs windows.

   Most window systems support arbitrarily located overlapping windows.
In contrast, Emacs windows are "tiled"; they never overlap, and
together they fill the whole of the screen or screen.  Because of the
way in which Emacs creates new windows and resizes them, you can't
create every conceivable tiling on an Emacs screen.  *Note Splitting
Windows::.  Also, see *Note Size of Window::.

   *Note Display::, for information on how the contents of the window's
buffer are displayed in the window.

 - Function: windowp OBJECT
     This function returns `t' if OBJECT is a window.


File: lispref.info,  Node: Splitting Windows,  Next: Deleting Windows,  Prev: Basic Windows,  Up: Windows

Splitting Windows
=================

   The functions described here are the primitives used to split a
window into two windows.  Two higher level functions sometimes split a
window, but not always: `pop-to-buffer' and `display-buffer' (*note
Displaying Buffers::.).

   The functions described here do not accept a buffer as an argument.
They let the two "halves" of the split window display the same buffer
previously visible in the window that was split.

 - Function: one-window-p &optional NO-MINI
     This function returns non-`nil' if there is only one window.  The
     argument NO-MINI, if non-`nil', means don't count the minibuffer
     even if it is active; otherwise, the minibuffer window is
     included, if active, in the total number of windows which is
     compared against one.

 - Command: split-window &optional WINDOW SIZE HORIZONTAL
     This function splits WINDOW into two windows.  The original window
     WINDOW remains the selected window, but occupies only part of its
     former screen area.  The rest is occupied by a newly created
     window which is returned as the value of this function.

     If HORIZONTAL is non-`nil', then WINDOW splits side by side,
     keeping the leftmost SIZE columns and giving the rest of the
     columns to the new window.  Otherwise, it splits into halves one
     above the other, keeping the upper SIZE lines and giving the rest
     of the lines to the new window.  The original window is therefore
     the right-hand or upper of the two, and the new window is the
     left-hand or lower.

     If WINDOW is omitted or `nil', then the selected window is split.
     If SIZE is omitted or `nil', then WINDOW is divided evenly into
     two parts.  (If there is an odd line, it is allocated to the new
     window.)  When `split-window' is called interactively, all its
     arguments are `nil'.

     The following example starts with one window on a screen that is 50
     lines high by 80 columns wide; then the window is split.

          (setq w (selected-window))
               => #<window 8 on windows.texi>
          (window-edges)          ; Edges in order:
               => (0 0 80 50)     ;   left--top--right--bottom

          ;; Returns window created
          (setq w2 (split-window w 15))
               => #<window 28 on windows.texi>

          (window-edges w2)
               => (0 15 80 50)    ; Bottom window;
                                  ;   top is line 15

          (window-edges w)
               => (0 0 80 15)     ; Top window

     The screen looks like this:

          __________
                  |          |  line 0
                  |    w     |
                  |__________|
                  |          |  line 15
                  |    w2    |
                  |__________|
                                line 50
           column 0   column 80

     Next, the top window is split horizontally:

          (setq w3 (split-window w 35 t))
               => #<window 32 on windows.texi>

          (window-edges w3)
               => (35 0 80 15)  ; Left edge at column 35

          (window-edges w)
               => (0 0 35 15)   ; Right edge at column 35

          (window-edges w2)
               => (0 15 80 50)  ; Bottom window unchanged

     Now, the screen looks like this:

          column 35
                   __________
                  |   |      |  line 0
                  | w |  w3  |
                  |___|______|
                  |          |  line 15
                  |    w2    |
                  |__________|
                                line 50
           column 0   column 80

 - Command: split-window-vertically SIZE
     This function splits the selected window into two windows, one
     above the other, leaving the selected window with SIZE lines.

     This function is simply an interface to `split-windows'.  Here is
     the complete function definition for it:

          (defun split-window-vertically (&optional arg)
            "Split selected window into two windows,
          one above the other..."
            (interactive "P")
            (split-window nil (and arg (prefix-numeric-value arg))))

 - Command: split-window-horizontally SIZE
     This function splits the selected window into two windows
     side-by-side, leaving the selected window with SIZE columns.

     This function is simply an interface to `split-windows'.  Here is
     the complete definition for `split-window-horizontally' (except for
     part of the documentation string):

          (defun split-window-horizontally (&optional arg)
            "Split selected window into two windows
          side by side..."
            (interactive "P")
            (split-window nil (and arg (prefix-numeric-value arg)) t))


File: lispref.info,  Node: Deleting Windows,  Next: Selecting Windows,  Prev: Splitting Windows,  Up: Windows

Deleting Windows
================

   A window remains visible on its screen unless you "delete" it by
calling certain functions that delete windows.  A deleted window cannot
appear on the screen, but continues to exist as a Lisp object until
there are no references to it.  There is no way to cancel the deletion
of a window aside from restoring a saved window configuration (*note
Window Configurations::.).  Restoring a window configuration also
deletes any windows that aren't part of that configuration.

   When you delete a window, the space it took up is given to one
adjacent sibling.  (In Emacs version 18, the space was divided evenly
among all the siblings.)

 - Function: window-live-p WINDOW
     This function returns `nil' if WINDOW is deleted, and `t'
     otherwise.

     *Warning:* erroneous information or fatal errors may result from
     using a deleted window as if it were live.

 - Command: delete-window &optional WINDOW
     This function removes WINDOW from the display.  If WINDOW is
     omitted, then the selected window is deleted.  An error is signaled
     if there is only one window when `delete-window' is called.

     This function returns `nil'.

     When `delete-window' is called interactively, WINDOW defaults to
     the selected window.

 - Command: delete-other-windows &optional WINDOW
     This function makes WINDOW the only window on its screen, by
     deleting all the other windows.  If WINDOW is omitted or `nil',
     then the selected window is used by default.

     The result is `nil'.

 - Command: delete-windows-on BUFFER &optional SCREEN
     This function deletes all windows showing BUFFER.  If there are no
     windows showing BUFFER, then this function does nothing.  If all
     windows in some screen are showing BUFFER (including the case
     where there is only one window), then the screen reverts to having
     a single window showing the buffer chosen by `other-buffer'.
     *Note The Buffer List::.

     If there are several windows showing different buffers, then those
     showing BUFFER are removed, and the others are expanded to fill the
     void.

     If SCREEN is a screen, then `delete-windows-on' considers just the
     windows on SCREEN.  If SCREEN is `nil', all windows on all screens
     are considered.  If SCREEN is `t', that stands for the selected
     screen.

     This function always returns `nil'.


File: lispref.info,  Node: Selecting Windows,  Next: Cyclic Window Ordering,  Prev: Deleting Windows,  Up: Windows

Selecting Windows
=================

   When a window is selected, the buffer in the window becomes the
current buffer, and the cursor will appear in it.

 - Function: selected-window
     This function returns the selected window.  This is the window in
     which the cursor appears and to which many commands apply.

 - Function: select-window WINDOW
     This function makes WINDOW the selected window.  The cursor then
     appears in WINDOW (on redisplay).  The buffer being displayed in
     WINDOW is immediately designated the current buffer.

     The return value is WINDOW.

          (setq w (next-window))
          (select-window w)
               => #<window 65 on windows.texi>

   The following functions choose one of the windows on the screen,
offering various criteria for the choice.

 - Function: get-lru-window &optional ALL-SCREENS
     This function returns the window least recently "used" (that is,
     selected).  The selected window is always the most recently used
     window.

     The selected window can be the least recently used window if it is
     the only window.  A newly created window becomes the least
     recently used window until it is selected.  The minibuffer window
     is not considered a candidate.

     The argument ALL-SCREENS controls which set of windows are
     considered.  If it is non-`nil', then all windows on all screens
     are considered.  Otherwise, only windows in the selected screen are
     considered.

 - Function: get-largest-window &optional ALL-SCREENS
     This function returns the window with the largest area (height
     times width).  If there are no side-by-side windows, then this is
     the window with the most lines.  The minibuffer window is not
     considered a candidate.

     If there are two windows of the same size, then the function
     returns the window which is first in the cyclic ordering of
     windows (see following section), starting from the selected window.

     The argument ALL-SCREENS controls which set of windows are
     considered.  If it is non-`nil', then all windows on all screens
     are considered.  Otherwise, only windows in the selected screen are
     considered.


File: lispref.info,  Node: Cyclic Window Ordering,  Next: Buffers and Windows,  Prev: Selecting Windows,  Up: Windows

Cycling Ordering of Windows
===========================

   When you use the command `C-x o' (`other-window') to select the next
window, it moves through all the windows on the screen in a specific
cyclic order.  For any given configuration of windows, this order never
varies.  It is called the "cyclic ordering of windows".

   This ordering generally goes from top to bottom, and from left to
right.  But it may go down first or go right first, depending on the
order in which the windows were split.

   If the first split was vertical (into windows one above each other),
and then the subwindows were split horizontally, then the ordering is
left to right in the top, and then left to right in the next lower part
of the screen, and so on.  If the first split was horizontal, the
ordering is top to bottom in the left part, and so on.  In general,
within each set of siblings at any level in the window tree, the order
is left to right, or top to bottom.

 - Function: next-window WINDOW &optional MINIBUF ALL-SCREENS
     This function returns the window following WINDOW in the cyclic
     ordering of windows.  This is the window which `C-x o' would select
     if done when WINDOW is selected.  If WINDOW is the only window
     visible, then this function returns WINDOW.

     The value of the argument MINIBUF determines whether the
     minibuffer is included in the window order.  Normally, when
     MINIBUF is `nil', the minibuffer is included if it is currently
     active; this is the behavior of `C-x o'.

     If MINIBUF is `t', then the cyclic ordering includes the
     minibuffer window even if it is not active.

     If MINIBUF is neither `t' nor `nil', then the minibuffer window is
     not included even if it is active.  (The minibuffer window is
     active while the minibuffer is in use.  *Note Minibuffers::.)

     When there are multiple screens, this functions normally cycles
     through all the windows in the selected screen, plus the
     minibuffer used by the selected screen even if it lies in some
     other screen.

     If ALL-SCREENS is `t', then it cycles through all the windows in
     all the screens that currently exist.

     If ALL-SCREENS is neither `t' nor `nil', then it cycles through
     precisely the windows in the selected screen, excluding the
     minibuffer in use if it lies in some other screen.

     This example shows two windows, which both happen to be displaying
     the same buffer:

          (selected-window)
               => #<window 56 on windows.texi>
          (next-window (selected-window))
               => #<window 52 on windows.texi>
          (next-window (next-window (selected-window)))
               => #<window 56 on windows.texi>

 - Function: previous-window WINDOW &optional MINIBUF ALL-SCREENS
     This function returns the window preceding WINDOW in the cyclic
     ordering of windows.  The other arguments affect which windows are
     included in the cycle, as in `next-window'.

 - Command: other-window COUNT
     This function selects the COUNTth next window in the cyclic order.
     If count is negative, then it selects the -COUNTth preceding
     window.  It returns `nil'.

     In an interactive call, COUNT is the numeric prefix argument.

 - Function: walk-windows PROC &optional MINIBUF ALL-SCREENS
     This function cycles through all visible windows, calling `proc'
     once for each window with the window as its sole argument.

     The optional argument MINIBUF says whether to include minibuffer
     windows.  A value of `t' means count the minibuffer window even if
     not active.  A value of `nil' means count it only if active.  Any
     other value means not to count the minibuffer even if it is active.

     If the optional third argument ALL-SCREENS is `t', that means
     include all windows in all screens.  If ALL-SCREENS is `nil', it
     means to cycle within the selected screen, but include the
     minibuffer window (if MINIBUF says so) that that screen uses, even
     if it is on another screen.  If ALL-SCREENS is neither `nil' nor
     `t', `walk-windows' sticks strictly to the selected screen.


File: lispref.info,  Node: Buffers and Windows,  Next: Displaying Buffers,  Prev: Cyclic Window Ordering,  Up: Windows

Buffers and Windows
===================

   This section describes low-level functions to examine windows or to
show buffers in windows in a precisely controlled fashion.

   *Note Displaying Buffers::, for related functions that find a window
to use and specify a buffer for it.  The functions described there are
easier to use than these, but they employ heuristics in choosing or
creating a window; use these functions when you need complete control.

 - Function: set-window-buffer WINDOW BUFFER-OR-NAME
     This function makes WINDOW display BUFFER-OR-NAME as its contents.
     It returns `nil'.

          (set-window-buffer (selected-window) "foo")
               => nil

 - Function: window-buffer &optional WINDOW
     This function returns the buffer that WINDOW is displaying.  If
     WINDOW is omitted, then this function returns the buffer for the
     selected window.

          (window-buffer)
               => #<buffer windows.texi>

 - Function: get-buffer-window BUFFER-OR-NAME &optional ALL-SCREENS
     This function returns a window currently displaying
     BUFFER-OR-NAME, or `nil' if there is none.  If there are several
     such windows, then the function returns the first one in the
     cyclic ordering of windows, starting from the selected window.
     *Note Cyclic Window Ordering::.

     The argument ALL-SCREENS controls which set of windows are
     considered.
        * If it is `nil', then windows on the selected screen are
          considered.

        * If it is a screen, then windows on that screen are considered.

        * If it is `t', then windows on all visible screens are
          considered.

        * If it is some other non-`nil' value, then all windows on all
          screens are considered.

 - Command: replace-buffer-in-windows BUFFER
     This function replaces BUFFER with some other buffer in all
     windows displaying it.  The other buffer used is chosen with
     `other-buffer'.  In the usual applications of this function, you
     don't care which other buffer is used; you just want to make sure
     that BUFFER is no longer displayed.

     This function returns `nil'.


File: lispref.info,  Node: Displaying Buffers,  Next: Choosing Window,  Prev: Buffers and Windows,  Up: Windows

Displaying Buffers in Windows
=============================

   In this section we describe convenient functions that choose a window
automatically and use it to display a specified buffer.  These functions
can also split an existing window in certain circumstances.  We also
describe variables that parameterize the heuristics used for choosing a
window.

   *Note Buffers and Windows::, for low-level functions that give you
more precise control.

   Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which is gratuitous and will surprise the user.  Instead, use
`set-buffer' (*note Current Buffer::.) and `save-excursion' (*note
Excursions::.), which designate buffers as current for programmed
access without affecting the display of buffers in windows.

 - Command: switch-to-buffer BUFFER-OR-NAME &optional NORECORD
     This function makes BUFFER-OR-NAME the current buffer, and also
     displays the buffer in the selected window.  This means that a
     human can see the buffer and subsequent keyboard commands will
     apply to it.  Contrast this with `set-buffer', which makes
     BUFFER-OR-NAME the current buffer but does not display it in the
     selected window.  *Note Current Buffer::.

     If BUFFER-OR-NAME does not identify an existing buffer, then a new
     buffer by that name is created.

     Normally the specified buffer is put at the front of the buffer
     list.  This affects the operation of `other-buffer'.  However, if
     NORECORD is non-`nil', this is not done.  *Note The Buffer List::.

     The `switch-to-buffer' function is often used interactively, as
     the binding of `C-x b'.  It is also used frequently in programs.
     It always returns `nil'.

 - Command: switch-to-buffer-other-window BUFFER-OR-NAME
     This function makes BUFFER-OR-NAME the current buffer and displays
     it in a window not currently selected.  It then selects that
     window.  The handling of the buffer is the same as in
     `switch-to-buffer'.

     The previously selected window is absolutely never used to display
     the buffer.  If it is the only window, then it is split to make a
     distinct window for this purpose.  If the selected window is
     already displaying the buffer, then it continues to do so, but
     another window is nonetheless found to display it in as well.

 - Function: pop-to-buffer BUFFER-OR-NAME &optional OTHER-WINDOW
     This function makes BUFFER-OR-NAME the current buffer and switches
     to it in some window, preferably not the window previously
     selected.  The "popped-to" window becomes the selected window.

     If the variable `pop-up-screens' is non-`nil', `pop-to-buffer'
     creates a new screen to display the buffer in.  Otherwise, if the
     variable `pop-up-windows' is non-`nil', windows may be split to
     create a new window that is different from the original window.
     For details, see *Note Choosing Window::.

     If OTHER-WINDOW is non-`nil', `pop-to-buffer' finds or creates
     another window even if BUFFER-OR-NAME is already visible in the
     selected window.  Thus BUFFER-OR-NAME could end up displayed in
     two windows.  On the other hand, if BUFFER-OR-NAME is already
     displayed in the selected window and OTHER-WINDOW is `nil', then
     the selected window is considered sufficient display for
     BUFFER-OR-NAME, so that nothing needs to be done.

     If BUFFER-OR-NAME is a string that does not name an existing
     buffer, a buffer by that name is created.

     An example use of this function is found at the end of *Note
     Filter Functions::.


File: lispref.info,  Node: Choosing Window,  Next: Window Point,  Prev: Displaying Buffers,  Up: Windows

Choosing a Window
=================

   This section describes the basic facility which chooses a window to
display a buffer in--`display-buffer'.  All the higher-level functions
and commands use this subroutine.  Here we describe how to use
`display-buffer' and how to customize it.

 - Function: display-buffer BUFFER-OR-NAME &optional NOT-THIS-WINDOW
     This function makes BUFFER-OR-NAME appear in some window, like
     `pop-to-buffer', but it does not select that window and does not
     make the buffer current.  The identity of the selected window is
     unaltered by this function.

     If NOT-THIS-WINDOW is non-`nil', it means that the specified
     buffer should be displayed in a window other than the selected
     one, even if it is already on display in the selected window.
     This can cause the buffer to appear in two windows at once.
     Otherwise, if BUFFER-OR-NAME is already being displayed in any
     window, that is good enough, so this function does nothing.

     `display-buffer' returns the window chosen to display
     BUFFER-OR-NAME.

     Precisely how `display-buffer' finds or creates a window depends on
     the variables described below.

   A window can be marked as "dedicated" to its buffer.  Then
`display-buffer' does not try to use that window.

 - Function: window-dedicated-p WINDOW
     This function returns `t' if WINDOW is marked as dedicated;
     otherwise `nil'.

 - Function: set-window-dedicated-p WINDOW FLAG
     This function marks WINDOW as dedicated if FLAGS is non-`nil', and
     nondedicated otherwise.

 - User Option: pop-up-windows
     This variable controls whether `display-buffer' makes new windows.
     If it is non-`nil' and there is only one window, then that window
     is split.  If it is `nil', then `display-buffer' does not split
     the single window, but rather replaces its buffer.

 - User Option: split-height-threshold
     This variable determines when `display-buffer' may split a window,
     if there are multiple windows.  `display-buffer' splits the
     largest window if it has at least this many lines.

     If there is only one window, it is split regardless of this value,
     provided `pop-up-windows' is non-`nil'.

 - User Option: pop-up-screens
     This variable controls whether `display-buffer' makes new screens.
     If it is non-`nil', `display-buffer' makes a new screen.  If it
     is `nil', then `display-buffer' either splits a window or reuses
     one.

     If this is non-`nil', the variables `pop-up-windows' and
     `split-height-threshold' do not matter.

     *Note Screens::, for more information.

 - Variable: pop-up-screen-function
     This variable specifies how to make a new screen if `pop-up-screen'
     is non-`nil'.

     Its value should be a function of no arguments.  When
     `display-buffer' makes a new screen, it does so by calling that
     function, which should return a screen.  The default value of the
     variable is a function which creates a screen using parameters from
     `pop-up-screen-alist'.

 - Variable: pop-up-screen-alist
     This variable holds an alist specifying screen parameters used when
     `display-buffer' makes a new screen.  *Note Screen Parameters::,
     for more information about screen parameters.

 - Variable: display-buffer-function
     This variable is the most flexible way to customize the behavior of
     `display-buffer'.  If it is non-`nil', it should be a function
     that `display-buffer' calls to do the work.  The function should
     accept two arguments, the same two arguments that `display-buffer'
     received.  It should choose or create a window, display the
     specified buffer, and then return the window.

     This hook takes precedence over all the other options and hooks
     described above.


File: lispref.info,  Node: Window Point,  Next: Window Start,  Prev: Choosing Window,  Up: Windows

Window Point
============

   Each window has its own value of point, independent of the value of
point in other windows displaying the same buffer.  This makes it useful
to have multiple windows showing one buffer.

   * The window point is established when a window is first created; it
     is initialized from the buffer's point, or from the window point
     of another window opened on the buffer if such a window exists.

   * Selecting a window sets the value of point in its buffer to the
     window's value of point.  Conversely, deselecting a window sets
     the window's value of point from that of the buffer.  Thus, when
     you switch between windows that display a given buffer, the point
     value for the selected window is in effect in the buffer, while
     the point values for the other windows are stored in those windows.

   * As long as the selected window displays the current buffer, the
     window's point and the buffer's point always move together; they
     remain equal.

   * *Note Positions::, for more details on positions.

   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

 - Function: window-point WINDOW
     This function returns the current position of point in WINDOW.
     For a nonselected window, this is the value point would have (in
     that window's buffer) if that window were selected.

     When WINDOW is the selected window and its buffer is also the
     current buffer, the value returned is the same as point in that
     buffer.

     Strictly speaking, it would be more correct to return the
     "top-level" value of point, outside of any `save-excursion' forms.
     But that value is hard to find.

 - Function: set-window-point WINDOW POSITION
     This function positions point in WINDOW at position POSITION in
     WINDOW's buffer.


File: lispref.info,  Node: Window Start,  Next: Vertical Scrolling,  Prev: Window Point,  Up: Windows

The Window Start Position
=========================

   Each window contains a marker used to keep track of a buffer position
which specifies where in the buffer display should start.  This position
is called the "display-start" position of the window (or just the
"start").  The character after this position is the one that appears at
the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

 - Function: window-start &optional WINDOW
     This function returns the display-start position of window WINDOW.
     If WINDOW is `nil', the selected window is used.

          (window-start)
               => 7058

     For a more complicated example of use, see the description of
     `count-lines' in *Note Text Lines::.

 - Function: window-end &optional WINDOW
     This function returns the position of the end of the display in
     window WINDOW.  If WINDOW is `nil', the selected window is used.

 - Function: set-window-start WINDOW POSITION &optional NOFORCE
     This function sets the display-start position of WINDOW to
     POSITION in WINDOW's buffer.

     The display routines insist that the position of point be visible
     when a buffer is displayed.  Normally, they change the
     display-start position (that is, scroll the window) whenever
     necessary to make point visible.  However, if you specify the
     start position with this function with `nil' for NOFORCE, it means
     you want display to start at POSITION even if that would put the
     location of point off the screen.  What the display routines do in
     this case is move point instead, to the left margin on the middle
     line in the window.

     For example, if point is 1 and you attempt to set the start of the
     window to 2, then the position of point would be "above" the top
     of the window.  The display routines would automatically move
     point if it is still 1 when redisplay occurs.  Here is an example:

          ;; Here is what `foo' looks like before executing
          ;;   the `set-window-start' expression.
          
          ---------- Buffer: foo ----------
          -!-This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------
          
          (set-window-start
           (selected-window)
           (1+ (window-start)))
          
          ;; Here is what `foo' looks like after executing
          ;;   the `set-window-start' expression.
          
          ---------- Buffer: foo ----------
          his is the contents of buffer foo.
          2
          3
          -!-4
          5
          6
          ---------- Buffer: foo ----------
          
               => 2

     However, when NOFORCE is non-`nil', `set-window-start' does
     nothing if the specified start position would make point invisible.

     This function returns POSITION, regardless of whether the NOFORCE
     option caused that position to be overruled.

 - Function: pos-visible-in-window-p &optional POSITION WINDOW
     This function returns `t' if POSITION is within the range of text
     currently visible on the screen in WINDOW.  It returns `nil' if
     POSITION is scrolled vertically out of view.  The argument
     POSITION defaults to the current position of point; WINDOW, to the
     selected window.  Here is an example:

          (or
          (pos-visible-in-window-p
           (point) (selected-window))
              (recenter 0))

     The `pos-visible-in-window-p' function considers only vertical
     scrolling.  It returns `t' if POSITION is out of view only because
     WINDOW has been scrolled horizontally.  *Note Horizontal
     Scrolling::.

