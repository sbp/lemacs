This is Info file ../../info/lispref.info, produced by Makeinfo-1.56
from the input file lispref.texinfo.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Minibuffer History,  Next: Completion,  Prev: Object from Minibuffer,  Up: Minibuffers

Minibuffer History
==================

   A minibuffer history list records previous minibuffer inputs so the
user can reuse them conveniently.  There are many separate history lists
which contain different kinds of inputs.  The Lisp programmer's job is
to specify the right history list for each use of the minibuffer.

   The basic minibuffer input functions `read-from-minibuffer' and
`completing-read' both accept an optional argument named HIST which is
how you specify the history list.  Here are the possible values:

VARIABLE
     If you specify a variable (a symbol), that variable is the history
     list.

(VARIABLE . STARTPOS)
     If you specify a cons cell of this form, then VARIABLE is the
     history list variable, and STARTPOS specifies the initial history
     position (an integer, counting from zero which specifies the most
     recent element of the history).

     If you specify STARTPOS, then you should also specify that element
     of the history as INITIAL, for consistency.

   If you don't specify HIST, then the default history list
`minibuffer-history' is used.  For other standard history lists, see
below.  You can also create your own history list variable; just
initialize it to `nil' before the first use.  The value of the history
list variable is a list of strings, most recent first.

   Both `read-from-minibuffer' and `completing-read' add new elements
to the history list automatically, and provide commands to allow the
user to reuse items on the list.  The only thing your program needs to
do to use a history list is to initialize it and to pass its name to
the input functions when you wish.  But it is safe to modify the list
by hand when the minibuffer input functions are not using it.

 - Variable: minibuffer-history
     The default history list for minibuffer history input.

 - Variable: query-replace-history
     A history list for arguments to `query-replace' (and similar
     arguments to other commands).

 - Variable: file-name-history
     A history list for file name arguments.


File: lispref.info,  Node: Completion,  Next: Yes-or-No Queries,  Prev: Minibuffer History,  Up: Minibuffers

Completion
==========

   "Completion" is a feature that fills in the rest of a name starting
from an abbreviation for it.  Completion works by comparing the user's
input against a list of valid names and determining how much of the
name is determined uniquely by what the user has typed.

   For example, when you type `C-x b' (`switch-to-buffer') and then
type the first few letters of the name of the buffer to which you wish
to switch, and then type TAB (`minibuffer-complete'), Emacs extends the
name as far as it can.  Standard Emacs commands offer completion for
names of symbols, files, buffers, and processes; with the functions in
this section, you can implement completion for other kinds of names.

   The `try-completion' function is the basic primitive for completion:
it returns the longest determined completion of a given initial string,
with a given set of strings to match against.

   The function `completing-read' provides a higher-level interface for
completion.  A call to `completing-read' specifies how to determine the
list of valid names.  The function then activates the minibuffer with a
local keymap that binds a few keys to commands useful for completion.
Other functions provide convenient simple interfaces for reading
certain kinds of names with completion.

* Menu:

* Basic Completion::       Low-level functions for completing strings.
                             (These are too low level to use the minibuffer.)
* Programmed Completion::  Finding the completions for a given file name.
* Minibuffer Completion::  Invoking the minibuffer with completion.
* Completion Commands::    Minibuffer commands that do completion.
* High-Level Completion::  Convenient special cases of completion
                             (reading buffer name, file name, etc.)
* Reading File Names::     Using completion to read file names.
* Lisp Symbol Completion:: Completing the name of a symbol.


File: lispref.info,  Node: Basic Completion,  Next: Programmed Completion,  Up: Completion

Basic Completion Functions
--------------------------

 - Function: try-completion STRING COLLECTION &optional PREDICATE
     This function returns the longest common substring of all possible
     completions of STRING in COLLECTION.  The value of COLLECTION must
     be an alist, an obarray, or a function which implements a virtual
     set of strings.

     If COLLECTION is an alist (*note Association Lists::.), completion
     compares the CAR of each cons cell in it against STRING; if the
     beginning of the CAR equals STRING, the cons cell matches.  If no
     cons cells match, `try-completion' returns `nil'.  If only one
     cons cell matches, and the match is exact, then `try-completion'
     returns `t'.  Otherwise, the value is the longest initial sequence
     common to all the matching strings in the alist.

     If COLLECTION is an obarray (*note Creating Symbols::.), the names
     of all symbols in the obarray form the space of possible
     completions.  They are tested and used just like the CARs of the
     elements of an association list.  (The global variable `obarray'
     holds an obarray containing the names of all interned Lisp
     symbols.)

     Note that the only valid way to make a new obarray is to create it
     empty and then add symbols to it one by one using `intern'.  Also,
     you cannot intern a given symbol in more than one obarray.

     If the argument PREDICATE is non-`nil', then it must be a function
     of one argument.  It is used to test each possible match, and the
     match is accepted only if PREDICATE returns non-`nil'.  The
     argument given to PREDICATE is either a cons cell from the alist
     (the CAR of which is a string) or else it is a symbol (*not* a
     symbol name) from the obarray.

     It is also possible to use a function symbol as COLLECTION.  Then
     the function is solely responsible for performing completion;
     `try-completion' returns whatever this function returns.  The
     function is called with three arguments: STRING, PREDICATE and
     `nil'.  (The reason for the third argument is so that the same
     function can be used in `all-completions' and do the appropriate
     thing in either case.)  *Note Programmed Completion::.

     In the first of the following examples, the string `foo' is
     matched by three of the alist CARs.  All of the matches begin with
     the characters `fooba', so that is the result.  In the second
     example, there is only one possible match, and it is exact, so the
     value is `t'.

          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               => "fooba"

          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               => t

     In the following example, numerous symbols begin with the
     characters `forw', and all of them begin with the word `forward'.
     In most of the symbols, this is followed with a `-', but not in
     all, so no more than `forward' can be completed.

          (try-completion "forw" obarray)
               => "forward"

     Finally, in the following example, only two of the three possible
     matches pass the predicate `test' (the string `foobaz' is too
     short).  Both of those begin with the string `foobar'.

          (defun test (s)
            (> (length (car s)) 6))
               => test

          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
               'test)
               => "foobar"

 - Function: all-completions STRING COLLECTION &optional PREDICATE
     This function returns a list of all possible completions, instead
     of the longest substring they share.  The parameters to this
     function are the same as to `try-completion'.

     If COLLECTION is a function, it is called with three arguments:
     STRING, PREDICATE and `t', and `all-completions' returns whatever
     the function returns.  *Note Programmed Completion::.

     Here is an example, using the function `test' shown in the example
     for `try-completion':

          (defun test (s)
            (> (length (car s)) 6))
               => test

          (all-completions
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           (function test))
               => ("foobar1" "foobar2")

 - Variable: completion-ignore-case
     If the value of this variable is non-`nil', Emacs does not
     consider case significant in completion.

   The two functions `try-completion' and `all-completions' have
nothing in themselves to do with minibuffers.  However, completion is
most often used there, which is why it is described in this chapter.


File: lispref.info,  Node: Programmed Completion,  Next: Minibuffer Completion,  Prev: Basic Completion,  Up: Completion

Programmed Completion
---------------------

   Sometimes it is not possible to create an alist or an obarray
containing all the intended possible completions.  In such a case, you
can supply your own function to compute the completion of a given
string.  This is called "programmed completion".

   To use this feature, pass a symbol with a function definition as the
COLLECTION argument to `completing-read'.  This command arranges to
pass the function along to `try-completion' and `all-completions',
which will then let your function do all the work.

   The completion function should accept three arguments:

   * The string to be completed.

   * The predicate function to filter possible matches, or `nil' if
     none.  Your function should call the predicate for each possible
     match and ignore the possible match if the predicate returns `nil'.

   * A flag specifying the type of operation.

   There are three flag values for three operations:

   * `nil' specifies `try-completion'.  The completion function should
     return the completion of the specified string, or `t' if the
     string is an exact match already, or `nil' if the string matches no
     possibility.

   * `t' specifies `all-completions'.  The completion function should
     return a list of all possible completions of the specified string.

   * `lambda' specifies a test for an exact match.  The completion
     function should return `t' if the specified string is an exact
     match for some possibility; `nil' otherwise.

   It would be consistent and clean for completion functions to allow
lambda expressions (lists which are functions) as well as function
symbols as COLLECTION, but this is impossible.  Lists as completion
tables are already assigned another meaning--as alists.  It would be
unreliable to fail to handle an alist normally because it is also a
possible function.  So you must arrange for any function you wish to
use for completion to be encapsulated in a symbol.

   Emacs uses programmed completion when completing file names.  *Note
File Name Completion::.


File: lispref.info,  Node: Minibuffer Completion,  Next: Completion Commands,  Prev: Programmed Completion,  Up: Completion

Completion and the Minibuffer
-----------------------------

   This section describes the basic interface for reading from the
minibuffer with completion.

 - Function: completing-read PROMPT COLLECTION &optional PREDICATE
          REQUIRE-MATCH INITIAL HIST
     This function reads a string in the minibuffer, assisting the user
     by providing completion.  It activates the minibuffer with prompt
     PROMPT, which must be a string.  If INITIAL is non-`nil',
     `completing-read' inserts it into the minibuffer as part of the
     input.  Then it allows the user to edit the input, providing
     several commands to attempt completion.

     The actual completion is done by passing COLLECTION and PREDICATE
     to the function `try-completion'.  This happens in certain
     commands bound in the local keymaps used for completion.

     If REQUIRE-MATCH is `t', the user is not allowed to exit unless
     the input completes to an element of COLLECTION.  If REQUIRE-MATCH
     is neither `nil' nor `t', then `completing-read' does not exit
     unless the input typed is itself an element of COLLECTION.  To
     accomplish this, `completing-read' calls `read-minibuffer'.  It
     uses the value of `minibuffer-local-completion-map' as the keymap
     if REQUIRE-MATCH is `nil', and uses
     `minibuffer-local-must-match-map' if REQUIRE-MATCH is non-`nil'.

     The argument HIST specifies which history list variable to use for
     saving the input and for minibuffer history commands.  It defaults
     to `minibuffer-history'.  *Note Minibuffer History::.

     Case is ignored when comparing the input against the possible
     matches if the built-in variable `completion-ignore-case' is
     non-`nil'.  *Note Basic Completion::.

     For example:

          (completing-read
           "Complete a foo: "
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           nil t "fo")

          ;; After evaluating the preceding expression,
          ;;   the following appears in the minibuffer:
          
          ---------- Buffer: Minibuffer ----------
          Complete a foo: fo-!-
          ---------- Buffer: Minibuffer ----------

     If the user then types `DEL DEL b RET', `completing-read' returns
     `barfoo'.

     The `completing-read' function binds three variables to pass
     information to the commands which actually do completion.  Here
     they are:

    `minibuffer-completion-table'
          This variable is bound to the COLLECTION argument.  It is
          passed to the `try-completion' function.

    `minibuffer-completion-predicate'
          This variable is bound to the PREDICATE argument.  It is
          passed to the `try-completion' function.

    `minibuffer-completion-confirm'
          This variable is bound to the REQUIRE-MATCH argument.  It is
          used in the `minibuffer-complete-and-exit' function.


File: lispref.info,  Node: Completion Commands,  Next: High-Level Completion,  Prev: Minibuffer Completion,  Up: Completion

Minibuffer Commands That Do Completion
--------------------------------------

   This section describes the keymaps, commands and user options used in
the minibuffer to do completion.

 - Variable: minibuffer-local-completion-map
     `completing-read' uses this value as the local keymap when an
     exact match of one of the completions is not required.  By
     default, this keymap makes the following bindings:

    `?'
          `minibuffer-completion-help'

    SPC
          `minibuffer-complete-word'

    TAB
          `minibuffer-complete'

     with other characters bound as in `minibuffer-local-map'.

 - Variable: minibuffer-local-must-match-map
     `completing-read' uses this value as the local keymap when an
     exact match of one of the completions is required.  Therefore, no
     keys are bound to `exit-minibuffer', the command which exits the
     minibuffer unconditionally.  By default, this keymap makes the
     following bindings:

    `?'
          `minibuffer-completion-help'

    SPC
          `minibuffer-complete-word'

    TAB
          `minibuffer-complete'

    LFD
          `minibuffer-complete-and-exit'

    RET
          `minibuffer-complete-and-exit'

     with other characters bound as in `minibuffer-local-map'.

 - Variable: minibuffer-completion-table
     The value of this variable is the alist or obarray used for
     completion in the minibuffer.  This is the global variable that
     contains what `completing-read' passes to `try-completion'.  It is
     used by all the minibuffer completion functions, such as
     `minibuffer-complete-word'.

 - Variable: minibuffer-completion-predicate
     This variable's value is the predicate that `completing-read'
     passes to `try-completion'.  The variable is also used by the other
     minibuffer completion functions.

 - Command: minibuffer-complete-word
     This function completes the minibuffer contents by at most a single
     word.  Even if the minibuffer contents have only one completion,
     `minibuffer-complete-word' does not add any characters beyond the
     first character that is not a word constituent.  *Note Syntax
     Tables::.

 - Command: minibuffer-complete
     This function completes the minibuffer contents as far as possible.

 - Command: minibuffer-complete-and-exit
     This function completes the minibuffer contents, and exits if
     confirmation is not required, i.e., if
     `minibuffer-completion-confirm' is non-`nil'.  If confirmation
     *is* required, it is given by repeating this command immediately.

 - Variable: minibuffer-completion-confirm
     When the value of this variable is non-`nil', Emacs asks for
     confirmation of a completion before exiting the minibuffer.  The
     function `minibuffer-complete-and-exit' checks the value of this
     variable before it exits.

 - Command: minibuffer-completion-help
     This function creates a list of the possible completions of the
     current minibuffer contents.  It works by calling `all-completions'
     using the value of the variable `minibuffer-completion-table' as
     the COLLECTION argument, and the value of
     `minibuffer-completion-predicate' as the PREDICATE argument.  The
     list of completions is displayed as text in a buffer named
     `*Completions*'.

 - Function: display-completion-list COMPLETIONS
     This function displays COMPLETIONS to the stream in
     `standard-output', usually a buffer.  (*Note Streams::, for more
     information about streams.)  The argument COMPLETIONS is normally
     a list of completions just returned by `all-completions', but it
     does not have to be.  Each element may be a symbol or a string,
     either of which is simply printed, or a list of two strings, which
     is printed as if the strings were concatenated.

     This function is called by `minibuffer-completion-help'.  The most
     common way to use it is together with
     `with-output-to-temp-buffer', like this:

          (with-output-to-temp-buffer " *Completions*"
            (display-completion-list
              (all-completions (buffer-string) my-alist)))

 - User Option: completion-auto-help
     If this variable is non-`nil', the completion commands
     automatically display a list of possible completions whenever
     nothing can be completed because the next character is not
     uniquely determined.


File: lispref.info,  Node: High-Level Completion,  Next: Reading File Names,  Prev: Completion Commands,  Up: Completion

High-Level Completion  Functions
--------------------------------

   This section describes the higher-level convenient functions for
reading certain sorts of names with completion.

 - Function: read-buffer PROMPT &optional DEFAULT EXISTING
     This function reads the name of a buffer and returns it as a
     string.  The argument DEFAULT is the default name to use, the
     value to return if the user exits with an empty minibuffer.  If
     non-`nil', it should be a string.  It is mentioned in the prompt,
     but is not inserted in the minibuffer as initial input.

     If EXISTING is non-`nil', then the name specified must be that of
     an  existing buffer.  The usual commands to exit the minibuffer do
     not exit if the text is not valid, and RET does completion to
     attempt to find a valid name.  (However, DEFAULT is not checked
     for this; it is returned, whatever it is, if the user exits with
     the minibuffer empty.)

     In the following example, the user enters `minibuffer.t', and then
     types RET.  The argument EXISTING is `t', and the only buffer name
     starting with the given input is `minibuffer.texi', so that name
     is the value.

          (read-buffer "Buffer name? " "foo" t)
          ;; After evaluating the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: Minibuffer ----------
          Buffer name? (default foo) -!-
          ---------- Buffer: Minibuffer ----------

          ;; The user types `minibuffer.t RET'.
          
               => "minibuffer.texi"

 - Function: read-command PROMPT
     This function reads the name of a command and returns it as a Lisp
     symbol.  The argument PROMPT is used as in `read-from-minibuffer'.
     Recall that a command is anything for which `commandp' returns
     `t', and a command name is a symbol for which `commandp' returns
     `t'.  *Note Interactive Call::.

          (read-command "Command name? ")
          ;; After evaluating the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          Command name?
          ---------- Buffer: Minibuffer ----------

     If the user types `forward-c RET', then this function returns
     `forward-char'.

     The `read-command' function is a simplified interface to the
     `completing-read' function.  It uses the `commandp' predicate to
     allow only commands to be entered, and it uses the variable
     `obarray' so as to be able to complete all extant Lisp symbols:

          (read-command PROMPT)
          ==
          (intern (completing-read PROMPT obarray 'commandp t nil))

 - Function: read-variable PROMPT
     This function reads the name of a user variable and returns it as a
     symbol.

          (read-variable "Variable name? ")
          
          ;; After evaluating the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: Minibuffer ----------
          Variable name? -!-
          ---------- Buffer: Minibuffer ----------

     If the user then types `fill-p RET', `read-variable' will return
     `fill-prefix'.

     This function is similar to `read-command', but uses the predicate
     `user-variable-p' instead of `commandp':

          (read-variable PROMPT)
          ==
          (intern
           (completing-read PROMPT obarray 'user-variable-p t nil))


File: lispref.info,  Node: Reading File Names,  Next: Lisp Symbol Completion,  Prev: High-Level Completion,  Up: Completion

Reading File Names
------------------

   Here is another high-level completion function, designed for reading
a file name.  It provides special features including automatic insertion
of the default directory.

 - Function: read-file-name PROMPT &optional DIRECTORY DEFAULT EXISTING
          INITIAL
     This function reads a file name in the minibuffer, prompting with
     PROMPT and providing completion.  If DEFAULT is non-`nil', then
     the function returns DEFAULT if the user just types RET.

     If EXISTING is non-`nil', then the name must refer to an existing
     file; then RET performs completion to make the name valid if
     possible, and then refuses to exit if it is not valid.  If the
     value of EXISTING is neither `nil' nor `t', then RET also requires
     confirmation after completion.

     The argument DIRECTORY specifies the directory to use for
     completion of relative file names.  Usually it is inserted in the
     minibuffer as initial input as well.  It defaults to the current
     buffer's default directory.

     If you specify INITIAL, that is an initial file name to insert in
     the buffer along with DIRECTORY.  In this case, point goes after
     DIRECTORY, before INITIAL.  The default for INITIAL is
     `nil'--don't insert any file name.  To see what INITIAL does, try
     the command `C-x C-v'.

     Here is an example:

          (read-file-name "The file is ")
          
          ;; After evaluating the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/-!-
          ---------- Buffer: Minibuffer ----------

     Typing `manual TAB' results in the following:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/manual.texi-!-
          ---------- Buffer: Minibuffer ----------

     If the user types RET, `read-file-name' returns the string
     `"/gp/gnu/elisp/manual.texi"'.

 - User Option: insert-default-directory
     This variable is used by `read-file-name'.  Its value controls
     whether `read-file-name' starts by placing the name of the default
     directory in the minibuffer, plus the initial file name if any.
     If the value of this variable is `nil', then `read-file-name' does
     not place any initial input in the minibuffer.  In that case, the
     default directory is still used for completion of relative file
     names, but is not displayed.

     For example:

          ;; Here the minibuffer starts out containing the default directory.
          
          (let ((insert-default-directory t))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ~lewis/manual/-!-
          ---------- Buffer: Minibuffer ----------

          ;; Here the minibuffer is empty and only the prompt
          ;;   appears on its line.
          
          (let ((insert-default-directory nil))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is -!-
          ---------- Buffer: Minibuffer ----------


File: lispref.info,  Node: Lisp Symbol Completion,  Prev: Reading File Names,  Up: Completion

Lisp Symbol Completion
----------------------

   If you type a part of a symbol, and then type `M-TAB'
(`lisp-complete-symbol'), this command attempts to fill in as much more
of the symbol name as it can.  Not only does this save typing, but it
can help you with the name of a symbol that you have partially
forgotten.

 - Command: lisp-complete-symbol
     This function performs completion on the symbol name preceding
     point.  The name is completed against the symbols in the global
     variable `obarray', and characters from the completion are
     inserted into the buffer, making the name longer.  If there is
     more than one completion, a list of all possible completions is
     placed in the `*Help*' buffer.  The bell rings if there is no
     possible completion in `obarray'.

     If an open parenthesis immediately precedes the name, only symbols
     with function definitions are considered.  (By reducing the number
     of alternatives, this may succeed in completing more characters.)
     Otherwise, symbols with either a function definition, a value, or
     at least one property are considered.

     `lisp-complete-symbol' returns `t' if the symbol had an exact, and
     unique, match; otherwise, it returns `nil'.

     In the following example, the user has already inserted `(forwa'
     into the buffer `foo.el'.  The command `lisp-complete-symbol' then
     completes the name to `(forward-'.

          ---------- Buffer: foo.el ----------
          (forwa-!-
          ---------- Buffer: foo.el ----------

          (lisp-complete-symbol)
               => nil

          ---------- Buffer: foo.el ----------
          (forward--!-
          ---------- Buffer: foo.el ----------


File: lispref.info,  Node: Yes-or-No Queries,  Next: Multiple Queries,  Prev: Completion,  Up: Minibuffers

Yes-or-No Queries
=================

   This section describes functions used to ask the user a yes-or-no
question.  The function `y-or-n-p' can be answered with a single
character; it is useful for questions where an inadvertent wrong answer
will not have serious consequences.  `yes-or-no-p' is suitable for more
momentous questions, since it requires three or four characters to
answer.  Variations of these functions can be used to ask a yes-or-no
question using a dialog box, or optionally using one.

   Strictly speaking, not all of these functions use the minibuffer; but
it seems best to describe them together.

 - Function: y-or-n-p PROMPT
     This function asks the user a question, expecting input in the echo
     area.  It returns `t' if the user types `y', `nil' if the user
     types `n'.  This function also accepts SPC to mean yes and DEL to
     mean no.  It accepts `C-]' to mean "quit", like `C-g', because the
     question might look like a minibuffer and for that reason the user
     might try to use `C-]' to get out.  The answer is a single
     character, with no RET needed to terminate it.  Upper and lower
     case are equivalent.

     "Asking the question" means printing PROMPT in the echo area,
     followed by the string `(y or n) '.  If the input is not one of
     the expected answers (`y', `n', `SPC', `DEL', or something that
     quits), the function responds `Please answer y or n.', and repeats
     the request.

     This function does not actually use the minibuffer, since it does
     not allow editing of the answer.  It actually uses the echo area
     (*note The Echo Area::.), which uses the same screen space as the
     minibuffer.  The cursor moves to the echo area while the question
     is being asked.

     The meanings of answers, even `y' and `n', are not hardwired.
     They are controlled by the keymap `query-replace-map'.  *Note
     Replacement::.

     In the following example, the user first types `q', which is
     invalid.  At the next prompt the user types `n'.

          (y-or-n-p "Do you need a lift? ")
          
          ;; After evaluating the preceding expression,
          ;;   the following prompt appears in the echo area:

          ---------- Echo area ----------
          Do you need a lift? (y or n)
          ---------- Echo area ----------
          
          ;; If the user then types `q', the following appears:
          ---------- Echo area ----------
          Please answer y or n.  Do you need a lift? (y or n)
          ---------- Echo area ----------
          
          ;; When the user types a valid answer,
          ;;   it is displayed after the question:
          ---------- Echo area ----------
          Do you need a lift? (y or n) y
          ---------- Echo area ----------

     Note that we show successive lines of echo area messages here.
     Only one actually appears on the screen at a time.

 - Function: yes-or-no-p PROMPT
     This function asks the user a question, expecting input in
     minibuffer.  It returns `t' if the user enters `yes', `nil' if the
     user types `no'.  The user must type RET to finalize the response.
     Upper and lower case are equivalent.

     `yes-or-no-p' starts by displaying PROMPT in the echo area,
     followed by `(yes or no) '.  The user must type one of the
     expected responses; otherwise, the function responds `Please answer
     yes or no.', waits about two seconds and repeats the request.

     `yes-or-no-p' requires more work from the user than `y-or-n-p' and
     is appropriate for more crucial decisions.

     Here is an example:

          (yes-or-no-p "Do you really want to remove everything? ")
          
          ;; After evaluating the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: minibuffer ----------
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------

     If the user first types `y RET', which is invalid because this
     function demands the entire word `yes', it responds by displaying
     these prompts, with a brief pause between them:

          ---------- Buffer: minibuffer ----------
          Please answer yes or no.
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------

 - Function: yes-or-no-p-dialog-box PROMPT
     This function asks the user a "y or n" question with a popup dialog
     box.  It returns `t' if the answer is "yes".  PROMPT is the string
     to display to ask the question.

   The following functions ask a question either in the minibuffer or a
dialog box, depending on whether the last user event (which presumably
invoked this command) was a keyboard or mouse event.  When Emacs is
running on a window system, the functions `y-or-n-p' and `yes-or-no-p'
are replaced with the following functions, so that menu items bring up
dialog boxes instead of minibuffer questions.

 - Function: y-or-n-p-maybe-dialog-box PROMPT
     This function asks user a "y or n" question, using either a dialog
     box or the minibuffer, as appropriate.

 - Function: yes-or-no-p-maybe-dialog-box PROMPT
     This function asks user a "yes or no" question, using either a
     dialog box or the minibuffer, as appropriate.


File: lispref.info,  Node: Multiple Queries,  Next: Minibuffer Misc,  Prev: Yes-or-No Queries,  Up: Minibuffers

Asking Multiple Y-or-N Queries
==============================

 - Function: map-y-or-n-p PROMPTER ACTOR LIST &optional HELP
          ACTION-ALIST
     This function, new in Emacs 19, asks the user a series of
     questions, reading a single-character answer in the echo area for
     each one.

     The value of LIST specifies what varies from question to question
     within the series.  It should be either a list of objects or a
     generator function.  If it is a function, it should expect no
     arguments, and should return either the next object or `nil'
     meaning there are no more questions.

     The argument PROMPTER specifies how to ask each question.  If
     PROMPTER is a string, the question text is computed like this:

          (format PROMPTER OBJECT)

     where OBJECT is the next object to ask about (as obtained from
     LIST).

     If not a string, PROMPTER should be a function of one argument
     (the next object to ask about) and should return the question text.

     The argument ACTOR says how to act on the answers that the user
     gives.  It should be a function of one argument, and it is called
     with each object that the user says yes for.  Its argument is
     always an object obtained from LIST.

     If the argument HELP is given, it should be a list of this form:

          (SINGULAR PLURAL ACTION)

     where SINGULAR is a string containing a singular noun that
     describes the objects conceptually being acted on, PLURAL is the
     corresponding plural noun, and ACTION is a transitive verb
     describing what ACTOR does.

     If you don't specify HELP, the default is `("object" "objects"
     "act on")'.

     Each time a question is asked, the user may enter `y', `Y', or SPC
     to act on that object; `n', `N', or DEL to skip that object; `!'
     to act on all following objects; ESC or `q' to exit (skip all
     following objects); `.' (period) to act on the current object and
     then exit; or `C-h' to get help.  These are the same answers that
     `query-replace' accepts.  The keymap `query-replace-map' defines
     their meaning for `map-y-or-n-p' as well as for `query-replace';
     see *Note Replacement::.

     You can use ACTION-ALIST to specify additional possible answers
     and what they mean.  It is an alist of elements of the form `(CHAR
     FUNCTION HELP)', each of which defines one additional answer.  In
     this element, CHAR is a character (the answer); FUNCTION is a
     function of one argument (an object from LIST); HELP is a string.

     When the user responds with CHAR, `map-y-or-n-p' calls FUNCTION.
     If it returns non-`nil', the object is considered "acted upon",
     and `map-y-or-n-p' advances to the next object in LIST.  If it
     returns `nil', the prompt is repeated for the same object.

     The return value of `map-y-or-n-p' is the number of objects acted
     on.


File: lispref.info,  Node: Minibuffer Misc,  Prev: Multiple Queries,  Up: Minibuffers

Minibuffer Miscellany
=====================

   This section describes some basic functions and variables related to
minibuffers.

 - Command: exit-minibuffer
     This command exits the active minibuffer.  It is normally bound to
     keys in minibuffer local keymaps.

 - Command: self-insert-and-exit
     This command exits the active minibuffer after inserting the last
     character typed on the keyboard (found in `last-command-char';
     *note Command Loop Info::.).

 - Command: previous-history-element N
     This command replaces the minibuffer contents with the value of the
     Nth previous (older) history element.

 - Command: next-history-element N
     This command replaces the minibuffer contents with the value of the
     Nth more recent history element.

 - Command: previous-matching-history-element PATTERN
     This command replaces the minibuffer contents with the value of the
     previous (older) history element that matches PATTERN.  At the
     time of printing, we have not made a final decision about how to
     get the pattern interactively or how to match it against history
     elements.

 - Command: next-matching-history-element PATTERN
     This command replaces the minibuffer contents with the value of the
     next (newer) history element that matches PATTERN.

 - Variable: minibuffer-setup-hook
     This is a normal hook that is run whenever the minibuffer is
     entered.

 - Variable: minibuffer-help-form
     The current value of this variable is used to rebind `help-form'
     locally inside the minibuffer (*note Help Functions::.).

 - Function: minibuffer-window &optional SCREEN
     This function returns the window that is used for the minibuffer.
     In Emacs 18, there is one and only one minibuffer window; this
     window always exists and cannot be deleted.  In Emacs 19, each
     screen can have its own minibuffer, and this function returns the
     minibuffer window used for screen SCREEN (which defaults to the
     currently selected screen).

 - Function: window-minibuffer-p WINDOW
     This function returns non-`nil' if WINDOW is a minibuffer window.

   It is not correct to determine whether a given window is a
minibuffer by comparing it with the result of `(minibuffer-window)',
because there can be more than one minibuffer window there is more than
one screen.

 - Function: minibuffer-window-active-p WINDOW
     This function returns non-`nil' if WINDOW, assumed to be a
     minibuffer window, is currently active.

 - Variable: minibuffer-scroll-window
     If the value of this variable is non-`nil', it should be a window
     object.  When the function `scroll-other-window' is called in the
     minibuffer, it scrolls this window.

   Finally, some functions and variables deal with recursive minibuffers
(*note Recursive Editing::.):

 - Function: minibuffer-depth
     This function returns the current depth of activations of the
     minibuffer, a nonnegative integer.  If no minibuffers are active,
     it returns zero.

 - User Option: enable-recursive-minibuffers
     If this variable is non-`nil', you can invoke commands (such as
     `find-file') which use minibuffers even while in the minibuffer
     window.  Such invocation produces a recursive editing level for a
     new minibuffer.  The outer-level minibuffer is invisible while you
     are editing the inner one.

     This variable only affects invoking the minibuffer while the
     minibuffer window is selected.   If you switch windows while in the
     minibuffer, you can always invoke minibuffer commands while some
     other window is selected.

   If a command name has a property `enable-recursive-minibuffers'
which is non-`nil', then the command can use the minibuffer to read
arguments even if it is invoked from the minibuffer.  The minibuffer
command `next-matching-history-element' (normally bound to `M-s' in the
minibuffer) uses this feature.


File: lispref.info,  Node: Command Loop,  Next: Keymaps,  Prev: Minibuffers,  Up: Top

Command Loop
************

   When you run Emacs, it enters the "editor command loop" almost
immediately.  This loop reads key sequences, executes their definitions,
and displays the results.  In this chapter, we describe how these things
are done, and the subroutines that allow Lisp programs to do them.

* Menu:

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Input Events::	What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How `C-g' works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.


File: lispref.info,  Node: Command Overview,  Next: Defining Commands,  Up: Command Loop

Command Loop Overview
=====================

   The command loop in Emacs is a standard event loop, reading events
one at a time with `next-event' and handling them with
`dispatch-event'.  An event is typically a single user action, such as
a keypress, mouse movement, or menu selection; but they can also be
notifications from the window system, informing Emacs that (for example)
part of its window was just uncovered and needs to be redrawn.  *Note
Input Events::.  Pending events are held in a first-in, first-out list
called the "event queue": events are read from the head of the list,
and newly arriving events are added to the tail.  In this way, events
are always processed in the order in which they arrive.

   `dispatch-event' does most of the work of handling user actions.
The first thing it must do is put the events together into a key
sequence, which is a sequence of events that translates into a command.
It does this by consulting the active keymaps, which specify what the
valid key sequences are and how to translate them into commands.  *Note
Key Lookup::, for information on how this is done.  The result of the
translation should be a keyboard macro or an interactively callable
function.  If the key is `M-x', then it reads the name of another
command, which is used instead.  This is done by the command
`execute-extended-command' (*note Interactive Call::.).

   Once the command is chosen, it must be executed, which includes
reading arguments to be given to it.  This is done by calling
`command-execute' (*note Interactive Call::.).  For commands written in
Lisp, the `interactive' specification says how to read the arguments.
This may use the prefix argument (*note Prefix Command Arguments::.) or
may read with prompting in the minibuffer (*note Minibuffers::.).  For
example, the command `find-file' has an `interactive' specification
which says to read a file name using the minibuffer.  The command's
function body does not use the minibuffer; if you call this command
from Lisp code as a function, you must supply the file name string as
an ordinary Lisp function argument.

   If the command is a string or vector (i.e., a keyboard macro) then
`execute-kbd-macro' is used to execute it.  You can call this function
yourself (*note Keyboard Macros::.).

   If a command runs away, typing `C-g' terminates its execution
immediately.  This is called "quitting" (*note Quitting::.).

 - Variable: pre-command-hook
     The editor command loop runs this normal hook before each command.
     This may examine the `this-command' variable to find out what
     command is about to be run, or may change it to cause a different
     command to run.  Function on this hook must be careful to avoid
     signalling errors!

 - Variable: post-command-hook
     The editor command loop runs this normal hook after each command.
     (In FSF Emacs 19, it is also run when the command loop is entered,
     or reentered after an error or quit.)  This may examine the
     `this-command' variable to find out what command was just executed.


File: lispref.info,  Node: Defining Commands,  Next: Interactive Call,  Prev: Command Overview,  Up: Command Loop

Defining Commands
=================

   A Lisp function becomes a command when its body contains, at top
level, a form which calls the special form `interactive'.  This form
does nothing when actually executed, but its presence serves as a flag
to indicate that interactive calling is permitted.  Its argument
controls the reading of arguments for an interactive call.

* Menu:

* Using Interactive::     General rules for `interactive'.
* Interactive Codes::     The standard letter-codes for reading arguments
                             in various ways.
* Interactive Examples::  Examples of how to read interactive arguments.


File: lispref.info,  Node: Using Interactive,  Next: Interactive Codes,  Up: Defining Commands

Using `interactive'
-------------------

   This section describes how to write the `interactive' form that
makes a Lisp function an interactively-callable command.

 - Special Form: interactive ARG-DESCRIPTOR
     This special form declares that the function in which it appears
     is a command, and that it may therefore be called interactively
     (via `M-x' or by entering a key sequence bound to it).  The
     argument ARG-DESCRIPTOR declares the way the arguments to the
     command are to be computed when the command is called
     interactively.

     A command may be called from Lisp programs like any other
     function, but then the arguments are supplied by the caller and
     ARG-DESCRIPTOR has no effect.

     The `interactive' form has its effect because the command loop
     (actually, its subroutine `call-interactively') scans through the
     function definition looking for it, before calling the function.
     Once the function is called, all its body forms including the
     `interactive' form are executed, but at this time `interactive'
     simply returns `nil' without even evaluating its argument.

   There are three possibilities for the argument ARG-DESCRIPTOR:

   * It may be omitted or `nil'; then the command is called with no
     arguments.  This leads quickly to an error if the command requires
     one or more arguments.

   * It may be a Lisp expression that is not a string; then it should
     be a form that is evaluated to get a list of arguments to pass to
     the command.

   * It may be a string; then its contents should consist of a code
     character followed by a prompt (which some code characters use and
     some ignore).  The prompt ends either with the end of the string
     or with a newline.  Here is a simple example:

          (interactive "bFrobnicate buffer: ")

     The code letter `b' says to read the name of an existing buffer,
     with completion.  The buffer name is the sole argument passed to
     the command.  The rest of the string is a prompt.

     If there is a newline character in the string, it terminates the
     prompt.  If the string does not end there, then the rest of the
     string should contain another code character and prompt,
     specifying another argument.  You can specify any number of
     arguments in this way.

     The prompt string can use `%' to include previous argument values
     in the prompt.  This is done using `format' (*note Formatting
     Strings::.).  For example, here is how you could read the name of
     an existing buffer followed by a new name to give to that buffer:

          (interactive "bBuffer to rename: \nsRename buffer %s to: ")

     If the first character in the string is `*', then an error is
     signaled if the buffer is read-only.

     If the first character in the string is `@', and if the key
     sequence used to invoke the command includes any mouse events, then
     the window associated with the first of those events is selected
     before the command is run.

     If the first character in the string is `_', then this command will
     not cause the region to be deactivated when it completes; that is,
     `zmacs-region-stays' will be set to `t' when the command exits
     successfully.

     You can use `*', `@', and `_' together; the order does not matter.
     Actual reading of arguments is controlled by the rest of the
     prompt string (starting with the first character that is not `*',
     `@', or `_').

