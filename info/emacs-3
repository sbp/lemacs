Info file ../info/emacs, produced by Makeinfo, -*- Text -*- from input
file lemacs.tex.

   This file documents the GNU Emacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992 Lucid, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: emacs,  Node: Completion,  Next: Repetition,  Prev: Minibuffer Edit,  Up: Minibuffer

Completion
==========

   When appropriate, the minibuffer provides a "completion" facility. 
You type the beginning of an argument and one of the completion keys,
and Emacs visibly fills in the rest, depending on what you have already
typed.

   When completion is available, certain keys--TAB, RET, and SPC--are
redefined to complete an abbreviation present in the minibuffer into a
longer string that it stands for, by matching it against a set of
"completion alternatives" provided by the command reading the
argument.  `?' is defined to display a list of possible completions of
what you have inserted.

   For example, when the minibuffer is being used by `Meta-x' to read
the name of a command, it is given a list of all available Emacs
command names to complete against.  The completion keys match the text
in the minibuffer against all the command names, find any additional
characters of the name that are implied by the ones already present in
the minibuffer, and add those characters to the ones you have given.

   Case is normally significant in completion, because it is
significant in most of the names that you can complete (buffer names,
file names and command names).  Thus, `fo' will not complete to `Foo'.
 When you are completing a name in which case does not matter, case
may be ignored for completion's sake if specified by program.

Completion Example
------------------

   Consider the following example.  If you type `Meta-x au TAB', TAB
looks for alternatives (in this case, command names) that start with
`au'.  There are only two commands: `auto-fill-mode' and
`auto-save-mode'.  They are the same as far as `auto-', so the `au' in
the minibuffer changes to `auto-'.

   If you type TAB again immediately, there are multiple possibilities
for the very next character--it could be `s' or `f'--so no more
characters are added; but a list of all possible completions is
displayed in another window.

   If you go on to type `f TAB', this TAB sees `auto-f'.  The only
command name starting this way is `auto-fill-mode', so completion
inserts the rest of that command.  You now have `auto-fill-mode' in
the minibuffer after typing just `au TAB f TAB'.  Note that TAB has
this effect because in the minibuffer it is bound to the function
`minibuffer-complete' when completion is supposed to be done.

Completion Commands
-------------------

   Here is a list of all the completion commands defined in the
minibuffer when completion is available.

`TAB'
     Complete the text in the minibuffer as much as possible 
      (`minibuffer-complete').

`SPC'
     Complete the text in the minibuffer but don't add or fill out more
     than one word (`minibuffer-complete-word').

`RET'
     Submit the text in the minibuffer as the argument, possibly
     completing first as described below
     (`minibuffer-complete-and-exit').

`?'
     Print a list of all possible completions of the text in the
     minibuffer (`minibuffer-list-completions').

   SPC completes similar to TAB, but never goes beyond the next hyphen
or space.  If you have `auto-f' in the minibuffer and type SPC, it
finds that the completion is `auto-fill-mode', but it stops completing
after `fill-'. The result is `auto-fill-'.  Another SPC at this point
completes all the way to `auto-fill-mode'.  SPC in the minibuffer runs
the function `minibuffer-complete-word' when completion is available.

   There are three different ways that RET can work in completing
minibuffers, depending on how the argument will be used.

   * "Strict" completion is used when it is meaningless to give any
     argument except one of the known alternatives.  For example, when
     `C-x k' reads the name of a buffer to kill, it is meaningless to
     give anything but the name of an existing buffer.  In strict
     completion, RET refuses to exit if the text in the minibuffer
     does not complete to an exact match.

   * "Cautious" completion is similar to strict completion, except that
     RET exits only if the text was an exact match already, not
     needing completion.  If the text is not an exact match, RET does
     not exit, but it does complete the text.  If it completes to an
     exact match, a second RET will exit.

     Cautious completion is used for reading file names for files that
     must already exist.

   * "Permissive" completion is used when any string is meaningful,
     and the list of completion alternatives is just a guide.  For
     example, when `C-x C-f' reads the name of a file to visit, any
     file name is allowed, in case you want to create a file.  In
     permissive completion, RET takes the text in the minibuffer
     exactly as given, without completing it.

   The completion commands display a list of all possible completions
in a window whenever there is more than one possibility for the very
next character.  Typing `?' explicitly requests such a list.  The list
of completions counts as help text, so `C-M-v' typed in the minibuffer
scrolls the list.

   When completion is done on file names, certain file names are
usually ignored.  The variable `completion-ignored-extensions'
contains a list of strings; a file whose name ends in any of those
strings is ignored as a possible completion.  The standard value of
this variable has several elements including `".o"', `".elc"',
`".dvi"' and `"~"'.  The effect is that, for example, `foo' completes
to `foo.c' even though `foo.o' exists as well.  If the only possible
completions are files that end in "ignored" strings, they are not
ignored.

   If a completion command finds the next character is undetermined, it
automatically displays a list of all possible completions.  If the
variable `completion-auto-help' is set to `nil', this does not happen,
and you must type `?' to display the possible completions.


File: emacs,  Node: Repetition,  Prev: Completion,  Up: Minibuffer

Repeating Minibuffer Commands
=============================

   Every command that uses the minibuffer at least once is recorded on
a special history list, together with the values of the minibuffer
arguments, so that you can repeat the command easily.  In particular,
every use of `Meta-x' is recorded, since `M-x' uses the minibuffer to
read the command name.

`C-x ESC'
     Re-execute a recent minibuffer command 
     (`repeat-complex-command').

`M-p'
     Within `C-x ESC', move to previous recorded command
     (`previous-complex-command').

`M-n'
     Within `C-x ESC', move to the next (more recent) recorded command
     (`next-complex-command').

`M-x list-command-history'
     Display the entire command history, showing all the commands `C-x
     ESC' can repeat, most recent first.

   `C-x ESC' is used to re-execute a recent command that used the
minibuffer. With no argument, it repeats the last command.  A numeric
argument specifies which command to repeat; 1 means the last one, and
larger numbers specify earlier commands.

   `C-x ESC' works by turning the previous command into a Lisp
expression and then entering a minibuffer initialized with the text for
that expression.  If you type just RET, the command is repeated as
before.  You can also change the command by editing the Lisp
expression.  The expression you finally submit will be executed.  The
repeated command is added to the front of the command history unless
it is identical to the most recently executed command already there.

   Even if you don't understand Lisp syntax, it will probably be
obvious which command is displayed for repetition.  If you do not
change the text, you can be sure the command will repeat exactly as
before.

   If you are in the minibuffer for `C-x ESC' and the command shown to
you is not the one you want to repeat, you can move around the list of
previous commands using `M-n' and `M-p'.  `M-p' replaces the contents
of the minibuffer with the next earlier recorded command, and `M-n'
replaces it with the next later command.  After finding the desired
previous command, you can edit its expression and then resubmit it by
typing RET.  Any editing you have done on the command to be repeated
is lost if you use `M-n' or `M-p'.

   `M-n' and `M-p' are specially defined within `C-x ESC' to run the
commands `previous-complex-command' and `next-complex-command'.

   The list of previous commands using the minibuffer is stored as a
Lisp list in the variable `command-history'.  Each element of the list
is a Lisp expression which describes one command and its arguments. 
Lisp programs can reexecute a command by feeding the corresponding
`command-history' element to `eval'.


File: emacs,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

Running Commands by Name
************************

   The Emacs commands that are used often or that must be quick to
type are bound to keys--short sequences of characters--for convenient
use.  Other Emacs commands that are used more rarely are not bound to
keys; to run them, you must refer to them by name.

   A command name consists, by convention, of one or more words,
separated by hyphens; for example, `auto-fill-mode' or `manual-entry'.
 The use of English words makes the command name easier to remember
than a key made up of obscure characters, even though it results in
more characters to type.  You can run any command by name, even if it
can be run by keys as well.

   To run a command by name, to start with `M-x', then type the
command name, and finish with RET.  `M-x' uses the minibuffer to read
the command name.  RET exits the minibuffer and runs the command.

   Emacs uses the minibuffer for reading input for many different
purposes; on this occasion, the string `M-x' is displayed at the
beginning of the minibuffer as a "prompt" to remind you that your
input should be the name of a command to be run.  *Note Minibuffer::,
for full information on the features of the minibuffer.

   You can use completion to enter a command name.  For example, to
invoke the command `forward-char', type:

     M-x forward-char RET
or

     M-x fo TAB c RET

Note that `forward-char' is the same command that you invoke with the
key `C-f'.  You can call any command (interactively callable function)
defined in Emacs by its name using `M-x' whether or not any keys are
bound to it.

   If you type `C-g' while Emacs reads the command name, you cancel
the `M-x' command and get out of the minibuffer, ending up at top
level.

   To pass a numeric argument to a command you are invoking with
`M-x', specify the numeric argument before the `M-x'.  `M-x' passes
the argument along to the function which it calls.  The argument value
appears in the prompt while the command name is being read.

   Normally, when describing a command that is run by name, we omit the
RET that is needed to terminate the name.  Thus we may refer to `M-x
auto-fill-mode' rather than `M-x auto-fill-mode RET'.  We mention the
RET only when it it necessary to emphasize its presence, for example,
when describing a sequence of input that contains a command name and
arguments that follow it.

   `M-x' is defined to run the command `execute-extended-command',
which is responsible for reading the name of another command and
invoking it.


File: emacs,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

Help
****

   Emacs provides extensive help features which revolve around a single
character, `C-h'.  `C-h' is a prefix key that is used only for
documentation-printing commands.  The characters you can type after
`C-h' are called "help options".  One help option is `C-h'; you use it
to ask for help about using `C-h'.

   `C-h C-h' prints a list of the possible help options, and then asks
you to type the desired option.  It prompts with a string

     A, B, C, F, I, K, L, M, N, S, T, V, W, C-c, C-d, C-n, C-w or C-h for more help:

You should type one of those characters.

   Typing a third `C-h' displays a description of what the options
mean; Emacs still waits for you to type an option.  To cancel, type
`C-g'.

   Here is a summary of the defined help commands.

`C-h a STRING RET'
     Display list of commands whose names contain STRING (`command-
     apropos').

`C-h b'
     Display a table of all key bindings in effect now; local bindings
     of the current major mode first, followed by all global bindings
     (`describe-bindings').

`C-h c KEY'
     Print the name of the command that KEY runs (`describe-key-
     briefly').  `c' is for `character'.  For more extensive
     information on KEY, use `C-h k'.

`C-h f FUNCTION RET'
     Display documentation on the Lisp function named FUNCTION
     (`describe-function').  Note that commands are Lisp functions, so
     a command name may be used.

`C-h i'
     Run Info, the program for browsing documentation files (`info'). 
     The complete Emacs manual is available on-line in Info.

`C-h k KEY'
     Display name and documentation of the command KEY runs
     (`describe-key').

`C-h l'
     Display a description of the last 100 characters you typed
     (`view-lossage').

`C-h m'
     Display documentation of the current major mode (`describe-mode').

`C-h n'
     Display documentation of Emacs changes, most recent first
     (`view-emacs-news').

`C-h s'
     Display current contents of the syntax table, plus an explanation
     of what they mean (`describe-syntax').

`C-h t'
     Display the Emacs tutorial (`help-with-tutorial').

`C-h v VAR RET'
     Display the documentation of the Lisp variable VAR (`describe-
     variable').

`C-h w COMMAND RET'
     Print which keys run the command named COMMAND (`where-is').

Documentation for a Key
=======================

   The most basic `C-h' options are `C-h c' (`describe-key-briefly')
and `C-h k'
(`describe-key').  `C-h c KEY' prints the name of the command that KEY
is bound to in the echo area.  For example, `C-h c C-f' prints
`forward-char'.  Since command names are chosen to describe what the
command does, using this option is a good way to get a somewhat cryptic
description of what KEY does.

   `C-h k KEY' is similar to `C-h c' but gives more information.  It
displays the documentation string of the command KEY is bound to as
well as its name.  This information does not usually fit into the echo
area, so a window is used for the display.

Help by Command or Variable Name
================================

   `C-h f' (`describe-function') reads the name of a Lisp function
using the minibuffer, then displays that function's documentation
string in a window.  Since commands are Lisp functions, you can use
option to get the documentation of a command that you know by name. 
For example,

     C-h f auto-fill-mode RET

displays the documentation for `auto-fill-mode'. Using `C-h f' is the
only way to see the documentation of a command that is not bound to
any key, that is, a command you would normally call using `M-x'.

   `C-h f' is also useful for Lisp functions you are planning to use
in a Lisp program.  For example, if you have just written the code
`(make-vector len)' and want to make sure you are using `make-vector'
properly, type `C-h f make-vector RET'.  Because `C-h f' allows all
function names, not just command names, you may find that some of your
favorite abbreviations that work in `M-x' don't work in `C-h f'.  An
abbreviation may be unique among command names, yet fail to be unique
when other function names are allowed.

   If you type RET, leaving the minibuffer empty, `C-h f' by default
describes the function called by the innermost Lisp expression in the
buffer around point, provided that is a valid, defined Lisp function
name.  For example, if point is located following the text
`(make-vector (car x)', the innermost list containing point is the one
starting with `(make-vector', so the default is to describe the
function `make-vector'.

   `C-h f' is often useful just to verify that you have the right
spelling for the function name.  If `C-h f' mentions a default in the
prompt, you have typed the name of a defined Lisp function.  If that is
what you wanted to know, just type `C-g' to cancel the `C-h f' command
and continue editing.

   `C-h w COMMAND RET' tells you what keys are bound to COMMAND.  It
prints a list of the keys in the echo area.  Alternatively, it informs
you that a command is not bound to any keys, which implies that you
must use `M-x' to call the command.

   `C-h v' (`describe-variable') is like `C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, if that is the name of a known Lisp variable. 
*Note Variables::.

Apropos
=======

   It is possible to ask a question like, "What are the commands for
working with files?"  To do this, type `C-h a file RET', which
displays a list of all command names that contain `file', such as
`copy-file', `find-file', and so on.  With each command name a brief
description of its use and information on the keys you can use to
invoke it is displayed.  For example, you would be informed that you
can invoke `find-file' by typing `C-x C-f'.  The `a' in `C-h a' stands
for `Apropos'; `C-h a' runs the Lisp function `command-apropos'.

   Because `C-h a' looks only for functions whose names contain the
string you specify, you must use ingenuity in choosing the string.  If
you are looking for commands for killing backwards and `C-h a
kill-backwards RET' doesn't reveal any commands, don't give up.  Try
just `kill', or just `backwards', or just `back'.  Be persistent. 
Pretend you are playing Adventure.  Also note that you can use a
regular expression as the argument (*note Regexps::.).

   Here is a set of arguments to give to `C-h a' that covers many
classes of Emacs commands, since there are strong conventions for
naming standard Emacs commands.  By giving you a feeling for the naming
conventions, this set of arguments can also help you develop a
technique for picking `apropos' strings.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, buffer, screen, window, file, dir, register, mode,
     beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent,
     case, change, set, what, list, find, view, describe.

   To list all Lisp symbols that contain a match for a regexp, not just
the ones that are defined as commands, use the command `M-x apropos'
instead of `C-h a'.

Other Help Commands
===================

   `C-h i' (`info') runs the Info program, which is used for browsing
through structured documentation files.  The entire Emacs manual is
available within Info.  Eventually all the documentation of the GNU
system will be available.  Type `h' after entering Info to run a
tutorial on using Info.

   If something surprising happens, and you are not sure what commands
you typed, use `C-h l' (`view-lossage').  `C-h l' prints the last 100
command characters you typed.  If you see commands you don't know, use
`C-h c' to find out what they do.

   Emacs has several major modes. Each mode redefines a few keys and
makes a few other changes in how editing works.  `C-h m'
(`describe-mode') prints documentation on the current major mode,
which normally describes all the commands that are changed in this
mode.

   `C-h b' (`describe-bindings') and `C-h s' (`describe-syntax')
present information about the current Emacs mode that is not covered
by `C-h m'.  `C-h b' displays a list of all key bindings now in
effect; the local bindings of the current major mode first, followed
by the global bindings (*note Key Bindings::.).  `C-h s' displays the
contents of the syntax table, with explanations of each character's
syntax (*note Syntax::.).

   The other `C-h' options display various files of useful
information.  `C-h C-w' displays details on the complete absence of
warranty for GNU Emacs.  `C-h n' (`view-emacs-news') displays the file
`emacs/etc/NEWS', which contains documentation on Emacs changes
arranged chronologically.  `C-h t' (`help-with-tutorial') displays the
learn-by-doing Emacs tutorial.  `C-h C-c' (`describe-copying')
displays the file `emacs/etc/COPYING', which tells you the conditions
you must obey in distributing copies of Emacs.  `C-h C-d'
(`describe-distribution') displays another file named
`emacs/etc/DISTRIB', which tells you how you can order a copy of the
latest version of Emacs.


File: emacs,  Node: Mark,  Next: Killing,  Prev: Help,  Up: Top

Selecting Text
**************

   Many Emacs commands operate on an arbitrary contiguous part of the
current buffer. You can select text in two ways:

   * You use special keys to select text by defining a region between
     point and the mark.

   * If you are running Lucid GNU Emacs under X, you can also select
     text with the mouse.

The Mark and the Region
=======================

   To specify the text for a command to operate on, set "the mark" at
one end of it, and move point to the other end.  The text between
point and the mark is called "the region".  You can move point or the
mark to adjust the boundaries of the region.  It doesn't matter which
one is set first chronologically, or which one comes earlier in the
text.

   Once the mark has been set, it remains until it is set again at
another place.  The mark remains fixed with respect to the preceding
character if text is inserted or deleted in a buffer.  Each Emacs
buffer has its own mark; when you return to a buffer that had been
selected previously, it has the same mark it had before.

   Many commands that insert text, such as `C-y' (`yank') and `M-x
insert-buffer', position the mark at one end of the inserted text--the
opposite end from where point is positioned, so that the region
contains the text just inserted.

   Aside from delimiting the region, the mark is useful for marking a
spot that you may want to go back to.  To make this feature more
useful, Emacs remembers 16 previous locations of the mark in the `mark
ring'.

* Menu:

* Setting Mark::	Commands to set the mark.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   Previous mark positions saved so you can go back there.
* Using X Selections::  Using the mouse to mark a region if running under X.


File: emacs,  Node: Setting Mark,  Next: Using Region,  Prev: Mark,  Up: Mark

Setting the Mark
----------------

   Here are some commands for setting the mark:

`C-SPC'
     Set the mark where point is (`set-mark-command').

`C-@'
     The same.

`C-x C-x'
     Interchange mark and point (`exchange-point-and-mark').

   For example, to convert part of the buffer to all upper-case, you
can use the `C-x C-u' (`upcase-region') command, which operates on the
text in the region.  First go to the beginning of the text you want to
capitalize and type `C-SPC' to put the mark there, then move to the
end, and then type `C-x C-u' to capitalize the selected region.  You
can also set the mark at the end of the text, move to the beginning,
and then type `C-x C-u'.  Most commands that operate on the text in
the region have the word `region' in their names.

   The most common way to set the mark is with the `C-SPC' command
(`set-mark-command').  This command sets the mark where point is. You
can then move point away, leaving the mark behind.  It is actually
incorrect to speak of the character `C-SPC'; there is no such
character.  When you type SPC while holding down CTRL, you get the
character `C-@' on most terminals. This character is actually bound to
`set-mark-command'.  But unless you are unlucky enough to have a
terminal where typing `C-SPC' does not produce `C-@', you should think
of this character as `C-SPC'.

   Since terminals have only one cursor, Emacs cannot show you where
the mark is located. Most people use the mark soon after they set it,
before they forget where it is. But you can see where the mark is with
the command `C-x C-x' (`exchange-point-and-mark') which puts the mark
where point was and point where the mark was.  The extent of the
region is unchanged, but the cursor and point are now at the previous
location of the mark.

   If you are using Lucid GNU Emacs under the X window system, you can
set the variable `zmacs-regions' to `t'. This makes the current region
(defined by point and mark) highlight and makes it available as the X
clipboard selection, which means you can use the menu bar items on it.
 *Note Active Regions:: for more information.

   `C-x C-x' is also useful when you are satisfied with the location of
point but want to move the mark; do `C-x C-x' to put point there and
then you can move it.  A second use of `C-x C-x', if necessary, puts
the mark at the new location with point back at its original location.

* Menu:

* Active Regions::  Having the region highlight while working under X.


File: emacs,  Node: Using Region,  Next: Marking Objects,  Prev: Setting Mark,  Up: Mark

Operating on the Region
-----------------------

   Once you have created an active region, you can do many things to
the text in it:

   * Kill it with `C-w' (*note Killing::.).

   * Save it in a register with `C-x x' (*note Registers::.).

   * Save it in a buffer or a file (*note Accumulating Text::.).

   * Convert case with `C-x C-l' or `C-x C-u' 
     (*note Case::.).

   * Evaluate it as Lisp code with `M-x eval-region' (*note Lisp
     Eval::.).

   * Fill it as text with `M-g' (*note Filling::.).

   * Print hardcopy with `M-x print-region' (*note Hardcopy::.).

   * Indent it with `C-x TAB' or `C-M-\' (*note Indentation::.).


File: emacs,  Node: Marking Objects,  Next: Mark Ring,  Prev: Using Region,  Up: Mark

Commands to Mark Textual Objects
--------------------------------

   There are commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.

`M-@'
     Set mark after end of next word (`mark-word').  This command and
     the following one do not move point.

`C-M-@'
     Set mark after end of next Lisp expression (`mark-sexp').

`M-h'
     Put region around current paragraph (`mark-paragraph').

`C-M-h'
     Put region around current Lisp defun (`mark-defun').

`C-x h'
     Put region around entire buffer (`mark-whole-buffer').

`C-x C-p'
     Put region around current page (`mark-page').

   `M-@' (`mark-word') puts the mark at the end of the next word,
while `C-M-@' (`mark-sexp') puts it at the end of the next Lisp
expression. These characters sometimes save you some typing.

   A number of commands are available that set both point and mark and
thus delimit an object in the buffer.  `M-h' (`mark-paragraph') moves
point to the beginning of the paragraph that surrounds or follows
point, and puts the mark at the end of that paragraph (*note
Paragraphs::.).  You can then indent, case-convert, or kill the whole
paragraph.  In the same fashion, `C-M-h' (`mark-defun') puts point
before and the mark after the current or following defun (*note
Defuns::.).  `C-x C-p' (`mark-page') puts point before the current
page (or the next or previous, depending on the argument), and mark at
the end (*note Pages::.).  The mark goes after the terminating page
delimiter (to include it), while point goes after the preceding page
delimiter (to exclude it).  Finally, `C-x h' (`mark-whole-buffer')
sets up the entire buffer as the region by putting point at the
beginning and the mark at the end.


File: emacs,  Node: Mark Ring,  Prev: Marking Objects,  Up: Mark

The Mark Ring
-------------

   Aside from delimiting the region, the mark is also useful for
marking a spot that you may want to go back to.  To make this feature
more useful, Emacs remembers 16 previous locations of the mark in the
"mark ring".  Most commands that set the mark push the old mark onto
this ring.  To return to a marked location, use `C-u C-SPC' (or `C-u
C-@'); this is the command `set-mark-command' given a numeric
argument.  The command moves point to where the mark was, and restores
the mark from the ring of former marks. Repeated use of this command
moves point to all the old marks on the ring, one by one.  The marks
you have seen go to the end of the ring, so no marks are lost.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-SPC' always stays in
the same buffer.

   Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This makes it easier for you to move back
later.  Searches set the mark, unless they do not actually move point. 
When a command sets the mark, `Mark Set' is printed in the echo area.

   The variable `mark-ring-max' is the maximum number of entries to
keep in the mark ring.  If that many entries exist and another entry is
added, the last entry in the list is discarded.  Repeating `C-u C-SPC'
circulates through the entries that are currently in the ring.

   The variable `mark-ring' holds the mark ring itself, as a list of
marker objects in the order most recent first.  This variable is local
in every buffer.


File: emacs,  Node: Mouse Selection,  Next: Entering Emacs,  Prev: Pull-Down Menus,  Up: Top

Selecting Text with the Mouse
=============================

   If you are using Lucid GNU Emacs under X, you can use the mouse
cursor to select text. There are two mouse cursor shapes:

   * When the mouse cursor is over text, it appears as an I-beam, the
     same cursor that `xterm' uses.

   * When the mouse cursor is not over text, it appears as a plus sign
     (+).

   There are two ways to select a region of text with the mouse:

   To select a word in text, double click with the left mouse button
while the mouse cursor is over the word.  The word is highlighted when
selected. On monochrome monitors, a stipled background indicates that a
region of text has been highlighted. On color monitors, a color
background indicates highlighted text. You can triple-click to select
whole lines.

   To select an arbitrary region of text:

  1. Move the mouse cursor over the character at the beginning of the
     region of text you want to select.

  2. Press and hold the left mouse button.

  3. While holding the left mouse button down, drag the cursor to the
     character at the end of the region of text you want to select.

  4. Release the left mouse button.

   The selected region of text is highlighted.

   Once a region of text is selected, it becomes the primary X
selection (*note Using X Selections::.) as well as the Emacs selected
region. You can paste it into other X applications and use the options
from the Edit pull-down menu on it.  Since it is also the Emacs
region, you can use Emacs region commands on it.


File: emacs,  Node: Killing,  Next: Yanking,  Prev: Mark,  Up: Top

Deletion and Killing
====================

   Most commands which erase text from the buffer save it. You can get
the text back if you change your mind, or you can move or copy it to
other parts of the buffer.  Commands which erase text and save it in
the kill ring are known as "kill" commands.  Some other commands erase
text but do not save it; they are known as "delete" commands.  (This
distinction is made only for erasing text in the buffer.)

   The commands' names and individual descriptions use the words
`kill' and `delete' to indicate what they do.  If you perform a kill
or delete command by mistake, use the `C-x u' (`undo') command to undo
it (*note Undo::.). The delete commands include `C-d' (`delete-char')
and DEL (`delete-backward-char'), which delete only one character at a
time, and those commands that delete only spaces or newlines. 
Commands that can destroy significant amounts of nontrivial data
usually kill.

Deletion
--------

`C-d'
     Delete next character (`delete-char').

`DEL'
     Delete previous character (`delete-backward-char').

`M-\'
     Delete spaces and tabs around point (`delete-horizontal-space').

`M-SPC'
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').

`C-x C-o'
     Delete blank lines around the current line (`delete-blank-lines').

`M-^'
     Join two lines by deleting the intervening newline, and any
     indentation following it (`delete-indentation').

   The most basic delete commands are `C-d' (`delete-char') and DEL
(`delete-backward-char').  `C-d' deletes the character after point,
the one the cursor is "on top of".  Point doesn't move.  DEL deletes
the character before the cursor, and moves point back.  You can delete
newlines like any other characters in the buffer; deleting a newline
joins two lines.  Actually, `C-d' and DEL aren't always delete
commands; if you give them an argument, they kill instead, since they
can erase more than one character this way.

   The other delete commands delete only formatting characters: spaces,
tabs and newlines.  `M-\' (`delete-horizontal-space') deletes all
spaces and tab characters before and after point.  `M-SPC'
(`just-one-space') does the same but leaves a single space after
point, regardless of the number of spaces that existed previously
(even zero).

   `C-x C-o' (`delete-blank-lines') deletes all blank lines after the
current line. If the current line is blank, it deletes all blank lines
preceding the current line as well as leaving one blank line, the
current line.  `M-^' (`delete-indentation') joins the current line and
the previous line, or the current line and the next line if given an
argument, by deleting a newline and all surrounding spaces, possibly
leaving a single space.  *Note M-^: Indentation.

Killing by Lines
----------------

`C-k'
     Kill rest of line or one or more lines (`kill-line').

   The simplest kill command is `C-k'.  If given at the beginning of a
line, it kills all the text on the line, leaving the line blank.  If
given on a blank line, the blank line disappears.  As a consequence, a
line disappears completely if you go to the front of a non-blank line
and type `C-k' twice.

   More generally, `C-k' kills from point up to the end of the line,
unless it is at the end of a line.  In that case, it kills the newline
following the line, thus merging the next line into the current one. 
Emacs ignores invisible spaces and tabs at the end of the line when
deciding which case applies: if point appears to be at the end of the
line, you can be sure the newline will be killed.

   If you give `C-k' a positive argument, it kills that many lines and
the newlines that follow them (however, text on the current line
before point is not killed).  With a negative argument, `C-k' kills
back to a number of line beginnings.  An argument of -2 means kill
back to the second line beginning.  If point is at the beginning of a
line, that line beginning doesn't count, so `C-u - 2 C-k' with point
at the front of a line kills the two previous lines.

   `C-k' with an argument of zero kills all the text before point on
the current line.

Other Kill Commands
-------------------

`C-w'
     Kill region (from point to the mark) (`kill-region').  *Note
     Words::.

`M-d'
     Kill word (`kill-word').

`M-DEL'
     Kill word backwards (`backward-kill-word').

`C-x DEL'
     Kill back to beginning of sentence (`backward-kill-sentence'). 
     *Note Sentences::.

`M-k'
     Kill to end of sentence (`kill-sentence').

`C-M-k'
     Kill sexp (`kill-sexp').  *Note Lists::.

`M-z CHAR'
     Kill up to next occurrence of CHAR (`zap-to-char').

   `C-w' (`kill-region') is a very general kill command; it kills
everything between point and the mark. You can use this command to
kill any contiguous sequence of characters by first setting the mark at
one end of a sequence of characters, then going to the other end and
typing `C-w'.

   A convenient way of killing is combined with searching: `M-z'
(`zap-to-char') reads a character and kills from point up to (but not
including) the next occurrence of that character in the buffer.  If
there is no next occurrence, killing goes to the end of the buffer.  A
numeric argument acts as a repeat count.  A negative argument means to
search backward and kill text before point.

   Other syntactic units can be killed: words, with `M-DEL' and `M-d'
(*note Words::.); sexps, with `C-M-k' (*note Lists::.); and sentences,
with `C-x DEL' and `M-k' (*note Sentences::.).


File: emacs,  Node: Yanking,  Next: Using X Selections,  Prev: Killing,  Up: Top

Yanking
=======

   "Yanking" means getting back text which was killed. Some systems
call this "pasting".  The usual way to move or copy text is to kill it
and then yank it one or more times.

`C-y'
     Yank last killed text (`yank').

`M-y'
     Replace re-inserted killed text with the previously killed text
     (`yank-pop').

`M-w'
     Save region as last killed text without actually killing it
     (`copy-region-as-kill').

`C-M-w'
     Append next kill to last batch of killed text
     (`append-next-kill').

* Menu:

* Kill Ring::       Where killed text is stored.  Basic yanking.
* Appending Kills:: Several kills in a row all yank together.
* Earlier Kills::   Yanking something killed some time ago.


File: emacs,  Node: Kill Ring,  Next: Appending Kills,  Prev: Yanking,  Up: Yanking

The Kill Ring
-------------

   All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, used in all
buffers, so you can kill text in one buffer and yank it in another
buffer.  This is the usual way to move text from one file to another. 
(*Note Accumulating Text::, for some other ways.)

   If you have two separate Emacs processes, you cannot use the kill
ring to move text. If you are using Lucid GNU Emacs under X, you can,
however, use the X selection mechanism to move text from one to
another.

   If you are using Lucid GNU Emacs under X and have one Emacs process
with multiple screens, they do share the same kill ring.  You can kill
or copy text in one Emacs screen, then yank it in the other screen
belonging to the same process.

   The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text and sets the mark at
the beginning of the text.  *Note Mark::.

   `C-u C-y' yanks the text, leaves the cursor in front of the text,
and sets the mark after it, if the argument is with just a `C-u'.  Any
other argument, including `C-u' and digits, has different results,
described below, under "Yanking Earlier Kills".

   To copy a block of text, you can also use `M-w'
(`copy-region-as-kill'), which copies the region into the kill ring
without removing it from the buffer. `M-w' is similar to `C-w'
followed by `C-y' but does not mark the buffer as "modified" and does
not actually cut anything.


File: emacs,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Kill Ring,  Up: Yanking

Appending Kills
---------------

   Normally, each kill command pushes a new block onto the kill ring. 
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' yanks it all back. This means you
don't have to kill all the text you want to yank in one command; you
can kill line after line, or word after word, until you have killed
what you want, then get it all back at once using `C-y'. (Thus we join
television in leading people to kill thoughtlessly.)

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add onto
the beginning.  This way, any sequence of mixed forward and backward
kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of
appending kills.  For example, suppose the buffer contains

     This is the first
     line of sample text
     and here is the third.

with point at the beginning of the second line.  If you type `C-k C-u 2
M-DEL C-k', the first `C-k' kills the text `line of sample text', `C-u
2 M-DEL' kills `the first' with the newline that followed it, and the
second `C-k' kills the newline after the second line.  The result is
that the buffer contains `This is and here is the third.' and a single
kill entry contains `the firstRETline of sample textRET'--all the
killed text, in its original order.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the
kill ring.  To force a kill command to append, first type the command
`C-M-w' (`append-next-kill'). `C-M-w' tells the following command, if
it is a kill command, to append the text it kills to the last killed
text, instead of starting a new entry.  With `C-M-w', you can kill
several separated pieces of text and accumulate them to be yanked back
in one place.


File: emacs,  Node: Earlier Kills,  Prev: Appending Kills,  Up: Yanking

Yanking Earlier Kills
---------------------

   To recover killed text that is no longer the most recent kill, you
need the `Meta-y' (`yank-pop') command.  You can use `M-y' only after
a `C-y' or another `M-y'.  It takes the text previously yanked and
replaces it with the text from an earlier kill.  To recover the text
of the next-to-the-last kill, first use `C-y' to recover the last
kill, then `M-y' to replace it with the previous kill.

   You can think in terms of a "last yank" pointer which points at an
item in the kill ring.  Each time you kill, the "last yank" pointer
moves to the new item at the front of the ring.  `C-y' yanks the item
which the "last yank" pointer points to.  `M-y' moves the "last yank"
pointer to a different item, and the text in the buffer changes to
match.  Enough `M-y' commands can move the pointer to any item in the
ring, so you can get any item into the buffer.  Eventually the pointer
reaches the end of the ring; the next `M-y' moves it to the first item
again.

   Yanking moves the "last yank" pointer around the ring, but does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   Use `M-y' with a numeric argument, to tell to advance the "last
yank" pointer by the specified number of items.  A negative argument
moves the pointer toward the front of the ring; from the front of the
ring, it moves to the last entry and starts moving forward from there.

   Once the text you are looking for is brought into the buffer, you
can stop doing `M-y' commands and the text will stay there. Since the
text is just a copy of the kill ring item, editing it in the buffer
does not change what's in the ring.  As long you don`t kill additional
text, the "last yank" pointer remains at the same place in the kill
ring: repeating `C-y' will yank another copy of the same old kill.

   If you know how many `M-y' commands it would take to find the text
you want, you can yank that text in one step using `C-y' with a
numeric argument.  `C-y' with an argument greater than one restores
the text the specified number of entries back in the kill ring.  Thus,
`C-u 2 C-y' gets the next to the last block of killed text.  It is
equivalent to `C-y M-y'.  `C-y' with a numeric argument starts
counting from the "last yank" pointer, and sets the "last yank"
pointer to the entry that it yanks.

   The variable `kill-ring-max' controls the length of the kill ring;
no more than that many blocks of killed text are saved.


File: emacs,  Node: Using X Selections,  Next: Accumulating Text,  Prev: Yanking,  Up: Top

Using X Selections
==================

   In the X window system, mouse selections provide a simple mechanism
for text transfer between different applications.  In a typical X
application, you can select text by pressing the left mouse button and,
then dragging the cursor over the text you want to copy. The text
becomes the primary X selection and is highlighted. The highlighted
region is at the same time the Emacs selected region and the primary X
selection:

   * Since the region is the primary X selection, you can go to a
     different X application and click the middle mouse button: the
     text that you selected in the previous application is pasted into
     the current application.

   * Since the region is the Emacs selected region, you can use all
     region commands (`C-w, M-w' etc.) as well as the options of the
     Edit menu to manipulate the selected text.

* Menu:

* X Clipboard Selection::     Storing the primary selection.
* Active Regions::      Using zmacs-style highlighting of the selected
                        region.
* X Cut Buffers::       X cut buffers are available for compatibility.


File: emacs,  Node: X Clipboard Selection,  Next: X Cut Buffers,  Prev: Using X Selections,  Up: Using X Selections

The Clipboard Selection
-----------------------

   There are other kinds of X selection besides the primary selection.
 Each time a region of text is added to the kill ring (for example,
with C-k, C-w, or M-w or with a Cut or Copy menu item), that text
becomes the clipboard selection.

   Usually, the clipboard selection is not visible. However, if you run
the `xclipboard' application, the most recently killed text--the value
of the clipboard selection--is displayed in a window.  Any time Emacs
adds text to the kill ring, the `xclipboard' application makes a copy
of it and displays it in its window. The value of the clipboard can
survive the lifetime of the running Emacs process. The `xclipboard'
man page provides more details.

   Warning: If you use the `xclipboard' application, remember that it
maintains a list of all things that have been pasted to the clipboard
(that is, killed in Emacs).  If you don't manually delete elements from
this list by clicking on the Delete button in the `xclipboard' window,
the clipboard will eventually consume a lot of memory.


File: emacs,  Node: X Cut Buffers,  Next: Active Regions,  Prev: X Clipboard Selection,  Up: Using X Selections

X Cut Buffers
-------------

   X cut buffers are a different, older way of transferring text
between applications. Lucid GNU Emacs supports cut buffers for
compatibility with older programs, even though selections are now the
preferred way of transferring text.

   X has a concept of applications "owning" selections.  When you
select text by clicking and dragging inside an application, the
application tells the X server that it owns the selection.  When
another application asks the X server for the value of the selection,
the X server requests the information from the owner. When you use
selections, the selection data is not actually transferred unless
someone wants it; the act of making a selection doesn't transfer data. 
Cut buffers are different: when you "own" a cut buffer, the data is
actually transferred to the X server immediately, and survives the
lifetime of the application.

   Any time a region of text becomes the primary selection in Emacs,
Emacs also copies that text to the cut buffer.  This makes it possible
to copy text from a Lucid GNU Emacs buffer and paste it into an older,
non-selection-based application (such as Emacs 18.)

   Note: Older versions of Emacs could not access the X selections,
only the X cut buffers.


File: emacs,  Node: Active Regions,  Prev: X Cut Buffers,  Up: Using X Selections

Active Regions
--------------

   By default, both the text you select in an Emacs buffer using the
click-and-drag mechanism and text you select by setting point and the
mark is highlighted. You can use Emacs region commands as well as the
Cut and Copy commands on the highlighted region you selected with the
mouse.

   If you prefer, you can make a distinction between text selected
with the mouse and text selected with point and the mark by setting
the variable `zmacs-regions' to `nil'.  In that case:

        The text selected with the mouse becomes both the X selection
     and the Emacs selected region. You can use menubar commands as
     well as Emacs region commands on it.

        The text selected with point and the mark does not highlight.
     You can only use Emacs region commands but not the menu bar items
     on it.

   Active regions originally come from Zmacs, the Lisp Machine editor.
 The idea behind them is that commands can only operate on a region
when the region is in an "active" state.  Put simply, you can only
operate on a region that is highlighted.

   When `zmacs-regions' is `t', there is no distinction between the
primary selection and the active region selected by point and the
mark.  To see this, set the mark (C-SPC) and move the cursor with any
cursor-motion command: the region between point and mark is
highlighted, and you can watch it grow and shrink as you move the
cursor.

   Any other commands besides cursor-motion commands (such as
inserting or deleting text) will cause the region to no longer be
active; it will no longer be highlighted, and will no longer be the
primary selection.  Errors also remove highlighting from a region.

   Commands which require a region (such as `C-w') signal an error if
the region is not active.  Certain commands cause the region to be in
its active state.  The most common ones are `push-mark' (C-SPC) and
`exchange-point-and-mark' (`C-x C-x').

