Info file ../info/gdb, produced by Makeinfo, -*- Text -*- from input
file gdb.tex.

   This file documents the GNU debugger GDB.

   Copyright (C) 1988, 1989 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.


File: gdb,  Node: Top,  Next: Top,  Prev: Top,  Up: (DIR)

Summary of GDB
**************

   The purpose of a debugger such as GDB is to allow you to execute
another program while examining what is going on inside it.  We call
the other program "your program" or "the program being debugged".

   GDB can do four kinds of things (plus other things in support of
these):

  1. Start the program, specifying anything that might affect its
     behavior.

  2. Make the program stop on specified conditions.

  3. Examine what has happened, when the program has stopped, so that
     you can see bugs happen.

  4. Change things in the program, so you can correct the effects of
     one bug and go on to learn about another without having to
     recompile first.

   GDB can be used to debug programs written in C and C++.  Pascal
support is being implemented, and Fortran support will be added when a
GNU Fortran compiler is written.

* Menu:

* License::    The GNU General Public License gives you permission
	       to redistribute GDB on certain terms; and also
	       explains that there is no warranty.
* User Interface::      GDB command syntax and input and output conventions.
* Files::      Specifying files for GDB to operate on.
* Options::    GDB arguments and options.
* Compilation::Compiling your program so you can debug it.
* Running::    Running your program under GDB.
* Stopping::   Making your program stop.  Why it may stop.  What to do then.
* Stack::      Examining your program's stack.
* Source::     Examining your program's source files.
* Data::       Examining data in your program.
* Symbols::    Examining the debugger's symbol table.
* Altering::   Altering things in your program.
* Sequences::  Canned command sequences for repeated use.
* Emacs::      Using GDB through GNU Emacs.
* Remote::     Remote kernel debugging across a serial line.
* Extensions:: Lucid extensions to GDB for debugging C++ code.
* Commands::   Index of GDB commands.
* Concepts::   Index of GDB concepts.


File: gdb,  Node: License,  Next: User Interface,  Prev: Top,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                           Version 1, February 1989

     Copyright (C) 1989 Free Software Foundation, Inc.
     675 Mass Ave, Cambridge, MA 02139, USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

   The license agreements of most software companies try to keep users
at the mercy of those companies.  By contrast, our General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  The
General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it. 
You can use it for your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights. 
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to
copy, distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on,
we want its recipients to know that what they have is not the
original, so that any problems introduced by others will not reflect
on the original authors' reputations.

   The precise terms and conditions for copying, distribution and
modification follow.

                             TERMS AND CONDITIONS

  1. This License Agreement applies to any program or other work which
     contains a notice placed by the copyright holder saying it may be
     distributed under the terms of this General Public License.  The
     "Program", below, refers to any such program or work, and a "work
     based on the Program" means either the Program or any work
     containing the Program or a portion of it, either verbatim or
     with modifications.  Each licensee is addressed as "you".

  2. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an
     appropriate copyright notice and disclaimer of warranty; keep
     intact all the notices that refer to this General Public License
     and to the absence of any warranty; and give any other recipients
     of the Program a copy of this General Public License along with
     the Program.  You may charge a fee for the physical act of
     transferring a copy.

  3. You may modify your copy or copies of the Program or any portion
     of it, and copy and distribute such modifications under the terms
     of Paragraph 1 above, provided that you also do the following:

        * cause the modified files to carry prominent notices stating
          that you changed the files and the date of any change; and

        * cause the whole of any work that you distribute or publish,
          that in whole or in part contains the Program or any part
          thereof, either with or without modifications, to be
          licensed at no charge to all third parties under the terms
          of this General Public License (except that you may choose
          to grant warranty protection to some or all third parties,
          at your option).

        * If the modified program normally reads commands
          interactively when run, you must cause it, when started
          running for such interactive use in the simplest and most
          usual way, to print or display an announcement including an
          appropriate copyright notice and a notice that there is no
          warranty (or else, saying that you provide a warranty) and
          that users may redistribute the program under these
          conditions, and telling the user how to view a copy of this
          General Public License.

        * You may charge a fee for the physical act of transferring a
          copy, and you may at your option offer warranty protection in
          exchange for a fee.

             Mere aggregation of another independent work with the Program
     (or its derivative) on a volume of a storage or distribution
     medium does not bring the other work under the scope of these
     terms.

  4. You may copy and distribute the Program (or a portion or
     derivative of it, under Paragraph 2) in object code or executable
     form under the terms of Paragraphs 1 and 2 above provided that
     you also do one of the following:

        * accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Paragraphs 1 and 2 above; or,

        * accompany it with a written offer, valid for at least three
          years, to give any third party free (except for a nominal
          charge for the cost of distribution) a complete
          machine-readable copy of the corresponding source code, to
          be distributed under the terms of Paragraphs 1 and 2 above;
          or,

        * accompany it with the information you received as to where
          the corresponding source code may be obtained.  (This
          alternative is allowed only for noncommercial distribution
          and only if you received the program in object code or
          executable form alone.)

             Source code for a work means the preferred form of the work
     for making modifications to it.  For an executable file, complete
     source code means all the source code for all modules it
     contains; but, as a special exception, it need not include source
     code for modules which are standard libraries that accompany the
     operating system on which the executable file runs, or for
     standard header files or definitions files that accompany that
     operating system.

  5. You may not copy, modify, sublicense, distribute or transfer the
     Program except as expressly provided under this General Public
     License.  Any attempt otherwise to copy, modify, sublicense,
     distribute or transfer the Program is void, and will
     automatically terminate your rights to use the Program under this
     License.  However, parties who have received copies, or rights to
     use copies, from you under this General Public License will not
     have their licenses terminated so long as such parties remain in
     full compliance.

  6. By copying, distributing or modifying the Program (or any work
     based on the Program) you indicate your acceptance of this
     license to do so, and all its terms and conditions.

  7. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.

  8. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version,
     but may differ in detail to address new problems or concerns.

        Each version is given a distinguishing version number.  If the
     Program specifies a version number of the license which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the
     Program does not specify a version number of the license, you may
     choose any version ever published by the Free Software Foundation.

  9. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to
     the author to ask for permission.  For software which is
     copyrighted by the Free Software Foundation, write to the Free
     Software Foundation; we sometimes make exceptions for this.  Our
     decision will be guided by the two goals of preserving the free
     status of all derivatives of our free software and of promoting
     the sharing and reuse of software generally.

                                      NO WARRANTY

 10. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 11. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS
     OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
     YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH
     ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                         END OF TERMS AND CONDITIONS

Appendix: How to Apply These Terms to Your New Programs
=======================================================

   If you develop a new program, and you want it to be of the greatest
possible use to humanity, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is
safest to attach them to the start of each source file to most
effectively convey the exclusion of warranty; and each file should
have at least the "copyright" line and a pointer to where the full
notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR
     
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 1, or (at your option)
     any later version.
     
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the
     program `Gnomovision' (a program to direct compilers to make passes
     at assemblers) written by James Hacker.
     
     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   That's all there is to it!


File: gdb,  Node: User Interface,  Next: Files,  Prev: License,  Up: Top

GDB Input and Output Conventions
********************************

   GDB is invoked with the shell command `gdb'.  Once started, it reads
commands from the terminal until you tell it to exit.

   A GDB command is a single line of input.  There is no limit on how
long it can be.  It starts with a command name, which is followed by
arguments whose meaning depends on the command name.  For example, the
command `step' accepts an argument which is the number of times to
step, as in `step 5'.  You can also use the `step' command with no
arguments.  Some command names do not allow any arguments.

   GDB command names may always be abbreviated if the abbreviation is
unambiguous.  Sometimes even ambiguous abbreviations are allowed; for
example, `s' is specially defined as equivalent to `step' even though
there are other commands whose names start with `s'.  Possible command
abbreviations are often stated in the documentation of the individual
commands.

   A blank line as input to GDB means to repeat the previous command
verbatim.  Certain commands do not allow themselves to be repeated
this way; these are commands for which unintentional repetition might
cause trouble and which you are unlikely to want to repeat.  Certain
others (`list' and `x') act differently when repeated because that is
more useful.

   A line of input starting with `#' is a comment; it does nothing. 
This is useful mainly in command files (*Note Command Files::).

   GDB indicates its readiness to read a command by printing a string
called the "prompt".  This string is normally `(gdb)'.  You can change
the prompt string with the `set prompt' command.  For instance, when
debugging GDB with GDB, it is useful to change the prompt in one of
the GDBs so that you tell which one you are talking to.

`set prompt NEWPROMPT'
     Directs GDB to use NEWPROMPT as its prompt string henceforth.

   To exit GDB, use the `quit' command (abbreviated `q').  `Ctrl-c'
will not exit from GDB, but rather will terminate the action of any
GDB command that is in progress and return to GDB command level.  It
is safe to type `Ctrl-c' at any time because GDB does not allow it to
take effect until a time when it is safe.

   Certain commands to GDB may produce large amounts of information
output to the screen.  To help you read all of it, GDB pauses and asks
you for input at the end of each page of output.  Type RET when you
want to continue the output.  Normally GDB knows the size of the
screen from on the termcap data base together with the value of the
`TERM' environment variable; if this is not correct, you can override
it with the `set screensize' command:

`set screensize LPP'
`set screensize LPP CPL'
     Specify a screen height of LPP lines and (optionally) a width of
     CPL characters.  If you omit CPL, the width does not change.

     If you specify a height of zero lines, GDB will not pause during
     output no matter how long the output is.  This is useful if
     output is to a file or to an editor buffer.

   Also, GDB may at times produce more information about its own
workings than is of interest to the user.  Some of these informational
messages can be turned on and off with the `set verbose' command:

`set verbose off'
     Disables GDB's output of certain informational messages.

`set verbose on'
     Re-enables GDB's output of certain informational messages.

   Currently, the messages controlled by `set verbose' are those which
announce that the symbol table for a source file is being read (*note
File Commands::., in the description of the command `symbol-file').


File: gdb,  Node: Files,  Next: Compilation,  Prev: User Interface,  Up: Top

Specifying GDB's Files
**********************

   GDB needs to know the file name of the program to be debugged, both
in order to read its symbol table and in order to start the program. 
To debug a core dump of a previous run, GDB must be told the file name
of the core dump.

* Menu:

* Arguments: File Arguments.   Specifying files with arguments
                                (when you start GDB).
* Commands: File Commands.     Specifying files with GDB commands.


File: gdb,  Node: File Arguments,  Next: File Commands,  Prev: Files,  Up: Files

Specifying Files with Arguments
===============================

   The usual way to specify the executable and core dump file names is
with two command arguments given when you start GDB.  The first
argument is used as the file for execution and symbols, and the second
argument (if any) is used as the core dump file name.  Thus,

     gdb progm core

specifies `progm' as the executable program and `core' as a core dump
file to examine.  (You do not need to have a core dump file if what
you plan to do is debug the program interactively.)

   *Note Options::, for full information on options and arguments for
invoking GDB.


File: gdb,  Node: File Commands,  Prev: File Arguments,  Up: Files

Specifying Files with Commands
==============================

   Usually you specify the files for GDB to work with by giving
arguments when you invoke GDB.  But occasionally it is necessary to
change to a different file during a GDB session.  Or you may run GDB
and forget to specify the files you want to use.  In these situations
the GDB commands to specify new files are useful.

`exec-file FILENAME'
     Specify that the program to be run is found in FILENAME.  If you
     do not specify a directory and the file is not found in GDB's
     working directory, GDB will use the environment variable `PATH'
     as a list of directories to search, just as the shell does when
     looking for a program to run.

`symbol-file FILENAME'
     Read symbol table information from file FILENAME.  `PATH' is
     searched when necessary.  Most of the time you will use both the
     `exec-file' and `symbol-file' commands on the same file.

     `symbol-file' with no argument clears out GDB's symbol table.

     The `symbol-file' command does not actually read the symbol table
     in full right away.  Instead, it scans the symbol table quickly
     to find which source files and which symbols are present.  The
     details are read later, one source file at a time, when they are
     needed.

     The purpose of this two-stage reading strategy is to make GDB
     start up faster.  For the most part, it is invisible except for
     occasional messages telling you that the symbol table details for
     a particular source file are being read.  (The `set verbose'
     command controls whether these messages are printed; *note User
     Interface::.).

     However, you will sometimes see in backtraces lines for functions
     in source files whose data has not been read in; these lines omit
     some of the information, such as argument values, which cannot be
     printed without full details of the symbol table.

     When the symbol table is stored in COFF format, `symbol-file' does
     read the symbol table data in full right away.  We haven't
     bothered to implement the two-stage strategy for COFF.

`core-file FILENAME'
     Specify the whereabouts of a core dump file to be used as the
     "contents of memory".  Note that the core dump contains only the
     writable parts of memory; the read-only parts must come from the
     executable file.

     `core-file' with no argument specifies that no core file is to be
     used.

     Note that the core file is ignored when your program is actually
     running under GDB.  So, if you have been running the program and
     you wish to debug a core file instead, you must kill the
     subprocess in which the program is running.  To do this, use the
     `kill' command (*note Kill Process::.).

`add-file FILENAME ADDRESS'
     The `add-file' command reads additional symbol table information
     from the file FILENAME.  You would use this when that file has
     been dynamically loaded into the program that is running.  ADDRESS
     should be the memory address at which the file has been loaded;
     GDB cannot figure this out for itself.

     The symbol table of the file FILENAME is added to the symbol table
     originally read with the `symbol-file' command.  You can use the
     `add-file' command any number of times; the new symbol data thus
     read keeps adding to the old.  The `symbol-file' command forgets
     all the symbol data GDB has read; that is the only time symbol
     data is forgotten in GDB.

`info files'
     Print the names of the executable and core dump files currently in
     use by GDB, and the file from which symbols were loaded.

   While all three file-specifying commands allow both absolute and
relative file names as arguments, GDB always converts the file name to
an absolute one and remembers it that way.

   The `symbol-file' command causes GDB to forget the contents of its
convenience variables, the value history, and all breakpoints and
auto-display expressions.  This is because they may contain pointers
to the internal data recording symbols and data types, which are part
of the old symbol table data being discarded inside GDB.


File: gdb,  Node: Compilation,  Next: Running,  Prev: Files,  Up: Top

Compiling Your Program for Debugging
************************************

   In order to debug a program effectively, you need to ask for
debugging information when you compile it.  This information in the
object file describes the data type of each variable or function and
the correspondence between source line numbers and addresses in the
executable code.

   To request debugging information, specify the `-g' option when you
run the compiler.

   The Unix C compiler is unable to handle the `-g' and `-O' options
together.  This means that you cannot ask for optimization if you ask
for debugger information.

   The GNU C compiler supports `-g' with or without `-O', making it
possible to debug optimized code.  We recommend that you *always* use
`-g' whenever you compile a program.  You may think the program is
correct, but there's no sense in pushing your luck.

   GDB no longer supports the debugging information produced by giving
the GNU C compiler the `-gg' option, so do not use this option.


File: gdb,  Node: Running,  Next: Stopping,  Prev: Compilation,  Up: Top

Running Your Program Under GDB
******************************

   To start your program under GDB, use the `run' command.  The program
must already have been specified using the `exec-file' command or with
an argument to GDB (*note Files::.); what `run' does is create an
inferior process, load the program into it, and set it in motion.

   The execution of a program is affected by certain information it
receives from its superior.  GDB provides ways to specify this
information, which you must do before starting the program.  (You can
change it after starting the program, but such changes do not affect
the program unless you start it over again.)  This information may be
divided into three categories:

The arguments.
     You specify the arguments to give the program as the arguments of
     the `run' command.

The environment.
     The program normally inherits its environment from GDB, but you
     can use the GDB commands `set environment' and `unset
     environment' to change parts of the environment that will be
     given to the program.

The working directory.
     The program inherits its working directory from GDB.  You can set
     GDB's working directory with the `cd' command in GDB.

   After the `run' command, the debugger does nothing but wait for your
program to stop.  *Note Stopping::.

   Note that once your program has been started by the `run' command,
you may evaluate expressions that involve calls to functions in the
inferior.  *Note Expressions::.  If you wish to evaluate a function
simply for its side affects, you may use the `set' command.  *Note
Assignment::.

* Menu:

* Arguments::          Specifying the arguments for your program.
* Environment::        Specifying the environment for your program.
* Working Directory::  Specifying the working directory for giving
                       to your program when it is run.
* Input/Output::       Specifying the program's standard input and output.
* Attach::             Debugging a process started outside GDB.
* Kill Process::       Getting rid of the child process running your program.


File: gdb,  Node: Arguments,  Next: Environment,  Prev: Running,  Up: Running

Your Program's Arguments
========================

   The arguments to your program are specified by the arguments of the
`run' command.  They are passed to a shell, which expands wildcard
characters and performs redirection of I/O, and thence to the program.

   `run' with no arguments uses the same arguments used by the previous
`run'.

   The command `set args' can be used to specify the arguments to be
used the next time the program is run.  If `set args' has no
arguments, it means to use no arguments the next time the program is
run.  If you have run your program with arguments and want to run it
again with no arguments, this is the only way to do so.


File: gdb,  Node: Environment,  Next: Working Directory,  Prev: Arguments,  Up: Running

Your Program's Environment
==========================

   The "environment" consists of a set of "environment variables" and
their values.  Environment variables conventionally record such things
as your user name, your home directory, your terminal type, and your
search path for programs to run.  Usually you set up environment
variables with the shell and they are inherited by all the other
programs you run.  When debugging, it can be useful to try running the
program with different environments without having to start the
debugger over again.

`info environment VARNAME'
     Print the value of environment variable VARNAME to be given to
     your program when it is started.  This command can be abbreviated
     `i env VARNAME'.

`info environment'
     Print the names and values of all environment variables to be
     given to your program when it is started.  This command can be
     abbreviated `i env'.

`set environment VARNAME VALUE'
`set environment VARNAME = VALUE'
     Sets environment variable VARNAME to VALUE, for your program
     only, not for GDB itself.  VALUE may be any string; the values of
     environment variables are just strings, and any interpretation is
     supplied by your program itself.  The VALUE parameter is optional;
     if it is eliminated, the variable is set to a null value.  This
     command can be abbreviated as short as `set e'.

     For example, this command:

          set env USER = foo

          tells the program, when subsequently run, to assume it is being
     run on behalf of the user named `foo'.

`delete environment VARNAME'
`unset environment VARNAME'
     Remove variable VARNAME from the environment to be passed to your
     program.  This is different from `set env VARNAME =' because
     `delete environment' leaves the variable with no value, which is
     distinguishable from an empty value.  This command can be
     abbreviated `d e'.


File: gdb,  Node: Working Directory,  Next: Input/Output,  Prev: Environment,  Up: Running

Your Program's Working Directory
================================

   Each time you start your program with `run', it inherits its
working directory from the current working directory of GDB.  GDB's
working directory is initially whatever it inherited from its parent
process (typically the shell), but you can specify a new working
directory in GDB with the `cd' command.

   The GDB working directory also serves as a default for the commands
that specify files for GDB to operate on.  *Note Files::.

`cd DIRECTORY'
     Set GDB's working directory to DIRECTORY.

`pwd'
     Print GDB's working directory.


File: gdb,  Node: Input/Output,  Next: Attach,  Prev: Working Directory,  Up: Running

Your Program's Input and Output
===============================

   By default, the program you run under GDB does input and output to
the same terminal that GDB uses.

   You can redirect the program's input and/or output using `sh'-style
redirection commands in the `run' command.  For example,

     run > outfile

starts the program, diverting its output to the file `outfile'.

   Another way to specify where the program should do input and output
is with the `tty' command.  This command accepts a file name as
argument, and causes this file to be the default for future `run'
commands.  It also resets the controlling terminal for the child
process, for future `run' commands.  For example,

     tty /dev/ttyb

directs that processes started with subsequent `run' commands default
to do input and output on the terminal `/dev/ttyb' and have that as
their controlling terminal.

   An explicit redirection in `run' overrides the `tty' command's
effect on input/output redirection, but not its effect on the
controlling terminal.

   When you use the `tty' command or redirect input in the `run'
command, only the *input for your program* is affected.  The input for
GDB still comes from your terminal.


File: gdb,  Node: Attach,  Next: Kill Process,  Prev: Input/Output,  Up: Running

Debugging an Already-Running Process
====================================

   Some operating systems allow GDB to debug an already-running process
that was started outside of GDB.  To do this, you use the `attach'
command instead of the `run' command.

   The `attach' command requires one argument, which is the process-id
of the process you want to debug.  (The usual way to find out the
process-id of the process is with the `ps' utility.)

   The first thing GDB does after arranging to debug the process is to
stop it.  You can examine and modify an attached process with all the
GDB commands that ordinarily available when you start processes with
`run'.  You can insert breakpoints; you can step and continue; you can
modify storage.  If you would rather the process continue running, you
may use the `continue' command after attaching GDB to the process.

   When you have finished debugging the attached process, you can use
the `detach' command to release it from GDB's control.  Detaching the
process continues its execution.  After the `detach' command, that
process and GDB become completely independent once more, and you are
ready to `attach' another process or start one with `run'.

   If you exit GDB or use the `run' command while you have an attached
process, you kill that process.  You will be asked for confirmation if
you try to do either of these things.

   The `attach' command is also used to debug a remote machine via a
serial connection.  *Note Attach::, for more info.


File: gdb,  Node: Kill Process,  Prev: Attach,  Up: Running

Killing the Child Process
=========================

`kill'
     Kill the child process in which the program being debugged is
     running under GDB.

     This command is useful if you wish to debug a core dump instead. 
     GDB ignores any core dump file if it is actually running the
     program, so the `kill' command is the only sure way to make sure
     the core dump file is used once again.

     It is also useful if you wish to run the program outside the
     debugger for once and then go back to debugging it.

     The `kill' command is also useful if you wish to recompile and
     relink the program, since on many systems it is impossible to
     modify an executable file which is running in a process.  But, in
     this case, it is just as good to exit GDB, since you will need to
     read a new symbol table after the program is recompiled if you
     wish to debug the new version, and restarting GDB is the easiest
     way to do that.


File: gdb,  Node: Stopping,  Next: Stack,  Prev: Running,  Up: Top

Stopping and Continuing
***********************

   When you run a program normally, it runs until it terminates.  The
principal purpose of using a debugger is so that you can stop it before
that point; or so that if the program runs into trouble you can
investigate and find out why.

* Menu:

* Signals::      Fatal signals in your program just stop it;
                 then you can use GDB to see what is going on.
* Breakpoints::  Breakpoints let you stop your program when it
                 reaches a specified point in the code.
* Continuing::   Resuming execution until the next signal or breakpoint.
* Stepping::     Stepping runs the program a short distance and
                 then stops it wherever it has come to.


File: gdb,  Node: Signals,  Next: Breakpoints,  Prev: Stopping,  Up: Stopping

Signals
=======

   A signal is an asynchronous event that can happen in a program.  The
operating system defines the possible kinds of signals, and gives each
kind a name and a number.  For example, `SIGINT' is the signal a
program gets when you type `Ctrl-c'; `SIGSEGV' is the signal a program
gets from referencing a place in memory far away from all the areas in
use; `SIGALRM' occurs when the alarm clock timer goes off (which
happens only if the program has requested an alarm).

   Some signals, including `SIGALRM', are a normal part of the
functioning of the program.  Others, such as `SIGSEGV', indicate
errors; these signals are "fatal" (kill the program immediately) if the
program has not specified in advance some other way to handle the
signal.  `SIGINT' does not indicate an error in the program, but it is
normally fatal so it can carry out the purpose of `Ctrl-c': to kill
the program.

   GDB has the ability to detect any occurrence of a signal in the
program running under GDB's control.  You can tell GDB in advance what
to do for each kind of signal.

   Normally, GDB is set up to ignore non-erroneous signals like
`SIGALRM' (so as not to interfere with their role in the functioning
of the program) but to stop the program immediately whenever an error
signal happens.  You can change these settings with the `handle'
command.  You must specify which signal you are talking about with its
number.

`info signal'
     Print a table of all the kinds of signals and how GDB has been
     told to handle each one.  You can use this to see the signal
     numbers of all the defined types of signals.

`handle SIGNALNUM KEYWORDS...'
     Change the way GDB handles signal SIGNALNUM.  The KEYWORDS say
     what change to make.

   To use the `handle' command you must know the code number of the
signal you are concerned with.  To find the code number, type `info
signal' which prints a table of signal names and numbers.

   The keywords allowed by the handle command can be abbreviated. 
Their full names are

`stop'
     GDB should stop the program when this signal happens.  This
     implies the `print' keyword as well.

`print'
     GDB should print a message when this signal happens.

`nostop'
     GDB should not stop the program when this signal happens.  It may
     still print a message telling you that the signal has come in.

`noprint'
     GDB should not mention the occurrence of the signal at all.  This
     implies the `nostop' keyword as well.

`pass'
     GDB should allow the program to see this signal; the program will
     be able to handle the signal, or may be terminated if the signal
     is fatal and not handled.

`nopass'
     GDB should not allow the program to see this signal.

   When a signal has been set to stop the program, the program cannot
see the signal until you continue.  It will see the signal then, if
`pass' is in effect for the signal in question at that time.  In other
words, after GDB reports a signal, you can use the `handle' command
with `pass' or `nopass' to control whether that signal will be seen by
the program when you later continue it.

   You can also use the `signal' command to prevent the program from
seeing a signal, or cause it to see a signal it normally would not see,
or to give it any signal at any time.  *Note Signaling::.


File: gdb,  Node: Breakpoints,  Next: Continuing,  Prev: Signals,  Up: Stopping

Breakpoints
===========

   A "breakpoint" makes your program stop whenever a certain point in
the program is reached.  You set breakpoints explicitly with GDB
commands, specifying the place where the program should stop by line
number, function name or exact address in the program.  You can add
various other conditions to control whether the program will stop.

   Each breakpoint is assigned a number when it is created; these
numbers are successive integers starting with 1.  In many of the
commands for controlling various features of breakpoints you use the
breakpoint number to say which breakpoint you want to change.  Each
breakpoint may be "enabled" or "disabled"; if disabled, it has no
effect on the program until you enable it again.

   The command `info break' prints a list of all breakpoints set and
not deleted, showing their numbers, where in the program they are, and
any special features in use for them.  Disabled breakpoints are
included in the list, but marked as disabled.  `info break' with a
breakpoint number as argument lists only that breakpoint.  The
convenience variable `$_' and the default examining-address for the
`x' command are set to the address of the last breakpoint listed
(*note Memory::.).

* Menu:

* Set Breaks::     How to establish breakpoints.
* Delete Breaks::   How to remove breakpoints no longer needed.
* Disabling::      How to disable breakpoints (turn them off temporarily).
* Conditions::     Making extra conditions on whether to stop.
* Break Commands:: Commands to be executed at a breakpoint.
* Error in Breakpoints:: "Cannot insert breakpoints" error--why, what to do.


File: gdb,  Node: Set Breaks,  Next: Delete Breaks,  Prev: Breakpoints,  Up: Breakpoints

Setting Breakpoints
-------------------

   Breakpoints are set with the `break' command (abbreviated `b'). 
You have several ways to say where the breakpoint should go.

`break FUNCTION'
     Set a breakpoint at entry to function FUNCTION.

`break +OFFSET'
`break -OFFSET'
     Set a breakpoint some number of lines forward or back from the
     position at which execution stopped in the currently selected
     frame.

`break LINENUM'
     Set a breakpoint at line LINENUM in the current source file. 
     That file is the last file whose source text was printed.  This
     breakpoint will stop the program just before it executes any of
     the code on that line.

`break FILENAME:LINENUM'
     Set a breakpoint at line LINENUM in source file FILENAME.

`break FILENAME:FUNCTION'
     Set a breakpoint at entry to function FUNCTION found in file
     FILENAME.  Specifying a file name as well as a function name is
     superfluous except when multiple files contain similarly named
     functions.

`break *ADDRESS'
     Set a breakpoint at address ADDRESS.  You can use this to set
     breakpoints in parts of the program which do not have debugging
     information or source files.

`break'
     Set a breakpoint at the next instruction to be executed in the
     selected stack frame (*note Stack::.).  In any selected frame but
     the innermost, this will cause the program to stop as soon as
     control returns to that frame.  This is equivalent to a `finish'
     command in the frame inside the selected frame.  If this is done
     in the innermost frame, GDB will stop the next time it reaches
     the current location; this may be useful inside of loops.

     GDB normally ignores breakpoints when it resumes execution, until
     at least one instruction has been executed.  If it did not do
     this, you would be unable to proceed past a breakpoint without
     first disabling the breakpoint.  This rule applies whether or not
     the breakpoint already existed when the program stopped.

`break ... if COND'
     Set a breakpoint with condition COND; evaluate the expression
     COND each time the breakpoint is reached, and stop only if the
     value is nonzero.  `...' stands for one of the possible arguments
     described above (or no argument) specifying where to break. 
     *Note Conditions::, for more information on breakpoint conditions.

`tbreak ARGS'
     Set a breakpoint enabled only for one stop.  ARGS are the same as
     in the `break' command, and the breakpoint is set in the same
     way, but the breakpoint is automatically disabled the first time
     it is hit.  *Note Disabling::.

   GDB allows you to set any number of breakpoints at the same place
in the program.  There is nothing silly or meaningless about this. 
When the breakpoints are conditional, this is even useful (*note
Conditions::.).


File: gdb,  Node: Delete Breaks,  Next: Disabling,  Prev: Set Breaks,  Up: Breakpoints

Deleting Breakpoints
--------------------

   It is often necessary to eliminate a breakpoint once it has done
its job and you no longer want the program to stop there.  This is
called "deleting" the breakpoint.  A breakpoint that has been deleted
no longer exists in any sense; it is forgotten.

   With the `clear' command you can delete breakpoints according to
where they are in the program.  With the `delete' command you can
delete individual breakpoints by specifying their breakpoint numbers.

   It is not necessary to delete a breakpoint to proceed past it.  GDB
automatically ignores breakpoints in the first instruction to be
executed when you continue execution without changing the execution
address.

`clear'
     Delete any breakpoints at the next instruction to be executed in
     the selected stack frame (*note Selection::.).  When the
     innermost frame is selected, this is a good way to delete a
     breakpoint that the program just stopped at.

`clear FUNCTION'
`clear FILENAME:FUNCTION'
     Delete any breakpoints set at entry to the function FUNCTION.

`clear LINENUM'
`clear FILENAME:LINENUM'
     Delete any breakpoints set at or within the code of the specified
     line.

`delete BNUMS...'
     Delete the breakpoints of the numbers specified as arguments.


File: gdb,  Node: Disabling,  Next: Conditions,  Prev: Delete Breaks,  Up: Breakpoints

Disabling Breakpoints
---------------------

   Rather than deleting a breakpoint, you might prefer to "disable" it. 
This makes the breakpoint inoperative as if it had been deleted, but
remembers the information on the breakpoint so that you can "enable"
it again later.

   You disable and enable breakpoints with the `enable' and `disable'
commands, specifying one or more breakpoint numbers as arguments.  Use
`info break' to print a list of breakpoints if you don't know which
breakpoint numbers to use.

   A breakpoint can have any of four different states of enablement:

   * Enabled.  The breakpoint will stop the program.  A breakpoint made
     with the `break' command starts out in this state.

   * Disabled.  The breakpoint has no effect on the program.

   * Enabled once.  The breakpoint will stop the program, but when it
     does so it will become disabled.  A breakpoint made with the
     `tbreak' command starts out in this state.

   * Enabled for deletion.  The breakpoint will stop the program, but
     immediately after it does so it will be deleted permanently.

   You change the state of enablement of a breakpoint with the
following commands:

`disable breakpoints BNUMS...'
`disable BNUMS...'
     Disable the specified breakpoints.  A disabled breakpoint has no
     effect but is not forgotten.  All options such as ignore-counts,
     conditions and commands are remembered in case the breakpoint is
     enabled again later.

`enable breakpoints BNUMS...'
`enable BNUMS...'
     Enable the specified breakpoints.  They become effective once
     again in stopping the program, until you specify otherwise.

`enable breakpoints once BNUMS...'
`enable once BNUMS...'
     Enable the specified breakpoints temporarily.  Each will be
     disabled again the next time it stops the program (unless you
     have used one of these commands to specify a different state
     before that time comes).

`enable breakpoints delete BNUMS...'
`enable delete BNUMS...'
     Enable the specified breakpoints to work once and then die.  Each
     of the breakpoints will be deleted the next time it stops the
     program (unless you have used one of these commands to specify a
     different state before that time comes).

   Aside from the automatic disablement or deletion of a breakpoint
when it stops the program, which happens only in certain states, the
state of enablement of a breakpoint changes only when one of the
commands above is used.

