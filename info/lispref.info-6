This is Info file ../../info/lispref.info, produced by Makeinfo-1.56
from the input file lispref.texinfo.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Array Functions,  Next: Vectors,  Prev: Arrays,  Up: Sequences Arrays Vectors

Functions that Operate on Arrays
================================

   In this section, we describe the functions that accept both strings
and vectors.

 - Function: arrayp OBJECT
     This function returns `t' if OBJECT is an array (i.e., either a
     vector or a string).

          (arrayp [a])
          => t
          (arrayp "asdf")
          => t

 - Function: aref ARRAY INDEX
     This function returns the INDEXth element of ARRAY.  The first
     element is at index zero.

          (setq primes [2 3 5 7 11 13])
               => [2 3 5 7 11 13]
          (aref primes 4)
               => 11
          (elt primes 4)
               => 11
          
          (aref "abcdefg" 1)
               => 98           ; `b' is ASCII code 98.

     See also the function `elt', in *Note Sequence Functions::.

 - Function: aset ARRAY INDEX OBJECT
     This function sets the INDEXth element of ARRAY to be OBJECT.  It
     returns OBJECT.

          (setq w [foo bar baz])
               => [foo bar baz]
          (aset w 0 'fu)
               => fu
          w
               => [fu bar baz]
          
          (setq x "asdfasfd")
               => "asdfasfd"
          (aset x 3 ?Z)
               => 90
          x
               => "asdZasfd"

     If ARRAY is a string and OBJECT is not a character, a
     `wrong-type-argument' error results.

 - Function: fillarray ARRAY OBJECT
     This function fills the array ARRAY with pointers to OBJECT,
     replacing any previous values.  It returns ARRAY.

          (setq a [a b c d e f g])
               => [a b c d e f g]
          (fillarray a 0)
               => [0 0 0 0 0 0 0]
          a
               => [0 0 0 0 0 0 0]
          (setq s "When in the course")
               => "When in the course"
          (fillarray s ?-)
               => "------------------"

     If ARRAY is a string and OBJECT is not a character, a
     `wrong-type-argument' error results.

   The general sequence functions `copy-sequence' and `length' are
often useful for objects known to be arrays.  *Note Sequence
Functions::.


File: lispref.info,  Node: Vectors,  Prev: Array Functions,  Up: Sequences Arrays Vectors

Vectors
=======

   Arrays in Lisp, like arrays in most languages, are blocks of memory
whose elements can be accessed in constant time.  A "vector" is a
general-purpose array; its elements can be any Lisp objects.  (The other
kind of array provided in Emacs Lisp is the "string", whose elements
must be characters.)  The main uses of vectors in Emacs are as syntax
tables (vectors of integers) and keymaps (vectors of commands).  They
are also used internally as part of the representation of a
byte-compiled function; if you print such a function, you will see a
vector in it.

   The indices of the elements of a vector are numbered starting with
zero in Emacs Lisp.

   Vectors are printed with square brackets surrounding the elements in
their order.  Thus, a vector containing the symbols `a', `b' and `c' is
printed as `[a b c]'.  You can write vectors in the same way in Lisp
input.

   A vector, like a string or a number, is considered a constant for
evaluation: the result of evaluating it is the same vector.  The
elements of the vector are not evaluated.  *Note Self-Evaluating
Forms::.

   Here are examples of these principles:

     (setq avector [1 two '(three) "four" [five]])
          => [1 two (quote (three)) "four" [five]]
     (eval avector)
          => [1 two (quote (three)) "four" [five]]
     (eq avector (eval avector))
          => t

   Here are some functions that relate to vectors:

 - Function: vectorp OBJECT
     This function returns `t' if OBJECT is a vector.

          (vectorp [a])
               => t
          (vectorp "asdf")
               => nil

 - Function: vector &rest OBJECTS
     This function creates and returns a vector whose elements are the
     arguments, OBJECTS.

          (vector 'foo 23 [bar baz] "rats")
               => [foo 23 [bar baz] "rats"]
          (vector)
               => []

 - Function: make-vector INTEGER OBJECT
     This function returns a new vector consisting of INTEGER elements,
     each initialized to OBJECT.

          (setq sleepy (make-vector 9 'Z))
               => [Z Z Z Z Z Z Z Z Z]

 - Function: vconcat &rest SEQUENCES
     This function returns a new vector containing all the elements of
     the SEQUENCES.  The arguments SEQUENCES may be lists, vectors, or
     strings.  If no SEQUENCES are given, an empty vector is returned.

     The value is a newly constructed vector that is not `eq' to any
     existing vector.

          (setq a (vconcat '(A B C) '(D E F)))
               => [A B C D E F]
          (eq a (vconcat a))
               => nil
          (vconcat)
               => []
          (vconcat [A B C] "aa" '(foo (6 7)))
               => [A B C 97 97 foo (6 7)]

     When an argument is an integer (not a sequence of integers), it is
     converted to a string of digits making up the decimal printed
     representation of the integer.  This special case exists for
     compatibility with Mocklisp, and we don't recommend you take
     advantage of it.  If you want to convert an integer in this way,
     use `format' (*note Formatting Strings::.) or `int-to-string'
     (*note String Conversion::.).

     For other concatenation functions, see `mapconcat' in *Note
     Mapping Functions::, `concat' in *Note Creating Strings::, and
     `append' in *Note Building Lists::.

   The `append' function may be used to convert a vector into a list
with the same elements (*note Building Lists::.):

     (setq avector [1 two (quote (three)) "four" [five]])
          => [1 two (quote (three)) "four" [five]]
     (append avector nil)
          => (1 two (quote (three)) "four" [five])


File: lispref.info,  Node: Symbols,  Next: Evaluation,  Prev: Sequences Arrays Vectors,  Up: Top

Symbols
*******

   A "symbol" is an object with a unique name.  This chapter describes
symbols, their components, and how they are created and interned.
Property lists are also described.  The uses of symbols as variables
and as function names are described in separate chapters; see *Note
Variables::, and *Note Functions::.  For the precise syntax for
symbols, see *Note Symbol Type::.

   You can test whether an arbitrary Lisp object is a symbol with
`symbolp':

 - Function: symbolp OBJECT
     This function returns `t' if OBJECT is a symbol, `nil' otherwise.

* Menu:

* Symbol Components::        Symbols have names, values, function definitions
                               and property lists.
* Definitions::              A definition says how a symbol will be used.
* Creating Symbols::         How symbols are kept unique.
* Property Lists::           Each symbol has a property list
                               for recording miscellaneous information.


File: lispref.info,  Node: Symbol Components,  Next: Definitions,  Prev: Symbols,  Up: Symbols

Symbol Components
=================

   Each symbol has four components (or "cells"), each of which
references another object:

Print name
     The "print name cell" holds a string which names the symbol for
     reading and printing.  See `symbol-name' in *Note Creating
     Symbols::.

Value
     The "value cell" holds the current value of the symbol as a
     variable.  When a symbol is used as a form, the value of the form
     is the contents of the symbol's value cell.  See `symbol-value' in
     *Note Accessing Variables::.

Function
     The "function cell" holds the function definition of the symbol.
     When a symbol is used as a function, its function definition is
     used in its place.  This cell is also used to make a symbol stand
     for a keymap or a keyboard macro, for editor command execution.
     Because each symbol has separate value and function cells,
     variables and function names do not conflict.  See
     `symbol-function' in *Note Function Cells::.

Property list
     The "property list cell" holds the property list of the symbol.
     See `symbol-plist' in *Note Property Lists::.

   The print name cell always holds a string, and cannot be changed.
The other three cells can be set individually to any specified Lisp
object.

   The print name cell holds the string that is the name of the symbol.
Since symbols are represented textually by their names, it is important
not to have two symbols with the same name.  The Lisp reader ensures
this: every time it reads a symbol, it looks for an existing symbol with
the specified name before it creates a new one.  (In GNU Emacs Lisp,
this is done with a hashing algorithm that uses an obarray; see *Note
Creating Symbols::.)

   In normal usage, the function cell usually contains a function or
macro, as that is what the Lisp interpreter expects to see there (*note
Evaluation::.).  Keyboard macros (*note Keyboard Macros::.), keymaps
(*note Keymaps::.) and autoload objects (*note Autoloading::.) are also
sometimes stored in the function cell of symbols.  We often refer to
"the function `foo'" when we really mean the function stored in the
function cell of the symbol `foo'.  We make the distinction only when
necessary.

   Similarly, the property list cell normally holds a correctly
formatted property list (*note Property Lists::.), as a number of
functions expect to see a property list there.

   The function cell or the value cell may be "void", which means that
the cell does not reference any object.  (This is not the same thing as
holding the symbol `void', nor the same as holding the symbol `nil'.)
Examining the value of a cell which is void results in an error, such
as `Symbol's value as variable is void'.

   The four functions `symbol-name', `symbol-value', `symbol-plist',
and `symbol-function' return the contents of the four cells.  Here as
an example we show the contents of the four cells of the symbol
`buffer-file-name':

     (symbol-name 'buffer-file-name)
          => "buffer-file-name"
     (symbol-value 'buffer-file-name)
          => "/gnu/elisp/symbols.texi"
     (symbol-plist 'buffer-file-name)
          => (variable-documentation 29529)
     (symbol-function 'buffer-file-name)
          => #<subr buffer-file-name>

Because this symbol is the variable which holds the name of the file
being visited in the current buffer, the value cell contents we see are
the name of the source file of this chapter of the Emacs Lisp Manual.
The property list cell contains the list `(variable-documentation
29529)' which tells the documentation functions where to find
documentation about `buffer-file-name' in the `DOC' file.  (29529 is
the offset from the beginning of the `DOC' file where the documentation
for the function begins.)  The function cell contains the function for
returning the name of the file.  `buffer-file-name' names a primitive
function, which has no read syntax and prints in hash notation (*note
Primitive Function Type::.).  A symbol naming a function written in
Lisp would have a lambda expression (or a byte-code object) in this
cell.


File: lispref.info,  Node: Definitions,  Next: Creating Symbols,  Prev: Symbol Components,  Up: Symbols

Defining Symbols
================

   A "definition" in Lisp is a special form that announces your
intention to use a certain symbol in a particular way.  In Emacs Lisp,
you can define a symbol as a variable, or define it as a function (or
macro), or both independently.

   A definition construct typically specifies a value or meaning for the
symbol for one kind of use, plus documentation for its meaning when used
in this way.  Thus, when you define a symbol as a variable, you can
supply an initial value for the variable, plus documentation for the
variable.

   `defvar' and `defconst' are special forms that define a symbol as a
global variable.  They are documented in detail in *Note Defining
Variables::.

   `defun' defines a symbol as a function, creating a lambda expression
and storing it in the function cell of the symbol.  This lambda
expression thus becomes the function definition of the symbol.  (The
term "function definition", meaning the contents of the function cell,
is derived from the idea that `defun' gives the symbol its definition
as a function.)  *Note Functions::.

   `defmacro' defines a symbol as a macro.  It creates a macro object
and stores it in the function cell of the symbol.  Note that a given
symbol can be a macro or a function, but not both at once, because both
macro and function definitions are kept in the function cell, and that
cell can hold only one Lisp object at any given time.  *Note Macros::.

   In GNU Emacs Lisp, a definition is not required in order to use a
symbol as a variable or function.  Thus, you can make a symbol a global
variable with `setq', whether you define it first or not.  The real
purpose of definitions is to guide programmers and programming tools.
They inform programmers who read the code that certain symbols are
*intended* to be used as variables, or as functions.  In addition,
utilities such as `etags' and `make-docfile' can recognize definitions,
and add the appropriate information to tag tables and the
`emacs/etc/DOC-VERSION' file. *Note Accessing Documentation::.


File: lispref.info,  Node: Creating Symbols,  Next: Property Lists,  Prev: Definitions,  Up: Symbols

Creating and Interning Symbols
==============================

   To understand how symbols are created in GNU Emacs Lisp, you must
know how Lisp reads them.  Lisp must ensure that it finds the same
symbol every time it reads the same set of characters.  Failure to do
so would cause complete confusion.

   When the Lisp reader encounters a symbol, it reads all the characters
of the name.  Then it "hashes" those characters to find an index in a
table called an "obarray".  Hashing is an efficient method of looking
something up.  For example, instead of searching a telephone book cover
to cover when looking up Jan Jones, you start with the J's and go from
there.  That is a simple version of hashing.  Each element of the
obarray is a "bucket" which holds all the symbols with a given hash
code; to look for a given name, it is sufficient to look through all
the symbols in the bucket for that name's hash code.

   If a symbol with the desired name is found, then it is used.  If no
such symbol is found, then a new symbol is created and added to the
obarray bucket.  Adding a symbol to an obarray is called "interning"
it, and the symbol is then called an "interned symbol".  In Emacs Lisp,
a symbol may be interned in only one obarray--if you try to intern the
same symbol in more than one obarray, you will get unpredictable
results.

   It is possible for two different symbols to have the same name in
different obarrays; these symbols are not `eq' or `equal'.  However,
this normally happens only as part of abbrev definition (*note
Abbrevs::.).

     Common Lisp note: in Common Lisp, a symbol may be interned in
     several obarrays at once.

   If a symbol is not in the obarray, then there is no way for Lisp to
find it when its name is read.  Such a symbol is called an "uninterned
symbol" relative to the obarray.  An uninterned symbol has all the
other characteristics of symbols.

   In Emacs Lisp, an obarray is represented as a vector.  Each element
of the vector is a bucket; its value is either an interned symbol whose
name hashes to that bucket, or 0 if the bucket is empty.  Each interned
symbol has an internal link (invisible to the user) to the next symbol
in the bucket.  Because these links are invisible, there is no way to
scan the symbols in an obarray except using `mapatoms' (below).  The
order of symbols in a bucket is not significant.

   In an empty obarray, every element is 0, and you can create an
obarray with `(make-vector LENGTH 0)'.  *This is the only valid way to
create an obarray.*  Prime numbers as lengths tend to result in good
hashing; lengths one less than a power of two are also good.

   *Do not try to create an obarray that is not empty.*  This does not
work--only `intern' can enter a symbol in an obarray properly.  Also,
don't try to put into an obarray of your own a symbol that is already
interned in the main obarray, because in Emacs Lisp a symbol cannot be
in two obarrays at once.

   Most of the functions below take a name and sometimes an obarray as
arguments.  A `wrong-type-argument' error is signaled if the name is
not a string, or if the obarray is not a vector.

 - Function: symbol-name SYMBOL
     This function returns the string that is SYMBOL's name.  For
     example:

          (symbol-name 'foo)
               => "foo"

     Changing the string by substituting characters, etc, does change
     the name of the symbol, but fails to update the obarray, so don't
     do it!

 - Function: make-symbol NAME
     This function returns a newly-allocated, uninterned symbol whose
     name is NAME (which must be a string).  Its value and function
     definition are void, and its property list is `nil'.  In the
     example below, the value of `sym' is not `eq' to `foo' because it
     is a distinct uninterned symbol whose name is also `foo'.

          (setq sym (make-symbol "foo"))
               => foo
          (eq sym 'foo)
               => nil

 - Function: intern NAME &optional OBARRAY
     This function returns the interned symbol whose name is NAME.  If
     there is no such symbol in the obarray, a new one is created,
     added to the obarray, and returned.  If OBARRAY is supplied, it
     specifies the obarray to use; otherwise, the value of the global
     variable `obarray' is used.

          (setq sym (intern "foo"))
               => foo
          (eq sym 'foo)
               => t
          
          (setq sym1 (intern "foo" other-obarray))
               => foo
          (eq sym 'foo)
               => nil

 - Function: intern-soft NAME &optional OBARRAY
     This function returns the symbol whose name is NAME, or `nil' if a
     symbol with that name is not found in the obarray.  Therefore, you
     can use `intern-soft' to test whether a symbol with a given name is
     interned.  If OBARRAY is supplied, it specifies the obarray to
     use; otherwise the value of the global variable `obarray' is used.

          (intern-soft "frazzle")        ; No such symbol exists.
               => nil
          (make-symbol "frazzle")        ; Create an uninterned one.
               => frazzle
          (intern-soft "frazzle")        ; That one cannot be found.
               => nil
          (setq sym (intern "frazzle"))  ; Create an interned one.
               => frazzle
          (intern-soft "frazzle")        ; That one can be found!
               => frazzle
          (eq sym 'frazzle)              ; And it is the same one.
               => t

 - Variable: obarray
     This variable is the standard obarray for use by `intern' and
     `read'.

 - Function: mapatoms FUNCTION &optional OBARRAY
     This function applies FUNCTION to every symbol in OBARRAY.  It
     returns `nil'.  If OBARRAY is not supplied, it defaults to the
     value of `obarray', the standard obarray for ordinary symbols.

          (setq count 0)
               => 0
          (defun count-syms (s)
            (setq count (1+ count)))
               => count-syms
          (mapatoms 'count-syms)
               => nil
          count
               => 1871

     See `documentation' in *Note Accessing Documentation::, for another
     example using `mapatoms'.


File: lispref.info,  Node: Property Lists,  Prev: Creating Symbols,  Up: Symbols

Property Lists
==============

   A "property list" ("plist" for short) is a list of paired elements
stored in the property list cell of a symbol.  Each of the pairs
associates a property name (usually a symbol) with a property or value.
Property lists are generally used to record information about a
symbol, such as how to compile it, the name of the file where it was
defined, or perhaps even the grammatical class of the symbol
(representing a word) in a language understanding system.

   Character positions in a string or buffer can also have property
lists.  *Note Text Properties::.

   The property names and values in a property list can be any Lisp
objects, but the names are usually symbols.  They are compared using
`eq'.  Here is an example of a property list, found on the symbol
`progn' when the compiler is loaded:

     (lisp-indent-function 0 byte-compile byte-compile-progn)

Here `lisp-indent-function' and `byte-compile' are property names, and
the other two elements are the corresponding values.

   Association lists (*note Association Lists::.) are very similar to
property lists.  In contrast to association lists, the order of the
pairs in the property list is not significant since the property names
must be distinct.

   Property lists are better than association lists when it is necessary
to attach information to various Lisp function names or variables.  If
all the pairs are recorded in one association list, the program will
need to search that entire list each time a function or variable is to
be operated on.  By contrast, if the information is recorded in the
property lists of the function names or variables themselves, each
search will scan only the length of one property list, which is usually
short.  For this reason, the documentation for a variable is recorded in
a property named `variable-documentation'.  The byte compiler likewise
uses properties to record those functions needing special treatment.

   However, association lists have their own advantages.  Depending on
your application, it may be faster to add an association to the front of
an association list than to update a property.  All properties for a
symbol are stored in the same property list, so there is a possibility
of a conflict between different uses of a property name.  (For this
reason, it is a good idea to use property names that are probably
unique, such as by including the name of the library in the property
name.)  An association list may be used like a stack where associations
are pushed on the front of the list and later discarded; this is not
possible with a property list.

 - Function: symbol-plist SYMBOL
     This function returns the property list of SYMBOL.

 - Function: setplist SYMBOL PLIST
     This function sets SYMBOL's property list to PLIST.  Normally,
     PLIST should be a well-formed property list, but this is not
     enforced.

          (setplist 'foo '(a 1 b (2 3) c nil))
               => (a 1 b (2 3) c nil)
          (symbol-plist 'foo)
               => (a 1 b (2 3) c nil)

     For symbols in special obarrays, which are not used for ordinary
     purposes, it may make sense to use the property list cell in a
     nonstandard fashion; in fact, the abbrev mechanism does so (*note
     Abbrevs::.).

 - Function: get SYMBOL PROPERTY
     This function finds the value of the property named PROPERTY in
     SYMBOL's property list.  If there is no such property, `nil' is
     returned.  Thus, there is no distinction between a value of `nil'
     and the absence of the property.

     The name PROPERTY is compared with the existing property names
     using `eq', so any object is a legitimate property.

     See `put' for an example.

 - Function: put SYMBOL PROPERTY VALUE
     This function puts VALUE onto SYMBOL's property list under the
     property name PROPERTY, replacing any previous value.

          (put 'fly 'verb 'transitive)
               =>'transitive
          (put 'fly 'noun '(a buzzing little bug))
               => (a buzzing little bug)
          (get 'fly 'verb)
               => transitive
          (symbol-plist 'fly)
               => (verb transitive noun (a buzzing little bug))


File: lispref.info,  Node: Evaluation,  Next: Control Structures,  Prev: Symbols,  Up: Top

Evaluation
**********

   The "evaluation" of expressions in Emacs Lisp is performed by the
"Lisp interpreter"--a program that receives a Lisp object as input and
computes its "value as an expression".  The value is computed in a
fashion that depends on the data type of the object, following rules
described in this chapter.  The interpreter runs automatically to
evaluate portions of your program, but can also be called explicitly
via the Lisp primitive function `eval'.

* Menu:

* Intro Eval::  Evaluation in the scheme of things.
* Eval::        How to invoke the Lisp interpreter explicitly.
* Forms::       How various sorts of objects are evaluated.
* Quoting::     Avoiding evaluation (to put constants in the program).


File: lispref.info,  Node: Intro Eval,  Next: Eval,  Up: Evaluation

Introduction to Evaluation
==========================

   The Lisp interpreter, or evaluator, is the program which computes
the value of an expression which is given to it.  When a function
written in Lisp is called, the evaluator computes the value of the
function by evaluating the expressions in the function body.  Thus,
running any Lisp program really means running the Lisp interpreter.

   How the evaluator handles an object depends primarily on the data
type of the object.

   A Lisp object which is intended for evaluation is called an
"expression" or a "form".  The fact that expressions are data objects
and not merely text is one of the fundamental differences between
Lisp-like languages and typical programming languages.  Any object can
be evaluated, but in practice only numbers, symbols, lists and strings
are evaluated very often.

   It is very common to read a Lisp expression and then evaluate the
expression, but reading and evaluation are separate activities, and
either can be performed alone.  Reading per se does not evaluate
anything; it converts the printed representation of a Lisp object to the
object itself.  It is up to the caller of `read' whether this object is
a form to be evaluated, or serves some entirely different purpose.
*Note Input Functions::.

   Do not confuse evaluation with command key interpretation.  The
editor command loop translates keyboard input into a command (an
interactively callable function) using the active keymaps, and then
uses `call-interactively' to invoke the command.  The execution of the
command itself involves evaluation if the command is written in Lisp,
but that is not a part of command key interpretation itself.  *Note
Command Loop::.

   Evaluation is a recursive process.  That is, evaluation of a form may
cause `eval' to be called again in order to evaluate parts of the form.
For example, evaluation of a function call first evaluates each
argument of the function call, and then evaluates each form in the
function body.  Consider evaluation of the form `(car x)': the subform
`x' must first be evaluated recursively, so that its value can be
passed as an argument to the function `car'.

   The evaluation of forms takes place in a context called the
"environment", which consists of the current values and bindings of all
Lisp variables.(1)  Whenever the form refers to a variable without
creating a new binding for it, the value of the binding in the current
environment is used.  *Note Variables::.

   Evaluation of a form may create new environments for recursive
evaluation by binding variables (*note Local Variables::.).  These
environments are temporary and will be gone by the time evaluation of
the form is complete.  The form may also make changes that persist;
these changes are called "side effects".  An example of a form that
produces side effects is `(setq foo 1)'.

   Finally, evaluation of one particular function call, `byte-code',
invokes the "byte-code interpreter" on its arguments.  Although the
byte-code interpreter is not the same as the Lisp interpreter, it uses
the same environment as the Lisp interpreter, and may on occasion invoke
the Lisp interpreter.  (*Note Byte Compilation::.)

   The details of what evaluation means for each kind of form are
described below (*note Forms::.).

   ---------- Footnotes ----------

   (1)  This definition of "environment" is specifically not intended
to include all the data which can affect the result of a program.


File: lispref.info,  Node: Eval,  Next: Forms,  Prev: Intro Eval,  Up: Evaluation

Eval
====

   Most often, forms are evaluated automatically, by virtue of their
occurrence in a program being run.  On rare occasions, you may need to
write code that evaluates a form that is computed at run time, such as
after reading a form from text being edited or getting one from a
property list.  On these occasions, use the `eval' function.

   The functions and variables described in this section evaluate
forms, specify limits to the evaluation process, or record recently
returned values.  Loading a file also does evaluation (*note
Loading::.).

 - Function: eval FORM
     This is the basic function for performing evaluation.  It evaluates
     FORM in the current environment and returns the result.  How the
     evaluation proceeds depends on the type of the object (*note
     Forms::.).

     Since `eval' is a function, the argument expression that appears
     in a call to `eval' is evaluated twice: once as preparation before
     `eval' is called, and again by the `eval' function itself.  Here
     is an example:

          (setq foo 'bar)
               => bar
          (setq bar 'baz)
               => baz
          ;; `eval' receives argument `bar', which is the value of `foo'
          (eval foo)
               => baz

     The number of currently active calls to `eval' is limited to
     `max-lisp-eval-depth' (see below).

 - Command: eval-current-buffer &optional STREAM
     This function evaluates the forms in the current buffer.  It reads
     forms from the buffer and calls `eval' on them until the end of the
     buffer is reached, or until an error is signaled and not handled.

     If STREAM is supplied, the variable `standard-output' is bound to
     STREAM during the evaluation (*note Output Functions::.).

     `eval-current-buffer' always returns `nil'.

 - Command: eval-region START END &optional STREAM
     This function evaluates the forms in the current buffer in the
     region defined by the positions START and END.  It reads forms from
     the region and calls `eval' on them until the end of the region is
     reached, or until an error is signaled and not handled.

     If STREAM is supplied, `standard-output' is bound to it for the
     duration of the command.

     `eval-region' always returns `nil'.

 - Variable: max-lisp-eval-depth
     This variable defines the maximum depth allowed in calls to
     `eval', `apply', and `funcall' before an error is signaled (with
     error message `"Lisp nesting exceeds max-lisp-eval-depth"').
     `eval' is called recursively to evaluate the arguments of Lisp
     function calls and to evaluate bodies of functions.

     This limit, with the associated error when it is exceeded, is one
     way that Lisp avoids infinite recursion on an ill-defined function.

     The default value of this variable is 200.  If you set it to a
     value less than 100, Lisp will reset it to 100 if the given value
     is reached.

     `max-specpdl-size' provides another limit on nesting.  *Note Local
     Variables::.

 - Variable: values
     The value of this variable is a list of values returned by all
     expressions which were read from buffers (including the
     minibuffer), evaluated, and printed.  The elements are in order,
     most recent first.

          (setq x 1)
               => 1
          (list 'A (1+ 2) auto-save-default)
               => (A 3 t)
          values
               => ((A 3 t) 1 ...)

     This variable is useful for referring back to values of forms
     recently evaluated.  It is generally a bad idea to print the value
     of `values' itself, since this may be very long.  Instead, examine
     particular elements, like this:

          ;; Refer to the most recent evaluation result.
          (nth 0 values)
               => (A 3 t)
          ;; That put a new element on,
          ;;   so all elements move back one.
          (nth 1 values)
               => (A 3 t)
          ;; This gets the element that was next-to-last
          ;;   before this example.
          (nth 3 values)
               => 1


File: lispref.info,  Node: Forms,  Next: Quoting,  Prev: Eval,  Up: Evaluation

Kinds of Forms
==============

   A Lisp object that is intended to be evaluated is called a "form".
How Emacs evaluates a form depends on its data type.  Emacs has three
different kinds of form that are evaluated differently: symbols, lists,
and "all other types".  All three kinds are described in this section,
starting with "all other types" which are self-evaluating forms.

* Menu:

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Indirection::    When a symbol appears as the car of a list,
			      we find the real function via the symbol.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           "Special forms" are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.


File: lispref.info,  Node: Self-Evaluating Forms,  Next: Symbol Forms,  Up: Forms

Self-Evaluating Forms
---------------------

   A "self-evaluating form" is any form that is not a list or symbol.
Self-evaluating forms evaluate to themselves: the result of evaluation
is the same object that was evaluated.  Thus, the number 25 evaluates to
25, and the string `"foo"' evaluates to the string `"foo"'.  Likewise,
evaluation of a vector does not cause evaluation of the elements of the
vector--it returns the same vector with its contents unchanged.

     '123               ; An object, shown without evaluation.
          => 123
     123                ; Evaluated as usual---result is the same.
          => 123
     (eval '123)        ; Evaluated ``by hand''---result is the same.
          => 123
     (eval (eval '123)) ; Evaluating twice changes nothing.
          => 123

   It is common to write numbers, characters, strings, and even vectors
in Lisp code, taking advantage of the fact that they self-evaluate.
However, it is quite unusual to do this for types that lack a read
syntax, because it is inconvenient and not very useful; however, it is
possible to put them inside Lisp programs when they are constructed
from subexpressions rather than read.  Here is an example:

     ;; Build such an expression.
     (setq buffer (list 'print (current-buffer)))
          => (print #<buffer eval.texi>)
     ;; Evaluate it.
     (eval buffer)
          -| #<buffer eval.texi>
          => #<buffer eval.texi>


File: lispref.info,  Node: Symbol Forms,  Next: Classifying Lists,  Prev: Self-Evaluating Forms,  Up: Forms

Symbol Forms
------------

   When a symbol is evaluated, it is treated as a variable.  The result
is the variable's value, if it has one.  If it has none (if its value
cell is void), an error is signaled.  For more information on the use of
variables, see *Note Variables::.

   In the following example, we set the value of a symbol with `setq'.
When the symbol is later evaluated, that value is returned.

     (setq a 123)
          => 123
     (eval 'a)
          => 123
     a
          => 123

   The symbols `nil' and `t' are treated specially, so that the value
of `nil' is always `nil', and the value of `t' is always `t'.  Thus,
these two symbols act like self-evaluating forms, even though `eval'
treats them like any other symbol.


File: lispref.info,  Node: Classifying Lists,  Next: Function Indirection,  Prev: Symbol Forms,  Up: Forms

Classification of List Forms
----------------------------

   A form that is a nonempty list is either a function call, a macro
call, or a special form, according to its first element.  These three
kinds of forms are evaluated in different ways, described below.  The
rest of the list consists of "arguments" for the function, macro or
special form.

   The first step in evaluating a nonempty list is to examine its first
element.  This element alone determines what kind of form the list is
and how the rest of the list is to be processed.  The first element is
*not* evaluated, as it would be in some Lisp dialects including Scheme.


File: lispref.info,  Node: Function Indirection,  Next: Function Forms,  Prev: Classifying Lists,  Up: Forms

Symbol Function Indirection
---------------------------

   If the first element of the list is a symbol then evaluation examines
the symbol's function cell, and uses its contents instead of the
original symbol.  If the contents are another symbol, this process,
called "symbol function indirection", is repeated until a non-symbol is
obtained.  *Note Function Names::, for more information about using a
symbol as a name for a function stored in the function cell of the
symbol.

   One possible consequence of this process is an infinite loop, in the
event that a symbol's function cell refers to the same symbol.  Or a
symbol may have a void function cell, causing a `void-function' error.
But if neither of these things happens, we eventually obtain a
non-symbol, which ought to be a function or other suitable object.

   More precisely, we should now have a Lisp function (a lambda
expression), a byte-code function, a primitive function, a Lisp macro, a
special form, or an autoload object.  Each of these types is a case
described in one of the following sections.  If the object is not one of
these types, the error `invalid-function' is signaled.

   The following example illustrates the symbol indirection process.  We
use `fset' to set the function cell of a symbol and `symbol-function'
to get the function cell contents (*note Function Cells::.).
Specifically, we store the symbol `car' into the function cell of
`first', and the symbol `first' into the function cell of `erste'.

     ;; Build this function cell linkage:
     ;;   -------------       -----        -------        -------
     ;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
     ;;   -------------       -----        -------        -------

     (symbol-function 'car)
          => #<subr car>

     (fset 'first 'car)
          => car

     (fset 'erste 'first)
          => first

     (erste '(1 2 3))   ; Call the function referenced by `erste'.
          => 1

   By contrast, the following example calls a function without any
symbol function indirection, because the first element is an anonymous
Lisp function, not a symbol.

     ((lambda (arg) (erste arg))
      '(1 2 3))
          => 1

After that function is called, its body is evaluated; this does involve
symbol function indirection when calling `erste'.

   The built-in function `indirect-function' provides an easy way to
perform symbol function indirection explicitly.

 - Function: indirect-function FUNCTION
     This function returns the meaning of FUNCTION as a function.  If
     FUNCTION is a symbol, then it finds FUNCTION's function definition
     and starts over with that value.  If FUNCTION is not a symbol,
     then it returns FUNCTION itself.

     Here is how you could define `indirect-function' in Lisp:

          (defun indirect-function (function)
            (if (symbolp function)
                (indirect-function (symbol-function function))
              function))


File: lispref.info,  Node: Function Forms,  Next: Macro Forms,  Prev: Function Indirection,  Up: Forms

Evaluation of Function Forms
----------------------------

   If the first element of a list being evaluated is a Lisp function
object, byte-code object or primitive function object, then that list is
a "function call".  For example, here is a call to the function `+':

     (+ 1 x)

   When a function call is evaluated, the first step is to evaluate the
remaining elements of the list in the order they appear.  The results
are the actual argument values, one argument from each element.  Then
the function is called with this list of arguments, effectively using
the function `apply' (*note Calling Functions::.).  If the function is
written in Lisp, the arguments are used to bind the argument variables
of the function (*note Lambda Expressions::.); then the forms in the
function body are evaluated in order, and the result of the last one is
used as the value of the function call.


File: lispref.info,  Node: Macro Forms,  Next: Special Forms,  Prev: Function Forms,  Up: Forms

Lisp Macro Evaluation
---------------------

   If the first element of a list being evaluated is a macro object,
then the list is a "macro call".  When a macro call is evaluated, the
elements of the rest of the list are *not* initially evaluated.
Instead, these elements themselves are used as the arguments of the
macro.  The macro definition computes a replacement form, called the
"expansion" of the macro, which is evaluated in place of the original
form.  The expansion may be any sort of form: a self-evaluating
constant, a symbol or a list.  If the expansion is itself a macro call,
this process of expansion repeats until some other sort of form results.

   Normally, the argument expressions are not evaluated as part of
computing the macro expansion, but instead appear as part of the
expansion, so they are evaluated when the expansion is evaluated.

   For example, given a macro defined as follows:

     (defmacro cadr (x)
       (list 'car (list 'cdr x)))

an expression such as `(cadr (assq 'handler list))' is a macro call,
and its expansion is:

     (car (cdr (assq 'handler list)))

Note that the argument `(assq 'handler list)' appears in the expansion.

   *Note Macros::, for a complete description of Emacs Lisp macros.


File: lispref.info,  Node: Special Forms,  Next: Autoloading,  Prev: Macro Forms,  Up: Forms

Special Forms
-------------

   A "special form" is a primitive function specially marked so that
its arguments are not all evaluated.  Special forms define control
structures or perform variable bindings--things which functions cannot
do.

   Each special form has its own rules for which arguments are evaluated
and which are used without evaluation.  Whether a particular argument is
evaluated may depend on the results of evaluating other arguments.

   Here is a list, in alphabetical order, of all of the special forms in
Emacs Lisp with a reference to where each is described.

`and'
     *note Combining Conditions::.

`catch'
     *note Catch and Throw::.

`cond'
     *note Conditionals::.

`condition-case'
     *note Handling Errors::.

`defconst'
     *note Defining Variables::.

`defmacro'
     *note Defining Macros::.

`defun'
     *note Defining Functions::.

`defvar'
     *note Defining Variables::.

`function'
     *note Anonymous Functions::.

`if'
     *note Conditionals::.

`interactive'
     *note Interactive Call::.

`let'
`let*'
     *note Local Variables::.

`or'
     *note Combining Conditions::.

`prog1'
`prog2'
`progn'
     *note Sequencing::.

`quote'
     *note Quoting::.

`save-excursion'
     *note Excursions::.

`save-restriction'
     *note Narrowing::.

`save-window-excursion'
     *note Window Configurations::.

`setq'
     *note Setting Variables::.

`setq-default'
     *note Creating Buffer-Local::.

`unwind-protect'
     *note Nonlocal Exits::.

`while'
     *note Iteration::.

`with-output-to-temp-buffer'
     *note Temporary Displays::.

     Common Lisp note: here are some comparisons of special forms in
     GNU Emacs Lisp and Common Lisp.  `setq', `if', and `catch' are
     special forms in both Emacs Lisp and Common Lisp.  `defun' is a
     special form in Emacs Lisp, but a macro in Common Lisp.
     `save-excursion' is a special form in Emacs Lisp, but doesn't
     exist in Common Lisp.  `throw' is a special form in Common Lisp
     (because it must be able to throw multiple values), but it is a
     function in Emacs Lisp (which doesn't have multiple values).


File: lispref.info,  Node: Autoloading,  Prev: Special Forms,  Up: Forms

Autoloading
-----------

   The "autoload" feature allows you to call a function or macro whose
function definition has not yet been loaded into Emacs.  When an
autoload object appears as a symbol's function definition and that
symbol is used as a function, Emacs will automatically install the real
definition (plus other associated code) and then call that definition.
(*Note Autoload::.)


File: lispref.info,  Node: Quoting,  Prev: Forms,  Up: Evaluation

Quoting
=======

   The special form `quote' returns its single argument "unchanged".

 - Special Form: quote OBJECT
     This special form returns OBJECT, without evaluating it.  This
     allows symbols and lists, which would normally be evaluated, to be
     included literally in a program.  (It is not necessary to quote
     numbers, strings, and vectors since they are self-evaluating.)

     Because `quote' is used so often in programs, Lisp provides a
     convenient read syntax for it.  An apostrophe character (`'')
     followed by a Lisp object (in read syntax) expands to a list whose
     first element is `quote', and whose second element is the object.
     Thus, the read syntax `'x' is an abbreviation for `(quote x)'.

     Here are some examples of expressions that use `quote':

          (quote (+ 1 2))
               => (+ 1 2)
          (quote foo)
               => foo
          'foo
               => foo
          ''foo
               => (quote foo)
          '(quote foo)
               => (quote foo)
          ['foo]
               => [(quote foo)]

   Other quoting constructs include `function' (*note Anonymous
Functions::.), which causes an anonymous lambda expression written in
Lisp to be compiled, and ``' (*note Backquote::.), which is used to
quote only part of a list, while computing and substituting other parts.


File: lispref.info,  Node: Control Structures,  Next: Variables,  Prev: Evaluation,  Up: Top

Control Structures
******************

   A Lisp program consists of expressions or "forms" (*note Forms::.).
We control the order of execution of the forms by enclosing them in
"control structures".  Control structures are special forms which
control when, whether, or how many times to execute the forms they
contain.

   The simplest control structure is sequential execution: first form
A, then form B, and so on.  This is what happens when you write several
forms in succession in the body of a function, or at top level in a
file of Lisp code--the forms are executed in the order they are
written.  We call this "textual order".  For example, if a function
body consists of two forms A and B, evaluation of the function
evaluates first A and then B, and the function's value is the value of
B.

   Naturally, Emacs Lisp has many kinds of control structures, including
other varieties of sequencing, function calls, conditionals, iteration,
and (controlled) jumps.  The built-in control structures are special
forms since their subforms are not necessarily evaluated.  You can use
macros to define your own control structure constructs (*note
Macros::.).

* Menu:

* Sequencing::             Evaluation in textual order.
* Conditionals::           `if', `cond'.
* Combining Conditions::   `and', `or', `not'.
* Iteration::              `while' loops.
* Nonlocal Exits::         Jumping out of a sequence.

