Info file lispref, produced by Makeinfo, -*- Text -*- from input file
lispref.texinfo.

This file documents GNU Emacs Lisp.

This is Edition 0.2 Beta of the GNU Emacs Lisp Reference Manual,  
for Emacs Version 18, with some references to Emacs Version 19.

Please read this document for review purposes.

Published by the Free Software Foundation, 675 Massachusetts Avenue, 
Cambridge, MA 02139 USA

Copyright (C) 1989 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.



File: lispref,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

This Info file documents GNU Emacs Lisp.

* Menu:

* License::
* Introduction::	
* Types of Lisp Object::	
* Numbers::	
* Strings and Characters::	

* Lists::	
* Sequences Arrays Vectors::   
* Symbols::	
* Variables::	

* Functions::	
* Macros::	
* Control Structures::	
* Evaluation::	

* Loading::	
* Byte Compilation::	
* Debugging::	
* Streams::	

* Minibuffers::	
* Command Loop::	
* Keymaps::	
* Modes::	

* Documentation::	
* Files::	
* Backups and Auto Saving::	
* Buffers::	

* Windows::	
* Positions::	
* Markers::	
* Text::	

* Searching and Matching::	
* Syntax Tables::	
* Lisp Expressions::	
* Abbreviations::

* Processes::	
* System Interface::	
* Emacs Display::	

Appendices
* Tips and Standards::
* GNU Emacs Internals::	
* Standard Errors::	
* Standard Buffer Local Variables::	
* Standard Keymaps::	
* Standard Hooks::	

* Index::



File: lispref,  Node: License,  Next: Introduction,  Prev: Top,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                        Version 1, February 1989

     Copyright (C) 1989 Free Software Foundation, Inc.
     675 Mass Ave, Cambridge, MA 02139, USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

 Preamble
=========

  The license agreements of most software companies try to keep users
at the mercy of those companies.  By contrast, our General Public
License is intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users. 
The General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it. 
You can use it for your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if
you distribute copies of the software, or if you modify it.

  For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

  We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to
copy, distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on,
we want its recipients to know that what they have is not the
original, so that any problems introduced by others will not reflect
on the original authors' reputations.

  The precise terms and conditions for copying, distribution and
modification follow.

                          TERMS AND CONDITIONS

  1. This License Agreement applies to any program or other work
     which contains a notice placed by the copyright holder saying it
     may be distributed under the terms of this General Public
     License.  The ``Program'', below, refers to any such program or
     work, and a ``work based on the Program'' means either the
     Program or any work containing the Program or a portion of it,
     either verbatim or with modifications.  Each licensee is
     addressed as ``you''.

  2. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an
     appropriate copyright notice and disclaimer of warranty; keep
     intact all the notices that refer to this General Public License
     and to the absence of any warranty; and give any other
     recipients of the Program a copy of this General Public License
     along with the Program.  You may charge a fee for the physical
     act of transferring a copy.

  3. You may modify your copy or copies of the Program or any portion
     of it, and copy and distribute such modifications under the
     terms of Paragraph 1 above, provided that you also do the
     following:

        * cause the modified files to carry prominent notices stating
          that you changed the files and the date of any change; and

        * cause the whole of any work that you distribute or publish,
          that in whole or in part contains the Program or any part
          thereof, either with or without modifications, to be
          licensed at no charge to all third parties under the terms
          of this General Public License (except that you may choose
          to grant warranty protection to some or all third parties,
          at your option).

        * If the modified program normally reads commands
          interactively when run, you must cause it, when started
          running for such interactive use in the simplest and most
          usual way, to print or display an announcement including an
          appropriate copyright notice and a notice that there is no
          warranty (or else, saying that you provide a warranty) and
          that users may redistribute the program under these
          conditions, and telling the user how to view a copy of this
          General Public License.

        * You may charge a fee for the physical act of transferring a
          copy, and you may at your option offer warranty protection
          in exchange for a fee.

     Mere aggregation of another independent work with the Program
     (or its derivative) on a volume of a storage or distribution
     medium does not bring the other work under the scope of these
     terms.

  4. You may copy and distribute the Program (or a portion or
     derivative of it, under Paragraph 2) in object code or
     executable form under the terms of Paragraphs 1 and 2 above
     provided that you also do one of the following:

        * accompany it with the complete corresponding
          machine-readable source code, which must be distributed
          under the terms of Paragraphs 1 and 2 above; or,

        * accompany it with a written offer, valid for at least three
          years, to give any third party free (except for a nominal
          charge for the cost of distribution) a complete
          machine-readable copy of the corresponding source code, to
          be distributed under the terms of Paragraphs 1 and 2 above;
          or,

        * accompany it with the information you received as to where
          the corresponding source code may be obtained.  (This
          alternative is allowed only for noncommercial distribution
          and only if you received the program in object code or
          executable form alone.)

     Source code for a work means the preferred form of the work for
     making modifications to it.  For an executable file, complete
     source code means all the source code for all modules it
     contains; but, as a special exception, it need not include
     source code for modules which are standard libraries that
     accompany the operating system on which the executable file
     runs, or for standard header files or definitions files that
     accompany that operating system.

  5. You may not copy, modify, sublicense, distribute or transfer the
     Program except as expressly provided under this General Public
     License.  Any attempt otherwise to copy, modify, sublicense,
     distribute or transfer the Program is void, and will
     automatically terminate your rights to use the Program under
     this License.  However, parties who have received copies, or
     rights to use copies, from you under this General Public License
     will not have their licenses terminated so long as such parties
     remain in full compliance.

  6. By copying, distributing or modifying the Program (or any work
     based on the Program) you indicate your acceptance of this
     license to do so, and all its terms and conditions.

  7. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from
     the original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.

  8. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version,
     but may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of the license which applies
     to it and ``any later version'', you have the option of
     following the terms and conditions either of that version or of
     any later version published by the Free Software Foundation.  If
     the Program does not specify a version number of the license,
     you may choose any version ever published by the Free Software
     Foundation.

  9. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to
     the author to ask for permission.  For software which is
     copyrighted by the Free Software Foundation, write to the Free
     Software Foundation; we sometimes make exceptions for this.  Our
     decision will be guided by the two goals of preserving the free
     status of all derivatives of our free software and of promoting
     the sharing and reuse of software generally.

                                   NO WARRANTY

 10. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ``AS IS''
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
     ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS
     WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE
     COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 11. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS
     OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
     YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH
     ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS

Appendix: How to Apply These Terms to Your New Programs
=======================================================

  If you develop a new program, and you want it to be of the greatest
possible use to humanity, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the ``copyright'' line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR
     
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 1, or (at your option)
     any later version.
     
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

 Also add information on how to contact you by electronic and paper
mail.

If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

 The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and
`show c'; they could even be mouse-clicks or menu items--whatever
suits your program.

You should also get your employer (if you work as a programmer) or
your school, if any, to sign a ``copyright disclaimer'' for the
program, if necessary.  Here a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the
     program `Gnomovision' (a program to direct compilers to make passes
     at assemblers) written by James Hacker.
     
     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

That's all there is to it!



File: lispref,  Node: Introduction,  Next: Types of Lisp Object,  Prev: License,  Up: Top

Introduction
************

  The greater part of the GNU Emacs text editor is written in the
programming language called Emacs Lisp.  You can write new code in
Emacs Lisp and install it as an extension to the editor.  At the same
time, Emacs Lisp is more than a mere `extension language'; it is a
full computer programming language  in its own right.  You can use it
as you would any other programming language.

  Because Emacs Lisp is designed for use in an editor, it has special
features for handling different kinds of text--plain text, marked-up
manuscripts, source code, mail, and the like--as well as features for
handling files, buffers, displays, subprocesses, and so on.

  This manual describes Emacs Lisp.  Generally speaking, the first part
of the manual describes those features of Emacs Lisp that are common
to many programming languages, and the latter part describes those
features that are peculiar to Emacs Lisp.

* Menu:

* Caveats::             Flaws and a request for help.
* Lisp History::        Emacs Lisp is descended from MacLisp.
* Conventions::         How the manual is formatted.

 

File: lispref,  Node: Caveats,  Next: Lisp History,  Prev: Introduction,  Up: Introduction

Caveats
=======

  This manual has gone through numerous drafts.  It is nearly complete
but not flawless.  There are a few sections which are not included,
either because we consider them secondary (such as most of the
individual modes) or because they are yet to be written.

  Because we are not able to deal with them completely, we have left
out several parts intentionally.  This includes most references to
VMS and all the Suntool and X related items.

  The manual should, however, be fully correct in what it does say; and
it is therefore open to criticism on anything it does include--from
specific examples and descriptive text, to the ordering of chapters
and sections.  If something is confusing, or you find that you have
to look at the sources or experiment to learn something not covered
in the manual, then perhaps the manual should be fixed.  Please let
us know.

As you use this manual in Info, we ask that you send corrections as
soon as you find them.  If you think of a simple, real life example
for a function or group of functions, please make an effort to write
it up and send it in.  Please reference any comments to the node name
and function or variable name, as appropriate.

Mail comments and corrections to lisp-manual-bugs@prep.ai.mit.edu.

      --Bil Lewis       31-Oct-87 
      --Dan LaLiberte   01-Apr-89



File: lispref,  Node: Lisp History,  Next: Conventions,  Prev: Caveats,  Up: Introduction

Lisp History
============

  Lisp (LISt Processing Language) was first developed in the late 1950s
at the Massachusetts Institute of Technology for research in
artificial intelligence.  The great power of the Lisp language makes
it superior for other purposes as well, such as writing editor
commands.

  Dozens of Lisp implementations have been built over the years, each
with its own idiosyncrasies.  Many of them were inspired by MacLisp,
which was written in the 1960's at MIT's Project MAC.  Eventually the
implementors of the descendents of MacLisp came together and
developed a standard for Lisp systems, called Common Lisp.

  GNU Emacs Lisp is largely inspired by MacLisp, and a little by Common
Lisp.  If you know Common Lisp, you will notice many similarities. 
But many of the features of Common Lisp have been omitted or
simplified in order to reduce the memory requirements of GNU Emacs. 
Sometimes the simplifications are so drastic that a Common Lisp user
might be very confused.  We will occasionally point out how GNU Emacs
Lisp differs from Common Lisp.  If you don't know Common Lisp, don't
worry about it; this manual is self-contained.



File: lispref,  Node: Conventions,  Prev: Lisp History,  Up: Introduction

Conventions
===========

This section explains the notational conventions that are used in
this manual.  You may want to skip this section and refer back to it
later.

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* nil and t::                How the symbols `nil' and `t' are used.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use for examples that print output.
* Error Messages::           The format we use for examples of errors.
* Buffer Text Notation::     The format we use for buffer contents in examples.
* Format of Descriptions::   Notation for describing functions, variables, etc.

 

File: lispref,  Node: Some Terms,  Next: nil and t,  Prev: Conventions,  Up: Conventions

Some Terms
----------

  Throughout this manual, the phrases ``the Lisp reader'' and ``the
Lisp printer'' are used to refer to those routines in Lisp that
convert textual representations of Lisp objects into actual objects,
and vice versa.  *Note Printed Representation::, for more details. 
You, the person reading this manual, are assumed to be ``the
programmer'' and you may be referred to as ``you''.  ``The user'' is
the person who uses the code that you write.

  Examples of Lisp code appear in this font or form: `(list 1 2 3)'. 
Names that represent arguments appear in this font or form:
FIRST-NUMBER.



File: lispref,  Node: nil and t,  Next: Evaluation Notation,  Prev: Some Terms,  Up: Conventions

nil and t
---------

  In GNU Emacs Lisp, the symbol `nil' is overloaded with three
meanings: it is a symbol with the name `nil'; it is the logical truth
value "false"; and it is the empty list--the list of zero elements.

  As far as the Lisp reader is concerned, `()' and `nil' are identical.
The Lisp reader interprets them the same way.  The different ways of
writing them are intended entirely for the human reader.  After the
Lisp reader has read either `()' or `nil', there is no way to
determine which representation was actually written by the programmer.

  Throughout this manual, we use `()' when we wish to emphasize that it
means the empty list, and we use `nil' when we wish to emphasize that
it means the truth value false.

     (cons 'foo ())                ; Emphasize the empty list
     (not nil)                     ; Emphasize the truth value false

  The symbol `t' always has only one meaning, the value `t'.  It is the
preferred way to represent the truth value "true", although any
non-`nil' value is considered to be true as well.

  In Emacs Lisp, `nil' and `t' are special symbols that always evaluate
to themselves.  An attempt to change their values results in a
`setting-constant' error.



File: lispref,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: nil and t,  Up: Conventions

Evaluation Notation
-------------------

  When you evaluate a piece of Lisp code, it produces a result.  In the
examples in this manual, this will be indicated with `=>':

     (car '(1 2))
          => 1

You can read this as ```(car '(1 2))' evaluates to 1''.

  When a form is a macro call, it expands into a new form for Lisp to
evaluate.  We show the result of the expansion with `==>'.  We may or
may not show the actual result of the evaluation of the expanded form.

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

  In some instances, when we describe one form, we show another form
which produces identical results.  The exact equivalency of two forms
is indicated with `=='.

     (make-sparse-keymap) == (list 'keymap)



File: lispref,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

Printing Notation
-----------------

  Many of the examples in this manual print text when they are
evaluated.  If you execute the code from an example in a Lisp
Interaction buffer (such as the buffer `*scratch*'), the printed text
is inserted into the buffer.  If the example is executed by other
means (such as by evaluating the function `eval-region'), then the
text is printed in the echo area.  You should be aware that text
printed in the echo area will not all be visible if more than one
line is required.

  In examples that print text after the code is evaluated, the printed
text is indicated with `-|', irrespective of how the form is executed.

The value returned by evaluating the form will follow on the next
line (here `bar').

     (progn (print 'foo) (print 'bar))
          -| foo
          -| bar
          => bar



File: lispref,  Node: Error Messages,  Next: Buffer Text Notation,  Prev: Printing Notation,  Up: Conventions

Error Messages
--------------

  Some examples cause errors to be signaled.  In them, the error
message (which always appears in the echo area) is shown on a line
starting with `error-->'.  Note that `error-->' itself does not
appear in the echo area.

     (+ 23 'x)
     error--> Wrong type argument: integer-or-marker-p, x



File: lispref,  Node: Buffer Text Notation,  Next: Format of Descriptions,  Prev: Error Messages,  Up: Conventions

Buffer Text Notation
--------------------

  Some examples show modifications to text in a buffer, often with
`before' and `after' versions.  In such cases, the entire contents of
the buffer in question are included between two lines of dashes
containing the buffer name.  In addition, the location of point is
shown as `-!-'.  (The symbol for point, of course, is not in the
actual buffer; it indicates the place *between* two characters where
point is located.)

     --------- Buffer: foo ---------
     This is the -!-contents of foo.
     --------- Buffer: foo ---------
     
     (insert "changed ")
          => nil
     --------- Buffer: foo ---------
     This is the changed -!-contents of foo.
     --------- Buffer: foo ---------



File: lispref,  Node: Format of Descriptions,  Prev: Buffer Text Notation,  Up: Conventions

Format of Descriptions
----------------------

  Functions, variables, macros, commands, user options, and special
forms are all described in this manual in a uniform format.  The
first line of the description contains the name of the item followed
by its arguments, if appropriate.

The category--function, variable, or whatever--appears at the
beginning of the line.

The description follows on succeeding lines, sometimes with examples.

* Menu:

* A Sample Function Description::       
* A Sample Variable Description::



File: lispref,  Node: A Sample Function Description,  Next: A Sample Variable Description,  Prev: Format of Descriptions,  Up: Format of Descriptions

A Sample Function Description
.............................

   In a function description, the name of the function being described
appears first.  It is followed on the same line by a list of
parameters.  The names used for the parameters are also used in the
body of the description.

  The appearance of the keyword `&optional' in the parameter list
indicates that the arguments for the following parameters may be left
out (in which case the parameters default to `nil').  Do not write
`&optional' when you call the function.

  The keyword `&rest' (which will always be followed by a single
parameter) indicates that any number of arguments can follow the
required and optional ones.  The additional arguments will be made
into a list to which the last parameter will be bound.  Do not write
`&rest' when you call the function.

  Here is a description of the imaginary `foo' function:

 * Function: foo INTEGER1 &optional INTEGER2 &rest INTEGERS

       The function `foo' subtracts INTEGER1 from INTEGER2, then adds
     all the rest of the arguments to the result.  If INTEGER2 is not
     supplied, then the number 19 is used by default.

          (foo 1 5 3 9)
               => 16
          (foo 5)
               => 14

     More generally,

          (foo W X Y Z)
          ==
          (+ (- X W) Y Z)

  Any parameter whose name contains the name of a type (e.g., INTEGER,
INTEGER1 or BUFFER) is expected to be of that type.  A plural of a
type (such as BUFFERS) often means a list of objects of that type. 
Parameters named OBJECT may be of any type.  (*Note Types of Lisp
Object::, for a list of Emacs object types.) Parameters with other
sorts of names (e.g., NEW-FILE) are discussed specifically.  In some
sections, features common to a class of parameters are described at
the beginning.

  Command, macro, and special form descriptions have the same form, but
the word `Function' is replaced by `Command', `Macro', or `Special
Form', respectively.  Commands are simply functions that may be
called interactively.  Macros and special forms process their
arguments in a different way from functions, but otherwise appear the
same.

  Special form descriptions use a different notation to specify
optional and repeated parameters because the possibilities are quite
a bit more complex.  ``[OPTIONAL-ARG]'' means that OPTIONAL-ARG is
optional and `REPEATED-ARGS...' means that REPEATED-ARGS may be
repeated zero or more times.  *Note Lambda Expressions::, for an
example of the use of this notation and for a more complete
description of the optional and rest arguments.



File: lispref,  Node: A Sample Variable Description,  Prev: A Sample Function Description,  Up: Format of Descriptions

A Sample Variable Description
.............................

   A "variable" is a name which can hold a value.  Although any variable
can be set by the user, certain variables that exist specifically so
that users can change them are called "user options".  Ordinary
variables and user options are described using a format like that for
functions except that there are no arguments.

  Here is a description of the imaginary `electric-future-map' variable.

 * Variable: electric-future-map

       The value of this variable is a full keymap used by electric
     command future mode.  The functions in this map will allow you
     to edit commands you have not yet thought about executing.

  User option descriptions have the same form, but `Variable' is
replaced by `User Option'.



File: lispref,  Node: Types of Lisp Object,  Next: Numbers,  Prev: Introduction,  Up: Top

Lisp Data Types
***************

  A Lisp "object" is a piece of data used and manipulated by Lisp
programs.  For our purposes, a "type" or "data type" is a set of
possible objects.

  Every object belongs to at least one type.  Objects of the same type
have a similar structure and may usually be used in the same contexts.
Types can overlap, and objects may belong to two or more types. 
Consequently, we can ask whether an object belongs to a particular
type, but not for ``the'' type of an object.

  A small set of fundamental object types are built into Emacs.  These
are called "primitive types".  All other types are constructed from
these types.  The primitive types are "integer", "cons", "symbol",
"string", "vector", "subr" and several special types, such as
"buffer", that are related to editing.  (*Note Editing Types::.)

  While an object may be a member of more than one type, every object
is a member of exactly one primitive type.  The primitive type of an
object is stored along with the object's data.  A Lisp function is
provided for each primitive type to check whether an object is a
member of that type.

  Note that while many other languages employ type declarations to
specify an object's type, Lisp objects are ``self-typing''.  The
primitive type of the object is implicit in the object itself.  For
example, if an object is a vector, nothing will be able to treat it
as a number because Lisp knows it is a vector, not a number.

  There are special terms for dealing with classes of types.  A
"supertype" is a union of "subtypes".  For example, strings and
vectors are both considered arrays, so the string and vector types
are both subtypes of the array supertype.

  This chapter describes the purpose, print representation, and read
syntax of each of the standard types in GNU Emacs Lisp.  Details on
how to use these types can be found in later chapters.

* Menu:

* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.

 

File: lispref,  Node: Printed Representation,  Next: Comments,  Prev: Types of Lisp Object,  Up: Types of Lisp Object

Printed Representation and Read Syntax
======================================

  The "printed representation" of an object is the format of the output
generated by the Lisp printer (the function `print') for that object.
The "read syntax" of an object is the format of the input accepted by
the Lisp reader (the function `read') for that object.  Very often,
the print representation and the read syntax are the same.

  It is important to distinguish between the textual representation of
a object (that you, the human, reads) and the object which results
from calling `read' on that text.

  Note that reading an object does not cause evaluation.  Reading
returns a Lisp object, which may or may not be evaluated later. 
Evaluation is a separate process (*note Evaluation::.).  Generally,
when you evaluate an expression interactively, the Lisp interpreter
first reads the textual representation of it and then evaluates the
Lisp object returned.

  *Note Input Functions::, for a description of `read', which is the
most basic function for reading objects.

  Every type has a print representation.  Some types have no read
syntax, since it may not make sense to enter objects of these types
directly in a Lisp program.  Objects of these types are always
printed in "hash notation": the characters `#<' followed by a
descriptive string (typically the type name followed by the name of
the object), and closed with a matching `>'.  Hash notation cannot be
read correctly, so the Lisp reader signals the error
`invalid-read-syntax' whenever a `#' is encountered.  For example,
the buffer type does not have a read syntax.

     (current-buffer)
          => #<buffer objects.texinfo>



File: lispref,  Node: Comments,  Next: Programming Types,  Prev: Printed Representation,  Up: Types of Lisp Object

Comments
========

  The Lisp reader skips comments.  A "comment" starts with a semicolon
(`;') and continues to the end of line.

You are encouraged to format comments according to several useful
conventions:

`;'
     Comments that start with a single semicolon, `;', should be all
     aligned to the same column on the right, or to the right of such
     a column if that is not possible.  Such comments usually apply
     only to code written on the same line.  In Emacs, in the Lisp
     modes, the `M-;' (`indent-for-comment') command automatically
     inserts such a `;' in the right place, or aligns such a comment
     if it is already inserted.

     (The following examples are taken from the Emacs sources.)

          (setq base-version-list                 ; there was a base
                (assoc (substring fn 0 start-vn)  ; version to which
                       file-version-assoc-list))  ; this looks like
                                                  ; a subversion

`;;'
     Comments that start with two semicolons, `;;', should be aligned
     to the same level of indentation as the code.  Such comments are
     used to describe the section that follows or the state of the
     program at that point.  For example,

            (prog1 (setq auto-fill-hook
                         ...
                         ...
              ;; update mode-line
              (set-buffer-modified-p (buffer-modified-p))))

`;;;'
     Comments that start with three semicolons, `;;;', should be
     aligned to the left margin.  Such comments are not used within
     function definitions, but are used to make more general comments.
     For example,

          ;;; This Lisp code is run in Emacs when it is to operate as
          ;;; a server for other processes.

`;;;;'
     Comments that start with four semicolons, `;;;;', should be
     aligned to the left margin and are used to indicate section
     headings.  For example,

          ;;;; The kill ring

In the Lisp modes in Emacs, various indentation commands follow these
conventions, such as `M-;' (`indent-for-comment') and TAB
(`lisp-indent-line').  They automatically indent comments the right
way, according the the number of semicolons.

  Any character may be included in a comment, but it is advisable to
precede any unpaired special characters, such as `(' and `)', with a
`\' to hide their normal meaning from Lisp editing commands.



File: lispref,  Node: Programming Types,  Next: Editing Types,  Prev: Comments,  Up: Types of Lisp Object

Programming Types
=================

  Types in Emacs Lisp can be divided into two general categories: those
having to do with Lisp programming, and those having to do with
editing.  The former are provided in many Lisp implementations, in
one form or another.  The latter are unique to Emacs Lisp.

* Menu:

* Number Type::	        Primarily integers.
* Character Type::	The representation of letters, numbers and
                        control characters.
* Sequence Type::	A supertype of lists and arrays.
* List Type::	        What gave Lisp its name (not to mention reputation).
* Array Type::	        A supertype of strings and vectors.
* String Type::	        An (efficient) array of characters.
* Vector Type::	        One-dimensional arrays.
* Symbol Type::	        A multi-use object that refers to a function,
                        variable, property list, or itself.
* Lisp Function Type::	A piece of executable code you can call from elsewhere.
* Lisp Macro Type::	A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::	A function written in C, callable from Lisp.
* Autoload Type::	A type used for automatically loading seldom
                        used functions.

 

File: lispref,  Node: Number Type,  Next: Character Type,  Prev: Programming Types,  Up: Programming Types

Number Type
-----------

  Integers are the only kind of number in GNU Emacs Lisp, version 18. 
The range of values for integers is -8388608 to 8388607 (24 bits; i.e.,

-2**24

to

2**24 - 1

) on most machines, although it is 25 or 26 bits on some.  It is
important to note that the Emacs Lisp arithmetic functions do not
check for overflow.  Thus `(1+ 8388607)' is -8388608, on 24-bit
implementations.

Version 19 supports floating point numbers.

  The read syntax for numbers is a sequence of (base ten) digits with
an optional sign.  The print representation produced by the Lisp
interpreter never has a leading `+'.

     -1               ; The integer -1.
     1                ; The integer 1.
     +1               ; Also the integer 1.
     16777217         ; Also the integer 1! (on a 24-bit implementation)

  *Note Numbers::, for more information.



File: lispref,  Node: Character Type,  Next: Sequence Type,  Prev: Number Type,  Up: Programming Types

Character Type
--------------

  A "character" object in Emacs Lisp is nothing more than an integer. 
In other words, characters are represented internally with their
eight-bit ASCII values.  For example, the character `A' is
represented internally as the integer 65.  If an arbitrary integer is
used as a character, only the lower eight bits are significant.

  It is unusual for a programmer to work with individual characters. 
It is far more common to work with *strings*, which are sequences
composed of characters (*note String Type::.).

  Characters have a variety of read syntax formats, such as `?A' and
`?\101'.  They all start with a question mark.  Since the internal
representation of a character is an integer, the printed
representation of a character is always a decimal number.

  The usual read syntax for alphanumeric characters is a question mark
followed by the character; for example, `?A' for the character `A',
`?B' for the character `B', and `?a' for the character `a'.  For
example,

     ?Q
          => 81
     
     ?q
          => 113

  The characters backspace, tab, newline, vertical tab, formfeed,
return, and escape may be represented as `?\b', `?\t', `?\n', `?\v',
`?\f', `?\r', `?\e', respectively.  Those values are 8, 9, 10, 11,
12, 13, and 27 in decimal.  Thus,

     ?\b                             ; backspace, BS, `C-h'
          => 8
     ?\t                             ; tab, TAB, `C-i'
          => 9
     ?\n                             ; newline, LFD, `C-j'
          => 10
     ?\v                             ; vertical tab, `C-k'
          => 11
     ?\f                             ; formfeed character, `C-l'
          => 12
     ?\r                             ; carriage return, RET, `C-m'
          => 13
     ?\e                             ; escape character, ESC, `C-['
          => 27
     ?\\                             ; backslash character, `\'
          => 92

  Control characters in general may be represented using yet another
read syntax.  This consists of a question mark followed by a
backslash, hat, and the corresponding non-control character, in
either upper or lowercase.  For example, either `?\^I' or `?\^i' may
be used as the read syntax for the character `C-I', the character
with the print syntax of `9'.

  The `^' may be replaced by `C-'; for example, `?\^I' may be replaced
by `?\C-I' and `?\^i' may be replaced by `?\C-i'.  For example,

     ?\^I
          => 9
     ?\C-I
          => 9

  When you represent control characters in files or strings, use of the
`^' syntax is preferred; but when you refer to keyboard input, the
`C-' syntax is preferred.

  A "meta character" is a character that has its eighth bit set.  The
read syntax for these characters is question mark, backslash, `M-',
and the corresponding seven-bit character; for example, `?\M-A' for
`M-A', the character with the print representation 193.  The
seven-bit character can be written directly or specified by any of
the `\' escapes mentioned above or below.  Thus, `M-A' can be written
as `?\M-A', or as `?\M-\101', or as `?\301'.

  Likewise, the character whose decimal print representation is 130 can
use any one of the following for its read syntax: `?\202',
`?\M-\C-b', `?\C-\M-b', or `?\M-\002'.  For example,

     ?\C-\M-b                        ?\M-\C-b
          => 130               => 130
     ?\^\M-b                         ?\M-\002
          => 130               => 130

  Finally, the most general read syntax consists of a question mark
followed by a backslash and the ASCII value of the character in octal
(up to three octal digits); for example, `?\101' for the character
`A', `?\001' for the character `C-a', and `?\002' for the character
`C-b'.  Although this syntax can represent any character, it is
preferred when the precise octal value is more important than the
ASCII representation.  (These sequences which start with backslash
are also known as "escape sequences".  These sequences have nothing
to do with the character ESC.)

     ?\012
          => 10
     ?\n
          => 10
     ?\C-j
          => 10
     
     ?A
          => 65
     ?\101
          => 65
     
     ?\M-A
          => 193
     ?\M-\101
          => 193
     ?\301
          => 193

  Any character without a special escape meaning may be preceded by a
backslash.  Thus `?A' is equivalent to `?\A'.  But any of the
characters `()\|;'`"#.,' *must* be preceded by a backslash to work
reliably in all contexts.  The space character, tab, newline,
formfeed and literal control characters must also be preceded by a
backslash.  However, it is cleaner to use one of the easily readable
escape sequences, such as `\t', instead of an actual control
character such as a tab.



File: lispref,  Node: Sequence Type,  Next: List Type,  Prev: Character Type,  Up: Programming Types

Types of Sequences
------------------

  A "sequence" is a Lisp object which represents an ordered set of
elements.  There are two kinds of sequence in Emacs Lisp: lists and
arrays.  Thus, an object of type list or of type array is also
considered a sequence.

  Arrays are further subdivided into strings and vectors.  Each array
is either a string or a vector.  Vectors can hold elements of any
type, but string elements must be integers from 0 to 255.

  Lists, strings and vectors are quite different, but they have
important similarities.  For example, all have a length L, and all
have elements which can be indexed from zero to L minus one.

  Several functions, called sequence functions, accept any kind of
sequence with equal facility.  For example, the function `elt' can be
used to extract an element of a sequence, given its index.  *Note
Sequences Arrays Vectors::.

  Sequences are always created anew upon reading; in other words, it is
impossible to read the same sequence twice, in the sense of `eq'
(*note Equality Predicates::.).  There is one exception: the empty
list `()' is always read as the same object, `nil'.



File: lispref,  Node: List Type,  Next: Array Type,  Prev: Sequence Type,  Up: Programming Types

List Type
---------

  A "list" object is a series of cons cells, linked together.  A "cons
cell" is an object comprising two pointers named the "car" and the
"cdr".  Each of them can point to any Lisp object, but normally the
CDR points either to another cons cell or to the empty list.  *Note
Lists::, for functions that work on lists.

  The names CAR and CDR have only historical meaning now.  The original
Lisp implementation on an IBM 704 computer referred to an ``address
register'' and ``decrement register''.  Hence, CAR referred to the
contents of the address register, and CDR referred to the contents of
the decrement register.  By comparison, ``cons cells'' are named for
the function `cons' that creates them, which in turn is named for its
purpose, the construction of cells.

  Because cons cells are so central to Lisp, we also have a word for
``an object which is not a cons cell''.  These objects are called
"atoms".

  The read syntax and print representation for lists are identical, and
consist of a left parenthesis, an arbitrary number of elements, and a
right parenthesis.

   Upon reading, any object at all inside the parentheses is made into
an element of the list.  That is, a cons cell is made for each element.
Its CAR points to the element, and its CDR points to a cons cell, the
CAR of which points to the next element in the list.  The CDR of the
last cons cell is set to point to `nil'.

  A list can be illustrated using diagrams in which the cons cells are
shown as pairs of boxes.  (The Lisp reader cannot read such an
illustration; unlike the textual notation, which can be understood
both by you, a human, and by the computer, the box illustrations can
only be understood by you.)  The following represents the three
element list `(rose violet buttercup)':

         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

  In the diagram, each box represents a slot that can refer to any Lisp
object.  Each pair of boxes represents a cons cell.  Each arrow is a
reference to a Lisp object, either an atom or another cons cell.

  In this example, the first box, the CAR of the first cons cell,
refers to or ``contains'' `rose' (a symbol).  The second box, the CDR
of the first cons cell, is a reference to the next pair of boxes, the
second cons cell.  The CAR of the second cons cell refers to `violet'
and the CDR refers to the third cons cell.  The CDR of the third (and
last) cons cell refers to `nil'.

Here is another diagram of the exact same list, `(rose violet
buttercup)', sketched in a different manner:

      --------------         ---------------         ------------------
     |car    |cdr    |       |car     |cdr    |       |car        |cdr    |
     |       |   o--------->|        |   o--------->|           |  nil  |
     | rose  |       |       | violet |       |       | buttercup |       |
      --------------         ---------------         ------------------

  A list with no elements in it is the "empty list"; it is identical to
the symbol `nil'.  In other words, `nil' is both a symbol and a list.

     (A 2 "A")            ; A list of three elements.
     ()                   ; A list of no elements (the empty list).
     nil                  ; A list of no elements (the empty list).
     ("A ()")             ; A list of one element: the string `"A ()"'.
     (A ())               ; A list of two elements: A and the empty list.
     (A nil)              ; Equivalent to the previous.
     ((A B C))            ; A list of one element
                          ; (which is a list of three elements).

   Here is the list `(A ())', or equivalently `(A nil)', depicted with
boxes and arrows:

         ___ ___      ___ ___
        |___|___|--> |___|___|--> nil
          |            |
          |            |
           --> A        --> nil

* Menu:

* Dotted Pair Notation::	An alternative syntax for lists.
* Association List Type::	A specially constructed list.

 

File: lispref,  Node: Dotted Pair Notation,  Next: Association List Type,  Prev: List Type,  Up: List Type

Dotted Pair Notation
....................

   "Dotted pair notation" is an alternative syntax for lists.  It
explicitly represents lists as cons cells.  In this syntax, `(A . B)'
is the cons cell whose CAR is the object A, and whose CDR is the
object B.  Dotted pair notation is therefore more general than the
syntax given before.  In the dotted pair notation, the list `(1 2 3)'
is written as `(1 .  (2 . (3 .  nil)))'; the two notations are
equivalent; but the former is usually more convenient.  When printing
a list, the dotted pair notation is only used if the CDR of a cell is
not a list.

  `Box notation' can also be used to illustrate what dotted pairs look
like.

  For example, `(rose . violet)' is diagrammed as follows:

         ________ ________
        |________|________|
          |          |
          |          |
           --> rose   --> violet

The three element list `(rose violet . buttercup)' looks like this:

         ___ ___      ________ _________
        |___|___|--> |________|_________|
          |            |           |
          |            |           |
           --> rose     --> violet  --> buttercup

  These diagrams make it evident that `(rose . violet . buttercup)'
must have an invalid syntax since it would require that a cons cell
have three parts rather than two.

  The list `(rose violet)' is equivalent to `(rose . (violet))' and
looks like this:

         ___ ___      ___ ___
        |___|___|--> |___|___|--> nil
          |            |
          |            |
           --> rose     --> violet

  Similarly, the three-element list `(rose violet buttercup)' is
equivalent to `(rose . (violet . (buttercup)))' and looks like this:

         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

This last list is perhaps best illustrated by a different style of
diagram, one that emphasizes the notion that the cons cells `contain'
the information to which they refer:

          --------------------------------------------
         |car   |cdr                                   |
         |      |                                      |
         |      |   -------------------------------   |
         |      |  |car     |cdr                    |  |
         | rose |  |        |                       |  |
         |      |  | violet |   ----------------   |  |
         |      |  |        |  |car        |cdr  |  |  |
         |      |  |        |  |           |     |  |  |
         |      |  |        |  | buttercup | nil |  |  |
         |      |  |        |  |           |     |  |  |
         |      |  |        |   ----------------   |  |
         |      |  |        |                       |  |
         |      |   -------------------------------   |
         |      |                                      |
          --------------------------------------------
     
     (rose violet buttercup) == (rose . (violet . (buttercup)))



File: lispref,  Node: Association List Type,  Prev: Dotted Pair Notation,  Up: List Type

Association List Type
.....................

   An "association list" or "alist" is a specially constructed list of
cons cells.  In each cons cell, the CAR is treated as a "key", and
the CDR is treated as an associated "value".  Association lists are
often used to record information that one might otherwise keep on a
stack, since new pairs may be simply added to the front of the list.

  Elements of an alist may be written using either dotted pair notation
or regular notation, but in any single application, you must use one
notation consistently.  In Emacs, dotted pair notation is most often
used for alists.

  For example,

     (setq alist-of-colors '((rose . red) (lily . white)  (buttercup . yellow)))

sets the variable `alist-of-colors' to an alist of three elements. 
In the first element, `rose' is the key and `red' is the value.

  *Note Association Lists::, for a further explanation of alists and
for functions that work on alists.



File: lispref,  Node: Array Type,  Next: String Type,  Prev: List Type,  Up: Programming Types

Array Type
----------

  An "array" object is composed of an arbitrary number of other Lisp
objects.  Any element of an array may be accessed in constant time. 
In contrast, an element of a list requires access time that is
proportional to the position of the element in the list.  Elements at
the end of a list take longer to access than elements at the
beginning of a list.

  Emacs defines two types of array, both of which are one-dimensional:
a string and a vector.  A string is an array of characters and a
vector is an array of arbitrary objects.  (In other programming
languages, the term ``array'' has a more general meaning than it does
in Emacs Lisp.) Each type of array has its own read syntax (*note
String Type::., and *note Vector Type::.).

   * Arrays may have any length, up to the size of the largest
     integer; but once created, an array has a fixed size.

   * Arrays are indexed such that the first element of an array has
     an index of zero, the second element as an index of 1, and so
     on.  This is called "zero-origin" indexing.  For example, an
     array of four elements is indexed by 0, 1, 2, and 3.

   * The elements of any array may be referenced or changed with the
     functions `aref' and `aset', respectively (*note Arrays::.).

  The array type is a subtype of sequences and a supertype of strings
and vectors.



File: lispref,  Node: String Type,  Next: Vector Type,  Prev: Array Type,  Up: Programming Types

String Type
-----------

  A "string" is an array of characters.  Strings are used for many
purposes, as can be expected in a text editor.  Examples of strings
include the names of Lisp symbols, messages for the user, and
substrings extracted from buffers.

  The read syntax for strings is a double-quote, an arbitrary number of
characters, and another double quote, `"like this"'.  The Lisp reader
will accept the same formats for reading the characters of a string
as it does for reading single characters (without the question mark
that begins a character literal).  This means that you enter a
double-quote in a string by preceding it with a backslash, and you
enter a character `A', `C-a', or a `M-C-A' the same way: `"like this:
\", \A, \C-a, \M-\C-a"'.  (*Note Character Type::, for a description
of the read syntax for characters.)

  Unlike the C programming language, newlines are allowed in Emacs Lisp
string literals.  But an escaped newline--one that is preceded by
`\'--does not become part of the string; i.e., the Lisp reader
ignores an escaped newline in a string literal.

     "It is useful to include newlines in
     documentation strings, but the newline is \
     ignored if escaped."
          => "It is useful to include newlines in
     documentation strings, but the newline is ignored if escaped."

  The print representation of strings is a double-quote, the characters
in it, and another double-quote with the exception that any backslash
or double-quote characters in the string are printed with a leading
backslash `"like this \" embedded quote"'.

  *Note Strings and Characters::, for functions that work with strings.



File: lispref,  Node: Vector Type,  Next: Symbol Type,  Prev: String Type,  Up: Programming Types

Vector Type
-----------

  A "vector" object is a one-dimensional array of elements each of
which can be of any type.  It takes a constant amount of time to
access any element of a vector.  On the other hand, in a list, the
access time of an element is proportional to the distance of the
element from the beginning of the list.

  The print representation and read syntax of vectors are the same: a
left square bracket, elements, and a right square bracket.  Like
numbers and strings, vectors return themselves when evaluated.

     [1 "two" (three)]      ; A vector of three elements.
          => [1 "two" (three)]

  *Note Vectors::, for functions that work with vectors.



File: lispref,  Node: Symbol Type,  Next: Lisp Function Type,  Prev: Vector Type,  Up: Programming Types

Symbol Type
-----------

  A "symbol" in GNU Emacs Lisp is an object that serves several
purposes.  A symbol may be used in programs to refer to a global
variable value, a function, a property list, or the symbol itself. 
In a given context, usually only one of these uses is intended.

  To support these uses, symbols have four attributes or "cells":

   * a print name cell

   * a function cell

   * a value cell

   * a property list cell.

  You may imagine a symbol as being a chest of four drawers.  The
function definition is put in one drawer, the value in another, and
so on.  Each drawer, or cell, is a reference to some other Lisp object.
You can change the contents of one drawer without changing any of the
others.  Thus, the drawer holding the value is independent of the
drawer holding the function definition, and vice-versa.  Note that
the print name is *not* the symbol; it is a string, which lives in
one of the four drawers of the symbol.

  In any symbol, either the function cell or the value cell or both of
them may be empty or "void".  (The term "void" is used to indicate
that a cell has no valid data in it, as in the error message,
`Symbol's value as variable is void'.  This should not be confused
with the symbol whose name is `void'.  Note also that the data in a
cell may be `nil', which is not void either.)

  The four functions, `symbol-name', `symbol-value', `symbol-plist',
and `symbol-function', return the contents of the four cells.

  An example is the symbol `buffer-file-name', which has the print name
`buffer-file-name' and data in the value, function, and property list
cells.

     (symbol-name 'buffer-file-name)
          => "buffer-file-name"
     (symbol-value 'buffer-file-name)
          => "/gnu/elisp/objects.texinfo"
     (symbol-plist 'buffer-file-name)
          => (variable-documentation 29529)
     (symbol-function 'buffer-file-name)
          => #<subr buffer-file-name>

The value cell of the symbol contains the name of this file.  The
property list cell contains the list `(variable-documentation 29529)'
which tells the Emacs help and documentation functions where to find
documentation about `buffer-file-name' in the `DOC' file.  (29529 is
the offset from the beginning of the `DOC' file where the
documentation for the function begins.)  The function cell contains
the code for returning the name of the file.  Since
`buffer-file-name' is a primitive function, its code has no read
syntax and prints in hash notation.  (*Note Primitive Function
Type::.  A function definition written in Lisp will have the Lisp (or
the byte-code) in this cell.)

The Print Name Cell
...................

   The "print name" is the most obvious characteristic of a symbol, and
is described in this section.  The other cells of symbols are
described in greater detail in *Note Symbols::.

  You often use the print name of a symbol to refer to it; the print
name is what the printer prints when handed a symbol.  The print name
is what distinguishes one symbol from another when the Lisp reader
reads them.  The print name cell is always a string object.

  You use a symbol in a program by typing its print name (without the
double-quotes that delimit strings).  The rules for reading the print
name of a symbol are similar to those for reading a string.  Any of
the characters `A-Z', `a-z', `0-9', and `-+*/_~!@$%^&=:<>{}' are read
as part of a symbol's name.  Other characters may be included in a
symbol's name by escaping them with a backslash.  In contrast to its
use in strings, however, a backslash in the print name of a symbol
does no more than quote the single character that follows the
backslash, without conversion.  For example, in a string, `\t'
represents a TAB; in the print name of a symbol, however, `\t' merely
quotes the letter `t'.  To have a symbol with a tab character in its
name, you must actually type an (escaped) tab.  But you would hardly
ever do such a thing.

     Common Lisp Note: In Common Lisp, lower case letters are always
     ``folded'' to upper case, unless they are explicitly escaped. 
     This is a marked contrast to Emacs Lisp, in which uppercase and
     lowercase letters are distinct.

  Here are several examples of symbol names.  Note that the `+' in the
last example is read as a symbol name instead of a number, because it
is not followed only by digits.

     foo                 ; A symbol named `foo'.
     FOO                 ; A symbol named `FOO', different from `foo'.
     char-to-string      ; A symbol named `char-to-string'.
     1+                  ; A symbol named `1+'
                         ;     (not `+1', which is an integer).
     \+1                 ; A symbol named `+1' (not a very readable name).
     \(*\ 1\ 2\)         ; A symbol named `(* 1 2)' (a worse name).
     +-*/_~!@$%^&=:<>{}  ; A symbol named `+-*/_~!@$%^&=:<>{}'.
                         ;     These characters need not be escaped.

 

File: lispref,  Node: Lisp Function Type,  Next: Lisp Macro Type,  Prev: Symbol Type,  Up: Programming Types

Lisp Function Type
------------------

  Just as functions in other programming languages are executable, a
"Lisp function" object is a piece of executable code.  However, Lisp
functions may also be considered data, unlike the functions in many
other languages; this is because a Lisp function object is a list
whose first element is the symbol `lambda' (*note Lambda
Expressions::.); or, in some cases, a Lisp function object is a
"subr" written in the C programming language (*note Primitive
Function Type::.).

  A "named function" is a symbol with something in its function cell. 
You define a named function with the special form `defun'.  For
example,

     (defun foo (n)
       (print n))
          => foo
     
     (symbol-function 'foo)
          => (lambda (n) (print n))    ; An interpreted function.

   An "anonymous Lisp function", on the other hand, may be created by
building a list that begins with `lambda'.

  Each of the following forms returns a value of 3.  The `funcall'
function calls its first argument, passing the remaining arguments to
it.  In the first example, the function that `funcall' calls is `+'. 
In the second example, the function object is the list starting with
`lambda'.  (In the second example, the list starting with `lambda'
accomplishes exactly the same as `+' does in the first example;
however, you may write the anonymous function as complicatedly as you
like.)  In the third example, the anonymous function is quoted with
`function' instead of with `quote' (for which `'' is the short form).

     (funcall '+ 1 2)
          => 3
     
     (funcall '(lambda (arg1 arg2) (+ arg1 arg2)) 1 2)
          => 3
     
     (funcall (function (lambda (arg1 arg2) (+ arg1 arg2))) 1 2)
          => 3

  These examples show anonymous functions which appear as constants in
the program.  It is also possible to construct anonymous functions
during execution.  They are, after all, just lists.

  Incidentally, if you know ahead of time that a constant list is going
to be used only as an anonymous function, it is best to quote it with
the special form `function' rather than with `quote'.  This is
because the `function' special form tells the byte compiler to
compile the list, replacing it with a compiled function.  The
`function' special form is equivalent to `quote' for interpreted
code.  *Note Anonymous Functions::.

  *Note Functions::, for explanations of `lambda', `defun', and
functions that work with functions.



File: lispref,  Node: Lisp Macro Type,  Next: Primitive Function Type,  Prev: Lisp Function Type,  Up: Programming Types

Lisp Macro Type
---------------

  A "Lisp macro" object is a piece of executable code, like a function,
but with different parameter-passing semantics.  A Lisp macro is a
list whose first element is the symbol `macro' and the remainder is
the same as a Lisp function object, including the `lambda' symbol.

  Lisp macro objects are usually defined with the built-in function
`defmacro'.  Any list that begins with `macro', however, is a macro
as far as Emacs is concerned.  *Note Macros::, for an explanation of
how to write a macro.



File: lispref,  Node: Primitive Function Type,  Next: Autoload Type,  Prev: Lisp Macro Type,  Up: Programming Types

Primitive Function Type
-----------------------

  A "primitive function" is a function callable from Lisp but written
in the C programming language.  Primitive functions are also called
"subrs" or "built-in functions".  (The word ``subr'' is derived from
``subroutine''.)  Most primitive functions evaluate all their
arguments when they are called.  A primitive function that does not
evaluate all its arguments is called a "special form" (*note Special
Forms::.).

  To the caller of a function, it does not matter if the function is
primitive.  However, it does matter if you are trying to substitute a
function written in Lisp for a primitive of the same name.  The
reason is that the primitive function may be called directly from C
code.  So long as the redefined function is called from Lisp, the new
definition will be used; but a call from C code may still use the old
definition.

  The term "function" is used to refer to all Emacs functions, whether
written in Lisp or C.  *Note Lisp Function Type::, for information
about the functions written in Lisp.

  Primitive functions have no read syntax and print in hash notation
with the name of the subroutine.

     (symbol-function 'car)          ; Access the function cell of the symbol.
          => #<subr car>
     (subrp (symbol-function 'car))  ; Is this a subroutine?
          => t                     ; Yes.

 

File: lispref,  Node: Autoload Type,  Prev: Primitive Function Type,  Up: Programming Types

Autoload Type
-------------

  An "autoload" object is a list whose first element is the symbol
`autoload'.  An autoload object is usually created with the function
`autoload', which stores the object in the function cell of a symbol.
An autoload object references a file to load when the symbol is used
as a function.  After the file has been loaded, the symbol should
have a new function cell that is not an autoload object.  The
contents of this cell are evaluated as if they had been there
originally.  This means that from the point of view of a user, the
function call works as expected, using the function definition in the
loaded file.

  *Note Autoload::, for a longer explanation.



File: lispref,  Node: Editing Types,  Next: Type Predicates,  Prev: Programming Types,  Up: Types of Lisp Object

Editing Types
=============

  The types in the previous section are common to many Lisp-like
languages.  But Emacs Lisp is more than an ordinary Lisp: many
additional data types and functions are provided for dealing with
editing in addition to Lisp programming per se.

* Menu:

* Buffer Type::         The basic object of editing.
* Window Type::         What makes buffers visible.
* Window Configuration Type::   Save what the screen looks like.
* Marker Type::         A position in a buffer.
* Process Type::        A process running on the underlying OS.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Syntax Table Type::   What a character means.

 

File: lispref,  Node: Buffer Type,  Next: Window Type,  Prev: Editing Types,  Up: Editing Types

Buffer Type
-----------

  A "buffer" object contains an indefinite number of characters.  A
buffer is most commonly used to hold the contents of a disk file
(*note Files::.).  Most buffers are also meant to be seen by the
user, and therefore displayed, at some time, in a window (*note
Windows::.).  But a buffer need not have an associated file or window.

  Buffers can be thought of as simple strings, albeit often very long,
but they are, in fact, more complex.  For example, text can be
inserted into a buffer very quickly, while ``inserting'' text into a
string is accomplished with concatenation and the result is an
entirely new string object.

  Each buffer has a designated position within the buffer, called
"point" (*note Positions::.).  Although many buffers may exist
simultaneously, only one buffer is the "current buffer".  Most
editing commands act on the contents of the current buffer in the
neighborhood of its point.  Many other functions manipulate or test
the characters in a buffer and, indeed, quite a bit of this manual is
devoted to describing such functions.

  Several other data structures are associated with buffers:

   * a local syntax table (*note Syntax Tables::.);

   * a local keymap (*note Keymaps::.); and,

   * a local variable binding list (*note Variables::.).

Each of these overrides its global counterpart.  By paying attention
to the "buffer-local" object instead of its global counterpart,
editing commands are able to provide a different behavior in each
buffer.

  Buffers have no read syntax.  They print in hash notation with the
buffer name.

     (current-buffer)
          => #<buffer objects.texinfo>

  *Note Buffers::, for details about buffer objects and buffer-related
functions and variables.



File: lispref,  Node: Window Type,  Next: Window Configuration Type,  Prev: Buffer Type,  Up: Editing Types

Window Type
-----------

  A "window" object describes the portion of the terminal screen that
Emacs uses to display a buffer.  Every window has an associated
buffer, but a buffer might not be displayed in any window.  On the
other hand, a buffer may be displayed in more than one window.

  While many windows may exist simultaneously, only one window is the
"selected window".  This is the window where the cursor is (usually)
displayed when command input is requested.  The selected window
usually displays the current buffer, but this is not necessarily the
case.  In particular, when Emacs (rather than a human) works on a
buffer, that buffer is the current buffer, but it does not have to be
visible to the user.  The `set-buffer' function is used to transfer
Emacs's attention without changing the displayed buffer.  (*Note
Changing Buffers::.)

  Windows have no read syntax.  They print in hash notation, giving the
window number and buffer name.  (The window numbers are only to help
humans debug using the windows' printed representation.)

     (selected-window)
          => #<window 1 on objects.texinfo>

  *Note Windows::, for a description of the functions that work on
windows.



File: lispref,  Node: Window Configuration Type,  Next: Marker Type,  Prev: Window Type,  Up: Editing Types

Window Configuration Type
-------------------------

  A "window configuration" object stores information about the
positions and sizes of windows at the time the window configuration
is created, so that the screen layout may be recreated later.

  Window configurations have no read syntax.  They print as
`#<window-configuration>'.  *Note Window Configurations::, for a
description of several functions related to window configurations.



File: lispref,  Node: Marker Type,  Next: Process Type,  Prev: Window Configuration Type,  Up: Editing Types

Marker Type
-----------

  A "marker" object denotes a position in a specific buffer.  Markers
therefore have two cells: one for the buffer, and one for the
position.  The position value is changed automatically as necessary,
as text is inserted into or deleted from the buffer.  This is to
ensure that the marker always points between the same two characters
in the buffer (unless the insertion or deletion is at the marker
position).

  Markers have no read syntax.  They print in hash notation, giving the
current character position and the name of the buffer.

     (point-marker)
          => #<marker at 10779 in objects.texinfo>

*Note Markers::, for information on how to test, create, copy, and
move markers.



File: lispref,  Node: Process Type,  Next: Stream Type,  Prev: Marker Type,  Up: Editing Types

Process Type
------------

  A "process" object references a subprocess that runs independently of
the Emacs process.  External subprocesses, such a shells, GDB,
telnet, and compilers, may be used to extend the processing
capability of Emacs far beyond the limitations of Emacs Lisp.

A process takes input from Emacs and the output is returned to Emacs
for further manipulation.  Both text and signals can be communicated
between Emacs and a subprocess.

  Processes have no read syntax.  They print in hash notation, giving
the name of the process.

     (process-list)
          => (#<process shell>)

*Note Processes::, for information about functions that create,
delete, return information about, send input or signals to, and
receive output from processes.



File: lispref,  Node: Stream Type,  Next: Keymap Type,  Prev: Process Type,  Up: Editing Types

Stream Type
-----------

  A "stream" object is used as a source or sink for characters.  A
stream is a Lisp object that can either supply characters or accept
them as output.  Many different objects can be used this way:
markers, buffers, strings, and functions.  Most often, input streams
(character sources) obtain characters from the keyboard, a buffer, or
a file; and output streams (character sinks) send characters to a
buffer, such as a `*Help*' buffer, or to the echo area.

  The object `nil', in addition to its other meanings, stands for the
stream referenced by the variables `standard-input' and
`standard-output'.  Also, the object `t' stands for input or output
in the minibuffer (*note Minibuffers::.).

  Streams have no special print or read syntax, and print as whatever
object they are.

  *Note Streams::, for a description of various functions related to
streams, including various parsing and printing functions.



File: lispref,  Node: Keymap Type,  Next: Syntax Table Type,  Prev: Stream Type,  Up: Editing Types

Keymap Type
-----------

  A "keymap" object maps keys typed by the user to functions.  Emacs
defines two kinds of keymaps: "full keymaps", which are vectors of
128 elements, and "sparse keymaps", which are association lists with
a preceding `keymap' symbol.

  *Note Keymaps::, for information about creating keymaps, handling
prefix keys, local as well as global keymaps, and changing key
bindings.



File: lispref,  Node: Syntax Table Type,  Prev: Keymap Type,  Up: Editing Types

Syntax Table Type
-----------------

  A "syntax table" object is a vector of 256 integers.  Each element of
the vector defines how the corresponding character is interpreted
when it appears in a buffer.  For example, in C mode (*note Major
Modes::.), the `+' character is punctuation, but in Lisp mode it is a
valid character in a symbol.  These different interpretations are
effected by changing the syntax table entry for `+', i.e., for
position 43.

  Syntax tables are only used for scanning text in buffers, not for
reading Lisp expressions.  The table which the Lisp interpreter uses
to read expressions is built into the Emacs source code and cannot be
changed.  For example, you cannot change the list delimiters to be
`{' and `}' instead of `(' and `)'.

  *Note Syntax Tables::, for details about syntax classes and how to
make and modify syntax tables.



File: lispref,  Node: Type Predicates,  Next: Equality Predicates,  Prev: Editing Types,  Up: Types of Lisp Object

Type Predicates
===============

  The Emacs Lisp interpreter itself does not perform type checking on
the actual arguments passed to functions when they are called.  It
could not do otherwise, since objects in Lisp are not declared to be
of a certain type, as they are in other programming languages.  It is
therefore up to each individual function to test whether each actual
argument belongs to a type that that produces a desired result when
passed to the function.

All built-in functions do check the types of their actual arguments
when appropriate and signal a `wrong-type-argument' error if an
argument is of the wrong type.

For example,

     (+ 2 'a)
          => Wrong type argument: integer-or-marker-p, a

  Many functions, called "type predicates", are provided to test
whether an object is a member of a given type.  (Following a
convention of long standing, the print names of most Emacs Lisp
predicates end in `p'.)

Here is a table pre-defined type predicates, in alphabetical order,
and where they are described further.

`atom'
     *note atom: List-related Predicates.

`arrayp'
     *note arrayp: Arrays.

`bufferp'
     *note bufferp: Buffers.

`char-or-string-p'
     *note char-or-string-p: Predicates for Strings.

`consp'
     *note consp: List-related Predicates.

`integer-or-marker-p'
     *note integer-or-marker-p: Predicates on Markers.

`integerp'
     *note integerp: Predicates on Numbers.

`keymapp'
     *note keymapp: Creating Keymaps.

`listp'
     *note listp: List-related Predicates.

`markerp'
     *note markerp: Predicates on Markers.

`natnump'
     *note natnump: Predicates on Numbers.

`nlistp'
     *note nlistp: List-related Predicates.

`processp'
     *note processp: Processes.

`sequencep'
     *note sequencep: Sequence Functions.

`stringp'
     *note stringp: Predicates for Strings.

`subrp'
     *note subrp: Function Cells.

`symbolp'
     *note symbolp: Symbols.

`syntax-table-p'
     *note syntax-table-p: Syntax Tables.

`user-variable-p'
     *note user-variable-p: Global Variables.

`vectorp'
     *note vectorp: Vectors.

`windowp'
     *note windowp: Basic Windows.



File: lispref,  Node: Equality Predicates,  Prev: Type Predicates,  Up: Types of Lisp Object

Equality Predicates
===================

  Here we describe two functions that test for equality between any two
objects.  Other functions test equality between objects of specific
types, e.g., strings.  See the appropriate chapter for these
predicates.

 * Function: eq OBJECT1 OBJECT2

       This function returns `t' if OBJECT1 and OBJECT2 are the same
     object, `nil' otherwise.  The ``same object'' means, in this
     case, that a change in one will be reflected by the same change
     in the other.

       `eq' will be true if OBJECT1 and OBJECT2 are numbers with the
     same value, or symbols with the same print name.  Other objects
     (e.g., lists, vectors, strings) with the same elements may or
     may not be `eq' to each other.

       (The `make-symbol' function returns an uninterned symbol that is
     not interned in the standard `obarray'; such symbols should not
     be tested against interned symbols until they are interned. 
     *Note Creating Symbols::.)

          (eq 'foo 'foo)
               => t
          
          (eq 456 456)
               => t
          
          (eq "asdf" "asdf")
               => nil
          
          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil
          
          (eq [(1 2) 3] [(1 2) 3])
               => nil
          
          (eq (point-marker) (point-marker))
               => nil

 * Function: equal OBJECT1 OBJECT2

       This function returns `t' if OBJECT1 and OBJECT2 have equal
     components, `nil' otherwise.  Whereas `eq' tests if two objects
     are the same, `equal' looks inside the objects, if necessary, to
     see if their elements are the same.  So, if two objects are
     `eq', they are `equal', but the converse is not always true.

          (equal 'foo 'foo)
               => t
          
          (equal 456 456)
               => t
          
          (equal "asdf" "asdf")
               => t
          
          (equal '(1 (2 (3))) '(1 (2 (3))))
               => t
          
          (equal [(1 2) 3] [(1 2) 3])
               => t
          
          (equal (point-marker) (point-marker))
               => t

     Comparison of strings is case-sensitive.

          (equal "asdf" "ASDF")
               => nil

The test for equality is implemented recursively, and circular lists
may therefore cause infinite recursion (leading to an error).



File: lispref,  Node: Numbers,  Next: Strings and Characters,  Prev: Types of Lisp Object,  Up: Top

Numbers
*******

  Integers  are the only kind of number in version 18 Emacs Lisp. 
These are whole numbers such as -3, 0, 7, 13, and 511.

  In version 19, there is a compile time option to support floating
point numbers, which are represented internally as the C type `double'.
A floating point number is a number with a fractional part, such as
-4.5, 0.0, or 2.71828.  A floating point number can be expressed in
an exponetial notation as well: thus, 1.5e2 equals 150; in this
example, `e2' stands for ten to the second power, and is multiplied
by 1.5.

* Menu:

* Number Basics::	      Representation and range of numbers.
* Predicates on Numbers::     Testing for numbers.
* Comparison of Numbers::     Equality and inequality predicates.
* Arithmetic Operations::     How to add, subtract, multiply and divide.
* Bitwise Operations::        Logical and, or, not, shifting.
* Random Numbers::            Obtaining random integers, predictable or not.

 

File: lispref,  Node: Number Basics,  Next: Predicates on Numbers,  Prev: Numbers,  Up: Numbers

Number Basics
=============

  The range of values for an integer depends on the machine.  The range
is -8388608 to 8388607 (24 bits; i.e.,

-2**24

to

2**24 - 1

) on most machines, but on others it is -16777216 to 16777215 (25
bits), or -33554432 to 33554431 (26 bits).  All of the examples shown
below assume an integer has 24 bits.

  The Lisp reader reads numbers as a sequence of digits with an
optional sign.

     1                ; The integer 1.
     +1               ; Also the integer 1.
     -1               ; The integer -1.
     16777217         ; Also the integer 1, due to overflow.
     0                ; The number 0.
     -0               ; The number 0.
     1.               ; Invalid syntax.

   To understand how various functions work on integers, especially the
bitwise operators (*note Bitwise Operations::.), it is often helpful
to view the numbers in their binary form.

  In 24 bit binary, the decimal integer 5 looks like this:

     0000 0000  0000 0000  0000 0101

(In the example, a space is put every 4 bits, and two spaces every 8
bits, to make the binary integer easier to read.)

  The negative integer -1 looks like this:

     1111 1111  1111 1111  1111 1111

-1 is represented as 24 ones.  (In jargon, this is called `"two's
complement" notation.)

  The negative integer, -5, is creating by subtracting 4 from -1.  In
binary, the decimal integer 4 is 100.  Consequently, -5 looks like
this:

     1111 1111  1111 1111  1111 1011

  In this implementation, the largest 24 bit binary integer is the
decimal integer 8,388,607.  In binary, this number looks like this:

     0111 1111  1111 1111  1111 1111

This binary number consists of all 1's, except for the left-most
digit, which is zero.

  As we said before, the arithmetic functions do not check whether
integers go outside their range; hence, when you add 1 to 8,388,607,
the negative integer -8,388,608 is returned:

     (+ 1 8388607)
          => -8388608
          => 1000 0000  0000 0000  0000 0000

  Many of the following functions accept markers for arguments as well
as integers.  (*Note Markers::.)  More accurately, the actual
parameters to such functions may be integers or markers; and
MARKER-OR-INT specifies the formal parameter.  When the actual
parameter is a marker, the position value of the marker is used and
the buffer of the marker is ignored.

  In version 19, except where *integer* is specified as an argument,
all of the functions for markers and integers also work for floating
point numbers.



File: lispref,  Node: Predicates on Numbers,  Next: Comparison of Numbers,  Prev: Number Basics,  Up: Numbers

Type Predicates for Numbers
===========================

  The `integerp' and `floatp' predicates test whether the argument is
an integer or floating point number, respectively.  Note that these
functions and the `natnump' predicate can take any type of Lisp
object as argument (the predicates would not be of much use
otherwise); but the `zerop' predicate requires an integer as its
argument.

 * Function: floatp OBJECT

     This predicate tests to see whether its argument is a floating
     point number and returns `t' if so, `nil' otherwise.

     `floatp' is part of version 19 Emacs, not version 18.

 * Function: integerp OBJECT

     This predicate tests to see whether its argument is an integer
     (a whole number) and returns `t' if so, `nil' otherwise.

 * Function: natnump OBJECT

     The `natnump' predicate (whose name comes from the phrase
     ``natural-number-p'') tests to see whether its argument is a
     nonnegative (i.e., natural) integer, and returns `t' if so,
     `nil' otherwise.  0 is considered non-negative.

     Markers are not converted to integers, hence `natnump' of a
     marker is always `nil'.

 * Function: zerop INTEGER

     This predicate tests to see whether its argument is zero, and
     returns `t' if so, `nil' otherwise.  These two forms are
     equivalent: `(zerop x) == (= x 0)'.



File: lispref,  Node: Comparison of Numbers,  Next: Arithmetic Operations,  Prev: Predicates on Numbers,  Up: Numbers

Comparison of Numbers
=====================

  The integer type is implemented by storing the value in the ``pointer
part'' of a Lisp object pointer (which, in the canonical case, has 24
bits of pointer, 7 bits of type and 1 bit for the garbage collector).
Because of this, the function `eq' will return `t' for two integers
with the same value.  *Note Equality Predicates::.

     Common Lisp Note: Because of the way numbers are implemented in
     Common Lisp, you generally need to use ``='' to test for
     equality between numbers.  However, GNU Emacs Lisp does not need
     very large integers; as a consequence, it is possible to
     restrict them to the size of a single word, allowing `eq' to be
     used.

 * Function: = MARKER-OR-INT1 MARKER-OR-INT2

     This function tests to see whether its arguments are the same
     number, and returns `t' if so, `nil' otherwise.

 * Function: /= MARKER-OR-INT1 MARKER-OR-INT2

     This function tests to see whether its arguments are not the
     same number, and returns `t' if so, `nil' otherwise.

 * Function: < MARKER-OR-INT1 MARKER-OR-INT2

     This function tests to see whether its first argument is
     strictly less than its second argument.  It returns `t' if so,
     `nil' otherwise.

 * Function: <= MARKER-OR-INT1 MARKER-OR-INT2

     This function tests to see whether its first argument is less
     than or equal to its second argument.  It returns `t' if so,
     `nil' otherwise.

 * Function: > MARKER-OR-INT1 MARKER-OR-INT2

     This function tests to see whether its first argument is
     strictly greater than its second argument.  It returns `t' if
     so, `nil' otherwise.

 * Function: >= MARKER-OR-INT1 MARKER-OR-INT2

     This function tests to see whether its first argument is greater
     than or equal to its second argument.  It returns `t' if so,
     `nil' otherwise.

 * Function: max MARKER-OR-INT &rest MARKER-OR-INTS

     This function returns the largest of its arguments.

          (max 20)
               => 20
          (max 1 2)
               => 2
          (max 1 3 2)
               => 3

 * Function: min MARKER-OR-INT &rest MARKER-OR-INTS

     This function returns the smallest of its arguments.



File: lispref,  Node: Arithmetic Operations,  Next: Bitwise Operations,  Prev: Comparison of Numbers,  Up: Numbers

Arithmetic Operations
=====================

  Emacs Lisp provides the traditional four arithmetic operations:
addition, subtraction, multiplication, and division.  A remainder
function supplements the (integer) division function.  In addition,
as a convenience, incrementing and decrementing functions are provided.

  It is important to note that in GNU Emacs Lisp, arithmetic functions
do not check for overflow.  Thus (1+ 8388607) may equal -8388608,
depending on your hardware.

 * Function: 1+ MARKER-OR-INT

     This function adds one to MARKER-OR-INT.

 * Function: 1- MARKER-OR-INT

     This function subtracts one from MARKER-OR-INT.

 * Function: + &rest INTEGERS

     This function adds its arguments together.  When given no
     arguments, `+' returns 0.  It does not check for overflow.

          (+)
               => 0
          (+ 1)
               => 1
          (+ 1 2 3 4)
               => 10

 * Function: - &optional INTEGER &rest OTHER-INTEGERS

     The `-' function serves two purposes: negation and subtraction.

     When `-' has a single argument, the value is the negative of the
     argument.

     When there are multiple arguments, each of the OTHER-INTEGERS is
     subtracted from INTEGER, cumulatively.  If there are no
     arguments, the result is `0'.

          (- 10 1 2 3 4)
               => 0
          (- 10)
               => -10
          (-)
               => 0

 * Function: * &rest INTEGERS

     This function multiplies its arguments together, and returns the
     product.  When given no arguments, `*' returns `1'.  It does not
     check for overflow.

          (*)
               => 1
          (* 1)
               => 1
          (* 1 2 3 4)
               => 24

 * Function: / DIVIDEND DIVISOR &rest OTHER-INTEGERS

     This function divides DIVIDEND by DIVISOR, and returns the
     quotient.  If there are more arguments, then they are each used
     to divide the previous result.  The result is always rounded
     down after each division.

     If you divide a numerator by `0', an `arith-error' results. 
     (*Note Errors::.)

          (/ 6 2)
               => 3
          (/ 5 2)
               => 2
          (/ 25 3 2)
               => 4
          (/ -17 6)
               => -2          ; (Could be -3 on some machines.)

 * Function: % DIVIDEND DIVISOR

     This function returns the value of DIVIDEND modulo DIVISOR, or
     in other words, the integer remainder after division of DIVIDEND
     by DIVISOR.  The sign of the result is the sign of DIVIDEND. 
     The sign of DIVISOR is ignored.

     An `arith-error' results if DIVISOR = `0'.

          (% 9 4)
               => 1
          (% -9 4)
               => -1
          (% 9 -4)
               => 1
          (% -9 -4)
               => -1



File: lispref,  Node: Bitwise Operations,  Next: Random Numbers,  Prev: Arithmetic Operations,  Up: Numbers

Bitwise Operations on Integers
==============================

  In a computer, an integer is a binary number, a pattern of zeros and
ones.  A bitwise operation transforms such a pattern.  For example, a
shift moves the whole pattern left or right one or more places,
reproducing the same pattern `moved over'.

  The following bitwise operations apply only to integers.

 * Function: lsh INTEGER1 INTEGER2

     `lsh', which is an abbreviation for "logical shift", shifts the
     bits in INTEGER1 to the left INTEGER2 places, or to the right if
     INTEGER2 is negative.  If both arguments are negative, `lsh'
     shifts in zeros.  See `ash' below.

     Thus, the decimal number 5 is the binary number `00000101'. 
     Shifted once to the left, with a zero put in the one's place,
     the number becomes `00001010', decimal 10.

     Here are two examples of shifting the pattern of bits one place
     to the left.  Since the contents of the right-most place has
     been moved one place to the left, a value has to be inserted
     into the right-most place.  With `lsh', a zero is placed into
     the right-most place.  (In these examples, the binary pattern is
     only eight bits long.  See `ash' for examples illustrating the
     full twenty-four bits of an Emacs Lisp integer.)

          (lsh 5 1)
               => 10
          
          00000101 => 00001010     ; Decimal 5 becomes decimal 10.
          
          (lsh 7 1)
               => 14
          
          00000111 => 00001110     ; Decimal 7 becomes decimal 14.

      As the examples illustrate, shifting the pattern of bits one
     place to the left produces a number that is twice the value of
     the previous number.

     Note, however that functions do not check for overflow, and a
     returned value may be negative (and in any case, no more than a
     24 bit value) when an integer is sufficiently left shifted.  For
     example:

          (lsh 8388607 1)         ; left shift
               => -2

     In binary, in the 24 bit implementation,

          0111 1111  1111 1111  1111 1111         ; decimal 8,388,607
          
          becomes
          
          1111 1111  1111 1111  1111 1110         ; decimal -2

     Shifting the pattern of bits two places to the left produces
     results like this (with 8-bit binary numbers):

          (lsh 3 2)
               => 12
          
          00000011 => 00001100       ; Decimal 3 becomes decimal 12.

      On the other hand, shifting the pattern of bits one place to the
     right looks like this:

          (lsh 6 -1)
               => 3
          
          00000110 => 00000011       ; Decimal 6 becomes decimal 3.
          
          (lsh 5 -1)
               => 2
          
          00000101 => 00000010       ; Decimal 5 becomes decimal 2.

      As the example illustrates, shifting the pattern of bits one
     place to the right divides the value of the binary number by
     two, rounding downward.

 * Function: ash INTEGER1 INTEGER2

     `ash' ("arithmetic shift") shifts the bits in INTEGER1 to the
     left INTEGER2 places, or to the right if INTEGER2 is negative.

     `ash' gives the same results as `lsh' except when INTEGER1 and
     INTEGER2 are both negative.  In that case, `ash' puts a one in
     the left-most position, while `lsh' puts a zero in the left-most
     position.

     Thus, with `ash', shifting the pattern of bits one place to the
     right looks like this:

          (ash -6 -1)
               => -3                    ; Decimal -6 becomes decimal -3.
          
          1111 1111  1111 1111  1111 1010
               => 
          1111 1111  1111 1111  1111 1101

     In contrast, shifting the pattern of bits one place to the right
     with `lsh' looks like this:

          (lsh -6 -1)
               => 8388605        ; Decimal -6 becomes decimal 8,388,605.
          
          1111 1111  1111 1111  1111 1010
               => 
          0111 1111  1111 1111  1111 1101

     In this case, the 1 in the left-most position is shifted one
     place to the right, and a zero is shifted into the left-most
     position.

     Here are other examples:

                                 ;              24-bit binary values
          
          (lsh 5 2)              ;  5  =  0000 0000  0000 0000  0000 0101
               => 20               ; 20  =  0000 0000  0000 0000  0001 0100
          (ash 5 2)
               => 20
          (lsh -5 2)             ; -5  =  1111 1111  1111 1111  1111 1011
               => -20              ; -20  =  1111 1111  1111 1111  1110 1100
          (ash -5 2)
               => -20
          
          (lsh 5 -2)             ;  5  =  0000 0000  0000 0000  0000 0101
               => 1                ;  1  =  0000 0000  0000 0000  0000 0001
          (ash 5 -2)
               => 1
          (lsh -5 -2     )       ; -5  =  1111 1111  1111 1111  1111 1011
               => 4194302          ;    0011 1111  1111 1111  1111 1110
          (ash -5 -2)            ; -5  =  1111 1111  1111 1111  1111 1011
               => -2               ; -2  =  1111 1111  1111 1111  1111 1110

 * Function: logand &rest MARKER-OR-INTS

     This function returns the ``logical and'' of the arguments: the
     N'th bit is set in the result if, and only if, the N'th bit is
     set in all the arguments.  ``Set'' means that the value of the
     bit is 1 rather than 0.

     For example, using 4-bit binary numbers, the ``logical and'' of
     13 and 12 is 12:

          1101
          1100
               => 1100

     In both the binary numbers, the two left-most bits are set
     (i.e., they are 1's), so the two left-most bits of the returned
     value are set.  But both of the two right-most bits are not set,
     so the two right-most bits of the returned value are 0's.

     Restating that example in decimal numbers,

          (logand 13 12)
               => 12

     If `logand' is not passed any argument, it returns a value of
     `-1', the number which consists entirely of ones.

     For `logand', `logior', and `logxor', if there is only one
     argument, that argument is the result.

                                 ;                24-bit binary values
          
          (logand 14 13)         ; 14  =  0000 0000  0000 0000  0000 1110
                                 ; 13  =  0000 0000  0000 0000  0000 1101
               => 12            ; 12  =  0000 0000  0000 0000  0000 1100
          
          (logand 14 13 4)       ; 14  =  0000 0000  0000 0000  0000 1110
                                 ; 13  =  0000 0000  0000 0000  0000 1101
               => 4             ;  4  =  0000 0000  0000 0000  0000 0100
          
          (logand)
          -1                     ; -1  =  1111 1111  1111 1111  1111 1111

 * Function: logior &rest MARKER-OR-INTS

     This function returns the ``inclusive or'' of it arguments: the
     n'th bit is set in the result if, and only if, the n'th bit is
     set in at least one of the arguments.  If there are no
     arguments, the result is `0'.

                                 ;               24-bit binary values
          
          (logior 12 5)          ; 12  =  0000 0000  0000 0000  0000 1100
                                 ;  5  =  0000 0000  0000 0000  0000 0101
               => 13            ; 13  =  0000 0000  0000 0000  0000 1101
          
          (logior 12 5 7)        ; 12  =  0000 0000  0000 0000  0000 1100
                                 ;  5  =  0000 0000  0000 0000  0000 0101
                                 ;  7  =  0000 0000  0000 0000  0000 0111
               => 15            ; 15  =  0000 0000  0000 0000  0000 1111

 * Function: logxor &rest MARKER-OR-INTS

     This function returns the ``exclusive or'' of its arguments: the
     N'th bit is set in the result if, and only if, the N'th bit is
     set in an odd number of the arguments.  If there are no
     arguments, the result is 0.

                                 ;               24-bit binary values
          
          (logxor 12 5)          ; 12  =  0000 0000  0000 0000  0000 1100
                                 ;  5  =  0000 0000  0000 0000  0000 0101
               => 9             ;  9  =  0000 0000  0000 0000  0000 1001
          
          (logxor 12 5 7)        ; 12  =  0000 0000  0000 0000  0000 1100
                                 ;  5  =  0000 0000  0000 0000  0000 0101
                                 ;  7  =  0000 0000  0000 0000  0000 0111
               => 14            ; 14  =  0000 0000  0000 0000  0000 1110

 * Function: lognot INTEGER

     This function returns the logical complement of its argument:
     the N'th bit is one in the result if, and only if, the N'th bit
     is zero in INTEGER, and vice-versa.

          (lognot 5)             ;  5  =  0000 0000  0000 0000  0000 0101
               => -6            ; -6  =  1111 1111  1111 1111  1111 1010



File: lispref,  Node: Random Numbers,  Prev: Bitwise Operations,  Up: Numbers

Random Numbers
==============

 * Function: random &optional FLAG

     This function returns a pseudo-random number of type integer. 
     When called more than once, this function returns a series of
     pseudo-random numbers.

     In a computer, such a series of a pseudo-random numbers is
     generated in a deterministic fashion.  As its name indicates, a
     pseudo-random number is not a random number.  However, a
     pseudo-random series of numbers has properties that mimic a
     truly random series in many ways.  For example, in a
     pseudo-random series, no number is supposed to appear more
     frequently that it would in a truly random series.

     A series of pseudo-random numbers is generated from a `seed'
     number that is derived from some changing value such as the time
     of day.  If the `random' function starts with the same seed, it
     generates the same sequence of numbers.

     On some machines, any integer representable in Lisp may be the
     result of `random'.  On other machines, the result can never be
     larger than a certain maximum or less than a certain (negative)
     minimum.

     When a pseudo-random series of numbers is generated, any of the
     possible values has the same probability of being returned as
     any other possible value.

     If you want random numbers that are different each time you run
     Emacs, use `(random t)' in your code at least once.  This
     reinitializes the pseudo-random number seed based on the current
     time of day and on Emacs' process ID number.

     Put another way, the sequence of numbers returned by `random' is
     the same in each Emacs run, unless you use `(random t)'.  For
     example, in one operating system, the first call to `(random)'
     after you start Emacs always returns `-1457731', and the second
     one always returns `-7692030'.  Therefore, programs that use
     `random' are repeatable, unless you evaluate `(random t)'.  This
     is helpful when you are debugging.



File: lispref,  Node: Strings and Characters,  Next: Lists,  Prev: Numbers,  Up: Top

Strings and Characters
**********************

  Strings are used to send messages to users, to hold extracts from
buffers, and for many other purposes.  The print names of symbols are
strings.  Because strings are so important, a large number of
functions are provided expressly for manipulating them.  In Emacs
Lisp, programmers often use strings, but they seldom use characters,
except when defining keymaps.

  The length of a string (like any array) is fixed, and cannot be
altered.  In particular, strings in Lisp are *not* terminated by any
particular character, such as ASCII code 0, as they are in C.  This
means that any character, including the null character (ASCII code
0), is a valid element of a string.

  Since strings are considered arrays, you can operate on them with the
general array functions.  (*Note Sequences Arrays Vectors::.)  For
example, you can access or change individual characters in a string
by using the `aref' and `aset' functions (*note Arrays::.).

  On the other hand, although strings are considered arrays, they
require only 8 bits for each element rather than a minimum of 32. 
This means that a string takes up much less memory than a vector of
the same length.

  *Note Text::, for information about functions that display strings or
copy them into buffers.

  *Note Character Type::, and *Note String Type::, for information
about the syntax of characters and strings.

* Menu:

* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting characters or strings and vice versa.
* Formatting Strings::        `format': Emacs's analog of `printf'.
* Character Case::            Case conversion functions.

 

File: lispref,  Node: Predicates for Strings,  Next: Creating Strings,  Prev: Strings and Characters,  Up: Strings and Characters

The Predicates for Strings
==========================

For more information about general sequence and array predicates, see
*Note Sequences Arrays Vectors::, and *Note Arrays::.

 * Function: stringp OBJECT

       This function returns `t' if the object is a string, `nil'
     otherwise.

 * Function: char-or-string-p OBJECT

       This function returns `t' if the object is a string or a
     character (i.e., an integer), `nil' otherwise.



File: lispref,  Node: Creating Strings,  Next: Text Comparison,  Prev: Predicates for Strings,  Up: Strings and Characters

Creating Strings
================

  The following functions return a string.  For example, in
`emacs/lisp/undigest.el', the `make-string' function is used to
generate a string of similar characters to use in searching for the
separator line in a mail digest.  In the `dired-uncompress' function
`emacs/lisp/dired.el', the `substring' function is used to extract a
filename without its `.Z' extension, whereas in `dired-compress', the
`concat' function is used to append `.Z' to a filename.

 * Function: make-string COUNT CHARACTER

       This function returns a string made up of COUNT repetitions of
     CHARACTER.  If COUNT is negative, an error is signaled.

          (make-string 5 ?x)
               => "xxxxx"
          (make-string 0 ?x)
               =>      ""

       Compare this function to `char-to-string', `make-vector', and
     `make-list'.  (See *Note String Conversion::, *Note Vectors::,
     and *Note Building Lists::.)

 * Function: substring STRING START &optional END

       This function returns a new string which consists of those
     characters from STRING in the range from (and including) the
     character at the index START up to (but excluding) the character
     at the index END.  The first character is numbered zero.

          (substring "abcdefg"  0 3)
               => "abc"

     In the example, the index for `a' is 0, the index for `b' is 1,
     and the index for `c' is 2.  Thus, three letters, `abc', are
     copied from the full string.  The index `3' marks the character
     position up to which the substring is copied.  The character
     whose index is three is actually the fourth character in the
     string.

       Note that the index location is just before the character that
     the cursor appears on top of; it may be just before the first
     character.  This location is exactly analogous to the location
     of point in a buffer, except that the position of the first
     character in a buffer is 1, but the index of the first character
     in a string is 0.  (*Note Positions::.)

       A negative number counts from the end of the string, so that -1
     is the index of the last character of the string.

          (substring "abcdefg" -3 -1)
               => "ef"

     In this example, the index for `e' = -3, the index for `f' = -2,
     and the index for `g' = -1.  More precisely, the starting index,
     -3, falls between the letters `d' and `e'; and the ending index,
     -1, falls between the letters `f' and `g'.  That is why only the
     two characters between the two index positions are copied, `e'
     and `f'.

     When `nil' is used as an index, it falls after the last
     character in the string.  Thus:

          (substring "abcdefg" -3  nil)
               => "efg"

     Omitting the argument END is equivalent to specifying `nil'.

     It follows that `(substring STRING 0)' returns a copy of all of
     STRING.

          (substring "abcdefg" 0)
               => "abcdefg"

     (But don't use `substring' to copy a whole string; use
     `copy-sequence' instead.)

       A `wrong-type-argument' error results if either START or END are
     non-integers.  An `args-out-of-range' error results if START
     indicates a character following END, or if either integer is out
     of range for the string.

 * Function: concat &rest SEQUENCES

       This function returns a new string consisting of the characters
     in the one or more arguments passed to it.  The arguments are
     not changed.  The arguments may be strings, lists of numbers, or
     vectors of numbers.  If no arguments are passed to `concat', the
     function returns an empty string.

          (concat "abc" "-def")
               => "abc-def"
          (concat "abc" -123 (list 120 (+ 256 121)) [122])
               => "abc-123xyz"
          (concat "The " "quick brown " "fox.")
               => "The quick brown fox."
          (concat)
               => ""

       The `concat' functions always constructs a new string which is
     not `eq' to any existing string.

       As a feature, in the special case where an argument is an
     integer (not a sequence of integers), it is converted to a
     string of digits making up the decimal print representation of
     the integer.

          (concat 137)
               => "137"
          (concat 54 321)
               => "54321"

       For information about other concatenation functions, see
     `mapconcat' in *Note Mapping Functions::, `vconcat' in *Note
     Vectors::, and `append' in *Note Building Lists::.



File: lispref,  Node: Text Comparison,  Next: String Conversion,  Prev: Creating Strings,  Up: Strings and Characters

Comparison of Characters and Strings
====================================

 * Function: char-equal CHARACTER1 CHARACTER2

       This function returns `t' if the arguments represent the same
     character, `nil' otherwise.  This is done by comparing two
     integers modulo 256.

          (char-equal ?x ?x)
               => t
          (char-to-string (+ 256 ?x))
               => "x"
          (char-equal ?x  (+ 256 ?x))
               => t

 * Function: string= STRING1 STRING2

       This function returns `t' if the characters of the two strings
     match exactly.  Case is significant.  `string-equal' is the same
     as `string='.

          (string= "abc" "abc")
               => t
          (string= "abc" "ABC")
               => nil
          (string= "ab" "ABC")
               => nil

 * Function: string-equal STRING1 STRING2

       `string-equal' is another name for `string='.

 * Function: string< STRING1 STRING2

       This function compares two strings and finds the first pair of
     characters, if any, in the two strings that do not match.  If
     the numeric value of the ASCII code of the character from the
     first string is less than the numeric value of the ASCII code of
     the character from the second string, then this function returns
     `t'.  If the strings match, the value is `nil'.

       Lower case letters have higher numeric values in the ASCII
     character set than their upper case counterparts; numbers and
     many punctuation characters have a lower numeric value than
     upper case letters.

          (string< "abc" "abd")
               => t
          (string< "abd" "abc")
               => nil
          (string< "123" "abc")
               => t

       When the strings have different lengths, and they match up to
     the length of STRING1, then the result is `t'.  If they match up
     to the length of STRING2, the result is `nil'.  A string without
     any characters in it is the smallest possible string.

          (string< "" "abc")
               => t
          (string< "ab" "abc")
               => t
          (string< "abc" "")
               => nil
          (string< "abc" "ab")
               => nil
          (string< "" "")
               => nil

 * Function: string-lessp STRING1 STRING2

     `string-lessp' is another name for `string<'.



File: lispref,  Node: String Conversion,  Next: Formatting Strings,  Prev: Text Comparison,  Up: Strings and Characters

Conversion of Characters and Strings
====================================

  Characters and strings may be converted into each other and into
integers.  `format' and `prin1-to-string' (*note Output Functions::.)
may also be used to convert Lisp objects into strings. 
`read-from-string' (*note Input Functions::.) may be used to
``convert'' a string representation of a Lisp object into an object. 
Also `concat', `append', and `vconcat' perform conversion of an
integer to decimal representation as a special feature.

  *Note Documentation::, for a description of the functions
`single-key-description' and `text-char-description', which return a
string representing the Emacs standard notation of the argument
character.  These functions are used primarily for printing help
messages.

 * Function: char-to-string CHARACTER

       This function returns a new string with a length of one character.
     The value of CHARACTER, modulo 256, is used to initialize the
     element of the string.

     This function is similar to `make-string' with an integer
     argument of 1.  (*Note Creating Strings::.)

          (char-to-string ?x)
               => "x"
          (char-to-string (+ 256 ?x))
               => "x"
          (make-string 1 ?x)
               => "x"

 * Function: string-to-char STRING

       This function returns the decimal numeric value of the first
     character in the string.  Expressed another way, this function
     returns the first character of the string in the print syntax
     for characters.  (*Note Character Type::.)

     If the string is empty, the function returns 0, which is
     identical to the result if the string begins with the null
     character, ASCII code 0.

          (string-to-char "ABC")
               => 65
          (string-to-char "xyz")
               => 120
          (string-to-char "")
               => 0
          (string-to-char "\000")
               => 0

 * Function: int-to-string INTEGER

       This function returns a string consisting of the digits of
     INTEGER, base ten.  When passed a positive integer as an
     argument, this function returns an unsigned string.  When passed
     a negative integer, the function returns a string with a leading
     minus sign.

          (int-to-string 256)
               => "256"
          (int-to-string -23)
               => "-23"

 * Function: string-to-int STRING

       This function returns the integer value of the characters in
     STRING, read as a number in base ten.

       The string is read starting from (and including) the first
     character, and it is read until a non-digit is encountered.  If
     the first character is not a digit, this function returns 0.

          (string-to-int "256")
               => 256
          (string-to-int "25 is a perfect square.")
               => 25
          (string-to-int "X256")
               => 0



File: lispref,  Node: Formatting Strings,  Next: Character Case,  Prev: String Conversion,  Up: Strings and Characters

Formatting Strings
==================

The `message' and `error' functions use conversion specification
sequences that are identical to those described here for `format'.

 * Function: format STRING &rest OBJECTS

       This function returns a new string that is made up from the
     characters in STRING with any conversion specification sequences
     in it replaced by encodings of the corresponding OBJECTS.

       A conversion specification sequence is a string of characters
     beginning with a `%'.  For example, if there is a `%s' in 
     STRING, the `format' function does not print the `%s' as such,
     but substitutes one of the other arguments there.  It evaluates
     that argument and inserts its print representation in place of
     the `%s'.

          (format "The value of fill-column is %d." fill-column)
               => "The value of fill-column is 72."

       If STRING contains more than one conversion specification, the
     conversion specifications are matched in order with successive
     arguments.  Thus, the first conversion specification in STRING
     is matched with the first argument that follows STRING; the
     second conversion specification is matched with the second
     argument that follows STRING; and so on.

     Any extra conversion specifications (those for which there are
     no matching arguments) will have unpredictable behavior.  Any
     extra objects will be ignored.

     Although conversion specifications are supposed to specify the
     types of object with which they are matched, no error is
     reported if there is a mismatch between the type specified by
     the conversion specification and the type of its corresponding
     object.

       The character `%' begins a conversion specification.  The
     characters following it indicate how the object should be
     represented.  The characters recognized are described below:

    `s'
          Replace the specification with the print representation of
          the object.  If there is no corresponding object, the empty
          string is used.

    `o'
          Replace the specification with the base eight
          representation of an integer.

    `d'
          Replace the specification with the base ten representation
          of an integer.

    `x'
          Replace the specification with the base sixteen
          representation of an integer.

    `c'
          Replace the specification with the print representation of
          a character.

    `%'
          A single `%' is placed in the string.

       Any other conversion character results in an `Invalid format
     operation' error.

       Here are several examples:

          (format "The name of this buffer is %s." (buffer-name))
               => "The name of this buffer is strings.texinfo."
          
          (format "The buffer object prints as %s." (current-buffer))
               => "The buffer object prints as #<buffer strings.texinfo>."
          
          (format "The octal value of 18 is %o, and the hex value is %x."
                  18 18)
               => "The octal value of 18 is 22, and the hex value is 12."

       All the specification characters allow an optional numeric
     prefix between the `%' and the character.  The optional numeric
     prefix defines the minimum width for the object.  If the print
     representation of the object contains fewer characters than
     this, then it is padded.  The padding character is normally a
     space, but if the numeric prefix starts with a zero, zeros are
     used for padding.

       The padding is on the left if the prefix is positive (or starts
     with zero) and on the right if the prefix is negative.

          (format "%06d will be padded on the left with zeros" 123)
               => "000123 will be padded on the left with zeros"
          (format "%-6d will be padded on the right" 123)
               => "123    will be padded on the right"

       No matter what the prefix, nothing in the print representation
     will be truncated.  This allows the programmer to specify
     spacing exactly without knowing how many characters there are in
     the object's print representation.

       In the three following examples, `%7s' specifies a minimum width
     of 7.  In the first case, the word inserted in place of `%7s'
     has only 3 letters, so 4 blank spaces are inserted for padding. 
     In the second case, the word "specification" is 13 letters wide
     but is not truncated.  In the third case, the padding is on the
     right.  (This does not work in version 18, but does work in
     version 19.)

          (format "The word `%7s' actually has %d letters in it." "foo" 
                  (length "foo"))
               => "The word `    foo' actually has 3 letters in it."  
          
          (format "The word `%7s' actually has %d letters in it."
                  "specification" 
                  (length "specification")) 
               => "The word `specification' actually has 13 letters in it."  
          
          (format "The word `%-7s' actually has %d letters in it." "foo" 
                  (length "foo"))
               => "The word `foo    ' actually has 3 letters in it."  
          ;; %-7s fails to work in version 18, but does work in version 19.
          ;; In version 18, padding is not inserted.

 

File: lispref,  Node: Character Case,  Prev: Formatting Strings,  Up: Strings and Characters

Character Case
==============

  The character case functions change the case both of single
characters and characters within strings.  The functions only convert
alphabetic characters (the letters `A' through `Z' and `a' through
`z'); other characters are not converted.  The functions do not
modify the strings which are passed to them as arguments.

  The examples below use the characters `X' and `x' which have ASCII
values 88 and 120 respectively.

 * Function: downcase STRING-OR-CHAR

       This function converts a character or a string to lower case.

       When the argument to `downcase' is a string, the function
     creates and returns a new string in which each letter in the
     argument that is upper case is converted to lower case.

       When the argument to `downcase' is a character, `downcase'
     returns the corresponding lower-case character.  This value is
     an integer.  If the original character is lower-case, or is not
     a letter, then the value equals the original character.

          (downcase "The cat in the hat")
               => "the cat in the hat"
          
          (downcase ?X)
               => 120

 * Function: upcase STRING-OR-CHAR

       This function converts a character or a string to upper case.

       When the argument to `upcase' is a string, the function creates
     and returns a new string in which each letter in the argument
     that is lower case is converted to upper case.

       When the argument to `upcase' is a character, `upcase' returns
     the corresponding upper-case character.  This value is an integer.
     If the original character is upper-case, or is not a letter,
     then the value equals the original character.

          (upcase "The cat in the hat")
               => "THE CAT IN THE HAT"
          
          (upcase ?x)
               => 88

 * Function: capitalize STRING-OR-CHAR

       This function capitalizes strings or characters.  If
     STRING-OR-CHAR is a string, the function creates and returns a
     new string, a copy of STRING-OR-CHAR in which each word has been
     capitalized.  This means that the first character of each word
     is converted to upper case and the rest are converted to lower
     case.

       The definition of a word is any sequence of consecutive
     characters that are assigned to the `word' category in the
     current syntax table (*Note Syntax Classes::).

       When the argument to `capitalize' is a character, `capitalize'
     has the same result as `upcase'.

          (capitalize "The cat in the hat")
               => "The Cat In The Hat"
          
          (capitalize "THE 77TH-HATTED CAT")
               => "The 77th-Hatted Cat"
          
          (capitalize ?x)
               => 88



File: lispref,  Node: Lists,  Next: Sequences Arrays Vectors,  Prev: Strings and Characters,  Up: Top

Lists
*****

  A "list" represents a sequence of zero or more elements.

  Lists in Lisp are not a primitive data type; they are built up from
"cons cells".  A cons cell is a data object which represents an
ordered pair.  It records two Lisp objects, one labeled as the CAR,
and the other labeled as the CDR.  (These names are traditional.)

  A list is either the distinguished symbol `nil' (which denotes the
empty list), or one or more cons cells chained together through the
CDR.  The CARs of these cons cells are the "elements" of the list.

* Menu:

* Lists as Boxes::	           Graphical notation to explain lists.
* List-related Predicates::	   Is this object a list?  Comparing two lists.
* Building Lists::      Creating list structure.
* List Elements::	Extracting the pieces of a list.
* Modifying Lists::	Storing new pieces into an existing list.
* Lists as Sets::	A list can represent a finite mathematical set.
* Association Lists::	A list can represent a finite relation or mapping.

 

File: lispref,  Node: Lists as Boxes,  Next: List-related Predicates,  Prev: Lists,  Up: Lists

Lists as Linked Pairs of Boxes
==============================

  A cons cell can be illustrated as a a pair of boxes.  The first box
represents the CAR and the second box represents the CDR.

  Here is an illustration of the two element list, `(tulip lily)':

      --------------         -------------- 
     |car    |cdr    |       |car    |cdr    |
     |       |       |       |       |       |
     |       |   o--------->|       |       |
     | tulip |       |       | lily  |  nil  |
     |       |       |       |       |       |
      --------------         --------------

  Each box refers to or `contains' a Lisp object.  Each pair of boxes
represents a cons cell.  The first box, which is the CAR of the first
cons cell, refers to or contains `tulip'.  The arrow from the CDR of
the first cons cell to the second cons cell indicates that the CDR of
the first cons cell refers to second cons cell.

  The exact same list can be illustrated in a different sort of box
notation like this:

         ___ ___      ___ ___         
        |___|___|--> |___|___|--> nil
          |            |
          |            |
           --> tulip    --> lily

  Here is a more complex illustration, this time of the three element
list, `((pine needles) oak maple)', the first element of which is a
two element list:

         ___ ___      ___ ___      ___ ___ 
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |      
          |            |            |
          |             --> oak      --> maple
          |
          |     ___ ___      ___ ___         
           --> |___|___|--> |___|___|--> nil
                 |            |
                 |            |
                  --> pine     --> needles

  The exact same list shown above, `((pine needles) oak maple)', is
represented in the first box notation like this:

      --------------         --------------         --------------
     |car    |cdr    |       |car    |cdr    |       |car    |cdr    |
     |       |       |       |       |       |       |       |       |
     |   o   |   o--------->|       |   o--------->|       |       |
     |   |   |       |       |  oak  |       |       | maple |  nil  |
     |   |   |       |       |       |       |       |       |       |
      -- | ---------         --------------         --------------
         |
         |
         |        --------------         ---------------- 
         |       |car    |cdr    |       |car      |cdr    |
         |       |       |       |       |         |       |
          ----->|       |   o--------->|         |       |
                 | pine  |       |       | needles |  nil  |
                 |       |       |       |         |       |
                  --------------         ----------------

  *Note List Type::, for the read and print syntax of lists, and for
more `box and arrow' illustrations of lists.



File: lispref,  Node: List-related Predicates,  Next: Building Lists,  Prev: Lists as Boxes,  Up: Lists

Predicates on Lists
===================

The following predicates test whether a Lisp object is an atom, cons
cell, list, or whether it is the distinguished object `nil'.  And the
function `nlistp' tests whether a function is *not* a list.

 * Function: consp OBJECT

       This function returns `t' if the object is a cons cell, `nil'
     otherwise.  `nil' is not a cons cell, although it *is* a list.

 * Function: atom OBJECT

       This function returns `t' if OBJECT is an atom, `nil' otherwise.
      All objects except cons cells are atoms.

          (atom OBJECT) == (not (consp OBJECT))

 * Function: listp OBJECT

       This function returns `t' if OBJECT is a cons cell or `nil'. 
     Otherwise, it returns `nil'.

          (listp '(1))
               => t
          (listp '())
               => t

 * Function: nlistp OBJECT

       This function is the opposite of `listp': it returns `t' if
     OBJECT is not a list.  Otherwise, it returns `nil'.

          (listp OBJECT) == (not (nlistp OBJECT))

 * Function: null OBJECT

       This function returns `t' if OBJECT is `nil'.  It returns `nil'
     otherwise.  This function is identical to `not', but by
     convention, `null' is used when OBJECT is considered a list, and
     `not' is used when it is considered to a truth value (see `not'
     in *Note Conditionals::).

          (null '(1))
               => nil
          (null '())
               => t



File: lispref,  Node: Building Lists,  Next: List Elements,  Prev: List-related Predicates,  Up: Lists

Building Cons Cells and Lists
=============================

  Many functions build lists, as they reside at the very heart of Lisp.
`cons' is the fundamental list building function; however, it is
interesting to note that `list' is used more times in the source code
for Emacs than `cons'.

 * Function: cons OBJECT1 OBJECT2

       This function is the fundamental function used to build new list
     structure.  It creates a new cons cell, making OBJECT1 the
     `car', and OBJECT2 the `cdr'.  It then returns a pointer to the
     new cons cell.  There is no requirement for OBJECT2 to be of any
     particular type, although it is normally a list.

          (cons 1 '(2))
               => (1 2)
          (cons 1 '())
               => (1)
          (cons 1 2)
               => (1 . 2)

 * Function: list &rest OBJECTS

       This function creates a list with OBJECTS as its elements.  The
     resulting list is always `nil'-terminated.  If no OBJECTS are
     given, the empty list is returned.

          (list 1 2 3 4 5)
               => (1 2 3 4 5)
          (list)
               => nil

 * Function: make-list LENGTH OBJECT

       This function creates a list of length LENGTH, with each element
     being OBJECT.

       Compare `make-list' to `make-string'.  (*Note Creating Strings::.)

          (make-list 3 'pigs)
               => (pigs pigs pigs)
          (make-list 0 'pigs)
               => nil

 * Function: append &rest SEQUENCES

       This function returns a list containing all the elements of
     SEQUENCES.  The SEQUENCES may be lists, vectors, strings, or
     integers.  All arguments except the last one are copied, so none
     of them are altered.

       The final argument to `append' may be any object but it is
     typically a list.  The final argument is not copied or converted.

          (setq trees '(pine oak)) 
               => (pine oak)
          (setq more-trees (append '(maple birch) trees))
               => (maple birch pine oak)
          
          trees
               => (pine oak)
          more-trees
               => (maple birch pine oak)
          (eq trees (cdr (cdr trees)))
               => t
          
          ;; With `apply', we can append a variable number of lists.
          (apply 'append '((a b c) nil (x y z) nil))
               => (a b c x y z)

       You can see what happens by looking at a box diagram.  The
     variable `trees' is set to the list `(pine oak)' and then the
     variable `more-trees' is set to the list `(maple birch pine
     oak)'; however, the variable `trees' continues to refer to the
     original list:

          more-trees                trees
          |                           |
          |     ___ ___      ___ ___  |     ___ ___      ___ ___
           --> |   |   |    |   |   |  --> |   |   |    |   |   |
               |___|___|--> |___|___|---> |___|___|--> |___|___|--> nil
                 |            |              |            |
                 |            |              |            |
                  --> maple    -->birch       --> pine     --> oak

       An empty sequence contributes nothing to the value returned by
     `append'.  As a consequence of this, a final `nil' argument
     forces a copy of the previous argument.

          trees 
               => (pine oak)
          (setq wood (append trees ()))
               => (pine oak)
          wood 
               => (pine oak)
          (eq wood trees) 
               => nil

       As a feature, in the special case where one of the SEQUENCES is
     an integer (but not a sequence of integers), it is first
     converted to a string of digits making up the decimal print
     representation of the integer.

          (setq trees '(pine oak))
               => (pine oak)
          (char-to-string \054) 
               => "6"
          (setq longer-list (append trees 6 '(spruce)))
               => (pine oak 54 spruce)
          ?x 
               => 120
          (setq x-list (append trees 6 ?x))
               => (pine oak 54 . 120)

     Also, somewhat mysteriously, at first:

          (append trees 6 ?x nil) => (pine oak 54 49 50 48)
          
          But note that:
          
          ?x => 120
          
          (char-to-string \049) => "1"
          (char-to-string \050) => "2"
          (char-to-string \048) => "0"

     If no SEQUENCES are given, `nil' is returned.

          (append)                         
               => nil

     See `nconc' in *Note Rearrangement::, for another way to join
     lists without copying.  See `copy-sequence' in *Note Sequences
     Arrays Vectors::, for another way to copy sequences.

 * Function: reverse LIST

     This function creates a new list whose elements are the elements
     of LIST, but in reverse order.  The original LIST is *not*
     altered.

          (setq x '(1 2 3 4))
               => (1 2 3 4)
          (reverse x)
               => (4 3 2 1)
          x
               => (1 2 3 4)



File: lispref,  Node: List Elements,  Next: Modifying Lists,  Prev: Building Lists,  Up: Lists

Accessing Elements of Lists
===========================

 * Function: car CONS-CELL

       This function returns the value pointed to by the first pointer
     of the cons cell, CONS-CELL.  Expressed another way, this
     function returns the CAR of CONS-CELL.  As a special case, if
     CONS-CELL is `nil', then `car' is defined to return `nil'. 
     Therefore, any list is allowed as an argument.

     An error is signaled if the argument is not a cons cell or `nil'.

          (car '(a b c))
               => a
          (car '())
               => nil

 * Function: cdr CONS-CELL

       This function returns the value pointed to by the second pointer
     of the cons cell, CONS-CELL.  Expressed another way, this
     function returns the CDR of CONS-CELL.  As a special case, if
     CONS-CELL is `nil', then `cdr' is defined to return `nil'. 
     Therefore, any list is allowed as an argument.

     An error is signaled if the argument is not a cons cell or `nil'.

          (cdr '(a b c))
               => (b c)
          (cdr '())
               => nil

 * Function: car-safe OBJECT

       This function lets you take the CAR of a cons cell while
     avoiding errors for other data types.  It returns the CAR of
     OBJECT if OBJECT is a cons cell, `nil' otherwise.  This is in
     contrast to `car', which signals an error if OBJECT is not a list.

          (car-safe OBJECT)
          ==
          (let ((x OBJECT))
            (if (consp x)
                (car x)
              nil))

 * Function: cdr-safe OBJECT

       This function lets you take the CDR of a cons cell while
     avoiding errors for other data types.  It returns the CDR of
     OBJECT if OBJECT is a cons cell, `nil' otherwise.  This is in
     contrast to `cdr', which signals an error if OBJECT is not a list.

          (cdr-safe OBJECT)
          ==
          (let ((x OBJECT))
            (if (consp x)
                (cdr x)
              nil))

 * Function: nth N LIST

       This function returns the Nth element of LIST.  Elements are
     numbered starting with zero, so the CAR of LIST is element
     number zero.  If LIST has fewer than N elements, the value is
     `nil'.

     If N is less than zero, then the first element is returned.

          (nth 2 '(1 2 3 4))
               => 3
          (nth 10 '(1 2 3 4))
               => nil
          (nth -3 '(1 2 3 4))
               => 1
          
          (nth n x) == (car (nthcdr n x))

 * Function: nthcdr N LIST

       This function returns the Nth cdr of LIST.  In other words, it
     removes the first N links of LIST and returns what follows.

     If N is less than or equal to zero, then all of LIST is
     returned.  If LIST has fewer than N elements, the value is `nil'.

          (nthcdr 1 '(1 2 3 4))
               => (2 3 4)
          (nthcdr 10 '(1 2 3 4))
               => nil
          (nthcdr -3 '(1 2 3 4))
               => (1 2 3 4)



File: lispref,  Node: Modifying Lists,  Next: Lists as Sets,  Prev: List Elements,  Up: Lists

Modifying Existing List Structure
=================================

  You can modify the CAR and CDR contents of a cons cell with the
primitives `setcar' and `setcdr'.

     Common Lisp Note: Common Lisp uses functions `rplaca' and
     `rplacd' to alter list structure; they change structure the same
     way as `setcar' and `setcdr', but the Common Lisp functions
     return the cons cell while `setcar' and `setcdr' return the new
     CAR or CDR.

* Menu:

* Setcar::	    Replacing an element in a list.
* Setcdr::	    Replacing part of the list backbone.
                      This can be used to remove or add elements.
* Rearrangement::   Reordering the elements in a list; combining lists.

 

File: lispref,  Node: Setcar,  Next: Setcdr,  Prev: Modifying Lists,  Up: Modifying Lists

Altering List Elements with `setcar'
------------------------------------

  Changing the CAR of a cons cell replaces one element of a list with a
different element.  This is done with `setcar'.

 * Function: setcar CONS OBJECT

       This function stores OBJECT as the new CAR of CONS, replacing
     its previous CAR.  It returns the value OBJECT.

          (setq x '(1 2))
               => (1 2)
          (setcar x '4)
               => 4
          x
               => (4 2)

  When a cons cell is part of the shared structure of several lists,
storing a new CAR into the cons changes one element of each of these
lists.  Here is an example:

     ;; Create two lists that are partly shared.
     (setq x1 '(a b c))
          => (a b c)
     (setq x2 (cons 'z (cdr x1)))
          => (z b c)
     
     ;; Replace the CAR of a shared link.
     (setcar (cdr x1) 'foo)
          => foo
     x1                           ; Both lists are changed.
          => (a foo c)
     x2
          => (z foo c)
     
     ;; Replace the CAR of a link that is not shared.
     (setcar x1 'baz)
          => baz
     x1                           ; Only one list is changed.
          => (baz foo c)
     x2
          => (z foo c)

  Here is a graphical depiction of the shared structure of the two
lists X1 and X2, showing why replacing `b' changes them both:

     x1:
      --------------         --------------         --------------
     |car    |cdr    |       |car    |cdr    |       |car    |cdr    |
     |   a   |   o--------->|   b   |   o--------->|   c   |  nil  |
     |       |       |    -->|       |       |       |       |       |
      --------------    |    --------------         --------------
                         |
     x2:                 |
      --------------    |
     |car    |cdr    |   |
     |   z   |   o------
     |       |       |
      --------------

Here is an alternative form of box diagram, showing the same
relationship:

       ___ ___        ___ ___      ___ ___ 
      |___|___|---> |___|___|--> |___|___|--> nil
        |        -->   |            |      
        |       |      |            |
         --> a  |       --> b        --> c
                |
      ___ ___   |
     |___|___|--
       |
       |  
        --> z



File: lispref,  Node: Setcdr,  Next: Rearrangement,  Prev: Setcar,  Up: Modifying Lists

Altering the CDR of a List
--------------------------

  The lowest-level primitive for modifying a CDR is `setcdr':

 * Function: setcdr CONS OBJECT

       This function stores OBJECT into the cdr of CONS.  The value
     returned is OBJECT, not CONS.

          (setq x '(1 2))
               => (1 2)
          (setcdr x '(4))
               => (4)
          x
               => (1 4)

  You can delete elements from the middle of a list by altering the
CDRs of the cons cells in the list.  For example, here is the result
of deleting the second element, `b', from the list `(a b c)', by
changing the CDR of the first cell:

     (setq x1 '(a b c))
          => (a b c)
     (setcdr x1 '(c))
          => (c)
     x1
          => (a c)

      --------------                                 --------------
     |car    |cdr    |                               |car    |cdr    |
     |   a   |   o--------------------------------->|   c   |  nil  |
     |       |       |                               |       |       |
      --------------                                 --------------

The second cons cell, which previously held the element `b', may
still exist and its CAR may still be `b', but it no longer forms part
of this list.

  It is equally easy to insert a new element by changing CDRs:

     (setq x1 '(a b c))
          => (a b c)
     (setcdr x1 (cons 'd (cdr x1)))
          => (d b c)
     x1
          => (a d b c)

      --------------         --------------         --------------
     |car    |cdr    |       |car    |cdr    |       |car    |cdr    |
     |   a   |   o   |    -->|   b   |   o--------->|   c   |  nil  |
     |       |   |   |   |   |       |       |       |       |       |
      --------- | --    |    --------------         --------------
                 |       | 
           -----         ------
          |                      |
          |    --------------   |
          |   |car    |cdr    |  |
           -->|   d   |   o-----
              |       |       |
               --------------



File: lispref,  Node: Rearrangement,  Prev: Setcdr,  Up: Modifying Lists

Functions that Rearrange Lists
------------------------------

  Here are some functions that rearrange lists ``destructively'' by
modifying the CDRs of their component cons cells.  We call these
functions ``destructive'' because the original lists passed as
arguments to them are chewed up to produce a new list that is returned.

 * Function: nconc &rest LISTS

     This function returns a list containing all the elements of LISTS.
     Unlike `append' (*note Building Lists::.), the LISTS are *not*
     copied; instead, the last CDR of each of the LISTS is changed to
     refer to the following list.  The last of the LISTS is not
     altered.

          (setq x '(1 2 3))
               => (1 2 3)
          (nconc x '(4 5))
               => (1 2 3 4 5)
          x
               => (1 2 3 4 5)

        Since the last argument of `nconc' is not itself modified, it is
     reasonable to use a constant list, such as ``(4 5)', as is done
     in the above example.  For the same reason, the last argument
     need not be a list:

          (setq x '(1 2 3))
               => (1 2 3)
          (nconc x 'z)
               => (1 2 3 . z)
          x
               => (1 2 3 . z)

     A common pitfall is to use a quoted constant list as a non-last
     argument to `nconc'.  If you do this, your program will change
     each time you run it!  Here is what happens:

          (defun add-foo (x)                ; This function should add
            (nconc '(foo) x))               ; `foo' to the front of its arg.
          
          (symbol-function 'add-foo)
               => (lambda (x) (nconc (quote (foo)) x))
          
          (setq xx (add-foo '(1 2)))        ; It seems to work.
               => (foo 1 2)          
          (setq xy (add-foo '(3 4)))        ; What happened?
               => (foo 1 2 3 4)     
          (eq xx xy)
               => t
          
          (symbol-function 'add-foo)
               => (lambda (x) (nconc '(foo 1 2 3 4) x))

 * Function: nreverse LIST

       This function returns the elements of LIST in reverse order. 
     Unlike `reverse', however, LIST is destructively altered by
     reversing the CDRs in the cons cells forming the list.  The last
     cons cell of the original list is now the first cell of the list.

          (setq x '(1 2 3 4))
               => (1 2 3 4)
          x
               => (1 2 3 4)
          (nreverse x)
               => (4 3 2 1)
          x
               => (1)

       Here is the `nreverse' of our favorite example, `(a b c)',
     presented graphically:

                                                          Reversed list:
           --------------         --------------         --------------
          |car    |cdr    |       |car    |cdr    |       |car    |cdr    |
          |   a   |  nil  |<--    |   b   |   o   |<--    |   c   |   o   |
          |       |       |   |   |       |   |   |   |   |       |   |   |
           --------------    |    --------- | --    |    --------- | --
                              |               |       |               |
                               --------------         --------------

 * Function: sort LIST PREDICATE

       This function sorts LIST stably, though destructively, and
     returns the sorted list.  It compares elements using PREDICATE. 
     A "stable" sort is one in which elements with equal sort keys
     maintain their relative order before and after the sort. 
     Stability is important when successive sorts are used to order
     elements according to different sets of keys.

       PREDICATE must be a function of two arguments.  It is called
     with two elements of LIST.  To get an increasing order sort, the
     PREDICATE should return `t' if the first element is ``less
     than'' the second, or `nil' if not.

       The destructive aspect of `sort' is that it rearranges the cons
     cells forming LIST by changing CDRs.  A nondestructive sort
     function would create new cons cells to store the elements in
     their sorted order.

       The CARs of the cons cells are never changed; the cons cell that
     contained the element `a' in the original LIST, still has `a' in
     its CAR after sorting, but it now appears in a different
     position in the list due to the change of CDR.  For example,

          (setq nums '(1 3 2 6 5 4 0))
               => (1 3 2 6 5 4 0)
          (sort nums '<)
               => (0 1 2 3 4 5 6)
          nums
               => (1 2 3 4 5 6)

     Note that `nums' no longer contains 0.  This shows why you
     should save the return-value of sort.  Don't assume a variable
     which held the argument now holds the entire sorted list!

       *Note Sorting::, for more functions that perform sorting.  See
     `documentation' in *Note Accessing Documentation::, for a useful
     example of `sort'.

See `delq', in *Note Lists as Sets::, for another function that
modifies cons cells.



File: lispref,  Node: Lists as Sets,  Next: Association Lists,  Prev: Modifying Lists,  Up: Lists

Using Lists as Sets
===================

  Lists can represent unordered mathematical sets--the elements in the
list are the members of the set.  All you have to do is ignore the
order.  In these applications, you will probably want to use the
functions `memq' and `delq'.

 * Function: memq OBJECT LIST

       This function tests to see whether OBJECT is a member of LIST. 
     If it is, `memq' returns a list starting with the first
     occurrence of OBJECT.  Otherwise, it returns `nil'.  The letter
     `q' in `memq' says that it uses `eq' to compare OBJECTS against
     the elements of the list.

          (memq 2 '(1 2 3 2 1))
               => (2 3 2 1)
          (memq '(2) '((1) (2)))   ; `(2)' and `(2)' are not `eq'.
               => nil

 * Function: delq OBJECT LIST

       This function removes all elements `eq' to OBJECT from LIST.

     Elements at the front of the list are removed (when necessary)
     simply by advancing down the list and returning a sublist that
     starts after those elements:

          (delq 'a '(a b c))
          ==
          (cdr '(a b c))

     When an element to be deleted appears in the middle of the list,
     removing it requires changing the CDRs (*note Setcdr::.).

          (setq sample-list '(1 2 3 (4)))
               => (1 2 3 (4))
          (delq 1 sample-list)
               => (2 3 (4))
          sample-list
               => (1 2 3 (4))
          (delq 2 sample-list)
               => (1 3 (4))
          sample-list
               => (1 3 (4))
          (delq '(4) sample-list)
               => (1 3 (4))

     Note that `(delq 1 sample-list)' does not remove the first
     element of `sample-list', but that `(delq 2 sample-list)'
     removes the second element.  Don't assume that a variable which
     held the argument now has fewer elements, or, conversely, that
     it holds the original list!

(In the final example, the `(4)' that `delq' attempts to match and
the `(4)' in the `sample-list' are not `eq'.)

     Common Lisp note: Common Lisp has functions `union' and
     `intersection' for set operations, but GNU Emacs Lisp does not
     have them.  You can write them in Lisp if you wish.



File: lispref,  Node: Association Lists,  Prev: Lists as Sets,  Up: Lists

Association Lists
=================

  An "association list", or "alist" for short, records a mapping from
keys to values.  It is a list of pairs (cons cells): the CAR of each
cell is the key, and the CDR is the associated value.  The key can be
any Lisp object, and so can the value.

  An sample of an alist is shown below; the key, `pine', is associated
with `cones'; the key, `oak', is associated with `acorns'; and the
key, `maple', is associated with `seeds'.

     '((pine . cones) 
       (oak . acorns) 
       (maple . seeds))

  The pairs in an alist may be of any kind.  For example, in the
following alist, the symbol `a' is associated with the number `1',
and the string `"b"' is associated with the *list* `(2 3)'.

     ((a . 1) ("b" 2 3))

  We recommend you use dotted pairs consistently, since they are the
simplest to handle.

  Association lists are often used to record information that you might
otherwise keep on a stack since new pairs may be simply added to the
front of the list.  When searching an association list for a pair
with a given key, the first pair with that key is returned, even if
there are several such pairs.

  It is *not* an error if an element of an association list is not a
cons cell.  The alist search functions simply ignore such elements.

  Note that property lists are similar to association lists in several
respects.  A property list behaves like an association list in which
each key can occur only once.  *Note Property Lists::, for a
comparison of property lists and association lists.

 * Function: assoc KEY ALIST

       This function returns the first pair associated with KEY in
     ALIST.  It compares KEY against the alist elements using
     `equal'.  It returns `nil' if no pair in ALIST has a CAR `equal'
     to KEY.

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               => ((pine . cones) (oak . acorns) (maple . seeds))
          (assoc 'oak trees)
               => (oak . acorns)
          (cdr (assoc 'oak trees))
               => acorns
          (assoc 'birch trees)
               => nil

     The elements of an association list need not be dotted pairs:

          (setq colors '((rose  red) (lily white)  (buttercup yellow)))
               => ((rose red) (lily white) (buttercup yellow))
          (assoc 'rose colors)
               => (rose red)
          (cdr (assoc 'rose colors))
               => (red)

     In the last example, the CDR is the *list* `(red)'; contrast
     this with the example using dotted pairs in which the atom
     `acorn' is returned.

       Also, the key and the associated value can be any kind of Lisp
     object, such as numbers, strings, or lists:

          (setq needles-per-cluster
                '((2 . ("Austrian Pine" "Red Pine"))
                  (3 . "Pitch Pine") 
                  (5 . "White Pine")))
          
          (cdr (assoc 3 needles-per-cluster))
               => "Pitch Pine"
          (cdr (assoc 2 needles-per-cluster))
               => ("Austrian Pine" "Red Pine")

 * Function: assq KEY ALIST

       This function is like `assoc' in that it returns the first pair
     associated with KEY in ALIST, but it makes the comparison using
     `eq' instead of `equal'.  `assq' returns `nil' if no pair in
     ALIST has a CAR `eq' to KEY.  This function is used more often
     than `assoc', since `eq' is faster than `equal' and most alists
     use symbols as keys.

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
          
          (assq 'pine trees)
               => (pine . cones)

     On the other hand, `assq' returns `nil' in the following case:

          (setq leaves
                '(("simple leaves" . oak)
                  ("compound leaves" . horsechestnut)))
          
          (assq "simple leaves" leaves)
               => nil
          (assoc "simple leaves" leaves)
               => ("simple leaves" . oak)

 * Function: rassq ALIST VALUE

       `rassq' is like `assq' except that the CDR of the ALIST pairs is
     tested instead of the CAR.  You can think of this as ``reverse
     assq'', finding the key for a given value.

       This function returns the first pair associated with VALUE in
     ALIST.  It returns `nil' if no pair in ALIST has a CDR `eq' to
     VALUE.

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
          
          (rassq 'acorns trees)
               => (oak . acorns)

     However, `rassq' will return `nil' if it cannot match VALUE with
     the alist:

          (setq colors '((rose  red) (lily white)  (buttercup yellow)))
          
          (rassq 'white colors)
               => nil

     In this case, the CDR of the pair `(lily white)' is not the
     symbol, `white', but is the list `(white)'.  This can be seen
     more clearly if the pair is expressed in the equivalent dotted
     pair notation:

          (lily white) == (lily . (white))

 * Function: copy-alist ALIST

     This function returns a two-level deep copy of ALIST: it creates
     a new copy of each pair, so that you can alter the associations
     of the new alist without changing the old one.

          (setq needles-per-cluster
                '((2 . ("Austrian Pine" "Red Pine"))
                  (3 . "Pitch Pine") 
                  (5 . "White Pine")))
          => 
          ((2 "Austrian Pine" "Red Pine") 
           (3 . "Pitch Pine") 
           (5 . "White Pine"))
          
          (setq copy (copy-alist needles-per-cluster))
          => 
          ((2 "Austrian Pine" "Red Pine") 
           (3 . "Pitch Pine") 
           (5 . "White Pine"))
          
          (eq needles-per-cluster copy)
               => nil
          (equal needles-per-cluster copy)
               => t
          (eq (car needles-per-cluster) (car copy))
               => nil
          (cdr (car (cdr needles-per-cluster)))
               => "Pitch Pine"
          (eq (cdr (car (cdr needles-per-cluster)))
              (cdr (car (cdr copy))))
               => t



File: lispref,  Node: Sequences Arrays Vectors,  Next: Symbols,  Prev: Lists,  Up: Top

Sequences, Arrays, and Vectors
******************************

  Two supertypes are described in this chapter, sequences and arrays. 
The primitive type, vector, is also described here.

  Recall that the "sequence" type is a supertype of three other Lisp
types: lists, vectors, and strings.  In other words, any list is a
sequence, any vector is a sequence, and any string is a sequence. 
The common property that all sequences have is that each is an
ordered collection of elements.

  An "array" is a sequence in which all elements are accessible in
constant time, and whose length cannot be changed.  Both strings and
vectors are arrays.  A list is not an array because the elements of a
list are not all accessible in constant time; in fact, the access
time of an element of a list is proportional to its position in the
list.

  The following diagram shows the relationship between all these types.

                 ___________________________________
                |                                   |
                |          Sequence                 |
                |  ______   ______________________  |
                | |      | |                      | |
                | | List | |         Array        | |
                | |      | |  ________   _______  | |   
                | |______| | |        | |       | | |
                |          | | String | | Vector| | |
                |          | |________| |_______| | |
                |          |______________________| |
                |___________________________________|

           @r{The Relationship between Sequences, Arrays, and Vectors}

  The elements of vectors and lists may be any Lisp objects.  The
elements of strings are all characters.

* Menu:

* Sequence Functions::    Functions that accept any kind of sequence.
* Arrays::                Characteristics of arrays in Emacs Lisp.
* Array Functions::       Functions specifically for arrays.
* Vectors::               Functions specifically for vectors.

 

File: lispref,  Node: Sequence Functions,  Next: Arrays,  Prev: Sequences Arrays Vectors,  Up: Sequences Arrays Vectors

Sequences
=========

  In Emacs Lisp, a "sequence" is either a list, a vector or a string. 
The common property that all sequences have is that each is an
ordered collection of elements.

  This section describes functions that accept any kind of sequence.

 * Function: sequencep OBJECT

     Returns `t' if OBJECT is a list, vector, or string, `nil'
     otherwise.

 * Function: copy-sequence SEQUENCE

     Returns a copy of SEQUENCE.  The copy is the same type of object
     as the original sequence, and it has the same elements in the
     same order.

     Storing a new element into the copy does not affect the original
     SEQUENCE, and vice versa.  However, the elements of the new
     sequence are not copies; they are identical (`eq') to the
     elements of the original.  Therefore, changes made within these
     elements, as found via the copied sequence, are also visible in
     the original sequence.

     See also `append' in *Note Building Lists::, `concat' in *Note
     Creating Strings::, and `vconcat' in *Note Vectors::, for others
     ways to copy sequences.

          (setq bar '(1 2))
               => (1 2)
          (setq x (vector 'foo bar))
               => [foo (1 2)]
          (setq y (copy-sequence x))
               => [foo (1 2)]
          
          (eq x y)
               => nil
          (equal x y)
               => t
          (eq (elt x 1) (elt y 1))
               => t
          
          ;; Replacing an element of one sequence.
          (aset x 0 'quux)
          x => [quux (1 2)]
          y => [foo (1 2)]
          
          ;; Modifying the inside of a shared element.
          (setcar (aref x 1) 69)
          x => [quux (69 2)]
          y => [foo (69 2)]

 * Function: length SEQUENCE

     Returns the number of elements in SEQUENCE.  If SEQUENCE is a
     cons that is not a list (the final CDR is not `nil'), a
     `wrong-type-argument' error results.

          (length '(1 2 3))
              => 3
          (length nil)
              => 0
          (length "foobar")
              => 6
          (length [1 2 3])
              => 3

 * Function: elt SEQUENCE INTEGER

     This function returns the element of SEQUENCE indexed by
     INTEGER.  Legitimate values of INTEGER range from 0 up to one
     less than the length of SEQUENCE; other values produce an
     `args-out-of-range' error.

          (elt [1 2 3 4] 2)
               => 3
          (elt '(1 2 3 4) 2)
               => 3
          (char-to-string (elt "1234" 2))
               => "3"
          (elt [1 2 3 4] 4)
               error-->Args out of range: [1 2 3 4], 4
          (elt [1 2 3 4] -1)
               error-->Args out of range: [1 2 3 4], -1

     This function duplicates `aref' (*note Arrays::.) and `nth'
     (*note Accessing Elements of Lists: List Elements.), except that
     it works for any kind of sequence.



File: lispref,  Node: Arrays,  Next: Array Functions,  Prev: Sequence Functions,  Up: Sequences Arrays Vectors

Arrays
======

  An "array" object is composed of an arbitrary number of other Lisp
objects.  Any element of an array may be accessed in constant time. 
In contrast, an element of a list requires access time that is
proportional to the position of the element in the list.  Elements at
the end of a list take longer to access than elements at the
beginning of a list.

  Emacs defines two types of array, both of which are one-dimensional:
strings and vectors.  A "vector" is a general array; its elements can
be any Lisp objects.  A "string" is a specialized array; its elements
must be characters (i.e., integers between 0 and 255).  Each type of
array has its own read syntax (*note String Type::., and *note Vector
Type::.).

  Both kinds of arrays share these characteristics:

   * Arrays may have any length, up to the size of the largest
     integer; but once created, an array has a fixed size.

   * Arrays are indexed such that the first element of an array has
     an index of zero, the second element as an index of 1, and so
     on.  This is called "zero-origin" indexing.  For example, an
     array of four elements is indexed by 0, 1, 2, and 3.

   * The elements of any array may be referenced or changed with the
     functions `aref' and `aset', respectively (*note Arrays::.).

  In principle, if you wish to have an array of characters, you could
use either a string or a vector.  In practice, we always choose
strings for such applications, for three reasons:

   * They occupy one fourth the space of a vector.

   * Strings are printed in a way that shows the contents more
     clearly as characters.

   * Many of the specialized editing and I/O facilities of Emacs
     accept only strings.  For example, you cannot insert a vector of
     characters into a buffer the way you can insert a string.  *Note
     Strings and Characters::.



File: lispref,  Node: Array Functions,  Next: Vectors,  Prev: Arrays,  Up: Sequences Arrays Vectors

Functions that Operate on Arrays
================================

  In this section, we describe the functions that accept both strings
and vectors.

 * Function: arrayp OBJECT

     This function returns `t' if the object is an array (i.e.,
     either a vector or a string).

          (arrayp [a])
          => t
          (arrayp "asdf")
          => t

 * Function: aref ARRAY INTEGER

     This function returns the INTEGER'th element of the ARRAY The
     first element is indexed with zero.

          (setq primes [2 3 5 7 11 13])
               => [2 3 5 7 11 13]
          (aref primes 4)
               => 11
          (elt primes 4)
               => 11
          
          (aref "abcdefg" 1)
               => 98           ; `b' is ASCII code 98.

      See also the function `elt', in *Note Sequence Functions::.

 * Function: aset ARRAY INTEGER OBJECT

     This function sets the INTEGER'th element of ARRAY to be OBJECT.
     It returns OBJECT.

          (setq w [foo bar baz])
               => [foo bar baz]
          (aset w 0 'fu)
               => fu
          w
               => [fu bar baz]
          
          (setq x "asdfasfd")
               => "asdfasfd"
          (aset x 3 ?Z)
               => 90
          x
               => "asdZasfd"

     If ARRAY is a string and OBJECT is not a character, a
     `wrong-type-argument' error results.

 * Function: fillarray ARRAY OBJECT

     This function fills the array with pointers to OBJECT, replacing
     any previous values.  It returns ARRAY.

          (setq a [a b c d e f g])
               => [a b c d e f g]
          (fillarray a 0)
               => [0 0 0 0 0 0 0]
          a
               => [0 0 0 0 0 0 0]
          (setq s "When in the course")
               => "When in the course"
          (fillarray s ?-)
               => "-----------------"

     If ARRAY is a string and OBJECT is not a character, a
     `wrong-type-argument' error results.

The general sequence functions `copy-sequence' and `length' are often
useful for objects known to be arrays.  *Note Sequence Functions::.



File: lispref,  Node: Vectors,  Prev: Array Functions,  Up: Sequences Arrays Vectors

Vectors
=======

  Arrays in Lisp, like arrays in most languages, are blocks of memory
whose elements can be accessed in constant time.  A "vector" is a
general-purpose array; its elements can be any Lisp objects.  (The
other kind of array provided in Emacs Lisp is the "string", whose
elements must be characters.)  The main uses of vectors in Emacs are
as syntax tables (vectors of integers), keymaps (vectors of
commands), and inside of compiled functions.

  The elements of a vector are numbered starting with zero in Emacs Lisp.

  Vectors are printed with square brackets surrounding the elements in
their order.  Thus, a vector containing the symbols `a', `b' and `c'
is printed as `[a b c]'.  You can write vectors in the same way in
Lisp input.

  A vector, like a string or a number, is considered a constant: the
result of evaluating it is the same vector.  The elements of the
vector are not evaluated.

  Here are examples of these principles:

     (setq avector
           [1 two '(three) "four" [five]])
          => [1 two (quote (three)) "four" [five]]
     (eval avector)
          => [1 two (quote (three)) "four" [five]]
     (eq avector (eval avector))
          => t

Here are some functions that relate specifically to vectors:

 * Function: vectorp OBJECT

     This function returns `t' if the object is a vector.

          (vectorp [a])
               => t
          (vectorp "asdf")
               => nil

 * Function: vector &rest OBJECTS

     This function returns a vector whose elements are the arguments,
     OBJECTS.

          (vector 'foo 23 [bar baz] "rats")
               => [foo 23 [bar baz] "rats"]
          (vector)
               => []

 * Function: make-vector INTEGER OBJECT

     This function returns a new vector consisting of INTEGER
     elements, all initialized to OBJECT.

          (setq sleepy (make-vector 9 'Z))
               => [Z Z Z Z Z Z Z Z Z]

 * Function: vconcat &rest SEQUENCES

     This function returns a new vector containing all the elements
     of the arguments, SEQUENCES.  These arguments may be lists,
     vectors, or strings; they may also be integers.  If no SEQUENCES
     are given, an empty vector is returned.

     The value is a newly constructed vector which is not `eq' to any
     existing vector.

          (setq a (vconcat '(A B C) '(D E F)))
               => [A B C D E F]
          (eq a (vconcat a))
               => nil
          (vconcat)
               => []

     As a special feature, if one of the SEQUENCES is an integer (not
     a sequence of integers), it is first converted to the string of
     digits making up the decimal print representation of the
     integer.  In the second example below, the number 123 is divided
     into three digits.  Note that the ASCII code of the character
     `1' is 49, and that of `a' is 97.

          (vconcat [A B C] 123 "aa" '(foo (6 7)))
               => [A B C 49 50 51 97 97 foo (6 7)]

     For other concatenation functions, `mapconcat' in *Note Mapping
     Functions::, `concat' in *Note Creating Strings::, and `append'
     in *Note Building Lists::.

  The `append' function may be used to convert a vector into a list
with the same elements (*note Building Lists::.):

     (append avector nil)
          => (1 two (quote (three)) "four" [five])



File: lispref,  Node: Symbols,  Next: Variables,  Prev: Sequences Arrays Vectors,  Up: Top

Symbols
*******

  This chapter describes how symbols may be used, what the components
of symbols are, and how symbols are created and interned.  Property
lists are also described here.

  A "symbol" is a unique name which may be used in several ways
simultaneously.  These are listed below with references to where
these uses are described.

   * A symbol can be used simply as a unique entity.  *Note Creating
     Symbols::

   * A symbol can be used as a global variable.  *Note Global
     Variables::

   * A symbol can be used as a local variable.  *Note Local Variables::

   * A symbol can be used to reference a function or macro.  *Note
     Functions::, and *Note Macros::.

   * A symbol can be used to reference a property list of global
     information.  *Note Property Lists::

  You may test whether an arbitrary Lisp object is a symbol with
`symbolp':

 * Function: symbolp OBJECT

       This function returns `t' if OBJECT is a symbol, `nil' otherwise.

* Menu:

* Symbol Components::        Symbols have names, values, function definitions
                               and property lists.
* Definitions::              A definition says how a symbol will be used.
* Creating Symbols::         How symbols are kept unique.
* Property Lists::           How to use property lists.
* Lisp Symbol Completion::   Completing the name of a symbol.

 

File: lispref,  Node: Symbol Components,  Next: Definitions,  Prev: Symbols,  Up: Symbols

Symbol Components
=================

  To support the above mentioned uses, each symbol has four components
(or attributes or cells), each of which references another object.

  The print name cell is described elsewhere (*note Symbol Type::.).

  One essential aspect of symbols is that a symbol with a given print
name is unique: no other symbol can have the same print name.  The
Lisp reader ensures this: every time it reads a name, it looks for an
existing symbol with that name before it creates a new one.  (In GNU
Emacs Lisp, this is done with a hashing algorithm that uses an
obarray; *note Creating Symbols::..)

  The other three cells of a symbol *may* reference any Lisp object
whatsoever.  In normal usage, the function cell usually contains a
reference to a function or macro, as that is what the Lisp
interpreter expects to see there (*note Evaluation::.).  Keyboard
macros (*note Keyboard Macros::.), keymaps (*note Keymaps::.) and
autoload objects (*note Autoloading::.) are also sometimes stored in
the function cell of symbols.

  Likewise, the property list cell normally references a correctly
formatted property list (*note Property Lists::.), as a number of
functions will expect to see a property list there.  The value cell
contains the symbol's global value, if any, and that may be any Lisp
object (*note Global Variables::.).

  Quite often, we will refer to the function `foo' when we really mean
the function referenced by the function cell of the symbol `foo'. 
Similarly for the value cell and property list cell.  The distinction
will only be made when necessary.

  The contents of a symbol's function cell are often called the
"function definition" of the symbol.

  Here is a summary of the components of a symbol.

Name
       The string of characters used to identify the symbol when
     reading or printing.  See `symbol-name' in *Note Creating
     Symbols::.

Value
       The global value of a symbol.  See `symbol-value' in *Note
     Accessing Variables::.

Function
       The function that is called when the symbol appears in the
     function position of a form being evaluated, or as the first
     argument to `funcall', `apply', etc.  This cell is also used by
     keymaps and keyboard macros.  See `symbol-function' in *Note
     Function Cells::.

Property List
       The property list is used by several functions to look up values
     that are associated with the symbol and a property symbol.  See
     `symbol-plist' in *Note Property Lists::.



File: lispref,  Node: Definitions,  Next: Creating Symbols,  Prev: Symbol Components,  Up: Symbols

Defining Symbols
================

  A "definition" in Lisp is a special form that announces your
intention to use a certain symbol in a particular way.  For example,
you can define a symbol as a variable, or as a function.

  A definition construct typically specifies a value or meaning for the
symbol for this kind of use, plus documentation for its meaning when
used in this way.  Thus, when you define a symbol as a variable, you
can supply an initial value for the variable, plus documentation for
the variable.

  When it is possible to use the same symbol in two different ways at
once, you can give the symbol a definition for each kind of use.  For
example, it is not unusual to define the same symbol both as a
function and as a variable.

  `defvar' and `defconst' are both definitions that establish a symbol
as a global variable.  They are documented in detail in *Note
Defining Variables::.

  `defun' defines a symbol as a function, creating a `lambda'
expression and storing it in the function cell of the symbol.  This
`lambda' expression thus becomes the function definition of the
symbol.  (The term ``function definition'', meaning the contents of
the function cell, is derived from the idea that `defun' gives the
symbol its definition as a function.)  *Note Functions::.

  A `defmacro' definition defines a symbol as a macro.  It creates a
`macro' expression and stores it in the function cell of the symbol. 
Note that a given symbol can be a macro or a function, but not both
at once.  This is because both macro and function definitions are
kept in the function cell, and that cell can hold only one Lisp
object at any given time.  *Note Macros::.

  In GNU Emacs Lisp, a definition is not required in order to use a
symbol as a variable or function.  Thus, you can make a symbol a
global variable with `setq', whether you define it first or not.  The
real purpose of a definition is to guide programmers and programming
tools.  They inform programmers who read the code that certain
symbols are *intended* to be used as variables, or as functions.  And
utilities such as `etags' and `make-docfile' can recognize
definitions, and add the appropriate information to tag tables and
the `etc/DOC' file.



File: lispref,  Node: Creating Symbols,  Next: Property Lists,  Prev: Definitions,  Up: Symbols

Creating and Interning Symbols
==============================

  To understand how symbols are created in GNU Emacs Lisp, it is
necessary to know how Lisp reads them.  It is essential to ensure
that every time Lisp reads the same set of characters, it finds the
same symbol.  Failure to do so would be disastrous.

  When the Lisp reader encounters a symbol, it reads in all the
characters in a name.  Then it ``hashes'' those characters into a
vector called an "obarray".  Hashing is just an efficient method of
looking something up.  Instead of searching a telephone book cover to
cover when looking up Jan Jones, you start with the `J's and go from
there.  That is a simple version of hashing.  A number of symbols
might all hash to the same element in that obarray, that is, they
hash to the same "bucket", and Lisp just looks through the bucket to
see if one of the symbols has the name in question.

  If such a symbol is found, then it is returned.  If no such symbol is
found, then a new symbol is created and added to the obarray.  Adding
a symbol to an obarray is called "interning" it, and the symbol may
then be called an "interned symbol".  A symbol may be interned in
only one obarray.

  If a symbol is not in an obarray, then there is no way for Lisp to
find it when its name is read.  Such a symbol is called an
"uninterned symbol" relative to the obarray.  An uninterned symbol
has all the other properties of symbols.  It is possible, though
uncommon, for two different symbols to have the same name in
different obarrays; they are not `eq' or `equal'.

  Most of the functions below take a name and sometimes an obarray as
arguments.  It is a `wrong-type-argument' error if the name is not a
string, or if the obarray is not a vector.

 * Function: symbol-name SYMBOL

       This function returns the string that is SYMBOL's name. 
     Changing the name cell of a symbol will change the name of the
     symbol.  Changing the string by substituting characters, etc,
     will also change the name of the symbol.  Don't do either of
     these things.  Rather, create a new symbol with the desired name.

          (symbol-name 'foo)
               => "foo"

 * Function: make-symbol NAME

     This function returns a newly allocated uninterned symbol whose
     name is NAME (which must be a string).  Its value and function
     definition are void, and its property list is `nil'.  In the
     example below, the value of `sym' is not `eq' to `foo' because
     the string was not interned.

          (setq sym (make-symbol "foo"))
               => foo
          (eq sym 'foo)
               => nil

 * Function: intern NAME &optional OBARRAY

     This function returns the symbol whose name is NAME.  If the
     symbol is not in the obarray, it is added.  If OBARRAY is
     supplied, it specifies the obarray to use; otherwise, the value
     of the global variable `obarray' is used.

          (setq sym (intern "foo"))
               => foo
          (eq sym 'foo)
               => t

 * Function: intern-soft NAME &optional OBARRAY

       This function returns the symbol whose name is NAME, or `nil' if
     a symbol with that name is not found in the obarray.  Therefore,
     you can use `intern-soft' to test whether a symbol with a given
     name is interned.  If OBARRAY is supplied, it specifies the
     obarray to use; otherwise the value of the global variable
     `obarray' is used.

          (intern-soft "frazzle")                ; No such symbol exists.
               => nil
          (make-symbol "frazzle")                ; Create an uninterned one.
               => frazzle
          (intern-soft "frazzle")                ; That one cannot be found.
               => nil
          (setq sym (intern "frazzle"))          ; Create an interned one.
               => frazzle
          (intern-soft "frazzle")                ; That one can be found!
               => frazzle
          (eq sym 'frazzle)                      ; And it is the same one.
               => t

 * Variable: obarray

       This global variable is the standard obarray for use by `intern'
     and `read'.  It is a vector whose length ought to be prime for
     best results (presently 511).  Each element is an interned
     symbol whose name hashes to that bucket.  That symbol (if any)
     has an internal link (invisible to the user) to the next symbol
     that hashes to that bucket.  The order of symbols in a bucket is
     unimportant.

 * Function: mapatoms FUNCTION &optional OBARRAY

     This function applies FUNCTION to every symbol in OBARRAY.  It
     returns `nil'.  If OBARRAY is not supplied, it defaults to the
     value of `obarray', the normal obarray of all symbols.

     See `documentation' in *Note Accessing Documentation::, for
     another example using `mapatoms'.

          (setq count 0)
               => 0
          (defun count-syms (s)
            (setq count (1+ count)))
               => count-syms
          (mapatoms 'count-syms)
               => nil
          count
               => 1871



File: lispref,  Node: Property Lists,  Next: Lisp Symbol Completion,  Prev: Creating Symbols,  Up: Symbols

Property Lists
==============

  A "property list" ("plist" for short) is a list of paired elements
stored in the property list cell of a symbol.  Each of the pairs
associates a property name (usually a symbol) with some property or
value.  Property lists are generally used to record information about
a symbol, such as how to compile it, the name of the file where it
was defined in some way, or the grammatical class of the symbol
(representing a word) in a language understanding system.

  The property names (or keys) and property values may be any Lisp
objects.  The property names are compared using `eq'.

  Association lists (*note Association Lists::.) are very similar to
property lists.  But unlike association lists, the order of the pairs
in the property list is not significant since the property names must
be distinct.

  Property lists are better than association lists when it is necessary
to attach information to various Lisp function names or variables. 
If all the pairs are recorded in one association list, it will be
necessary to search that entire list each time a function or variable
is to be operated on.  By contrast, if the information is recorded in
the property lists of the function names or variables themselves,
each search will scan only the length of one property list, which is
usually short.  For this reason, the documentation for a variable is
recorded in a property named `variable-documentation'.  The byte
compiler likewise uses properties to record those functions needing
special treatment.

  However, association lists have their own advantages.  Depending on
your application, it may be faster to add a pair to the front of an
association list than to update a property.  All properties for a
symbol are stored in the same property list, so there is a
possibility of a conflict between different uses of a property name. 
(For this reason, it is best to name properties in some unique
fashion such as including the name of your extension package in the
property name.)  An association list may be used like a stack where
pairs are pushed on the top of the stack and later popped off; this
is not possible with a property list.

 * Function: symbol-plist SYMBOL

     This function returns the property list of SYMBOL.

     You should *not* use this function to get access to the property
     list for the purpose of altering it.  (See the example for
     `setplist').

 * Function: setplist SYMBOL PLIST

       This function sets SYMBOL's property list to PLIST.  Normally,
     PLIST should be a well-formed property list, but this is not
     enforced.

          (setplist 'foo '(a 1 b (2 3) c nil))
               => (a 1 b (2 3) c nil)
          (symbol-plist 'foo)
               => (a 1 b (2 3) c nil)

     For symbols in special obarrays, which therefore are never used
     for ordinary purposes, it may make sense to use the property
     list cell in a nonstandard fashion; in fact, the abbrev
     mechanism does so (*note Abbreviations::.).

 * Function: get SYMBOL KEY

     This function finds the value of the property named KEY in
     SYMBOL's property list.  If there is no such key, `nil' is
     returned.  Thus, there is no distinction between an associated
     value of `nil' and the absence of the key.

     KEY is compared with the property names using `eq', so any
     object is a legitimate key.  See `put' for an example.

 * Function: put SYMBOL KEY VALUE

     This function puts VALUE onto SYMBOL's property list under the
     property name KEY, replacing any previous value.

          (put 'fly 'verb 'transitive)
               =>'transitive
          (put 'fly 'noun '(a buzzing little bug))
               => (a buzzing little bug)
          (get 'fly 'verb)
               => transitive
          (symbol-plist 'fly)
               => (verb transitive noun (a buzzing little bug))



File: lispref,  Node: Lisp Symbol Completion,  Prev: Property Lists,  Up: Symbols

Lisp Symbol Completion
======================

  If you type a part of a symbol, and then type `M-TAB'
(`lisp-complete-symbol'), Emacs will attempt to return as much of the
name of the symbol that it can.  Not only does this save typing, but
it can help you with the name of a symbol that you partially forgot.

  For more on completion, see *Note Completion::.

 * Command: lisp-complete-symbol

       This function performs completion on the symbol name preceding
     point.  The name is completed against the symbols in the global
     variable `obarray', and characters from the completion are
     inserted into the buffer, making the name longer.  If there is
     more than one completion, a list of all possible completions is
     placed in the `*Help*' buffer.  The bell rings if there is no
     possible completion in `obarray'.

       If the name starts just after the character `(', only symbols
     with function definitions will be considered.  Otherwise,
     symbols with any of a function definition, value, or property
     will be considered.

       `lisp-complete-symbol' returns `t' if the symbol had an exact, 
     and unique, match; otherwise, it returns `nil'.

       In the example, the user already inserted `(forwa' into the
     buffer  `foo.el'.  `lisp-complete-symbol' is then invoked, and
     completes  the function call to `(forward-'.

          --------- Buffer: foo.el ---------
          (forwa-!-
          --------- Buffer: foo.el ---------
          
          (lisp-complete-symbol)
               => nil
          
          --------- Buffer: foo.el ---------
          (forward--!-
          --------- Buffer: foo.el ---------



File: lispref,  Node: Variables,  Next: Functions,  Prev: Symbols,  Up: Top

Variables
*********

  A "variable" is a name used in a program to stand for a value. 
Nearly all programming languages have variables of some sort in the
textual representation of the program.  In a Lisp program in textual
form, variables are written like symbols.

  In Lisp, unlike most programming languages, programs have
representations in terms of data structures in addition to their
textual representations.  In other words, a collection of Lisp
objects can be considered a Lisp program.  In this representation, a
symbol (a kind of Lisp object) stands for a variable (a programming
entity).  Variables are written like symbols in the text, because the
text is processed by converting it to Lisp objects, and the variables
in the text must be converted to symbols.  *Note Symbols::, for more
information.

  The current value of a variable resides in the symbol's value cell
(*note Symbol Components::.).

* Menu:

* Global Variables::      Variable values that exist permanently, everywhere.
* Constant Variables::    Certain "variables" have values that never change.
* Local Variables::       Variable values that exist only temporarily.
* Void Variables::        Symbols that lack values.
* Defining Variables::    A definition says a symbol is used as a variable.
* Accessing Variables::   Examining values of variables whose names
                            are known only at run time.
* Setting Variables::     Storing new values in variables.
* Variable Resolution::   How Lisp chooses among local and global values.
* Buffer Local Variables::Variable values in effect only in one buffer.
* Default Value::         The default value is seen in buffers
                            that don't have their own local values.

 

File: lispref,  Node: Global Variables,  Next: Constant Variables,  Prev: Variables,  Up: Variables

Global Variables
================

  The simplest way to use a variable is "globally".  This means that
the variable has just one value at a time, and this value is in
effect (at least for the moment) throughout the Lisp system.  The
value remains in effect until you specify a new one.  When a new
value replaces the old one, no memory of the old value remains in the
variable.

  You give the symbol a value with `setq'.  For example,

     (setq x '(a b))

gives the variable `x' the value `(a b)'.  Note that the first
argument of `setq', the name of the variable, is not evaluated; but
the second argument, the desired value, is evaluated normally.

  Once you have done this, you can refer to the variable by using the
symbol by itself as an expression.  Thus,

     x
          => (a b)

assuming the `setq' form shown above has already been executed.

  If you do another `setq', the new value replaces the old one.

     x
          => (a b)
     (setq x 4)
          => 4
     x
          => 4



File: lispref,  Node: Constant Variables,  Next: Local Variables,  Prev: Global Variables,  Up: Variables

Variables that Never Change
===========================

  Emacs Lisp has two special symbols, `nil' and `t', that always
evaluate to themselves.  These symbols cannot be rebound, nor can
their value cells be changed.  An attempt to change the value results
in a `setting-constant' error.

     nil == 'nil
          => nil
     (setq nil 500)
     error--> Attempt to set constant symbol: nil



File: lispref,  Node: Local Variables,  Next: Void Variables,  Prev: Constant Variables,  Up: Variables

Local Variables
===============

  Global variables are given values that last until explicitly
superseded with new values.  Sometimes it is useful to create
variable values that exist temporarily--only while within a certain
part of the program.  These values are called "local", and the
variables so used are called "local variables".

  For example, when a function is called, its argument variables
receive new local values which last until the function exits. 
Similarly, the `let' special form explicitly establishes new local
values for specified variables; these last until exit from the `let'
form.

  When a local value is established, the previous value (or lack of
one) of the variable is saved away.  When the life span of the local
value is over, the previous value is restored.  In the mean time, we
say that the previous value is "shadowed" and "not visible".  Both
global and local values may be shadowed.

  If you set a variable (such as, with `setq') while it is local, this
replaces the local value; it does not alter the global value, or
previous local values which are shadowed.  To model this behavior, we
speak of a "local binding" of the variable as well as a local value.

  The local binding is a place that holds a local value.  Entry to a
function, or a special form such as `let', creates the local binding;
exit from the function or from the `let' removes the local binding. 
As long as the local binding lasts, the variable's value is stored
within it.  Use of `setq' or `set' while there is a local binding
stores a different value into the local binding; it does not create a
new binding.

  We also speak of the "global binding", which is where (conceptually)
the global value is kept.

  A variable can have more than one local binding at a time (for
example, if there are nested `let' forms that bind it).  In such a
case, the most recently created local binding that still exists is
the "current binding" of the variable.  If there are no local
bindings, the variable's current binding is its global binding. 
Ordinary evaluation of a symbol always returns the value of its
current binding.

  Sometimes we call the current binding the "most-local existing
binding", for emphasis.

  The special forms `let' and `let*' exist specifically to create local
bindings.

 * Special form: let (BINDINGS...) FORMS...

     This function binds variables according to BINDINGS and then
     evaluates all of the FORMS in textual order.  The `let'-form
     returns the value of the last form in FORMS.

     Each of the BINDINGS is either (i) a symbol, in which case that
     symbol is bound to `nil'; or (ii) a list of the form `(SYMBOL
     FORM)', in which case SYMBOL is bound to the result of
     evaluating FORM (FORM may be omitted, in which case `nil' is
     used).

     All of the FORMs in BINDINGS are evaluated in the order they
     appear and *before* any of the symbols are bound.  The example
     illustrates this: `Z' is bound to the old value of `Y', which is
     2, not the new value, 1.

          (setq Y 2)
               => 2
          (let ((Y 1) 
                (Z Y))
            (list Y Z))
               => (1 2)

 * Special form: let* (BINDINGS...) FORMS...

     This special form is like `let', except that the symbols in
     BINDINGS are bound as they are encountered before the remaining
     forms are evaluated.  Therefore, an expression in the BINDINGS
     may reasonably refer to symbols already bound by this BINDINGS. 
     Compare the following example with the example above for `let'.

          (setq Y 2)
               => 2
          (let* ((Y 1)
                 (Z Y))    ; Use the just-established value of `Y'.
            (list Y Z))
               => (1 1)

  Here is a complete list of the other situations which create local
bindings:

   * Function calls (*note Functions::.).

   * Macro calls (*note Macros::.).

   * `condition-case' (*note Errors::.).

  The number of local variable bindings at any given time, of all
variables combined, is limited to the value of `max-specpdl-size'
(*note Eval::.).  This limit is designed to catch infinite recursions.
If it gets in your way, you can set it as large as you like.



File: lispref,  Node: Void Variables,  Next: Defining Variables,  Prev: Local Variables,  Up: Variables

When a Variable is ``Void''
===========================

  If you have never given a symbol any value as a global variable, we
say that that symbol's global value is "void".  In other words, the
symbol's value cell does not have any Lisp object in it.  If you try
to evaluate this symbol, you get a `void-variable' error, rather than
a value.

  Note that a value of `nil' is not the same as void.  The symbol `nil'
is a Lisp object and can be the value of a variable just as any other
object can be; but it is *a value*.  A void variable does not have
any value.

  After you have given a variable a value, you can make it void once
more using `makunbound'.

 * Function: makunbound SYMBOL

     This function makes the current binding of SYMBOL void.  This
     causes any future attempt to use this symbol as a variable to
     signal the error `void-variable', unless or until you set it
     again.

     `makunbound' returns SYMBOL.

          (makunbound 'x)          ; Make the global value of `x' void.
               => x
          x
          error--> Symbol's value as variable is void: x

     If SYMBOL is locally bound, `makunbound' affects the most local
     existing binding.  This is the only way a symbol can have a void
     local binding, since all the constructs that create local
     bindings create them with values.  In this case, the voidness
     lasts at most as long as that binding does; when the binding is
     removed due to exit from the construct that made it, the
     previous or global binding is reexposed as usual, and the
     variable is no longer void unless the newly reexposed binding
     was void all along.

          (setq x 1)               ; Put a value in the global binding.
               => 1
          (let ((x 2))             ; Locally bind it.
            (makunbound 'x)        ; Void the local binding.
            x)
          error--> Symbol's value as variable is void: x
          x                        ; The global binding is unchanged.
               => 1
          
          (let ((x 2))             ; Locally bind it.
            (let ((x 3))           ; And again.
              (makunbound 'x)      ; Void the innermost-local binding.
              x))                  ; And refer: it's void.
          error--> Symbol's value as variable is void: x
          
          (let ((x 2))
            (let ((x 3))
              (makunbound 'x))     ; Void inner binding, then remove it.
            x)                     ; Now outer `let' binding is visible.
               => 2

  A symbol that has been made void with `makunbound' is
indistinguishable as a variable from one that has never received a
value and has always been void.

  You can use the function `boundp' to test whether a symbol is
currently void.

 * Function: boundp SYMBOL

     `boundp' returns `t' if SYMBOL is not void; to be more precise,
     if its current binding is not void.  It returns `nil' otherwise.

          (boundp 'abracadabra)                ; Starts out void.
               => nil
          (let ((abracadabra 5))               ; Locally bind it.
            (boundp 'abracadabra))
               => t
          (boundp 'abracadabra)                ; Still globally void.
               => nil
          (setq abracadabra 5)                 ; Make it globally nonvoid.
               => 5
          (boundp 'abracadabra)
               => t



File: lispref,  Node: Defining Variables,  Next: Accessing Variables,  Prev: Void Variables,  Up: Variables

Defining Global Variables
=========================

  You may declare your intention to use a symbol as a global variable
with `defconst' or `defvar'.

  In GNU Emacs Lisp, definitions serve three purposes.  First, they
inform the user who reads the code that certain symbols are
*intended* to be used as variables.  Second, they inform the Lisp
system of these things, supplying a value and documentation.  Third,
they provide information to utilities such as `etags' and
`make-docfile', which create data bases of the functions and
variables in a program.

  The difference between `defconst' and `defvar' is primarily a matter
of intent, of interest to human readers, but it also makes a
difference for initialization.  Emacs Lisp does not restrict the ways
in which a variable can be used based on `defconst' or `defvar'
declarations.

  A user-option defined in a library that is not loaded into Emacs by
default should be defined with `defvar', so that the user can give
his own value to the variable before loading the library.  If
`defconst' were used to define the user option, loading the library
would always override any previous value of the variable.

 * Special form: defvar SYMBOL [VALUE [DOC-STRING]]

     This special form informs a person reading your code that SYMBOL
     will be used as a variable that the programs are likely to set
     or change.  It is also used for all user-option variables except
     in the preloaded parts of Emacs.  Note that SYMBOL is not
     evaluated; the symbol to be defined must appear explicitly in
     the `defvar'.

     If SYMBOL already has a value (i.e., it is not void), VALUE is
     not even evaluated, and SYMBOL's value remains unchanged.  If
     SYMBOL is void and VALUE is specified, it is evaluated and
     SYMBOL is set to the result.  (If VALUE is not specified, the
     value of SYMBOL is not changed in any case.)

     The `defvar' form returns SYMBOL, but it is normally used at top
     level in a file where its value does not matter.

     If the DOC-STRING argument appears, it specifies the
     documentation for the variable.  (This opportunity to specify
     documentation is one of the main benefits of defining the
     variable.) The documentation is stored on the symbol under the
     property `variable-documentation'.  The Emacs help functions
     (*note Documentation::.) look for this property.

     If the first character of DOC-STRING is `*', it means that this
     variable is considered to be a user option.  This affects
     commands such as `set-variable' and `edit-options'.

     For example, the form below defines `foo' but does not set the
     value cell of `foo'.

          (defvar foo)
               => foo

     The second example sets the value of `bar' to `23', and gives it
     a documentation string.

          (defvar bar 23 "The normal weight of a bar.")
               => bar

     The following form changes the documentation string for `bar',
     making it a user option, but does not change the value (the
     addition `(1+ 23)' is not even performed, since `bar' is already
     nonvoid).

          (defvar bar (1+ 23) "*The normal weight of a bar.")
               => bar
          bar
               => 23

     Here is an equivalent expression for the `defvar' special form:

          (defvar SYMBOL VALUE DOC-STRING)
          ==
          (progn
            (if (not (boundp 'SYMBOL))
                (setq SYMBOL VALUE))
            (put 'SYMBOL 'variable-documentation 'DOC-STRING)
            'SYMBOL)

 * Special form: defconst SYMBOL [VALUE [DOC-STRING]]

     This special form informs a person reading your code that SYMBOL
     has a global value, established here, that will not normally be
     locally bound, or changed by the execution of the program.  The
     user, however, may be welcome to change it.  Note that SYMBOL is
     not evaluated; the symbol to be defined must appear explicitly
     in the `defconst'.

     `defconst' always evaluates VALUE and sets the global value of
     SYMBOL to the result, provided VALUE is given.

     Note: don't use `defconst' for user-option variables in
     libraries that are not normally loaded.  The user should be able
     to specify a value for such a variable in the `.emacs' file, so
     that it will be in effect if/when the library is loaded later.

     Here, `pi' is a constant which presumably ought not to be
     changed by anyone (attempts by the Indiana State Legislature
     notwithstanding).  However, as the second form illustrates, this
     is only advisory.

          (defconst pi 3 "Pi to one place.")
               => pi
          (setq pi 4)
               => pi
          pi
               => 4

 * Function: user-variable-p VARIABLE

     This function returns `t' if VARIABLE is a user option, intended
     to be set by the user for customization, as opposed to by
     programs.  (Other variables exist for the internal purposes of
     Lisp programs, and users need not know about them.)

     The decision is based on the first character of the property
     `variable-documentation' of VARIABLE.  If the property exists
     and is a string, and its first character is `*', then the result
     is `t'; otherwise, the result is `nil'.

  Note that if the `defconst' and `defvar' special forms are used while
the variable has a local binding, the local binding's value is set;
the global binding is therefore not changed.  But the normal way to
use these special forms is at top level in a file, where there should
be no relevant local bindings in effect.



File: lispref,  Node: Accessing Variables,  Next: Setting Variables,  Prev: Defining Variables,  Up: Variables

Accessing Variable Values
=========================

  The usual way to reference a variable is just to write the symbol
which names it (*note Symbol Forms::.).  However, this requires you
to choose the variable to reference when you write the program. 
Usually that is exactly what you want to do, but occasionally you
need to choose at run time which variable to reference.  Then you can
use `symbol-value'.

 * Function: symbol-value SYMBOL

     This function returns the value of SYMBOL.  This is the value in
     the innermost local binding of the symbol, or its global value
     if it has no local bindings.

          (setq abracadabra 5)
               => 5
          (setq foo 9)
               => 9
          
          ;; Here the symbol `abracadabra'
          ;; is the symbol whose value is examined.
          (let ((abracadabra 'foo))
            (symbol-value 'abracadabra))
               => foo
          
          ;; Here the value of `abracadabra',
          ;; which is `foo',
          ;; is the symbol whose value is examined.
          (let ((abracadabra 'foo))
            (symbol-value abracadabra))
               => 9
          
          (symbol-value 'abracadabra)
               => 5

     A `void-variable' error is signaled if SYMBOL has neither a
     local binding nor a global value.



File: lispref,  Node: Setting Variables,  Next: Variable Resolution,  Prev: Accessing Variables,  Up: Variables

How to Alter a Variable Value
=============================

 * Special form: setq [SYMBOL FORM]...

     This special form is the most common method of changing a
     variable's value.  Each SYMBOL is given a new value, which is
     the result of evaluating the corresponding FORM.  Naturally it
     is the most-local existing binding of each symbol that is changed.

     The value of the `setq' form is the value of the last FORM.

          (setq x (1+ 2))
               => 3
          x                     ; `x' now has a global value.
               => 3
          (let ((x 5)) 
            (setq x 6)          ; The local binding of `x' is set.
            x)
               => 6
          x                     ; The global value is unchanged.
               => 3

     Note that the first FORM is evaluated, then the first SYMBOL is
     set, then the second FORM is evaluated, then the second SYMBOL
     is set, and so on:

          (setq x 10            ; Notice that `x' is set
                y (1+ x))       ; before the value of `y' is computed.
               => 11

 * Function: set SYMBOL VALUE

     This function sets SYMBOL's value to VALUE, then returns VALUE. 
     Since `set' is a function, the expression written for SYMBOL is
     evaluated to obtain the symbol to be set.

     As usual, it is the most-local existing binding of the variable
     that is set.  If SYMBOL is not actually a symbol, a
     `wrong-type-argument' error is signaled.

          (set one 1)
          error--> Symbol's value as variable is void: one
          (set 'one 1)
               => 1
          (set 'two 'one)
               => one
          (set two 2)            ; `two' evaluates to symbol `one'.
               => 2
          one                    ; So it is `one' that was set.
               => 2
          (let ((one 1))         ; This binding of `one' is set,
            (set 'one 3)         ; not the global value.
            one)
               => 3
          one
               => 2

     Logically speaking, `set' is a more fundamental primitive that
     `setq'.  Any use of `setq' can be trivially rewritten to use
     `set'; `setq' could even be defined as a macro, given the
     availability of `set'.

     However, `set' itself is rarely used; beginners hardly need to
     know about it.  It is needed only when the choice of variable to
     be set is made at run time.  For example, the command
     `set-variable', which reads a variable name from the user and
     then sets it, needs to use `set'.

          Common Lisp Note: In Common Lisp, `set' always changes the
          symbol's special value, ignoring any lexical bindings.  In
          Emacs Lisp, all variables and all bindings are special, so
          `set' always affects the most local existing binding.



File: lispref,  Node: Variable Resolution,  Next: Buffer Local Variables,  Prev: Setting Variables,  Up: Variables

Local Variable Resolution
=========================

  There is only one canonical symbol `foo', but various variable values
may be in effect for it, from different places in the Lisp programs. 
Therefore, when the variable is evaluated, Emacs Lisp must decide
which of these values is currently in effect.  The process by which
this is done is called "variable resolution".

  Local bindings in Emacs Lisp have "indefinite scope" and "dynamic
extent".  "Scope" refers to *where* textually in the source code the
binding can be accessed.  "Extent" refers to *when*, as the program
is executing, the binding exists.  The combination of dynamic extent
and indefinite scope is called "dynamic scoping".  By contrast, most
programming languages use "lexical scoping", in which references to a
local variable must be textually within the function or block that
binds the variable.

     Common Lisp note: variables declared ``special'' in Common Lisp
     behave exactly this way.

* Menu:

* Impl of Scope::  How dynamic scoping is implemented in Emacs Lisp.
* Scope::          Scope means where in the program a value is visible.
                     Comparison with other languages.
* Extent::         Extent means how long in time a value exists.

 

File: lispref,  Node: Impl of Scope,  Next: Scope,  Prev: Variable Resolution,  Up: Variable Resolution

Sample Implementation of Dynamic Scoping
----------------------------------------

  A simple sample implementation (which is not how Emacs Lisp is
actually implemented) might help you understand dynamic binding.

  Suppose there is a stack of bindings: variable-value pairs.  To find
the value of a variable, search the stack from top to bottom for a
binding for that variable; the value from that binding is the value
of the variable.  To set the variable, search for a binding, then
store the new value into that binding.

  At entry to a function or to a `let' form, we can push bindings on
the stack for the arguments or local variables created there.  At
exit, we can remove those bindings.

  As you can see, a function's argument bindings remain in effect as
long as it continues execution, even during its calls to other
functions.  That is why we say the extent of the binding is dynamic. 
And these other functions can refer to the bindings, if they use
these variables.  That is why we say the scope is indefinite.

  Binding a variable in one function and using it in another is a
powerful technique, but if used without restraint, it can make
programs hard to understand.  There are two clean ways to use this
technique:

   * Only a few related functions, written close together in one
     file, use or bind the variable.  Its purpose is communication
     within one program.

     You should write comments to inform other programmers that they
     can see all uses of the variable before them, and to advise them
     not to add uses elsewhere.

   * The variable has a well-defined, documented meaning, and various
     functions refer to it (but do not bind it or set it) wherever
     that meaning is relevant.  For example, the variable
     `case-fold-search' is defined as ``non-`nil' means ignore case
     when searching''; various search and replace functions refer to
     it directly or through their subroutines, but do not bind or set
     it.

     Then you can bind the variable in other programs, knowing
     reliably what the effect will be.



File: lispref,  Node: Scope,  Next: Extent,  Prev: Impl of Scope,  Up: Variable Resolution

Scope
-----

  Emacs Lisp uses "indefinite scope" for local variable bindings.  This
means that it finds values of free variables by looking backward on
the (dynamic) call chain.  It follows that any function anywhere in
the program text might access a given binding of a variable. 
Consider the following function definitions:

     (defun binder (x)  ; `x' is bound in `binder'.
        (foo 5))        ; `foo' is some other function.
     
     (defun user ()     ; `x' is used in `user'.
       (list x))

  In a lexically scoped language, the binding of `x' from `binder'
would never be accessible in `user', because `user' is not textually
contained within the function `binder'.

  However, in dynamically scoped Emacs Lisp, `user' may or may not
refer to the binding of `x' established in `binder', depending on
circumstances:

   * If we call `user' directly without calling `binder' at all, then
     whatever binding of `x' is found, it won't be from `binder'.

   * If we define `foo' as follows and call `binder', then the
     binding made in `binder' will be seen in `user':

          (defun foo (lose)
            (user))

   * If we define `foo' as follows and call `binder', then the
     binding made in `binder' *will not* be seen in `user':

          (defun foo (x)
            (user))

     Here, when `foo' is called by `binder', it binds `x'.  (The
     binding in `foo' is said to "shadow" the one made in `binder'.) 
     Therefore, `user' will access the `x' bound by `foo' instead of
     the one bound by `binder'.



File: lispref,  Node: Extent,  Prev: Scope,  Up: Variable Resolution

Extent
------

  "Extent" refers to the time during program execution that a variable
name is valid.  In Emacs Lisp, a variable is valid only while the
form that bound it is executing.  This is called "dynamic extent". 
``Local'' or ``automatic'' variables in most languages, including C
and Pascal, have dynamic extent.

  One alternative to dynamic extent is "indefinite extent".  This means
that a variable binding can live on past the exit from the form that
made the binding.  Common Lisp and Scheme, for example, support this,
but Emacs Lisp does not.

  To illustrate this, the function below, `make-add', returns a
function that purports to add N to its own argument M.  This would
work in Common Lisp, but it does not work as intended in Emacs Lisp,
because after the call to `make-add' exits, the variable `n' is no
longer bound to the actual argument 2.

     (defun make-add (n)
         (function (lambda (m) (+ n m))))  ; Return a function.
          => make-add
     (fset 'add2 (make-add 2))  ; Define function add2 with (make-add 2).
          => (lambda (m) (+ n m))
     (add2 4)                   ; Try to add 2 to 4.
     error--> Symbol's value as variable is void: n



File: lispref,  Node: Buffer Local Variables,  Next: Default Value,  Prev: Variable Resolution,  Up: Variables

Buffer Local Variables
======================

  Global and local variables are common features of almost all
programming languages, if not necessarily in the same form that they
take in Emacs Lisp.  Emacs Lisp is meant for programming editing
commands, though, and the central object of editing is the buffer
(*Note Buffers::.)  Therefore, Emacs Lisp also supports "buffer-local
variables", which may have differing values in various buffers.

  A buffer-local variable has a buffer-local binding associated with a
particular buffer.  The binding is in effect when that buffer is
current; otherwise, it is not in effect.  If you set the variable
while a buffer-local binding is in effect, the new value goes in that
binding, so the global binding is unchanged; this means that the
change is visible in that buffer alone.

  A variable may have buffer-local bindings in some buffers but not in
others.  The global binding is shared by all the buffers that don't
have their own bindings.  Thus, if you set the variable in a buffer
that does not have a buffer-local binding for it, the new value is
visible in all buffers except those with buffer-local bindings. 
(Here we are assuming that there are no `let'-style local bindings to
complicate the issue.)

  The most common use of buffer-local bindings is for major modes to
change variables that control the behavior of commands.  For example,
C mode and Lisp mode both set the variable `paragraph-start' to
specify that only blank lines separate paragraphs.  They do this by
making the variable buffer-local in the buffer that is being put into
C mode or Lisp mode, and then setting it to the new value for that
mode.

  The usual way to make a buffer-local binding is with
`make-local-variable', which is what major mode commands use.  This
affects just the current buffer; all other buffers (including those
yet to be created) continue to share the global value.

  A more powerful operation is to mark the variable as "automatically
buffer local", with the function `make-variable-buffer-local'.  You
can think of this as making the variable local in all buffers, even
those yet to be created.  More precisely, the effect is that setting
the variable automatically makes the variable local to the current
buffer if it is not already so.  All buffers start out by sharing the
global value of the variable as usual, but any `setq' while in a
buffer creates a buffer-local binding for that buffer.  The new value
is stored in the buffer-local binding, leaving the (default) global
binding untouched.  The global value can no longer be changed with
`setq'; you need to use `setq-default' to do that.

  When a variable has local values in one or more buffers, you can get
Emacs very confused by binding the variable with `let', changing to a
different current buffer in which a different binding is in effect,
and then exiting the `let'.  The best way to preserve your sanity is
to avoid such situations.  If you use `save-excursion' around each
piece of code that changes the current buffer, you can never have
this problem.

  Local variables in a file you edit are also represented by
buffer-local bindings for the buffer that holds the file within Emacs.
*Note Auto Major Mode::.

 * Command: make-local-variable SYMBOL

     This function creates a buffer-local binding for SYMBOL in the
     current buffer.  Other buffers are not affected.  The value
     returned is SYMBOL.

     The buffer-local value of SYMBOL starts out as the same value
     SYMBOL previously had.

          ;; In buffer `b1':
          (setq foo 5)                ; Affects all buffers.
               => 5
          (make-local-variable 'foo)  ; Now it is local in `b1'.
               => foo
          foo                         ; That did not change the value.
               => 5
          (setq foo 6)                ; Change the value in `b1'.
               => 6
          foo
               => 6
          
          ;; In buffer `b2', the value hasn't changed.
          (save-excursion
            (set-buffer "b2")
            foo)
               => 5

 * Command: make-variable-buffer-local SYMBOL

     This function marks SYMBOL automatically buffer local, so that
     any attempt to set it will make it local to the current buffer
     at the time.

     The value returned is SYMBOL.

 * Function: buffer-local-variables &optional BUFFER

     This function tells you what the buffer local variables are in
     buffer BUFFER.  It returns an association list (*note
     Association Lists::.)  in which each pair is a buffer-local
     variable and its value.  If BUFFER is omitted, the current
     buffer is used.

          (setq lcl (buffer-local-variables))
               => ((fill-column . 75)
              (case-fold-search . t)
              ...
              (mark-ring #<marker at 5454 in buffers.texinfo>)
              (require-final-newline . t))

     Note that changing the values in this list will *not* change the
     local value of the variable.

 * Command: kill-local-variable SYMBOL

     This function deletes the buffer-local binding (if any) for
     SYMBOL in the current buffer.  As a result, the global (default)
     binding of SYMBOL are now visible in this buffer.  Usually this
     causes the value of SYMBOL to change, since the global value is
     not the same as the buffer-local value that was just eliminated.

     It is possible to kill the local binding of a variable which
     automatically becomes local when set.  This causes the variable
     to show its global value in the current buffer.  However, if you
     set the variable again, it will once again create a local value.

     `kill-local-variable' returns SYMBOL.

 * Function: kill-all-local-variables

     This function eliminates all the buffer-local variable bindings
     of the current buffer.  As a result, the buffer will see the
     default values of all variables.

     This function also resets certain other information pertaining
     to the buffer: its local keymap is set to `nil', its syntax
     table is set to the value of `standard-syntax-table', and its
     abbrev table is set to the value of
     `fundamental-mode-abbrev-table'.

     Every major mode command begins by calling this function, which
     has the effect of switching to Fundamental mode, and erasing
     most of the effects of the previous major mode.

     `kill-all-local-variables' returns `nil'.



File: lispref,  Node: Default Value,  Prev: Buffer Local Variables,  Up: Variables

The Default Value of a Buffer-Local Variable
============================================

  The functions `default-value' and `setq-default' allow you to access
and change the global value regardless of whether the current buffer
has a buffer-local binding.  You could use `setq-default' to change
the default setting of `paragraph-start' for most buffers; and this
would work even when you are in a C or Lisp mode buffer which has a
buffer-local value for this variable.

 * Function: default-value SYMBOL

     Return SYMBOL's default value.  This is the value that is seen
     in buffers that do not have their own values for this variable. 
     If SYMBOL is not buffer-local, than this is the same as
     `symbol-value' (*note Accessing Variables::.).

 * Special form: setq-default SYMBOL VALUE

     This function sets the default (global) value of SYMBOL to
     VALUE.  SYMBOL is not evaluated, but VALUE is.  The value of the
     `setq-default' form is VALUE.

     The default value is seen in buffers that do not have their own
     buffer-local values for this variable.

     If a SYMBOL is not buffer-local for the current buffer, this is
     equivalent to `setq' in the current buffer for that symbol.  If
     SYMBOL is buffer-local for the current buffer, then this changes
     the value that most other buffers will see (as long as they
     don't have a buffer-local value), but not the value that the
     current buffer sees.

          ;; In buffer `foo':
          (make-local-variable 'local)
               => local
          (setq local 'value-in-foo)
               => value-in-foo
          (setq-default local 'new-default)
               => new-default
          local
               => value-in-foo
          (default-value 'local)
               => new-default
          
          ;; In (the new) buffer `bar':
          local
               => new-default
          (default-value 'local)
               => new-default
          (setq local 'another-default)
               => another-default
          (default-value 'local)
               => another-default
          
          ;; Back in buffer foo:
          local
               => value-in-foo
          (default-value 'local)
               => another-default

 * Function: set-default SYMBOL VALUE

     This function is like `setq-default', except that SYMBOL is
     evaluated.

          (set-default (car '(a b c)) 23)
               => 23
          (default-value 'a)
               => 23



File: lispref,  Node: Functions,  Next: Macros,  Prev: Variables,  Up: Top

Functions
*********

  A Lisp program is composed mainly of Lisp functions.  This chapter
explains what functions are, how they accept arguments, and how to
define them.

* Menu:

* What Is a Function::    Lisp functions vs primitives; terminology.
* Lambda Expressions::    How functions are expressed as Lisp objects.
* Function Names::        A symbol can serve as the name of a function.
* Defining Functions::    Lisp expressions for defining functions.
* Calling Functions::     How to use an existing function.
* Mapping Functions::     Applying a function to each element of a list, etc.
* Anonymous Functions::   Lambda-expressions are functions with no names.    
* Function Cells::        Accessing or setting the function definition
                            of a symbol.
* Related Topics::        Cross-references to specific Lisp primitives
                            that have a special bearing on how functions work.

 

File: lispref,  Node: What Is a Function,  Next: Lambda Expressions,  Prev: Functions,  Up: Functions

What Is a Function
==================

  There are two kinds of functions in GNU Emacs Lisp: they may be
primitives written in C, or they may be defined in Lisp.  In Emacs
version 18.52, there are approximately 580 functions in 64 C source
files, and over 2600 functions in about 145 Lisp files.

  The C-coded functions are the built-in functions of Lisp; they appear
in Lisp as the special objects called "subrs".  These primitives
provide the lowest-level interfaces to editing functions or operating
system services, or in a very few cases, they exist to perform
certain important operations more quickly than a Lisp program could
do them.  Primitives can be modified or added only by changing the C
sources and recompiling the editor.  This is harder than writing Lisp
code, but not impossibly hard; see *Note Writing Emacs Primitives::.

  Most extensions to the Emacs editor are written in Lisp.  If you have
ever programmed other versions of Emacs you will find writing code
for GNU Emacs very pleasant; the Lisp provided is a true version of
Lisp, and functions that are used as editing commands do not require
any special calling sequence.

  Macros are an alternative to functions.  Macros differ from functions
in that they define new forms of Lisp syntax; they translate a Lisp
expression that you write into an equivalent expression to be
evaluated instead.  *Note Macros::, for how to define and use macros.

  We start by defining some terminology:

"function"
     A "function" in general is anything that can be applied to
     arguments in a Lisp program.  In some cases, we will uses it
     more specifically to mean a function written in Lisp.  Special
     forms and macros are not functions.

"primitive"
     A "primitive" is a function callable from Lisp that is written
     in C, such as `car' and `cdr'.  These are sometimes called
     "built-in" functions or "subrs".

"lambda expression"
     A "lambda expression" is a function written in Lisp.  These are
     described in the following section.

     *Note Lambda Expressions::.

"special form"
     A "special form" is a primitive that is like a function but does
     not evaluate all of its arguments in the usual way.  It may
     evaluate only some of the arguments, or may evaluate them in an
     unusual order, or several times.  Many special forms are
     described in *Note Control Structures::.

"command"
     A "command" is a function that is advertised to the user and can
     be invoked by the user with `M-x', or bound to a key in some
     keymap.  A function written in Lisp is a command if it contains
     an interactive declaration (*note Defining Commands::.).  Since
     a command is a function, it can be called from Lisp expressions
     like other functions; in this case, the fact that the function
     is a command makes no difference.

"keystroke command"
     A "keystroke command" is a command that is bound to a key
     sequence (typically one to three keystrokes).  The distinction
     is made here merely to avoid confusion with the meaning of
     ``command'' in non-Emacs editors; for programmers, the
     distinction is normally unimportant.



File: lispref,  Node: Lambda Expressions,  Next: Function Names,  Prev: What Is a Function,  Up: Functions

Lambda Expressions
==================

  A function written in Lisp is a list that looks like this:

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

(Such a list is called a "lambda expression" for historical reasons.)

* Menu:

* Lambda Components::	    The parts of a lambda expression.
* Simple Lambda::	    A simple example.
* Argument List::	    Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.

 

File: lispref,  Node: Lambda Components,  Next: Simple Lambda,  Prev: Lambda Expressions,  Up: Lambda Expressions

Components of a Lambda Expression
---------------------------------

  A function written in Lisp (a ``lambda expression'') is a list that
looks like this:

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

  The first element of this list is always the symbol `lambda'.  This
indicates that the list represents a function.  The reason `lambda'
is used in functions is so that other lists, intended for other uses,
will probably not be valid functions.

  The second element is a list of argument variable names (symbols). 
This is called the "lambda list".  When a Lisp function is called,
the argument values are matched up against the names in the lambda
list, which are given local bindings with the values provided.  *Note
Local Variables::.

  The documentation string is an actual string, which serves to
describe the function for the Emacs help system.  *Note Function
Documentation::.

  The interactive declaration is a list of the form `(interactive
CODE-STRING)'.  This declares how to provide arguments if the
function is used interactively.  Functions with this declaration are
called "commands"; they can be called using `M-x' or bound to a key. 
Functions not intended to be called in this way should not have
interactive declarations.  *Note Defining Commands::, for how to
write an interactive declaration.

  The rest of the elements are the "body" of the function: Lisp code to
execute, or, as a Lisp programmer would say, ``a list of Lisp forms
to evaluate''.  The value returned by the function is the value
returned by the last element of the body.



File: lispref,  Node: Simple Lambda,  Next: Argument List,  Prev: Lambda Components,  Up: Lambda Expressions

A Simple Lambda-Expression Example
----------------------------------

  Consider for example the following function:

     (lambda (a b c) (+ a b c))

We can call it just as we might call a named function, by using it as
the CAR of an expression, like this:

     ((lambda (a b c) (+ a b c))
      1 2 3)

The body of this lambda expression is evaluated with the variable `a'
bound to 1, `b' bound to 2, and `c' bound to 3.  Evaluation of the
body adds these three numbers, producing the result 6; therefore,
this call to the function returns the value 6.

  Note that the arguments can be the results of other function calls,
as in this example:

     ((lambda (a b c) (+ a b c))
      1 (* 2 3) (- 5 4))

Here all the arguments `1', `(* 2 3)', and `(- 5 4)' are evaluated,
left to right.  Then the function shown is applied to the argument
values 1, 6 and 1 to produce the value 8.

  Constructs such as shown here are rarely useful.  You can get the
same result, of making local variables and giving them values, using
the special form `let'.  And `let' is clearer and easier to write.

  But calls to explicit `lambda' expressions were very useful in the
old days of Lisp, before the special form `let' was invented.  At
that time, there was no other way to make a local variable and
initialize it.



File: lispref,  Node: Argument List,  Next: Function Documentation,  Prev: Simple Lambda,  Up: Lambda Expressions

Advanced Features of Argument Lists
-----------------------------------

  Our simple sample function,

     (lambda (a b c) (+ a b c))

specifies three arguments, so it must be called with three arguments:
if you try to call it with only two arguments or four arguments, you
will get a `wrong-number-of-arguments' error.

  It is often convenient to write a function that allows certain
arguments to be omitted.  For example, the function `substring'
accepts three arguments--a string, the start index and the end
index--but the third argument defaults to the end of the string if
you omit it.  It is also convenient for certain functions to accept
an indefinite number of arguments, as the functions `and' and `+' do.

  To specify optional arguments that may be omitted when a function is
called, simply include the keyword `&optional' before the optional
arguments.  To specify a list of zero or more extra arguments,
include the keyword `&rest' before one final argument.

  The complete syntax for an argument list is as follows:

     (REQUIRED-VARS...
      [&optional OPTIONAL-VARS...]
      [&rest REST-VAR])

The square brackets indicate that the `&optional' and `&rest'
clauses, and the variables that follow them, are optional.

  A call to the function requires one actual argument for each of the
REQUIRED-VARS.  There may be actual arguments for zero or more of the
OPTIONAL-VARS, and there cannot be any more actual arguments than
these unless `&rest' exists.  In that case, there may be any number
of extra actual arguments.

  If actual arguments for the optional and rest variables are omitted,
then they always default to `nil'.  However, the body of the function
is free to consider `nil' an abbreviation for some other meaningful
value.  This is what `substring' does; `nil' as the third argument
means to use the length of the string supplied.  There is no way for
the function to distinguish between an explicit argument of `nil' and
an omitted argument.

     Common Lisp Note: Common Lisp allows the function to specify
     what default values will be used when an optional argument is
     omitted; GNU Emacs Lisp always uses `nil'.

  For example, an argument list that looks like this:

     (a b &optional c d &rest e)

binds A and B to the first two actual arguments, which are required. 
If one or two more arguments are included, C and D are bound to them
respectively; any arguments after the first four are collected into a
list and E is bound to that list.  If there are only two arguments, C
is `nil'; if two or three arguments, D is `nil'; if four arguments or
fewer, E is `nil'.

  There is no way to have required arguments following optional
ones--it would not make sense.  To see why this must be so, suppose
that C in the example were optional and D were required.  If three
actual arguments are given; then what should be bound to the third
argument?  Similarly, it makes no sense to have any arguments after a
`&rest' argument.

  Here are some examples of argument lists:

     ((lambda (n) (1+ n))                ;One parameter:
      1)                                 ;requires exactly one argument
          => 2
     ((lambda (n &optional n1)           ;One parameter and one optional:
              (if n1 (+ n n1) (1+ n)))   ;1 or 2 arguments.
      1 2)
          => 3
     ((lambda (n &rest ns)                ;One parameter and &rest:
              (+ n (apply '+ ns)))        ;1 or more arguments.
      1 2 3 4 5)
          => 15



File: lispref,  Node: Function Documentation,  Prev: Argument List,  Up: Lambda Expressions

Documentation Strings of Functions
----------------------------------

  A lambda expression may optionally have a "documentation string" just
after the lambda list.  This string does not affect execution of the
function; it is a kind of comment, but a systematized comment which
actually appears inside the Lisp world and can be used by the Emacs
help system.  *Note Documentation::, for how the DOCUMENTATION-STRING
is displayed for the user.

  It is a good idea to provide documentation strings for all commands,
and for all other functions in your program that users of your
program should know about; internal functions might as well have only
comments, since they don't take up any room when your program is
loaded.

  The first line of the documentation string should be complete in
itself, because `apropos' displays just this first line.  It should
consist of one or two complete sentences that summarize the
function's purpose.

  The start of the documentation string is usually indented; since
these spaces come before the starting double-quote, they are not part
of the string.  Some people make a practice of indenting any
additional lines of the string so that the text lines up.  *This is a
mistake.* The indentation of the following lines is inside the
string; what looks nice in the source code will look ugly in the help
system.

  You may wonder how the documentation string could be optional, since
there are required components of the function that follow it (the
body).  Since evaluation of a string returns that string, without any
side effects, it has no effect if it is not the last form in the
body.  Thus, in practice, there is no confusion between the first
form of the body and the documentation string; if the only body form
is a string then it serves both as the return value and as the
documentation.



File: lispref,  Node: Function Names,  Next: Defining Functions,  Prev: Lambda Expressions,  Up: Functions

How a Function Can Have a Name
==============================

  In most computer languages, every function has a name; the idea of a
function without a name is nonsensical.  In Lisp, a function in the
strictest sense has no name.  It is simply a list whose first element
is `lambda', or a primitive subr-object.

  However, a symbol can serve as the name of a function.  This happens
when you put the function in the symbol's "function cell" (*note
Symbol Components::.).  Then the symbol itself becomes a valid,
callable function, equivalent to the list or subr-object that its
function cell refers to.  The contents of the function cell is also
spoken of as the symbol's "function definition".

  In practice, nearly all functions are given names in this way and
referred to through their names.  For example, the symbol `car' works
as a function and does what it does because the primitive subr-object
`#<subr car>' is stored in its function cell.

  We give functions names because it is more convenient to refer to
them by their names in other functions.  For primitive subr-objects
such as `#<subr car>', names are the only way you can refer to them:
there is no read syntax for such objects.  For functions written in
Lisp, the name makes it possible to refer to the function without
including a copy of it.  Also, a function with a name can refer to
itself--it can be recursive.  Writing the function's own name is much
more convenient than making the function point to itself (something
which is not impossible but which has various disadvantages in
practice).

  Functions are often identified with the symbols used to name them. 
For example, we often speak of ``the function `car''', not
distinguishing between the symbol `car' and the primitive subr-object
that is its function definition.  For most purposes, there is no need
to distinguish.

  Even so, keep in mind that a function need not have a unique name. 
While a given function object *usually* appears in the function cell
of only one symbol, this is just a matter of convenience.  It is very
easy to store it in several symbols using `fset'; then each of the
symbols is equally well a name for the same function.



File: lispref,  Node: Defining Functions,  Next: Calling Functions,  Prev: Function Names,  Up: Functions

Defining Named Functions
========================

  The usual way to create a function written in Lisp is to give it a
name at the same time.  This is called "defining a function", and it
is done with the `defun' special form.

 * Special form: defun NAME PARAMETER-LIST BODY-FORMS

     `defun' is the usual way to define new Lisp functions.  It
     defines the symbol NAME as a function which looks like this:

          (lambda PARAMETER-LIST . BODY-FORMS)

     This lambda expression is stored in the function cell of NAME. 
     The value returned by evaluating the `defun' form is NAME, but
     usually we ignore this value.

     As described previously (*note Lambda Expressions::.),
     PARAMETER-LIST is a list of parameter names and may include the
     keywords `&optional' and `&rest'.  Also, the first two forms in
     BODY-FORMS may be a documentation string and an interactive
     declaration.

     Note that the same NAME may also be used as a global variable
     since the value cell is independent of the function cell.  But
     take precautions against unintentionally redefining functions
     since `defun' will even redefine primitive functions such as
     `car' without any hesitation or notification.

          (defun foo () 5)
               => foo
          (foo)
               => 5
          
          (defun bar (a &optional b &rest c)
              (list a b c))
               => bar
          (bar 1 2 3 4 5)
               => (1 2 (3 4 5))
          (bar 1)
               => (1 nil nil)
          (bar)
          error--> Wrong number of arguments.
          
          (defun capitalize-backwards ()
            "This function makes the last letter of a word upper-case."
            (interactive)
            (backward-word 1)
            (forward-word 1)
            (backward-char 1)
            (capitalize-word 1))
               => capitalize-backwards



File: lispref,  Node: Calling Functions,  Next: Mapping Functions,  Prev: Defining Functions,  Up: Functions

Function Invocation
===================

  Defining functions is only half the battle.  Functions don't do
anything until you "call" them, which means, tell them to run.  This
process is also known as "invocation".

  The most common way of invoking a function is simply to evaluate a
list.  For example, evaluating the list `(concat "a" "b")' calls the
function `concat'.  *Note Evaluation::, for a description of
evaluation in general.

  When you evaluate a list, you have to specify the function name in
your program.  This means that the choice of which function to call
is made when you write the program.  Usually that's just what you want.
Occasionally you need to decide at run time which function to call. 
Then you can use the functions `apply' and `funcall'.

 * Function: funcall FUNCTION &rest ARGUMENTS

     `funcall' calls FUNCTION with ARGUMENTS, and returns whatever
     FUNCTION returns.

     Since `funcall' is a function, all of its arguments, including
     FUNCTION, are evaluated before `funcall' is called.  This means
     that you can use any expression to come up with the function to
     be called.  It also means that `funcall' does not see the
     expressions you write for the ARGUMENTS, only their values.

     The ARGUMENTS are *not* evaluated a second time in the act of
     calling FUNCTION.  `funcall' enters the normal procedure for
     calling a function at the place where the arguments have already
     been evaluated.     FUNCTION must be either a Lisp function or a
     primitive function.  Special forms and macros are not allowed,
     because they make sense only when given the ``unevaluated''
     argument expressions.  `funcall' cannot give these because, as
     we saw above, it never sees them in the first place.

          (setq f 'list)
               => list
          (funcall f 'x 'y 'z)
               => (x y z)
          (funcall f 'x 'y '(z))
               => (x y (z))
          (funcall 'and t nil)
          error--> Invalid function: #<subr and>

     Compare this example with that of `apply'.

 * Function: apply FUNCTION &rest ARGUMENTS

     `apply' calls FUNCTION with ARGUMENTS, just like `funcall' but
     with one difference: the last of ARGUMENTS is a list of
     arguments to give to FUNCTION, rather than a single argument. 
     We also say that this list is "appended" to the other arguments.

     `apply' returns the result of that call to FUNCTION.  As with
     `funcall', FUNCTION must either be a Lisp function or a
     primitive function; special forms and macros do not make sense
     to apply.

          (setq f 'list)
               => list
          (apply f 'x 'y 'z)
          error--> Wrong type argument: listp, z
          (apply f 'x 'y '(z))
               => (x y z)
          (apply f '(x y z))
               => (x y z)
          
          (apply 'append '((a b c) nil (x y z) nil))
               => (a b c x y z)

     An interesting example of using `apply' is found in the
     description of `mapcar'; see the following section.



File: lispref,  Node: Mapping Functions,  Next: Anonymous Functions,  Prev: Calling Functions,  Up: Functions

Mapping Functions
=================

  A "mapping function" applies a given function to each element of a
list or other collection.  Emacs Lisp has three such functions: two,
`mapcar' and `mapconcat', which scan a list, are described here. 
(The third function is `mapatoms'; see *Note Creating Symbols::.)

 * Function: mapcar FUNCTION SEQUENCE

     `mapcar' applies FUNCTION to each element of SEQUENCE in turn. 
     The results are made into a `nil'-terminated list.

     The argument SEQUENCE may be a list, a vector or a string.  The
     result is always a list.  The length of the result is the same
     as the length of SEQUENCE.

     For example:

          (mapcar 'car '((a b) (c d) (e f)))
               => (a c e)
          (mapcar '1+ [1 2 3])
               => (2 3 4)
          (mapcar char-to-string "abc")
               => ("a" "b" "c")
          
          ;; Call each function in `my-hooks'.
          (mapcar 'funcall my-hooks)
          
          (defun mapcar* (f &rest args)
            "Apply FUNCTION to successive cars of all ARGS, until one ends.
          Return the list of results."
            (cons (apply f (mapcar 'car args))       ; Apply function to CARs.
                  (let ((rest (mapcar 'cdr args)))
                    (if (not (memq 'nil rest))
                        (apply 'mapcar* f rest)))))  ; Do the same for CDRs.
          
          (mapcar* 'cons '(a b c) '(1 2 3 4))
               => ((a . 1) (b . 2) (c . 3))

 * Function: mapconcat FUNCTION SEQUENCE SEPARATOR

     `mapconcat' applies FUNCTION to each element of SEQUENCE: the
     results, which must be strings, are concatenated.  Between each
     pair of result strings, `mapconcat' inserts the string
     SEPARATOR.  Usually SEPARATOR contains a space or comma or other
     suitable punctuation.

     FUNCTION must be a function that can take one argument and
     returns a string.

          (mapconcat 'symbol-name
                     '(The cat in the hat)
                     " ")
               => "The cat in the hat"
          
          (mapconcat (function (lambda (x) (format "%c" (1+ x))))
                     "HAL-8000"
                     "")
               => "IBM.9111"



File: lispref,  Node: Anonymous Functions,  Next: Function Cells,  Prev: Mapping Functions,  Up: Functions

Anonymous Functions
===================

  In Lisp, a function is a list with a certain format (or a
subroutine); names are ``extra''.  Although usually functions are
defined with `defun' and given names at the same time, it is
occasionally more concise to use an anonymous function--a list that
starts with `lambda'.

  Any method of creating such a list makes a valid function.  Even this:

     (setq silly (append '(lambda (x)) (list (list '+ (* 3 4) 'x))))
          => (lambda (x) (+ 12 x))

This computes a list that looks like `(lambda (x) (+ 12 x))' and
makes it the value (*not* the function definition!) of `silly'.

  Here is how we might call this function:

     (funcall silly 1)
          => 13

(It does *not* work to write `(silly 1)', because this function is
not the *function definition* of `silly'.  We have not given `silly'
any function definition, just a value as a variable.)

  But most of the time, anonymous functions are constants which appear
in your program.  For example, you might want to pass one as an
argument to the function `mapcar', which applies any given function
to each element of a list.  Here we pass an anonymous function that
multiplies a number by two:

     (defun double-each (list)
       (mapcar '(lambda (x) (* 2 x)) list))
          => double-each
     (double-each '(2 11))
          => (4 22)

In such cases, we usually use `function' instead of simple quotation.

 * Special form: function FUNCTION-OBJECT

     This special form returns FUNCTION-OBJECT without evaluating it.
     In this, it is equivalent to `quote'.  However, it serves as a
     note to the Emacs Lisp compiler that FUNCTION-OBJECT is intended
     to be used only as a function, and therefore can safely be
     compiled.  *Note Quoting::, for comparison.

  Using `function' instead of `quote' makes a difference inside a
function or macro that you are going to compile.  For example:

     (defun double-each (list)
       (mapcar (function (lambda (x) (* 2 x))) list))
          => double-each
     (double-each '(2 11))
          => (4 22)

If this definition of `double-each' is compiled, the anonymous
function is compiled as well.  In the previous definition, above, the
argument passed to `mapcar' is the precise list shown:

     (lambda (arg) (+ arg 5))

This is because the Lisp compiler cannot assume this list is a
function, even though it looks like one, and it does not know what
`mapcar' does with the list.  Perhaps `mapcar' will check that the
CAR of the third element is the symbol `+'!  We use `function' to
tell the compiler to go ahead and compile.

  We also often write `function' instead of `quote' when quoting the
name of a function, but then it is just a sort of comment.

     (function SYMBOL) == (quote SYMBOL) == 'SYMBOL

  See `documentation' in *Note Accessing Documentation::, for a
realistic example using `function' and an anonymous function.



File: lispref,  Node: Function Cells,  Next: Related Topics,  Prev: Anonymous Functions,  Up: Functions

Accessing Function Cell Contents
================================

  The "function definition" of a symbol is the object stored in the
function cell of the symbol.  The functions described here access,
test, and set the function cell of symbols.

 * Function: symbol-function SYMBOL

     Returns the object in the function cell of SYMBOL.  If the
     symbol's function cell is void, a `void-function' error is
     signaled.

     This function does not check that the object is a legitimate
     function.

          (defun bar (n) (+ n 2))
               => bar
          (symbol-function 'bar)
               => (lambda (n) (+ n 2))
          (fset 'baz 'bar)
               => bar
          (symbol-function 'baz)
               => bar

 * Function: subrp OBJECT

     This function returns `t' if OBJECT is a built-in function (i.e.
     a Lisp primitive).

          (subrp 'message)                ; `message' is a symbol,
               => nil                   ; not a subr object.
          (subrp (symbol-function 'message))
               => t

  If you have never given a symbol any function definition, we say that
that symbol's function cell is "void".  In other words, the function
cell does not have any Lisp object in it.  If you try to call this
symbol as a function, the result is a `void-function' error.

  Note that void is not the same as `nil' or the symbol `void'.  The
symbols `nil' and `void' are Lisp objects, and can be stored into a
function cell just as any other object can be (and they can be valid
functions if you define them in turn with `defun'); but they are
*something*.  A void function cell contains no object whatever.

  You can test the voidness of a symbol's function definition with
`fboundp'.  After you have given a symbol a function definition, you
can make it void once more using `fmakunbound'.

 * Function: fboundp SYMBOL

     Returns `t' if the symbol has an object in its function cell,
     `nil' otherwise.  It does not check that the object is a
     legitimate function.

 * Function: fmakunbound SYMBOL

     This function sets the symbol's function pointer to be ``void''
     (not the *symbol* `void'), so that any attempt to access this
     cell will cause a `void-function' error.  (See also
     `makunbound', in *Note Local Variables::.)

          (defun foo (x) x)
               => x
          (fmakunbound 'foo)
               => x
          (foo 1)
          error--> Symbol's function definition is void: foo

 * Function: fset SYMBOL OBJECT

     This function sets the function cell of SYMBOL to be OBJECT. 
     The result is OBJECT.  Normally OBJECT should be a function or
     the name of one, but this is not checked.

     There are three normal uses of this function:

        * Copying one symbol's function definition to another.  (In
          other words, making an alternate name for a function.)

        * Giving a symbol a function definition that is not a list
          and therefore cannot be made with `defun'.  *Note
          Classifying Lists::, for an example of this usage.

        * In constructs for defining or altering functions.  If
          `defun' were not a primitive, it could be written in Lisp
          (as a macro) using `fset'.

     Here are examples of the first two uses:

          ;; Give `first' the same definition `car' has.
          (fset 'first (symbol-function 'car))
               => #<subr car>
          (first '(1 2 3))
               => 1
          
          ;; Make the symbol `car' the function definition of `xfirst'.
          (fset 'xfirst 'car)
               => car
          (xfirst '(1 2 3))
               => 1
          (symbol-function 'xfirst)
               => car
          (symbol-function (symbol-function 'xfirst))
               => #<subr car>

  When writing a function that extends a previously defined function,
the following idiom is often used:

     (fset 'old-foo (symbol-function 'foo))
     
     (defun foo ()
       "Just like old-foo, except more so."
       (old-foo)
       (more-so))

This does not work properly if `foo' had been defined to autoload,
like this:

     autoload 'foo "foo-file" "This function doesn't do much.")

In this case, when `foo' calls `old-foo', Lisp will attempt to define
`old-foo' by loading the file `foo-file'.  Since this file defines
`foo' rather than `old-foo', the autoload will get an error.

The only way to avoid the problem is to make sure `foo-file' is
loaded before moving aside the old definition of `foo'.



File: lispref,  Node: Related Topics,  Prev: Function Cells,  Up: Functions

Other Topics Related to Functions
=================================

  Here is a table of several functions that do things related to
function calling and function definitions.

`apply'
     *Note Calling Functions::.

`funcall'
     *Note Calling Functions::.

`eval'
     *Note Eval::.

`mapatoms'
     *Note Creating Symbols::.

`mapcar'
     *Note Mapping Functions::.

`mapconcat'
     *Note Mapping Functions::.

`documentation'
     *Note Documentation::.

`interactive'
     *Note Interactive Call::.

`call-interactively'
     *Note Interactive Call::.

`interactive-p'
     *Note Interactive Call::.

`commandp'
     *Note Command Overview::.

`autoload'
     *Note Autoload::.

`ignore'
     *Note Key Lookup::.

`undefined'
     *Note Key Lookup::.



File: lispref,  Node: Macros,  Next: Control Structures,  Prev: Functions,  Up: Top

Macros
******

"Macros" enable you to define new control constructs and other
language features.  A macro is defined much like a function; but
instead of saying how to compute a value, it says how to compute
another Lisp expression which will compute the value.  We call this
expression the "expansion" of the macro.

Macros can do this because they operate on the unevaluated
expressions for the arguments, not on the argument values as
functions do.  Therefore they can construct an expansion containing
these argument expressions, or parts of them.

* Menu:

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Backquote::               Easier construction of list structure.
* Problems with Macros::    Don't evaluate the macro arguments too many times.
                              Don't hide the user's variables.

 

File: lispref,  Node: Simple Macro,  Next: Expansion,  Prev: Macros,  Up: Macros

A Simple Example of a Macro
===========================

Suppose we would like to define a Lisp construct to increment a
variable value, much like the `++' operator in C.  We would like to
write `(inc x)' and have the effect of `(setq x (1+ x))'.  Here is
how to do it:

     (defmacro inc (var)
        (list 'setq var (list '1+ var)))

When called as `(inc x)', the argument `var' has the value `x'--*not*
the *value* of `x'.  The body of the macro uses this to construct the
expansion, which is `(setq x (1+ x))'.  Once the macro definition
returns this expansion, Lisp proceeds to evaluate it, thus
incrementing `x'.



File: lispref,  Node: Expansion,  Next: Compiling Macros,  Prev: Simple Macro,  Up: Macros

Expansion of a Macro Call
=========================

This section describes in detail the process of expanding a macro call.

A macro call looks just like a function call: it is a list which
starts with the name of the macro.  The rest of the elements of the
list are the arguments of the macro.

Evaluation of the macro call begins like evaluation of a function
call except for one crucial difference: the macro arguments are the
actual expressions appearing in the macro call.  They are not
evaluated before they are given to the macro definition.  By
contrast, the arguments of a function are results of evaluating the
elements of the function call list.

Having obtained the arguments, Lisp invokes the macro just as a
function is invoked.  The argument variables of the macro are bound
to the argument values from the macro call, or to a list of them in
the case of a `&rest' argument.  And the macro body executes and
returns its value just as a function body does.

Now comes the second crucial difference between macros and functions:
the value returned by the macro body is not the value of the macro
call.  Instead, it is an alternate expression for computing that
value, also known as the "expansion" of the macro.  The Lisp
interpreter therefore proceeds to evaluate the expansion as soon as
it comes back from the macro.

Since the expression is evaluated normally, it may contain calls to
other macros.  It may even be a call to the same macro, though this
is unusual.

You can see what a macro call would expand into by means of
`macroexpand':

 * Function: macroexpand FORM &optional ENVIRONMENT

     This function expands FORM, if it is a macro call.  If the
     result is another macro call, it is expanded in turn, until
     something which is not a macro call results.  That is the value
     returned by `macroexpand'.  If FORM is not a macro call to begin
     with, it is returned as given.

     Note that `macroexpand' does not look at the subexpressions of
     FORM (although some macro definitions may do so).  If they are
     macro calls themselves, `macroexpand' will not expand them.

     If ENVIRONMENT is provided, it specifies an alist of macro
     definitions that shadow the currently defined macros.  This is
     used by byte-compilation.

          (defmacro inc (var)
              (list 'setq var (list '1+ var)))
               => inc
          
          (macroexpand '(inc r))
               => (setq r (1+ r))
          
          (defmacro inc2 (var1 var2)
              (list 'progn (list 'inc var1) (list 'inc var2)))
               => inc2
          
          (macroexpand '(inc2 r s))
               => (progn (inc r) (inc s))        ; `inc' not expanded here.

 

File: lispref,  Node: Compiling Macros,  Next: Defining Macros,  Prev: Expansion,  Up: Macros

Macros and Byte-Compilation
===========================

You might ask why we take the trouble to compute an expansion for a
macro and then evaluate the expansion.  Why not have the macro body
produce the desired results directly?  The reason has to do with the
Lisp compiler.

When a macro call appears in a Lisp program being compiled, the Lisp
compiler calls the macro definition just as the interpreter would,
and receives an expansion.  But instead of evaluating this expansion,
it compiles it.  As a result, the compiled code produces the value
and side effects that we want, and it executes just as fast as if we
had written the expansion ourselves.  This would be impossible if the
macro body computed the value and side effects itself--they would be
computed at compile time, which is not useful.

In order for compilation of macro calls to work, the macros must be
defined in Lisp when the calls to them are compiled.  The compiler
has a special feature to help you do this: if a file being compiled
contains a `defmacro' form, the macro is defined temporarily for the
rest of the compilation of that file.  To use this, you must define
the macro in the same file where it is used, and before its first
use.  Alternatively, you can put your macro definitions in a separate
file and load that file before doing any compilation.



File: lispref,  Node: Defining Macros,  Next: Backquote,  Prev: Compiling Macros,  Up: Macros

Defining Macros
===============

  A Lisp macro is a list whose CAR is `macro'.  Its CDR should be a
function; expansion of the macro works by applying the function (with
`apply') to the list of unevaluated argument-expressions from the
macro call.

  You can use an anonymous Lisp macro just like an anonymous function,
but this is never done, because it does not make sense to pass an
anonymous macro to mapping functions such as `mapcar'.  In practice,
all Lisp macros have names, and they are usually defined with the
special form `defmacro'.

 * Special form: defmacro NAME PARAMETER-LIST BODY-FORMS...

     `defmacro' defines the symbol NAME as a macro which looks like
     this:

          (macro lambda PARAMETER-LIST . BODY-FORMS)

     This macro-object is stored in the function cell of NAME.  The
     value returned by evaluating the `defmacro' form is NAME, but
     usually we ignore this value.

     The shape and meaning of PARAMETER-LIST is the same as in a
     function, and the keyword `&rest' and `&optional' may be used
     (*note Argument List::.).  Macros may have a documentation
     string, but any `interactive' declaration is ignored since
     macros cannot be called interactively.



File: lispref,  Node: Backquote,  Next: Problems with Macros,  Prev: Defining Macros,  Up: Macros

Backquote
=========

It could prove rather awkward to write macros of significant size,
simply due the number of times the function `list' needs to be
called.  To make writing these forms easier, a macro ``' (pronounced
"backquote") exists.

  Backquote allows you to quote a list, but selectively evaluate
elements of that list.  In its simplest form, it is identical to the
special form `quote'.  In the example below, the two forms yield
identical results.

     (` (a list of (+ 2 3) elements))
          => (a list of (+ 2 3) elements)
     (quote (a list of (+ 2 3) elements))
          => (a list of (+ 2 3) elements)

By inserting a special marker, `,', inside of the argument to
backquote, it is possible to evaluate desired portions of the argument:

     (list 'a 'list 'of (+ 2 3) 'elements)
          => (a list of 5 elements)
     (` (a list of (, (+ 2 3)) elements))
          => (a list of 5 elements)

 * Macro: ` LIST

     This macro returns LIST as quote would, except any sublist
     beginning with the special marker `,' will have its second
     element evaluated.

     If any of these specially marked sublists contain more than two
     elements, those elements will be ignored.

     There are several subtle bugs that should simply be avoided. 
     The following forms do not work as one would expect:

          ;; Use of a `,' expression as the CDR of a list.
          (` (a . (, 1)))					; Not `(a . 1)'
               => (a \, 1)                                
          ;; Use of `,' in a vector.
          (` [a (, 1) c])					; Not `[a 1 c]'
               error--> Wrong type argument                      
          ;; Use of a `,' as the entire argument of ``'.
          (` (, 2))					; Not 2
               => (\, 2)                                  
          
          (` (a list of (, (list (+ 2 3))) elements xx))
           => (a list of (5) elements xx)



File: lispref,  Node: Problems with Macros,  Prev: Backquote,  Up: Macros

Common Problems Using Macros
============================

When defining a macro you must always pay attention to how many times
the arguments will be evaluated when the expansion is executed.  To
illustrate this problem, here is a macro to facilitate iteration. 
This macro allows us to write a simple ``for'' loop such as one might
find in Pascal.

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop, e.g.,
         (for i from 1 to 10 do (print i))."
     
       (list 'let (list (list var init))
             (cons 'while (cons (list '<= var final)
                                (append body (list (list 'inc var)))
                                ))))
          => for
     
     (for i from 1 to 3 do
        (setq square (* i i))
        (princ (format "\n%d %d" i square)))
     ==>
     (let ((i 1))
       (while (<= i 3)
         (setq square (* i i))
         (princ (format "%d      %d" i square))
         (inc i)))
     
          -|1       1
          -|2       4
          -|3       9
          => nil

The arguments `from', `to', and `do' in this macro are ``syntactic
sugar''; they are entirely ignored.  The idea is that you will write
noise words (such as `from', `to', and `do') in those positions in
the macro call.

This macro suffers from the defect that FINAL is evaluated on every
iteration.  If FINAL is a constant, there's no problem.  If it had
been a more complex form, say `(long-complex-calculation x)', it
would slow down the execution significantly.  If FINAL has side
effects, executing it more than once could be disastrous.

A well-designed macro takes steps to avoid this problem by producing
an expansion that evaluates the argument expressions exactly once
unless they are supposed to be repeated.  Here is a suitable
expansion for the `for' macro:

     (let ((i 1)
           (max 3))
       (while (<= i max)
         (setq square (* i i))
         (princ (format "%d      %d" i square))
         (inc i)))

Here is a macro definition that creates this expansion:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       (` (let (( (, var) (, init) )
                ( max (, final) ))
            (while (<= (, var) max)
                   (,@ body)
                   (inc (, var))
                   ))))

However, this definition has a different problem: it introduces a
local variable named `max' which the user does not expect.  This will
cause trouble in examples such as the following:

     (let ((max 0))
       (for x from 0 to 10 do
         (let ((this (frob x)))
           (if (< max this)
               (setq max this)))))

where the references to `max' inside the body of the `for', which are
supposed to refer to the user's binding of `max', will get instead
the binding made by `for'.

The way to correct this is to use an uninterned symbol instead of
`max' (*note Creating Symbols::.).  The uninterned symbol can be
bound and referred to just like any other symbol; but if it is
created by `for', we know that it cannot appear in the user's
program.  And since it is not interned, there is no way the user can
put it into the program later.  It will not appear anywhere except
where put by `for'.  Here is a definition of `for' which works this
way:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       (let ((tempvar (make-symbol "max")))
         (` (let (((, var) (, init))
                  ((, tempvar) (, final)))
              (while (<= (, var) (, tempvar))
                     (,@ body)
                     (inc (, var)))))))

This creates an uninterned symbol named `max' and puts it in the
expansion where the canonical, interned symbol `max' was used
previously.

Another problem can happen if you evaluate any of the macro argument
expressions during the computation of the expansion: if it is
supposed to refer to the user's variables, you may have trouble if
the user happens to use a variable with the same name as one of the
macro arguments.  The problem is that inside the macro body, the
macro argument binding is the most local binding of this variable, so
any references inside the form being evaluated will refer to it. 
Here is an example:

     (defmacro foo (a)
       (list 'setq (eval a) t))
          => foo
     (setq x 'b)
     (foo x) ==> (setq b t)
          => t                  ; and `b' has been set.
     but
     (setq a 'b)
     (foo a) ==> (setq 'b t)   ; invalid!
     error--> Symbol's value is void: b

Here it makes a difference whether the user types `a' or `x', because
`a' conflicts with the macro argument variable `a'.

In general it is better to avoid calling `eval' in a macro definition
at all.



File: lispref,  Node: Control Structures,  Next: Evaluation,  Prev: Macros,  Up: Top

Control Structures
******************

  A Lisp program consists of expressions or "forms" (*note Forms::.). 
We control the order of execution of the forms by enclosing them in
"control structures".  Control structures are special forms which
control when, whether, or how many times to execute the forms they
contain.

  The simplest control structure is sequential execution: first form A,
then form B, and so on.  This is what happens when you write several
forms in succession in the body of a function, or at top level in a
file of Lisp code.  The forms are executed in the order they are
written.  We call this "textual order".  For example, if a function
body consists of two forms A and B, evaluation of the function
evaluates first A and then B, and the function's value is the value
of B.

  Naturally, Emacs Lisp has many kinds of control structures, including
other varieties of sequencing, function calls, conditionals,
iteration, and (controlled) jumps.  These control structures are
special forms since their subforms are not necessarily evaluated. 
You can use macros to define your own control structure constructs
(*note Macros::.).

* Menu:

* Sequencing::             Evaluation in textual order.
* Conditionals::           `if', `cond'.
* Combining Conditions::   `and', `or', `not'.
* Iteration::              `while' loops.
* Nonlocal Exits::         Jumping out of a sequence.

 

File: lispref,  Node: Sequencing,  Next: Conditionals,  Prev: Control Structures,  Up: Control Structures

Sequencing
==========

  Evaluating forms in the order they are written is the most common
control structure.  Sometimes this happens automatically, such as in
a function body.  Elsewhere you must use a control structure
construct to do this: `progn', the simplest control construct of Lisp.

  A `progn' special form looks like this:

     (progn A B C ...)

and it says to execute the forms A, B, C and so on, in that order. 
These forms are called the body of the `progn' form.  The value of
the last form in the body becomes the value of the entire `progn'.

  When Lisp was young, `progn' was the only way to execute two or more
forms in succession and use the value of the last of them.  But
programmers found they often needed to use a `progn' in the body of a
function, where (at that time) only one form was allowed.  So the
body of a function was made into an ``implicit `progn''': several
forms are allowed just as in the body of an actual `progn'.  Many
other control structures likewise contain an implicit `progn'.  As a
result, `progn' is not used as often as it used to be.  It is needed
now most often inside of an `unwind-protect', `and', or `or'.

 * Special form: progn FORMS...

     This special form evaluates all of the FORMS, in textual order,
     returning the result of the final form.

          (progn (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
               => "The third form"

  Two other control constructs likewise evaluate a series of forms but
return a different value:

 * Special form: prog1 FORM1 FORMS...

     This special form evaluates FORM1 and all of the FORMS, in
     textual order, returning the result of the first form.

          (prog1 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
               => "The first form"

     Here is a way to remove the first element from a list in the
     variable `x', then go ahead and use that element:

          (foo (prog1 (car x) (setq x (cdr x))))

 * Special form: prog2 FORM1 FORM2 FORMS...

     This special form evaluates FORM1, FORM2, and all of the
     following FORMS, in textual order, returning the result of the
     second form.

          (prog2 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
               => "The second form"



File: lispref,  Node: Conditionals,  Next: Combining Conditions,  Prev: Sequencing,  Up: Control Structures

Conditionals
============

  Conditional control structures choose among alternatives.  Emacs Lisp
has two conditional forms: `if', which is much the same as in other
languages, and `cond', which is a generalized case statement.

 * Special form: if CONDITION THEN-FORM ELSE-FORMS...

     `if' chooses between the THEN-FORM and the ELSE-FORMS based on
     the value of CONDITION.  If the evaluated CONDITION is
     non-`nil', THEN-FORM is evaluated and the result returned. 
     Otherwise, the ELSE-FORMS are evaluated in textual order, and
     the value of the last one is returned.  (The ELSE part of `if'
     is an example of an implicit `progn'.  *Note Sequencing::.)

     If CONDITION has the value `nil', and no ELSE-FORMS are given,
     `if' returns `nil'.

     `if' is a special form because the branch which is not selected
     is never evaluated--it is ignored.  Thus, in the example below,
     `true' is not printed because `print' is never called.

          (if nil 
              (print 'true) 
            'very-false)
               => very-false

 * Special form: cond CLAUSE...

     `cond' chooses among an arbitrary number of alternatives.  Each
     CLAUSE in the `cond' must be a list.  The CAR of this list is
     the CONDITION; the remaining elements, if any, the BODY-FORMS. 
     Thus, a clause looks like this:

          (CONDITION BODY-FORM...)

     `cond' tries the clauses in textual order, by evaluating the
     CONDITION of each clause.  If the value of CONDITION is
     non-`nil', the BODY-FORMS are evaluated, and the value of the
     last BODY-FORM becomes the value of the `cond'.  The remaining
     clauses are ignored.

     If the value of CONDITION is `nil', the clause ``fails'', so the
     CONDITION of the following clause is tried.

     If no CONDITION evaluates to non-`nil', so that every clause
     fails, `cond' returns `nil'.

     In the following example, if the value of `x' is a number, then
     it is returned, but if `x' is not a number, then Emacs tests
     whether it is a string; and if is not a string, Emacs tests
     whether it is a symbol.

          (cond ((numberp x) x)
                 ((stringp x) x)
                 ((symbolp x) (symbol-value x)))

     A clause may also look like this:

          (CONDITION)

     Then, if CONDITION is non-`nil' when tested, the value of
     CONDITION becomes the value of the `cond' form.

     Often we want the last clause to be executed whenever none of
     the previous clauses was successful.  To do this, we use `t' as
     the CONDITION of the last clause, like this: `(t BODY-FORMS)'. 
     The form `t' evaluates to `t', which is never `nil', so this
     clause never fails, provided the `cond' gets to it at all.

     For example,

          (cond ((eq a 1) 'foo)
                (t "default"))
               => "default"

     This expression is a `cond' which returns `foo' if the value of
     `a' is 1, and returns the string `"default"' otherwise.

Both `cond' and `if' can usually be written in terms of the other. 
Therefore, the choice between them is a matter of taste and style. 
For example:

     (if A B C)
     ==
     (cond ((A B) (t C))



File: lispref,  Node: Combining Conditions,  Next: Iteration,  Prev: Conditionals,  Up: Control Structures

Constructs for Combining Conditions
===================================

  This section describes three constructs that are often used together
with `if' and `cond' to express complicated conditions.

  The constructs `and' and `or' can also be used individually as kinds
of multiple conditional constructs.

 * Function: not CONDITION

     This function tests for the falsehood of CONDITION.  It returns
     `t' if CONDITION is `nil', and `nil' otherwise.  The function
     `not' is identical to `null', and we recommend using `null' if
     you are testing for an empty list.

 * Special form: and CONDITIONS...

     The `and' special form tests whether all the CONDITIONS are
     true.  It works by evaluating the CONDITIONS one by one in the
     order written.

     If any of the CONDITIONS evaluates to `nil', then the result of
     the `and' must be `nil' regardless of the remaining CONDITIONS;
     so the remaining CONDITIONS are ignored and the `and' returns
     right away.

     If all the CONDITIONS turn out non-`nil', then the value of the
     last of them becomes the value of the `and'.

     Here is an example.  The first condition returns the integer 1,
     which is not `nil'.  Similarly, the second condition returns the
     integer 2, which is not `nil'.  The third condition is `nil', so
     the remaining condition is never evaluated.

          (and (print 1) (print 2) nil (print 3))
               -| 1
               -| 2
               => nil

     Here is a more realistic example of using `and':

          (if (and (consp foo) (eq (car foo) 'x))
              (message "foo is a list starting with x"))

     Note that `(car foo)' is not executed if `(consp foo)' returns
     `nil', thus avoiding an error.

     `and' can be expressed in terms of either `if' or `cond'.  For
     example:

          (and ARG1 ARG2 ARG3)
          ==
          (if ARG1 (if ARG2 ARG3))
          ==
          (cond (ARG1 (cond (ARG2 ARG3))))

 * Special form: or CONDITIONS...

     The `or' special form tests whether at least one of the
     CONDITIONS is true.  It works by evaluating all the CONDITIONS
     one by one in the order written.

     If any of the CONDITIONS evaluates to a non-`nil' value, then
     the result of the `or' must be non-`nil'; so the remaining
     CONDITIONS are ignored and the `or' returns right away.  The
     value it returns is the non-`nil' value of the condition just
     evaluated.

     If all the CONDITIONS turn out `nil', then the `or' expression
     returns `nil'.

     For example, this expression tests whether `x' is either 0 or
     `nil'.

          (or (eq x nil) (= x 0))

     Like the `and' function, `or' can be written in terms of `cond'.
     For example:

          (or ARG1 ARG2 ARG3)
          ==
          (cond (ARG1)
                (ARG2)
                (ARG3))

     You could almost write `or' in terms of `if', but not quite:

          (if ARG1 ARG1
            (if ARG2 ARG2 
              ARG3))

     This is not completely equivalent because here Emacs can
     evaluate ARG1 or ARG2 twice.  By contrast, `(or ARG1' ARG2 ARG3)
     never evaluates any argument more than once.



File: lispref,  Node: Iteration,  Next: Nonlocal Exits,  Prev: Combining Conditions,  Up: Control Structures

Iteration
=========

  Iteration means executing part of a program repetitively.  For
example, you might want to repeat some expressions once for each
element of a list, or once for each integer from 0 to N.  You can do
this in Emacs Lisp with the special form `while':

 * Special form: while CONDITION FORMS...

     `while' first evaluates CONDITION.  If the result is non-`nil',
     it evaluates FORMS in textual order.  Then it re-evaluates
     CONDITION, repeating this process until CONDITION evaluates to
     `nil'.

     There is no limit on the number of iterations that may occur. 
     The loop will continue until either CONDITION evaluates to `nil'
     or until an error or `throw' jumps out of it (*note Nonlocal
     Exits::.).

     The value of a `while' form is always `nil'.

          (setq num 0)
               => 0
          (while (< num 4)
            (princ (format "Iteration %d." num))
            (setq num (1+ num)))
          -| Iteration 0.
          -| Iteration 1.
          -| Iteration 2.
          -| Iteration 3.
               => nil



File: lispref,  Node: Nonlocal Exits,  Prev: Iteration,  Up: Control Structures

Nonlocal Exits
==============

  A nonlocal exit is a transfer of control from one point in a program
to another remote point.  Nonlocal exits can occur in Emacs Lisp as a
result of errors; you can also use them under explicit control.

* Menu:

* Catch and Throw::	Nonlocal exits for the program's own purposes.
* Examples of Catch::	Showing how such nonlocal exits can be written.
* Errors::	        How errors are signaled and handled.
* Cleanups::	        Arranging to run a cleanup form if an error happens.

 

File: lispref,  Node: Catch and Throw,  Next: Examples of Catch,  Prev: Nonlocal Exits,  Up: Nonlocal Exits

Explicit Nonlocal Exits: `catch' and `throw'
--------------------------------------------

  Most control constructs affect only the flow of control within the
construct itself.  The function `throw' is the sole exception: it
performs a nonlocal exit on command.  `throw' is used inside a
`catch', and jumps back to that `catch'.  For example:

     (catch 'foo
       (progn
         ...
                (throw 'foo t)
         ...))

The `throw' transfers control straight back to the corresponding
`catch', which returns immediately.  The code following the `throw'
is not executed.  The second argument of `throw' is used as the
return value of the `catch'.

  The `throw' and the `catch' are matched through the first argument:
`throw' searches for a `catch' whose first argument is `eq' to the
one specified.  Thus, in the above example, the `throw' specifies
`foo', and the `catch' specifies the same symbol, so that `catch' is
applicable.  If there is more than one applicable `catch', the
innermost one wins.

  All Lisp constructs between the `catch' and the `throw', including
function calls, are exited automatically along with the `catch'. 
When binding constructs such as `let' or function calls are exited in
this way, the bindings are unbound, just as they are when the binding
construct is exited normally (*note Local Variables::.).  Likewise,
the buffer and position saved by `save-excursion' are restored, and
so are the buffer restrictions saved by `save-restriction' and the
window selection saved by `save-window-excursion'.  Any cleanups
established with the `unwind-protect' special form are executed if
the `unwind-protect' is exited with a `throw'.

  The `throw' need not appear lexically within the `catch' that it
jumps to.  It can equally well be called from another function called
within the `catch'.  As long as the `throw' takes place
chronologically after entry to the `catch', and chronologically
before exit from it, it has access to that `catch'.  This is why
`throw' can be used in commands such as `exit-recursive-edit' which
throw back to the Emacs command loop (*note Recursive Editing::.).

     Common Lisp Note: Most other versions of Lisp, including Common
     Lisp, have several ways of transferring control nonsequentially:
     `return', `return-from', and `go', for example.  Emacs Lisp has
     only `throw'.

 * Special form: catch TAG BODY...

     `catch' establishes a return point for the `throw' function. 
     The return point is distinguished from other such return points
     by TAG, which may be any Lisp object.  The argument TAG is
     evaluated normally before the return point is established.

     With the return point in effect, the forms of the BODY are
     evaluated in textual order.  If the forms execute normally,
     without error or nonlocal exit, the value of the last body form
     is returned from the `catch'.

     If, instead, a `throw' is done specifying the same value TAG,
     the `catch' exits immediately; the value it returns is whatever
     was specified as the second argument of `throw'.

 * Function: throw TAG VALUE

     The purpose of `throw' is to return from a return point
     previously established with `catch'.  The argument TAG is used
     to choose among the various existing return points; it must be
     `eq' to the value specified in the `catch'.  If multiple return
     points match TAG, the innermost one is used.

     The argument VALUE is used as the value to return from that
     `catch'.

     If no return point is in effect with tag TAG, then a `no-catch'
     error is signaled with data `(TAG VALUE)'.



File: lispref,  Node: Examples of Catch,  Next: Errors,  Prev: Catch and Throw,  Up: Nonlocal Exits

Examples of `catch' and `throw'
-------------------------------

  One way to use `catch' and `throw' is to exit from a doubly nested
loop.  (In most languages, this would be done with a ``go to''.) Here
we compute `(foo I J)' for I and J varying from 0 to 9:

     (defun search-foo ()
       (catch 'loop
         (let ((i 0))
           (while (< i 10)
             (let ((j 0))
               (while (< j 10)
                 (if (foo i j)
                     (throw 'loop (list i j)))
                 (setq j (1+ j))))
             (setq i (1+ i))))))

If `foo' ever returns non-`nil', we stop immediately and return a
list of I and J.  If `foo' always returns `nil', the `catch' returns
normally, and the value is `nil', since that is the result of the
`while'.

  Here are two tricky examples, slightly different, showing two return
points at once.  First, two return points with the same tag, `hack':

     (defun catch2 (tag)
       (catch tag
         (throw 'hack 'yes)))
     => catch2
     
     (catch 'hack 
       (print (catch2 'hack))
       'no)
     -| yes
     => no

Since both return points have tags that match the `throw', it goes to
the inner one, the one established in `catch2'.  Therefore, `catch2'
returns normally with value `yes', and this value is printed. 
Finally the second body form in the outer `catch', which is `'no', is
evaluated and returned from the outer `catch'.

  Now let's change the argument given to `catch2':

     (defun catch2 (tag)
       (catch tag
         (throw 'hack 'yes)))
     => catch2
     
     (catch 'hack
       (print (catch2 'quux))
       'no)
     => yes

We still have two return points, but this time only the outer one has
the tag `hack'; the inner one has the tag `quux' instead.  Therefore,
the `throw' returns the value `yes' from the outer return point.  The
function `print' is never called, and the body-form `'no' is never
evaluated.



File: lispref,  Node: Errors,  Next: Cleanups,  Prev: Examples of Catch,  Up: Nonlocal Exits

Errors
------

  When Emacs Lisp attempts to evaluate a form that, for some reason,
cannot be evaluated, it "signals" an "error".

  When an error occurs, Emacs's default reaction is to print an error
message and terminate execution of the current command.  This is the
right thing to do in most cases, such as if you type `C-f' at the end
of the buffer.

  In complicated programs, simple termination may not be what you want.
For example, the program may have made temporary changes in data
structures, or created temporary buffers which must, at all costs, be
deleted before the program is finished.  In such cases, you would use
`unwind-protect' to establish "cleanup expressions" to be evaluated
in case of error.  Occasionally, you may wish the program to continue
execution despite an error in a subroutine.  In these cases, you
would use `condition-case' to establish "error handlers" to recover
control in case of error.

  Each error has an associated "error symbol" (also called an "error
name") which identifies the event that caused the problem.  The error
symbol is useful for programs that handle some kinds of error, but
not all.

* Menu:

* Signalling Errors::     How to report an error.
* Processing of Errors::  What Emacs does when you report an error.
* Handling Errors::       How you can trap errors and continue execution.
* Error Names::           How errors are classified for trapping them.

 

File: lispref,  Node: Signalling Errors,  Next: Processing of Errors,  Prev: Errors,  Up: Errors

How to Signal an Error
......................

   Most errors are signaled ``automatically'' within Lisp primitives
which you call for other purposes, such as if you try to take the CAR
of an integer or move forward a character at the end of the buffer;
but you can signal them explicitly with the functions `error' and
`signal'.

 * Function: error FORMAT-STRING &rest ARGS

     This function signals an error with an error message constructed
     by applying `format' (*note String Conversion::.) to
     FORMAT-STRING and ARGS.

     Typical uses of `error' is shown in the following examples:

          (error "You have committed an error.  Try something else.")
               error--> You have committed an error.  Try something else.
          
          (error "You have committed %d errors.  You don't learn fast." 10)
               error--> You have committed 10 errors.  You don't learn fast.

      `error' works by calling `signal' with the error symbol `error'
     and the string returned by `format' as the only arguments.

     If you want to use a user-supplied string as an error message
     verbatim, don't just do `(error STRING)'.  If STRING contains
     `%', it will be interpreted as a format specifier, with
     undesirable results.  Instead, do `(error "%s" STRING)'.

 * Function: signal ERROR-SYMBOL DATA

     This function signals an error named by ERROR-SYMBOL.  The
     argument DATA is a list of additional Lisp objects relevant to
     the circumstances of the error.

     ERROR-SYMBOL must have an `error-conditions' property whose
     value is a list of condition names.  *Note Error Names::, for a
     description of how to set up your own error conditions.

     The number and significance of the objects in DATA depends on
     ERROR-SYMBOL.  For example, with a `wrong-type-arg' error, there
     are two objects in the list: a predicate which describes the
     type that was expected, and the object which failed to fit that
     type.

     Both ERROR-SYMBOL and DATA are available to any error handlers
     which handle the error: a list `(ERROR-SYMBOL . DATA)' is
     constructed to become the value of the local variable bound in
     the `condition-case' form.  If the error is not handled, both of
     them are used in printing the error message.

          (signal 'wrong-number-of-arguments '(x y))
               error--> Wrong number of arguments: x, y
          
          (signal 'no-such-error '("My unknown error condition."))
               error--> peculiar error: "My unknown error condition."

     Common Lisp Note: The function `signal' is the sole function
     that can signal an error (the `error' function calls it).  This
     implies that Emacs Lisp has nothing like the Common Lisp concept
     of continuable errors.



File: lispref,  Node: Processing of Errors,  Next: Handling Errors,  Prev: Signalling Errors,  Up: Errors

How Emacs Processes Errors
..........................

 When an error is signaled, Emacs searches for an active "handler" for
the error.  A handler is a specially marked place in the Lisp code of
the current function or any of the functions by which it was called. 
If an applicable handler exists, its code is executed, and control
resumes following the handler.  The handler executes in the
environment of the `condition-case' which established it; all
functions called within that `condition-case' have already been
exited, and the handler cannot return to them.

If no applicable handler is in effect in your program, the current
command is terminated and control returns to the editing command
loop, because the command loop has its own handler for all kinds of
errors.  The command loop's handler uses the error symbol and
associated data to print an error message.

If no handler applies, the Lisp debugger may be called.  The debugger
is enabled if the variable `debug-on-error' (*note Error
Debugging::.) is non-`nil'.  Unlike error handlers, the debugger runs
in the environment of the error, so that you can examine values of
variables precisely as they were at the time of the error.  *Note
Debugging::, for the details.



File: lispref,  Node: Handling Errors,  Next: Error Names,  Prev: Processing of Errors,  Up: Errors

Writing Code to Handle Errors
.............................

   The usual effect of signaling an error is to terminate the command
that is running and return immediately to the Emacs editing command
loop.  You can arrange to trap errors occuring in a part of your
program by establishing an "error handler" with the special form
`condition-case'.  A simple example looks like this:

     (condition-case nil
         (delete-file filename)
       (error nil))

This deletes the file, catching any error that occurs and returning
`nil'.

  The second argument of `condition-case' is called the "protected
form".  (In the example above, the protected form is a call to
`delete-file'.)  The error handlers go into effect when this form
begins execution and are deactivated when this form returns.  They
remain in effect for all the intervening time.  In particular, they
are in effect during the execution of subroutines called by this
form, and their subroutines, and so on.  This is a good thing, since,
strictly speaking, errors can be signaled only by Lisp primitives,
not by the protected form itself.

  The arguments after the second one are handlers.  Each handler lists
one or more "condition names" (which are symbols) to specify which
errors it will handle.  The error symbol specified when an error is
signaled also defines a list of condition names.  A handler applies
to an error if they have any condition names in common.  In the
example above, there is one handler, and it specifies one condition
name, `error'.  That condition includes all errors.

  The search for an applicable handler checks all the established
handlers starting with the most recently established one.  Thus, if
two nested `condition-case' forms try to handle the same error, the
inner of the two will actually handle it.

  When an error is handled, control returns to the handler, executing
the cleanups of all `unwind-protect' forms that are exited by doing so.
Then, the body of the handler is executed.  After this, execution
continues by returning from the `condition-case' form.  Because the
protected form is exited completely before execution of the handler,
the handler cannot resume execution at the point of the error, nor
can it examine variable bindings that were made within the protected
form.  All it can do is clean up and proceed.

  Error signaling and handling have some resemblance to `throw' and
`catch', but they are entirely separate facilities.  An error cannot
be caught by a `catch', and a `throw' cannot be handled by an error
handler (though if there is no `catch', `throw' will signal an error
which can be handled).

 * Special form: condition-case VAR PROTECTED-FORM HANDLERS...

     This special form establishes the error handlers HANDLERS around
     the execution of PROTECTED-FORM.  If PROTECTED-FORM executes
     without error, the value it returns becomes the value of the
     `condition-case' form; in this case, the `condition-case' has no
     effect.  The `condition-case' form makes a difference when an
     error occurs during PROTECTED-FORM.

     Each of the HANDLERS is a list of the form `(CONDITIONS
     BODY...)'.  CONDITIONS is a condition name to be handled, or a
     list of condition names; BODY is one or more Lisp expressions to
     be executed when this handler handles an error.

     Each error that occurs has an "error symbol" which describes
     what kind of error it is.  The `error-conditions' property of
     this symbol is a list of condition names (*note Error Names::.).
     Emacs searches all the active `condition-case' forms for a
     handler which specifies one or more of these names; the
     innermost matching `condition-case' handles the error.  The
     handlers in this `condition-case' are tested in the order in
     which they appear.

     The body of the handler is then executed, and the
     `condition-case' returns normally, using the value of the last
     form in the body as the overall value.

     The argument VAR is a variable.  `condition-case' does not bind
     this variable when executing the PROTECTED-FORM, only when it
     handles an error.  At that time, VAR is bound locally to a list
     of the form `(ERROR-SYMBOL . DATA)', giving the particulars of
     the error.  The handler can refer to this list to decide what to
     do.  For example, if the error is for failure opening a file,
     the file name is the second element of DATA--the third element
     of VAR.

     If VAR is `nil', that means, ``don't bind any variable'': then
     the error symbol and associated data are not made available to
     the handler.

  Here is an example of using `condition-case' to handle the error that
results from dividing by zero.  The handler prints out a warning
message and returns a very large number.

     (defun safe-divide (dividend divisor)
       (condition-case err		     
           ;; Protected form.
           (/ dividend divisor)		
         ;; The handler.
         (arith-error			; Condition.
          (princ (format "Arithmetic error: %s" err))
          1000000)))
     => safe-divide
     
     (safe-divide 5 0)
          -| Arithmetic error: (arith-error)
     => 1000000

The handler specifies condition name `arith-error' so that it will
handle only division-by-zero errors.  Other kinds of errors will not
be handled, at least not by this `condition-case'.  Thus,

     (safe-divide nil 3)
          error--> Wrong type argument: integer-or-marker-p, nil

  Here is a `condition-case' that catches all kinds of errors,
including those signaled with `error':

     (setq baz 34)
          => 34
     
     (condition-case err
         (if (eq baz 35)
             t
           ;; This is a call to the function `error'.
           (error "Rats!  The variable %s was %s, not 35." 'baz baz))
       ;; This is the handler; it is not a form.
       (error (princ (format "The error was: %s" err)) 
              2))
     
          -| The error was: (error "Rats!  The variable baz was 34, not 35.")
          => 2

  `condition-case' may be used to trap errors that are unexpected, such
as in a function that executes an expression read from the user.  It
may also be used to trap errors that are expected, such as failure to
open a file when you call `insert-file-contents'.



File: lispref,  Node: Error Names,  Prev: Handling Errors,  Up: Errors

Error Symbols and Condition Names
.................................

   When you signal an error, you specify an "error symbol" to specify
the kind of error you have in mind.  Each error has one and only one
error symbol to categorize it.  This is the finest classification of
errors defined by the Lisp language.

  These narrow classifications are grouped into a hierarchy of wider
classes called "error conditions", identified by "condition names". 
The narrowest such classes belong to the error symbols themselves:
each error symbol is also a condition name.  There are also condition
names for more extensive classes, up to the condition name `error'
which takes in all kinds of errors.  Thus, each error has one or more
condition names: `error', the error symbol if that is distinct from
`error', and perhaps some intermediate classifications.

  In order for a symbol to be usable as an error symbol, it must have
an `error-conditions' property which gives a list of condition names.
This list defines the conditions which this kind of error belongs to.
(The error symbol itself, and the symbol `error', should always be
members of this list.)  Thus, the hierarchy of condition names is
defined by the `error-conditions' properties of the error symbols.

  In addition to the `error-conditions' list, the error symbol should
have an `error-message' property whose value is a string to be
printed when that error is signaled but not handled.  If the
`error-message' property exists, but is not a string, the untrappable
`peculiar error' will be signaled.

  Here is how we define a new error symbol, `new-error', and how we
would then signal it:

     (put 'new-error 'error-conditions '(error my-own-errors new-error))
          => (error my-own-errors new-error)
     (put 'new-error 'error-message "A new error")
          => "A new error"

This error has three condition names: `new-error', the narrowest
classification; `my-own-errors', which we imagine is a wider
classification; and `error', which is the widest of all.     
Naturally, Emacs will never signal a `new-error' on its own; only an
explicit call to `signal' (*note Errors::.) in your code can do this:

     (signal 'new-error '(x y))
          error--> A new error: x, y

  This error can be handled through any of the three condition names. 
This example handles `new-error' and any other errors in the class
`my-own-errors':

     (condition-case foo
         (bar nil t)
       (my-own-errors nil))

  The significant way that errors are classified is by their condition
names.  They are the names used to match errors with handlers.  An
error symbol serves only as a convenient way to specify the intended
error message and list of condition names.  Lisp could have been
designed differently, so that `signal' would need a list of condition
names rather than one error symbol, but that would have made it more
cumbersome.

  By contrast, using only error symbols without condition names would
seriously decrease the power of `condition-case'.  Condition names
make it possible to categorize errors at various levels of generality
when you write an error handler.  Using error symbols alone would
eliminate all but the narrowest level of classification.

  In the appendix (*note Standard Errors::.) is a list of all the
standard error symbols and their conditions.



File: lispref,  Node: Cleanups,  Prev: Errors,  Up: Nonlocal Exits

Cleaning up from Nonlocal Exits
-------------------------------

  The `unwind-protect' construct is essential whenever you temporarily
put a data structure in an inconsistent state; it permits you to
ensure the data are consistent in the event of an error.

 * Special form: unwind-protect BODY CLEANUP-FORMS...

     `unwind-protect' executes the BODY with a guarantee that the
     CLEANUP-FORMS will be evaluated if control leaves BODY, no
     matter how that happens.  The BODY may complete normally, or
     execute a `throw' over the `unwind-protect', or cause an error;
     in all cases, the CLEANUP-FORMS will be evaluated.

     Only the BODY is actually protected by the `unwind-protect'.  If
     any of the CLEANUP-FORMS themselves exit (e.g., via a `throw' or
     an error), it is *not* guaranteed that the rest of them will be
     executed.  If the failure of one of the CLEANUP-FORMS has the
     potential to cause trouble, then it should be protected by
     another `unwind-protect' around that form.

     The number of currently active `unwind-protect' forms counts,
     together with the number of local variable bindings, against the
     limit `max-specpdl-size' (*note Local Variables::.).

  For example, you might make an invisible buffer for temporary use,
which you wish to be sure to kill before the next command:

     (save-excursion
       (let ((buffer (get-buffer-create " *temp*")))
         (set-buffer buffer)
         (unwind-protect
             BODY
           (kill-buffer buffer))))

You might think that we could just as well write `(kill-buffer
(current-buffer))' and dispense with the variable `buffer'.  However,
the way shown above is safer, if BODY happens to get an error after
switching to a different buffer!  (Alternatively, you could write
another `save-excursion' around the body, to ensure that the
temporary buffer becomes current in time to kill it.)

  Here is an actual example taken from the file `ftp.el'.  It creates a
process (*note Processes::.) to try to establish a connection to a
remote machine.  As the function `ftp-login' is highly susceptible to
numerous problems which the writer of the function cannot anticipate,
it is protected with a form that guarantees deletion of the process
in the event of failure.  Otherwise, Emacs might fill up with useless
subprocesses.

     (let ((win nil))
       (unwind-protect
           (progn
             (setq process (ftp-setup-buffer host file))
             (if (setq win (ftp-login process host user password))
                 (message "Logged in")
               (error "Ftp login failed")))
         (or win (and process (delete-process process)))))

  This example actually has a small bug: if the user types `C-g' to
quit, and the quit happens immediately after the function
`ftp-setup-buffer' returns but before the variable `process' is set,
the process will not be killed.  There is no easy way to fix this
bug, but at least it is very unlikely.



File: lispref,  Node: Evaluation,  Next: Loading,  Prev: Control Structures,  Up: Top

Evaluation
**********

  The "evaluation" of expressions in Emacs Lisp invokes the "Lisp
interpreter".  The Lisp interpreter, which is actually the `eval'
function described below, looks at the object it is given, and
computes its "value as an expression" in a fashion depending on the
object's type.

* Menu:

* Intro Eval::  Evaluation in the scheme of things.
* Eval::        How to invoke the Lisp interpreter explicitly.
* Forms::       How various sorts of objects are evaluated.
* Quoting::     Avoiding evaluation (to put constants in the program).

 

File: lispref,  Node: Intro Eval,  Next: Eval,  Prev: Evaluation,  Up: Evaluation

Introduction to Evaluation
==========================

  The "evaluation" of expressions in Emacs Lisp invokes the "Lisp
interpreter".  The Lisp interpreter, which is actually the `eval'
function described below, looks at the object it is given, and
returns its "value as an expression" in a fashion depending on the
object's type.

  Any object can be evaluated, but in practice only numbers, symbols,
lists and strings are evaluated very often.  A Lisp object which is
intended for evaluation is called an "expression" or a "form".  The
fact that expressions are data objects, not merely text, is one of
the fundamental differences between Lisp-like languages and typical
programming languages.

  First, evaluation is not command key interpretation.  The editing
command loop interprets keyboard input using the current keymaps, and
then uses `call-interactively' to invoke the command.  The execution
of the command itself usually involves evaluation, but that is
another matter.  (*Note Command Loop::.)

  Second, evaluation does not result from simply reading a form. 
Reading produces the form itself, not the value of the form.  It
converts the printed representation of the form to a Lisp object,
which *is* the form in the strict sense.

  Evaluation is a recursive process.  That is, evaluation of a form may
cause `eval' to be called again to evaluate parts of the form.  For
example, evaluation of a function call first evaluates each argument
of the function call, and then evaluates each form in the function
body.  Consider evaluation of the form `(car x)': the subform `x'
must first be evaluated recursively, so that its value can be passed
as an argument to the function `car'.

  The evaluation of forms takes place in a context called the
"environment".  This consists of the ambient, inherited values and
bindings of all Lisp variables.  Whenever the form refers to a
variable without creating a new binding for it, the value of the
ambient binding is used.  (*Note Variables::.)

  Evaluation of a form may create new environments for nested,
recursive evaluation by binding variables (*note Local Variables::.).
These environments are temporary and will be gone by the time
evaluation of the form is complete.  The form may also make changes
that persist; these changes are called "side-effects".  An example of
a form that produces side-effects is `(setq foo 1)'.

  Finally, evaluation of one particular function call, `byte-code',
invokes the "byte-code interpreter" on its arguments.  Although the
byte-code interpreter is not the same as the Lisp interpreter, it
uses the same environment as the Lisp interpreter, and it may invoke
the Lisp interpreter.  (*Note Byte Compilation::.)

  The details of what evaluation means for each kind of form are
described later (*note Forms::.).



File: lispref,  Node: Eval,  Next: Forms,  Prev: Intro Eval,  Up: Evaluation

Eval
====

  Most forms, most of the time, are evaluated automatically, by virtue
of their occurence in a program.  But on rare occasions, you may need
to write code that evaluates a form; for example, if the form is
found in a file being edited.  On these occasions, use the  `eval'
function.

    The functions and variables described in this section evaluate forms,
specify limits to the evaluation process, or record recently returned
values.  Evaluation is also performed by calling `apply' and
`funcall' (*note Calling Functions::.) and `load' (*note Loading::.).
The details of what evaluation means for each kind of form are
described in another section; see *Note Forms::.

 * Function: eval FORM

       This is the basic function that performs evaluation.  It
     evaluates FORM in the current environment, and returns the
     result.  How the evaluation proceeds depends on the type of the
     object (*note Forms::.).

       Since `eval' is a function, the argument expression you write
     for it is evaluated twice: once as preparation before `eval' is
     called, and again by the `eval' function itself.  Here is an
     example:

          (setq foo 'bar)
               => bar
          (setq bar 'baz)
               => baz
          ;; `eval' is called on the form `bar', which is the value of `foo'
          (eval foo)
               => baz

       The number of currently active calls to `eval' is limited to
     `max-lisp-eval-depth'.

 * Command: eval-current-buffer &optional STREAM

       This function evaluates the forms in the current buffer.  It
     reads forms from the buffer and calls `eval' on them until the
     end of the buffer is reached, or an error is signaled and not
     handled.

       If STREAM is supplied, the variable `standard-output' is bound
     to STREAM during the evaluation (*note Output Functions::.).

     `eval-current-buffer' always returns `nil'.

 * Command: eval-region START END &optional STREAM

       This function evaluates forms in the current buffer in the
     region defined by the positions START and END.  It reads forms
     from the region and calls `eval' on them until the end of the
     region is reached, or an error is signaled and not handled.

       If STREAM is supplied, `standard-output' is bound to it for the
     duration of the evaluation.

     `eval-region' always returns `nil'.

 * Variable: max-specpdl-size

       This variable defines the limit on the number of local variable
     bindings and `unwind-protect' cleanups (*note Nonlocal Exits::.)
     that are allowed before the error `error' is signaled (with data
     `"Variable binding depth exceeds max-specpdl-size"').

       This limit and the associated error when it is exceeded is one
     way that Lisp avoids infinite recursion on an ill-defined
     function.

       The default value is 600.

 * Variable: max-lisp-eval-depth

       This variable defines the maximum depth allowed in calls to
     `eval', `apply', and `funcall' before the error `error' is
     signaled (with data `"Lisp nesting exceeds max-lisp-eval-depth"').
     `eval' is called recursively to evaluate the arguments of Lisp
     function calls and to evaluate bodies of functions.

       This limit and the associated error when it is exceeded is one
     way that Lisp avoids infinite recursion on an ill-defined
     function.

       The default value is 200.  If you set it to a value less than
     100, Lisp will reset it to 100.

 * Variable: values

       The value of this variable is a list of values returned by all
     expressions which were read from buffers (including the
     minibuffer), evaluated, and printed.  The elements are in order,
     most recent first.

          (setq x 1)
               => 1
          (list 'A (1+ 2) auto-save-default)
               => (A 3 t)
          values
               => ((A 3 t) 1 ...)

     This variable is useful for referring back to values of forms
     you have evaluated.  It is generally a bad idea to examine the
     value of `values' directly, since it may be very long.  Instead,
     examine particular elements, like this:

          ;; Refer to the most recent evaluation result.
          (nth 0 values)
               => (A 3 t)
          ;; That put a new element on, so all elements move back one.
          (nth 1 values)
               => (A 3 t)
          (nth 3 values)
               => 1



File: lispref,  Node: Forms,  Next: Quoting,  Prev: Eval,  Up: Evaluation

Kinds of Forms
==============

  Any Lisp object that we intend to evaluate is a "form".  How Emacs
evaluates a form depends on its data type.  Emacs has three different
kinds of form that are evaluated differently: symbols, lists, and
`all other types'.  All three kinds are described in this section,
starting with `all other types' which are self-evaluating forms.

* Menu:

* Self-Evaluating Forms::       Forms that evaluate to themselves.
* Symbol Forms::                Symbols evaluate as variables.
* Nonempty List Forms::         Function and macro calls, and special forms.

 

File: lispref,  Node: Self-Evaluating Forms,  Next: Symbol Forms,  Prev: Forms,  Up: Forms

Self-Evaluating Forms
---------------------

  A "self-evaluating form" is any form that is not a list or symbol. 
Self-evaluating forms evaluate to themselves: the result of
evaluation is the same object that was evaluated.  Thus, the number
25 evaluates to 25, and the string `"foo"' evaluates to the string
`"foo"'.  Likewise, evaluation of a vector does not cause evaluation
of the elements of the vector--it returns that very vector.

     '123               ; An object, shown without evaluation.
          => 123
     123                ; Evaluated as usual--result is the same.
          => 123
     (eval '123)        ; Evaluated ``by hand''--result is the same.
          => 123
     (eval (eval '123)) ; Evaluating twice changes nothing.
          => 123

  It is common to write numbers, characters, strings, and even vectors
in Lisp code, taking advantage of the fact that they self-evaluate. 
However, it is quite unusual to do this for types that lack a read
syntax, because it is inconvenient and not useful; but it is possible
to put them inside Lisp programs when they are constructed *as Lisp
objects*.  Here is an example:

     ;; Build such an expression.
     (setq buffer (list 'print (current-buffer)))
          => (print #<buffer evaluation.texinfo>)
     ;; Evaluate it.
     (eval buffer)
          -| #<buffer evaluation.texinfo>)
          => #<buffer evaluation.texinfo>)



File: lispref,  Node: Symbol Forms,  Next: Nonempty List Forms,  Prev: Self-Evaluating Forms,  Up: Forms

Symbol Forms
------------

  When a symbol is evaluated, it is treated as a variable.  The result
is the variable's value, if it has one.  If it has none (if its value
cell is void), you get an error.  For more information on the binding
of variables, see *Note Variables::.

  In the following example, the value cell of a symbol is set to a
value (with `setq').  When the symbol is then evaluated, that value
is returned.

     (setq a 123)
          => 123
     (eval 'a)
          => 123
     a
          => 123

  Two symbols, `nil' and `t', are special, because the value of `nil'
is always `nil' and the value of `t' is always `t'.  Thus, these two
symbols act like self-evaluating forms, even though `eval' treats
them like any other symbol.



File: lispref,  Node: Nonempty List Forms,  Prev: Symbol Forms,  Up: Forms

Nonempty List Forms
-------------------

  A form which is a nonempty list is either a function call, a macro
call, or a special form, according to its first element.  These three
kinds of forms are evaluated in different ways, described below.  The
rest of the list consists of "arguments" for the function, macro or
special form.

* Menu:

* Classifying Lists::	How to distinguish various sorts of list forms.
* Function Forms::      Forms that call functions.
* Macro Forms::         Forms that call macros.
* Special Forms::       ``Special forms'' are ideosyncratic primitives,
                           most of them extremely important.
* Autoloading::         Functions set up to load files
                           containing their real definitions.

 

File: lispref,  Node: Classifying Lists,  Next: Function Forms,  Prev: Nonempty List Forms,  Up: Nonempty List Forms

Classification of List Forms
----------------------------

  The first step in evaluating a nonempty list is to examine its first
element.  This element alone determines what kind of form the list is
and how the rest of the list is to be processed.  The first element
is *not* evaluated, as it would be in some dialects of Lisp
languages, such as Scheme.

  If the first element of the list is a symbol, as it most commonly is,
then the symbol's function cell is examined.  If the object
referenced by the function cell is another symbol, the function cell
of that symbol is examined, and used exactly as if it had been the
original symbol.  If that is another symbol, this process, called
"symbol function indirection", is repeated until a non-symbol is
obtained.

  One possible consequence of this process is an infinite loop, if a
symbol's function cell refers to the same symbol.  Or a symbol may
have a void function cell, causing a `void-function' error.  But if
neither of these things happens, we eventually obtain a non-symbol,
which ought to a function or a related object.

  More precisely, we should now have a Lisp function (a lambda
expression), a primitive function, a Lisp macro, a special form, or
an autoload object.  Each of these types is a case described in one
of the following sections.  If the object is not one of these types,
the error `invalid-function' is signaled.

  The following example illustrates the symbol indirection process.  We
use `fset' to set the function cell of a symbol and `symbol-function'
to get the function cell contents (*note Function Cells::.).  In this
way we store the symbol `car' into the function cell of `first', and
the symbol `first' into the function cell of `erste'.

     ;; Build this function cell linkage:
     ;;    ------------       ----        ------        ------
     ;;   | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
     ;;    ------------       ----        ------        ------


          (symbol-function 'car)
          => #<subr car>
     (fset 'first 'car)
          => car
     (fset 'erste 'first)
          => first
     (erste '(1 2 3))           ; Call the function referenced by `erste'.
          => 1

  By contrast, the following example calls a function without any
symbol function indirection, because the first element is not a
symbol, but rather an anonymous Lisp function.

     ((lambda (arg) (erste arg))
      '(1 2 3)) 
          => 1

However, after that function is called, its body is evaluated; this
does involve symbol function indirection when calling `erste'.



File: lispref,  Node: Function Forms,  Next: Macro Forms,  Prev: Classifying Lists,  Up: Nonempty List Forms

Evaluation of Function Forms
----------------------------

  If the first element of a list being evaluated is a Lisp function
object or primitive function object, then that form is called a
"function call".  For example, this is a call to the function `+':

     (+ 1 x)

  When a function call is evaluated, first the elements of the rest of
the list are evaluated in the order they appear.  Then the function
is called with this list of arguments, effectively using the function
`apply' to do this (*note Calling Functions::.).  If the function is
written in Lisp, the arguments are used to bind the parameter
variables of the function (*note Lambda Expressions::.); then the
forms in the function body are evaluated in order, and the result of
the last one is used as the value of the function call.



File: lispref,  Node: Macro Forms,  Next: Special Forms,  Prev: Function Forms,  Up: Nonempty List Forms

Lisp Macro Evaluation
---------------------

  If the first element of a list being evaluated is a macro object,
then that form is called a "macro call".

  When a macro call is evaluated, the elements of the rest of the list
are *not* initially evaluated; instead, these elements themselves are
used as the arguments of the macro.  The macro definition computes a
replacement form, called the "expansion" of the macro.  Then the
expansion is evaluated in place of the original form.  The expansion
may be any sort of form; a self-evaluating constant, a symbol or a
list.  If the expansion is itself a macro call, this process of
expansion repeats until some other sort of form results.

  Normally, the argument expressions are not evaluated as part of
computing the macro expansion, but instead appear as part of the
expansion.  So they are evaluated when the expansion is evaluated.

  For example, given a macro defined as follows:

     (defmacro cadr (x)
       (list 'car (list 'cdr x)))

an expression such as `(cadr (assq 'handler list))' is a macro call,
and its expansion is:

     (car (cdr (assq 'handler list)))

Note that the argument `(assq 'handler list)' appears in the
expansion, as usual.

*Note Macros::, for the complete description of Emacs Lisp macros.



File: lispref,  Node: Special Forms,  Next: Autoloading,  Prev: Macro Forms,  Up: Nonempty List Forms

Special Forms
-------------

  A "special form" is a primitive function specially marked so that its
arguments are not all evaluated.  Special forms define control
structures or perform variable bindings--things which functions
cannot do.

  Each special form has its own rules for which arguments are evaluated
and which are used without evaluation.  Sometimes, whether a
particular argument is evaluated depends on the results of evaluating
other arguments.

  Here is a list, in alphabetical order, of all of the special forms in
Emacs Lisp with a reference to where each is described.

`and'
     *note Combining Conditions::.

`catch'
     *note Catch and Throw::.

`cond'
     *note Conditionals::.

`condition-case'
     *note Errors::.

`defvar'
     *note Global Variables::.

`defmacro'
     *note Defining Macros::.

`defun'
     *note Defining Functions::.

`defvar'
     *note Defining Variables::.

`if'
     *note Conditionals::.

`function'
     *note Anonymous Functions::.

`interactive'
     *note Interactive Call::.

`let'
     *note Local Variables::.

`let*'
     *note Local Variables::.

`or'
     *note Combining Conditions::.

`progn'
     *note Sequencing::.

`prog1'
     *note Sequencing::.

`prog2'
     *note Sequencing::.

`quote'
     *note Quoting::.

`save-excursion'
     *note Excursions::.

`save-restriction'
     *note Clipping Restrictions::.

`save-window-excursion'
     *note Window Configurations::.

`setq'
     *note Setting Variables::.

`setq-default'
     *note Buffer Local Variables::.

`unwind-protect'
     *note Nonlocal Exits::.

`while'
     *note Iteration::.

`with-output-to-temp-buffer'
     *note Temporary Displays::.

     Common Lisp Note: Here are some comparisons of special forms in
     GNU Emacs Lisp and Common Lisp: `setq', `if', and `catch' are
     special forms in both Emacs Lisp and Common Lisp.  `defun' is a
     special form in Emacs Lisp, but a macro in Common Lisp. 
     `save-excursion' is a special form in Emacs Lisp, but doesn't
     exist in Common Lisp.  `throw' is a special form in Common Lisp
     (because it must be able to throw multiple values), but it is a
     function in Emacs Lisp (which doesn't have multiple values).



File: lispref,  Node: Autoloading,  Prev: Special Forms,  Up: Nonempty List Forms

Autoloading
-----------

  The "autoload" feature allows you to call a function or macro whose
function definition has not yet been loaded into Emacs.  When an
autoload object appears as a symbol's function definition and that
symbol is used as a function, Emacs will automatically install the
real definition (plus other associated code) and then call that
definition.  (*Note Autoload::.)



File: lispref,  Node: Quoting,  Prev: Forms,  Up: Evaluation

Quoting
=======

  The special form `quote' returns its single argument ``unchanged''.

 * Special form: quote OBJECT

     This special form returns OBJECT, without evaluating it.  This
     allows symbols and lists, which would normally be evaluated, to
     be included literally in a program.  (It is not necessary to
     quote numbers, strings, and vectors since they are
     self-evaluating.)  Use `function' instead of `quote' when
     quoting lambda expressions (*note Anonymous Functions::.).

     Because `quote' is used so often in programs, a convenient read
     syntax is defined.  An apostrophe character (`'') followed by a
     form expands to a list whose first element is `quote', and whose
     second element is the form.

          (quote (+ 1 2))
               => (+ 1 2)
          (quote foo)
               => foo
          'foo
               => foo
          ''foo
               => (quote foo)
          '(quote foo)
               => (quote foo)
          ['foo]
               => [(quote foo)]



File: lispref,  Node: Loading,  Next: Byte Compilation,  Prev: Evaluation,  Up: Top

Loading
*******

  Loading a file of Lisp code means bringing the program into the Lisp
environment in the form of Lisp objects.  Emacs finds and opens the
file, reads the contents of the file, evaluates each form within it,
and then closes the file.

  Thus, the load functions evaluate all the expressions in a file just
as the `eval-current-buffer' function evaluates all the expressions
in a buffer.  The difference is that the load functions read and
evaluate the text in the file as found on disk, not the text in an
Emacs buffer.

  The loaded file must contain Lisp expressions, either as source code
or, optionally, as byte-compiled code.  Each form in the file is
called a "top-level form".  There is no special format for the forms
in a loadable file; any form in a file may equally well be typed
directly into a buffer and evaluated there.  (Indeed, most code is
tested this way.)  Most often, the forms in a load file are function
and variable definitions.

* Menu:

* Loading Libraries::		Files containing code are called libraries.
* How Programs Do Loading::     The `load' function and others.
* Autoload::   	                Setting up a function to autoload.
* Features::                    Loading a library if it isn't already loaded.

 

File: lispref,  Node: Loading Libraries,  Next: How Programs Do Loading,  Prev: Loading,  Up: Loading

Lisp Libraries and Loading
==========================

  A file containing Lisp code is often called a "library".  Thus, the
`Rmail library' is a file containing code for reading mail. 
Similarly, a `Lisp library directory' is a directory of files
containing Lisp code.

  You may load a file more than once in an Emacs session.  For example,
after you have rewritten and reinstalled a function definition by
editing it in a buffer, you may wish to return to the original
version; you can do this by reloading the file in which it is located.

  However, when you load or re-load files, bear in mind that the `load'
and `load-library' functions automatically load a byte-compiled file
rather than a non-compiled file of similar name.  If you rewrite a
file that you intend to save and reinstall, remember to byte-compile
it if necessary; otherwise you may find yourself inadvertently
reloading the older, byte-compiled file instead of your newer,
non-compiled file!

  When writing the forms in a library, keep in mind that the library
might be loaded more than once.  For example, the choice of `defvar'
vs. `defconst' for defining a variable depends on whether it is
desirable to reinitialize the variable if the library is reloaded:
`defconst' does so, and `defvar' does not.  (*Note Defining
Variables::.)

  The easy way to add an element to an alist is like this:

     (setq minor-mode-alist (cons '(leif-mode " Leif") minor-mode-alist))

But this would add multiple elements if the library is reloaded.  To
avoid the problem, write this:

     (or (assq 'leif-mode minor-mode-alist)
         (setq minor-mode-alist
               (cons '(leif-mode " Leif") minor-mode-alist)))

  Occasionally you will want to test explicitly whether the library was
already loaded; you can do so as follows:

     (if (not (boundp 'foo-was-loaded))
         EXECUTE-FIRST-TIME-ONLY)
     
     (setq foo-was-loaded t)

  There are several interface functions for loading.  For example, the
`autoload' function creates a Lisp object that loads a file when it
is evaluated (*note Autoload::.).  `require' also causes files to be
loaded (*note Features::.).  Ultimately, all these facilities call
the `load' function to do the work.

  Any errors that are encountered while loading a file cause `load' to
abort.  If the load was done for the sake of `autoload', certain
kinds of top-level forms, those which define functions, are undone.

  To learn how `load' is used to build Emacs, see *Note Building Emacs::.



File: lispref,  Node: How Programs Do Loading,  Next: Autoload,  Prev: Loading Libraries,  Up: Loading

How Programs Do Loading
=======================

 * Function: load FILENAME &optional MISSING-OK NOMESSAGE NOSUFFIX

     This function finds and opens a file of Lisp code, evaluates all
     the forms in it, and closes the file.

     To find the file, `load' first looks for a file named
     `FILENAME.elc', that is, for a file whose name has `.elc'
     appended.  If such a file exists, it is loaded.  But if there is
     no file by that name, then `load' looks for a file whose name
     has `.el' appended.  If that file exists, it is loaded. 
     Finally, if there is no file by either name, `load' looks for a
     file named FILENAME with nothing appended, and loads it if it
     exists.  (The `load' function is not clever about looking at
     FILENAME.  In the perverse case of a file named `foo.el.el',
     evaluation of `(load "foo.el")' will indeed find it.)

     If the optional argument NOSUFFIX is non-`nil', then the
     suffixes `.elc' and `.el' are not tried.  In this case, the
     filename must be specified precisely.

     If FILENAME is a relative file name, such as `foo.bar' or
     `baz/foo.bar', Emacs searches for the file using the variable
     `load-path'.  Emacs does this by appending FILENAME to each of
     the directories listed in `load-path', and loading the first
     file it finds whose name matches.  The current working directory
     is tried only if it is specified in `load-path', where it is
     represented as `nil'.

     When FILENAME is a relative file name, all three possible
     suffixes are tried in the first directory in `load-path', then
     all three in the second directory in `load-path', etc.

     Messages like `Loading foo.el ...' and `Loading foo.el ... 
     done' are printed in the echo area while loading unless
     NOMESSAGE is non-`nil'.

     The error `file-error' is signaled (with `Cannot open load file
     FILENAME') if no file is found.  No error is signaled if
     MISSING-OK is non-`nil'--then `load' just returns `nil'.

     `load' returns `t' if the file loads successfully.

 * Option: load-path

     The value of this global variable is a list of directories to
     search when loading files with `load'.  Each element is a string
     (which must be a directory name) or `nil' (which stands for the
     current working directory).  The value of `load-path' is
     initialized from the environment variable `EMACSLOADPATH', if it
     exists; otherwise it is set to the default specified in
     `emacs/src/paths.h' when Emacs is built.

     The syntax of `EMACSLOADPATH' is the same as that of `PATH';
     fields are separated by `:', and `.' is used for the current
     working directory.  Here is an example of how to set your
     `EMACSLOADPATH' variable from a CSH `.login' file:

          setenv EMACSLOADPATH .:/user/liberte/emacs:/usr/local/lib/emacs/lisp

     Here is how to set it using SH:

          export EMACSLOADPATH
          EMACSLOADPATH=.:/user/liberte/emacs:/usr/local/lib/emacs/lisp

     Here is an example of code you can place in a `.emacs' file to
     add several directories to the front of your default `load-path':

          (setq load-path
                (append
                 (list nil
                       "/user/liberte/emacs"
                       "/usr/local/lisplib")
                 load-path))

     In this example, the path searches the current working directory
     first, followed by `/user/liberte/emacs' and
     `/usr/local/lisplib', which are then followed by the standard
     directories for Lisp code.

 * Variable: load-in-progress

     This global variable is non-`nil' if Emacs is in the process of
     loading a file, and it is `nil' otherwise.  This is how `defun'
     and `provide' determine whether a load is in progress, so that
     their effect can be undone if the load fails.



File: lispref,  Node: Autoload,  Next: Features,  Prev: How Programs Do Loading,  Up: Loading

Autoload
========

  The "autoload" facility allows you to call a function or macro whose
function definition has not yet been loaded into Emacs.  An attempt
to call the symbol while its definition is an `autoload' object will
automatically install the real definition and its other associated
code, and then call the real definition.

  To prepare a function or macro for autoloading, you must call
`autoload' on it, specifying the function name and the name of the
file to be loaded.  This is usually done when Emacs is first built,
by files such as `emacs/lisp/loaddefs.el'.

  The following example shows how `doctor' is prepared for autoloading
in `loaddefs.el':

     (autoload 'doctor "doctor"
       "\
     Switch to *doctor* buffer and start giving psychotherapy."
       t)

The backslash and newline immediately following the double-quote are
a convention used only the preloaded Lisp files such as
`loaddefs.el'; they cause the documentation string to be put in the
`etc/DOC' file.  If this autoload were in one of your libraries, you
would write just this:

     (autoload 'doctor "doctor"
       "Switch to *doctor* buffer and start giving psychotherapy."
       t)

  Calling `autoload' creates an `autoload' object containing the name
of the file and some other information, and makes this the definition
of the specified symbol.  When you later try to call that symbol as a
function or macro, the file is loaded; the loading should redefine
that symbol with its proper definition.  After the file completes
loading, the function or macro is called as if it had been there
originally.

  If, at the end of loading the file, the desired Lisp function or
macro has not been defined, then the error `error' is signaled (with
data `"Autoloading failed to define function FUNCTION-NAME"'.

  The autoloaded file may, of course, contain other definitions and may
require or provide one or more features.  If the file is not
completely loaded (due to some error in the evaluation of the
contents) any function definitions or `provide' calls that occurred
during the load are undone.  This is to ensure that another
`autoload' attempt will result from the next attempt to call the
autoloading function.

 * Function: autoload SYMBOL FILENAME &optional DOCSTRING INTERACTIVE
MACRO

       This function defines the function (or macro) named SYMBOL so as
     to load automatically from FILENAME.  FILENAME is a file name
     which will be passed to `load' when the function is called.

       DOCSTRING is the documentation string for the function. 
     Normally, this is the same string that is in the function
     definition itself.  This makes it possible for you to look at
     the documentation without loading the file.

       If INTERACTIVE is non-`nil', then the function can be called
     interactively.  This lets completion in `M-x' work without
     loading the symbol's definition.  The complete interactive
     specification need not be given here.  If MACRO is non-`nil',
     then the function is really a macro.

       If SYMBOL already has a non-`nil' function cell that is not an
     `autoload' object, `autoload' does nothing and returns `nil'. 
     If the function cell of SYMBOL is void, or is already an
     `autoload' object, then it is set to an `autoload' object that
     looks like this:

          (autoload FILENAME DOCSTRING INTERACTIVE MACRO)

       For example,

          (symbol-function 'run-prolog)
               => (autoload "prolog" 169681 t nil)

     In this case, `prolog' is the name of the file to load, 169681
     is the reference to the documentation string in the
     `emacs/etc/DOC' file (*note Documentation Basics::.), `t' means
     the function is interactive, and `nil' that it is not a macro.



File: lispref,  Node: Features,  Prev: Autoload,  Up: Loading

Features
========

  `provide' and `require' are an alternative to `autoload' for loading
files automatically.  They work in terms of named "features". 
Autoloading is triggered by calling a specific function, but a
feature is loaded the first time another program asks for it by name.

  The use of named features simplifies the task of determining whether
required definitions have been defined.  A feature name stands for a
collection of functions, variables, etc.  A program that needs the
collection may ensure that they are defined by "requiring" the
feature.  If the file that contains the feature has not yet been
loaded, then it will be loaded (or an error will be signaled if it
cannot be loaded).  The file thus loaded must "provide" the required
feature or an error will be signaled.

  To require the presence of a feature, call `require' with the name of
the feature.  `require' looks in the global variable `features' to
see whether the desired feature has been provided already.  If not,
it loads the associated file.  The file that contains the feature
should call `provide' at the top-level to add the feature to
`features' once it is loaded.

  Features are normally named after the files they are provided in so
that `require' need not be given the file name.

  For example, in `emacs/lisp/prolog.el',  the definition for
`run-prolog' includes the following code:

     (interactive)
     (require 'shell)
     (switch-to-buffer (make-shell "prolog" "prolog"))
     (inferior-prolog-mode))

The expression `(require 'shell)' means that if the `shell' file has
not yet been loaded, it will be loaded.  This ensures that
`make-shell' is defined.

Also, the `emacs/lisp/shell.el' file contains the following top-level
expression:

     (provide 'shell)

This adds `shell' to the global `features' list when the `shell' file
is loaded, so that `(require 'shell)' will know that nothing needs to
be done.  (The order of the elements in the `features' list is not
significant.)

  When `require' is used at top-level in a file, it takes effect if you
byte-compile that file (*note Byte Compilation::.).  This is in case
the required package contains macros that the byte-compiler must know
about.

  Although top-level calls to `require' are evaluated during
byte-compilation, `provide' calls are not.  Therefore, you can ensure
that a file of definitions is loaded before it is byte-compiled by
including a `provide' followed by a `require' for the same feature,
as in the following example.

     (provide 'my-feature)  ; ignored by byte compiler, evaluated by load
     (require 'my-feature)  ; evaluated by byte compiler

 * Function: provide FEATURE

     This function announces that FEATURE is now loaded, or being
     loaded, into the current Emacs session.  This means that the
     facilities associated with FEATURE are or will be available for
     other Lisp programs.

     The direct effect of calling `provide' is to add FEATURE to the
     front of the list `features' if it is not already in the list. 
     FEATURE must be a symbol.  `provide' returns FEATURE.

          features
               => (bar bish)
          
          (provide 'foo)
               => foo
          features
               => (foo bar bish)

     During autoloading, if the file is not completely loaded (due to
     some error in the evaluation of the contents) any function
     definitions or `provide' calls that occurred during the load are
     undone.

 * Function: require FEATURE &optional FILENAME

       This function looks to see if FEATURE is present in the current
     Emacs session (i.e., `(featurep FEATURE)' is true).  If it is
     not, then `require' loads FILENAME with `load'.  If FILENAME is
     not supplied, then FEATURE is used as the file name to load.

       If FEATURE is not provided after the file has been loaded, Emacs
     will signal the error `error' (with data `Required feature
     FEATURE was not provided').

 * Function: featurep FEATURE

       This function returns `t' if FEATURE has been provided in the
     current Emacs session (i.e., FEATURE is a member of `features'.)

 * Variable: features

       The value of this global variable is a list of symbols which are
     the features loaded in the current Emacs session.  Each symbol
     was put in this list with a call to `provide'.



File: lispref,  Node: Byte Compilation,  Next: Debugging,  Prev: Loading,  Up: Top

Byte Compilation
****************

  GNU Emacs Lisp has a "compiler" which translates functions which you
write in Lisp into a special form called "byte code" which can be
executed more efficiently.  The compiler replaces each function
definition with byte code.  When a byte code function is called, its
definition is evaluated by the "byte code interpreter".

  Because the byte compiled code is evaluated by the byte-code
interpreter, instead of being executed directly by the machine's
hardware (as true compiled code is), byte-code is completely
transportable from machine to machine without re-compilation.  But it
is not as fast as true compiled code.

  *Note Compilation Errors::, for how to investigate errors in byte
compilation.

* Menu:

* Compilation Functions::       Byte compilation functions.
* Disassembly::                 Disassembling byte code; how to read byte code.

 

File: lispref,  Node: Compilation Functions,  Next: Disassembly,  Prev: Byte Compilation,  Up: Byte Compilation

The Compilation Functions
=========================

  An individual function or macro definition may be byte-compiled with
the `byte-compile' function.  A whole file may be byte-compiled with
`byte-compile-file' and several files may be byte-compiled with
`byte-recompile-directory' or `batch-byte-compile'.  Only `defun' and
`defmacro' forms in a file are byte-compiled; other top-level forms
are not altered by byte-compilation.

  Be careful when byte compiling code that uses macros.  Macro calls
are expanded when they are compiled; therefore the macros must
already be defined for proper compilation.  For more details, see
*Note Macros::.

  While byte-compiling a file, any `require' calls at top-level are
executed.  This is one way to ensure that necessary macro definitions
are available during compilation: require the file that defines them.
*Note Features::.

  A byte compiled function is not as efficient as a primitive function
written in C, but it will run much faster than the interpreted version.
As a rough comparison, consider the example below:

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n)) 
                   0))
         (list t1 (current-time-string))
         ))
          => silly-loop
     
     (silly-loop 100000)
          => ("Thu Jan 12 20:18:38 1989" 
             "Thu Jan 12 20:19:29 1989")  ; 51 secconds
     
     (byte-compile 'silly-loop)
          => [Compiled code not shown]
     
     (silly-loop 100000)
          => ("Thu Jan 12 20:21:04 1989" 
         "Thu Jan 12 20:21:17 1989")  ; 13 seconds

  In this example, the interpreted code required 51 seconds to run,
whereas the byte compiled code required 13 seconds.  These results
are representative, but there will be great variability depending on
the specific functions called.

 * Function: byte-compile SYMBOL

       This function byte-compiles the function definition of SYMBOL,
     replacing the previous definition with the compiled one.  The
     function definition of SYMBOL must be the actual code for the
     function; i.e., the compiler will not follow indirection to
     another symbol.  `byte-compile' does not compile macros.

          (defun factorial (integer)
            "Compute factorial of INTEGER."
            (if (= 1 integer) 1
              (* integer (factorial (1- integer)))))
               => factorial
          
          (byte-compile 'factorial)
               => (lambda (integer) 
                           "Compute factorial of INTEGER." 
                           (byte-code "\301^HU\203
                           ^@\301\202^Q^@\302^H\303^HS!\"\207"
                                      [integer 1 * factorial] 4))

     The string which is the first argument of `byte-code' is the
     actual byte code.  Each character in it is an instruction.  The
     vector contains all the constants, variable names and function
     names used by the function, except for certain primitives which
     are coded as special instructions.

       The `byte-compile' function is not autoloaded as are
     `byte-compile-file' and `byte-recompile-directory'.

 * Command: byte-compile-file FILENAME

       This function compiles a file of Lisp code named FILENAME into a
     file of byte code.  The output file's name is made by appending
     `c' to the end of FILENAME.

       Compilation works by reading the input file one form at a time. 
     If it is a definition of a function or macro, the compiled
     function or macro definition is written out.  Other forms are
     copied out unchanged.  All comments are discarded when the input
     file is read.

       When called interactively, this command prompts you for the
     filename.

          % ls -l push*
          -rw-r--r--  1 lewis             791 Oct  5 20:31 push.el
          
          (byte-compile-file "~/emacs/push.el")
               => t
          
          % ls -l push*
          -rw-r--r--  1 lewis             791 Oct  5 20:31 push.el
          -rw-rw-rw-  1 lewis             638 Oct  8 20:25 push.elc

 * Command: byte-recompile-directory DIRECTORY FLAG

       This function recompiles every `.el' file in DIRECTORY that
     needs recompilation.  A file needs recompilation if a `.elc'
     file exists but is older than the `.el' file.

       If a `.el' file exists, but there is no corresponding `.elc'
     file, then FLAG is examined.  If it is `nil', the file is
     ignored.  If it is non-`nil', the user is asked if the file
     should be compiled.

 * Function: batch-byte-compile

       This function runs `byte-compile-file' on the files remaining on
     the command line.  This function must be used only in a batch
     execution of Emacs, as it kills Emacs on completion.  Each file
     will be processed, even if an error occurs while compiling a
     previous file.  (The file with the error will not produce any
     compiled code, of course.)

          % emacs -batch -f batch-byte-compile *.el

 * Function: byte-code CODE-STRING DATA-VECTOR MAX-STACK

       This is the function that actually interprets byte code.  A
     byte-compiled function is actually defined with a body that
     calls `byte-code'.  Don't call this function yourself!  Only
     `byte-code' knows how to generate valid calls to this function.



File: lispref,  Node: Disassembly,  Prev: Compilation Functions,  Up: Byte Compilation

Dissassembled Byte Code
=======================

  People never write byte code; that job is left to the byte compiler. 
But a disassembler has been provided to satisfy a cat-like curiosity.
The disassembler converts the byte-compiled code into a humanly
readable form.

  The byte code interpreter is implemented as a simple stack machine. 
Values get stored by being pushed onto the stack, and are popped off
and manipulated, the results being pushed back onto the stack.  When
a function returns, the top of the stack is popped and returned as
the value of the function.

  In addition to the stack, variables bound in the environment can also
hold values during execution.  The values of such variables can be
pushed onto the stack, or the variables can be set by popping the
stack.

 * Command: disassemble OBJECT &optional STREAM

     This function prints the disassembled code for OBJECT.  If
     STREAM is supplied, then output goes there.  Otherwise, the
     disassembled code is printed to the stream `standard-output'. 
     OBJECT can be a function name or a lambda expression.

     As a special exception, if this function is used interactively,
     it outputs to a buffer named `*Disassemble*'.

  Here are two examples of using the `disassemble' function.  The
comments added to the examples do not appear in the output of
`disassemble'.

     (defun factorial (integer)
       "Compute factorial of an integer."
       (if (= 1 integer) 1
         (* integer (factorial (1- integer)))))
          => factorial
     
     (factorial 4)
          => 24
     
     (disassemble 'factorial)
          => byte code for factorial:
      doc: Compute factorial of an integer.
      args: (integer)
     
     0   constant 1              ; push 1 onto stack
     
     1   varref   integer        ; get value of `integer' from the environment
                                 ;     and push the value onto the stack
     
     2   eqlsign                 ; pop top two values off stack,
                                 ;     compare them,
                                 ;     and push result onto stack
     
     3   goto-if-nil 10          ; pop and test top of stack;
                                 ;     if `nil', go to 10,
                                 ;     else continue
     
     6   constant 1              ; push 1 onto top of stack
     
     7   goto     17             ; go to 17 (in this case, 1 will be
                                 ;     returned by the function)
     
     10  constant *              ; push symbol `*' onto stack
     
     11  varref   integer        ; push value of `integer' onto stack
     
     12  constant factorial      ; push `factorial' onto stack
     
     13  varref   integer        ; push value of `integer' onto stack
     
     14  sub1                    ; pop `integer', decrement value,
                                 ;     push new value onto stack
     
                             ; stack now is:
                             ;     decremented value of `integer'
                             ;     `factorial' 
                             ;     value of `integer'
                             ;     `*'
     
     15  call     1              ; call function `factorial' using
                                 ;     the first (i.e., the top) element
                                 ;     of the stack as the argument;
                                 ;     push returned value onto stack
     
                             ; stack now is:
                             ;        result of result of recursive
                             ;             call to `factorial'
                             ;        value of `integer'
                             ;        `*'
     
     16  call     2              ; using the first two (i.e., the top two)
                                 ;     elements of the stack as arguments,
                                 ;     call the function `*',
                                 ;     pushing the result onto the stack
     
     17  return                  ; return the top element of the stack
     
          => nil

The `silly-loop' function is somewhat more complex:

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n)) 
                   0))
         (list t1 (current-time-string))
         ))
          => silly-loop
     
     (disassemble 'silly-loop)
          => byte code for silly-loop:
      doc: Return time before and after N iterations of a loop.
      args: (n)
     
     0   constant current-time-string      ; push `current-time-string'
                                           ;     onto top of stack
     
     1   call     0              ; call `current-time-string' with no
                                 ;     argument, pushing result onto stack
     
     2   varbind  t1             ; pop stack and bind `t1' to popped value
     
     3   varref   n              ; get value of `n' from the environment
                                 ;     and push the value onto the stack
     
     4   sub1                    ; subtract 1 from top of stack
     
     5   dup                     ; duplicate the top of the stack;
                                 ;     i.e. copy the top of the stack
                                 ;     and push the copy onto the stack
     
     6   varset   n              ; pop the top of the stack,
                                 ;     and bind `n' to the value
     
                         ; in effect, the sequence `dup varset' copies
                         ; the top of the stack into the value of `n'
                         ; without popping it
     
     7   constant 0              ; push 0 onto stack
     
     8   gtr                     ; pop top two values off stack,
                                 ;     test if N is greater than 0
                                 ;     and push result onto stack
     
     9   goto-if-nil-else-pop 17     ; goto 17 if `n' > 0 else
                                     ;     pop top of stack and continue
                                     ;     (this exits the while loop)
     
     12  constant nil            ; push `nil' onto stack
                                 ;     (this is the body of the loop)
     
     13  discard                 ; discard result of the body of the loop
                                 ;     (a while loop is always evaluated
                                 ;     for its side effects)
     
     14  goto     3              ; jump back to beginning of while loop
     
     17  discard                 ; discard result of while loop
                                 ;     by popping top of stack
     
     18  varref   t1             ; push value of `t1' onto stack
     
     19  constant current-time-string      ; push `current-time-string'
                                           ;     onto top of stack
     
     20  call     0              ; call `current-time-string' again
     
     21  list2                   ; pop top two elements off stack,
                                 ;     create a list of them,
                                 ;     and push list onto stack
     
     22  unbind   1              ; unbind t1 in local environment
     
     23  return                  ; return value of the top of stack
     
          => nil



File: lispref,  Node: Debugging,  Next: Streams,  Prev: Byte Compilation,  Up: Top

Debugging
*********

  If the problem occurs when you run the program, you can use the Lisp
Debugger to investigate what is happening during execution.

  If the problem is syntactic, so that Lisp cannot even read the
program, you can use the Emacs facilities for editing Lisp to
localize it.

  If the problem occurs when trying to compile the program with the
byte compiler, you need to know how to examine the compiler's input
buffer.

* Menu:

* Debugger::            How the Emacs Lisp debugger is implemented.
* Syntax Errors::       How to find syntax errors.
* Compilation Errors::  How to find errors that show up in byte compilation.

   Another useful debugging tool is a dribble file.  When a dribble file
is open, Emacs copies all keyboard input characters to that file. 
You can examine it to find out what you did.  *Note Terminal Input::;
also see the `open-termscript' function in *Note Terminal Output::.



File: lispref,  Node: Debugger,  Next: Syntax Errors,  Prev: Debugging,  Up: Debugging

The Lisp Debugger
=================

  The "Lisp debugger" provides you with the ability to suspend
evaluation of a form.  While evaluation is suspended (a state that is
commonly known as a "break"), you may examine the runtime stack,
examine the values of local or global variables and, optionally,
change those values.  Since a break is a recursive edit while in the
middle of a function call, it is possible to do anything, including
calling the debugger again.  *Note Recursive Editing::.

  The debugger can step through the control structures of an
interpreted function, but cannot do so in a byte-compiled function. 
If you find that the problem occurs in a byte-compiled function, run
the function interpreted instead so you can step through it.  To do
this, visit the source file of the function and type `C-M-x' on its
definition.

* Menu:

* Error Debugging::       Entering the debugger when an error happens.
* Function Debugging::    Entering it when a certain function is called.
* Explicit Debug::        Entering it at a certain point in the program.
* Using Debugger::        What the debugger does; what you see while in it.
* Debugger Commands::     Commands used while in the debugger.
* How Debugger Works::    Overview of debugger implementation.
* Invoking the Debugger:: How to call the function `debug'.

 

File: lispref,  Node: Error Debugging,  Next: Function Debugging,  Prev: Debugger,  Up: Debugger

Entering the Debugger When an Error Occurs
------------------------------------------

  The most important way to enter the debugger is when a Lisp error
happens.  This allows you to investigate the immediate causes of the
error.

  However, entry to the debugger is not a normal consequence of an
error.  Many commands frequently get Lisp errors when invoked in
inappropriate contexts (such as `C-f' at the end of the buffer) and
during ordinary editing it would be very unpleasant to enter the
debugger each time this happens.

  So, if you want errors to start the debugger, you must set the
variable `debug-on-error' to non-`nil'.

  Quitting with `C-g' is not considered an error, and `debug-on-error'
has no effect on the handling of `C-g'.  However, if you set
`debug-on-quit' non-`nil', `C-g' will invoke the debugger.  This can
be useful for debugging an infinite loop; set `debug-on-quit' to `t',
then start the loop, and type `C-g' once it has had time to reach its
steady state.  `debug-on-quit' has no effect on errors.

 * Option: debug-on-error

     This variable determines whether the debugger is called when a
     error is signaled and not handled.  If `debug-on-error' is
     non-`nil', then the debugger is called when an error happens. 
     Otherwise the debugger is not called for errors.

 * Option: debug-on-quit

     This variable determines whether the debugger is called when
     `quit' is signaled and not handled.  If `debug-on-quit' is
     non-`nil', then the debugger is called whenever you quit (that
     is, type `C-g').  If `debug-on-quit' is `nil', then the debugger
     is not called when you quit.  *Note Quitting::.



File: lispref,  Node: Function Debugging,  Next: Explicit Debug,  Prev: Error Debugging,  Up: Debugger

Entering the Debugger when Some Function is Called
--------------------------------------------------

 * Command: debug-on-entry FUNCTION-NAME

       This function requests FUNCTION-NAME to invoke the debugger each
     time it is called.  It works by inserting the form `(debug
     'debug)' into the function definition as the first form.

       Any function defined as Lisp code may be debugged, regardless of
     whether it is interpreted code or compiled code.  Even functions
     that are commands may be debugged.  They will enter the debugger
     when called inside a function, or when called interactively. 
     Primitive functions (i.e., those written in C) may not be
     debugged.

       When `debug-on-entry' is called interactively, Emacs prompts you
     for FUNCTION-NAME in the minibuffer.

       If `debug-on-entry' is called more than once on the same
     function, the second call does nothing.  `debug-on-entry'
     returns FUNCTION-NAME.

          (defun fact (n)
            (if (zerop n) 1
                (* n (fact (1- n)))))
               => fact
          (debug-on-entry 'fact)
               => fact
          (fact 3)
               => 6
          
          --------- Buffer: *Backtrace* ---------
          Entering:
          * fact(3)
            eval-region(4870 4878 t)
            byte-code("...")
            eval-last-sexp(nil)
            (let ...)
            eval-insert-last-sexp(nil)
          * call-interactively(eval-insert-last-sexp)
          --------- Buffer: *Backtrace* ---------
          
          (symbol-function 'fact)
               => (lambda (n)
               (debug (quote debug))
               (if (zerop n) 1 (* n (fact (1- n)))))

 * Command: cancel-debug-on-entry FUNCTION-NAME

       This function undoes the effect of `debug-on-entry' on
     FUNCTION-NAME.

       When `cancel-debug-on-entry' is called interactively, Emacs
     prompts you for FUNCTION-NAME in the minibuffer.

       If `cancel-debug-on-entry' is called more than once on the same
     function, the second call does nothing.  `cancel-debug-on-entry'
     returns FUNCTION-NAME.



File: lispref,  Node: Explicit Debug,  Next: Using Debugger,  Prev: Function Debugging,  Up: Debugger

Explicit Entry to the Debugger
------------------------------

  You can cause the debugger to be called at a certainn point in your
program by writing the expression `(debug)' at that point.  To do
this, visit the source file, insert the text `(debug)' at the proper
place, and type `C-M-x'.  Be sure to undo this insertion before you
save the file!

  Remember that the place where you insert `(debug)' must be a place
where an additional form can be evaluated and its value ignored.  (If
the value isn't ignored, it will alter the execution of the program!)
Usually this means inside a `progn' or an implicit `progn' (*note
Sequencing::.).



File: lispref,  Node: Using Debugger,  Next: Debugger Commands,  Prev: Explicit Debug,  Up: Debugger

Using the Debugger
------------------

  When the debugger is entered, it displays the previously selected
buffer in one window and a buffer named `*Backtrace*' in another
window.  The backtrace buffer contains one line for each level of
Lisp function execution currently going on.  At the beginning of this
buffer is a message describing the reason that the debugger was
invoked (such as, what error message if it was invoked due to an
error).

  The backtrace buffer is read-only, and is in a special major mode,
Backtrace mode, in which letters are defined as debugger commands. 
The usual Emacs editing commands are available; you can switch
windows to examine the buffer that was being edited at the time of
the error, and you can also switch buffers, visit files, and do any
other sort of editing.  However, the debugger is a recursive editing
level (*note Recursive Editing::.) and it is wise to go back to the
backtrace buffer and officially exit the debugger when you don't want
to use it any more.  Exiting the debugger kills the backtrace buffer.

  The contents of the backtrace buffer show you the functions that are
executing and the arguments that were given to them.  It has the
additional purpose of allowing you to specify a stack frame by moving
point to the line describing that frame.  The frame whose line point
is on is considered the "current stack frame".  Some of the debugger
commands operate on the current frame.  Debugger commands are mainly
used for stepping through code an expression at a time.  Here is a
list of them.



File: lispref,  Node: Debugger Commands,  Next: How Debugger Works,  Prev: Using Debugger,  Up: Debugger

Debugger Commands
-----------------

  Once you are in the debugger, these special commands are available in
addition to the usual cursor motion commands.  Also, you can switch
buffers to look at the data being operated on or the program that is
running.

`c'
     Exit the debugger and continue execution.  In most cases,
     execution of the program continues as if the debugger had never
     been entered (aside from the effect of any variables or data
     structures you may have changed while inside the debugger). 
     This includes entry to the debugger due to function entry or
     exit, explicit invocation, quitting or certain errors.  Most
     errors cannot be continued; trying to continue an unsuitable
     error causes the same error to occur again.

`d'
     Continue execution, but enter the debugger the next time a Lisp
     function is called.  This allows you to step through the
     subexpressions of an expression, seeing what values the
     subexpressions compute and what else they do.

     The stack frame made for the function call which enters the
     debugger in this way will be flagged automatically for the
     debugger to be called when the frame is exited.  You can use the
     `u' command to cancel this flag.

`b'
     Set up to enter the debugger when the current frame is exited. 
     Frames that will invoke the debugger on exit are flagged with
     stars.

`u'
     Don't enter the debugger when the current frame is exited.  This
     cancels a `b' command on that frame.

`e'
     Read a Lisp expression in the minibuffer, evaluate it, and print
     the value in the echo area.  This is the same as the command
     `M-ESC', except that `e' is not normally disabled like `M-ESC'.

`q'
     Terminate the program being debugged; return to top-level Emacs
     command execution.

     If the debugger was entered due to a `C-g' but you really want
     to quit, not to debug, use the `q' command.

`r'
     Return a value from the debugger.  The value is computed by
     reading an expression with the minibuffer and evaluating it.

     The value returned by the debugger makes a difference when the
     debugger was invoked due to exit from a Lisp call frame (as
     requested with `b'); then the value specified in the `r' command
     is used as the value of that frame.

     The debugger's return value also matters with many errors.  For
     example, `wrong-type-argument' errors will use the debugger's
     return value instead of the invalid argument; `no-catch' errors
     will use the debugger value as a throw tag instead of the tag
     that was not found.  If an error was signaled by calling the
     Lisp function `signal', the debugger's return value is returned
     as the value of `signal'.



File: lispref,  Node: How Debugger Works,  Next: Invoking the Debugger,  Prev: Debugger Commands,  Up: Debugger

How the Debugger Works
----------------------

  The operation of the debugger is simple: it performs one basic
operation, which is to enter a break.  The debugger enters such a
break when any of the following conditions occurs:

   * when a certain function specified by you is entered or exited;

   * when a error occurs; or

   * when a `quit' signal is not handled by user code.

   * when your program calls `debug' explicitly.

After entering the break, the debugger displays information about the
status of the stack in a `*Backtrace*' buffer, and waits for you to
type a command.

  When you cause Emacs to continue evaluation at a break for function
entry or exit, the debugger will arrange for the called function to
continue to a normal conclusion and return the same value that it
would return when evaluated without the debugger.  It will not
produce an abnormal termination unless you specifically request it.



File: lispref,  Node: Invoking the Debugger,  Prev: How Debugger Works,  Up: Debugger

Functions to Invoke the Debugger
--------------------------------

 * Function: debug &rest DEBUGGER-ARGS

       This function enters the debugger.  It switches buffers to a
     buffer named `*Backtrace*' (or `*Backtrace*<2>' if it is the
     second recursive edit, etc.), and prints out information about
     the stack.  Emacs then enters a recursive edit, leaving that
     buffer showing in the selected window, which is in Debugger mode.

       Debugger mode provides a `continue' command which operates by
     exiting the recursive edit, switching back to the previous
     buffer, and returning to whatever called `debug'.  This is the
     only way the function `debug' can return to its caller.

       If the first of the DEBUGGER-ARGS passed to `debug' is `nil' (or
     if it is not one of the following special values), then the rest
     of the arguments to `debug' are printed at the top of the
     `*Backtrace*' buffer.  This mechanism is used to display a
     message to the user.

       However, if the first argument passed to `debug' is one of the
     following special values, then it has special significance. 
     Normally, these values are passed to `debug' only by the
     internals of Emacs and the debugger, and not by programmers
     calling `debug'.

       The special values are:

    `lambda'
            When `lambda' is the first of the DEBUGGER-ARGS, the
          debugger displays `Entering:' as a line of text at the top
          of the buffer.  This is used to show that a function set
          for debug on entry is being entered.

    `debug'
            When `debug' is the first of the DEBUGGER-ARGS, the
          debugger likewise displays `Entering:', just as when
          `lambda' is passed as the first of the DEBUGGER-ARGS.  In
          addition, `debug' as the first argument directs the
          debugger to mark the function that called `debug' so that
          it will break also on exit.

    `error'
            When `error' is the first argument, the debugger shows that
          it is being entered because an error or `quit' was signaled
          and not handled.  If an error was signaled, presumably the
          variable `debug-on-error' is non-`nil'.  If `quit' was
          signaled, then presumably the variable `debug-on-quit' is
          non-`nil'.

            When entering, the debugger displays `Signaling:' followed
          by the error signaled and any arguments to `signal'.

            For example,

               (let ((debug-on-error t))
                    (/ 1 0))
               
               --------- Buffer: *Backtrace* ---------
               Signaling: (arith-error)
                 /(1 0)
               ...

    `t'
            When `t' is the first argument, the debugger will indicate
          that Emacs is beginning the evaluation of a function call. 
          The debugger displays `Beginning evaluation of function
          call form:' as the top line in the buffer.

    `exit'
            When `exit' is the first argument, it means that a function
          that was being debugged is returning a value.  The debugger
          displays `Return value:' on the top line of the buffer,
          followed by the returned value.

    `nil'
            Use `nil' as the first of the DEBUGGER-ARGS when you want
          to enter the debugger directly.  The rest of the
          DEBUGGER-ARGS are printed on the top line of the buffer. 
          You can use this feature to display messages--for example,
          to remind yourself of the conditions under which `debug' is
          called.

 * Variable: debugger

       The value of this variable is the function to call to invoke the
     debugger.  Its value must be a function (or, more typically, the
     name of a function) of any number of arguments.  Presumably this
     function will enter some kind of debugger.

       The first argument that Lisp hands to the function indicates why
     it was called.  The convention for arguments is detailed in the
     description of `debug'.

 * Command: backtrace

       This function prints a trace of Lisp function calls currently
     active.  This is the function used by `debug' to fill up the
     `*Backtrace*' buffer.  It is written in C, as it must have
     access to the stack to determine which function calls are
     active.  The return value is always `nil'.

       In the following example, `backtrace' is called explicitly in a
     Lisp expression.  When the expression is evaluated, the
     backtrace is printed to the stream `standard-output': in this
     case, to the buffer `backtrace-output'.  Each line of the
     backtrace represents one function call.  If the arguments of the
     function call are all known, they are displayed; if they are
     being computed, that fact is displayed.  The arguments of
     special forms are elided.

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))
                                   ))))))
          
               => nil
          ---------- Buffer: backtrace-output -----------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval-region(1973 2142 #<buffer *scratch*>)
            byte-code("...  for eval-print-last-sexp ...")
            eval-print-last-sexp(nil)
          * call-interactively(eval-print-last-sexp)
          ---------- Buffer: backtrace-output -----------

 * Option: stack-trace-on-error

       This obsolete variable controls whether Lisp automatically
     displays a backtrace buffer after every error that is not
     handled.  A quit signal counts as an error for this variable. 
     If it is non-`nil' then a backtrace is shown in a pop-up buffer
     named `*Backtrace*' on every error.  If it is `nil', then a
     backtrace is not shown.

       When a backtrace is shown, that buffer is not selected.  If
     either `debug-on-quit' or `debug-on-error' is also non-`nil',
     then a backtrace is shown in one buffer, and the debugger is
     popped up in another buffer with its own backtrace.

 * Variable: debug-on-next-call

     This variable determines whether the debugger is called before
     the next `eval', `apply' or `funcall'.  It is automatically
     reset to `nil' when the debugger is entered.

     The `d' command in the debugger works by setting this variable.

 * Function: backtrace-debug LEVEL FLAG

       This function sets the debug-on-exit flag of the eval frame
     LEVEL levels down to FLAG.  If FLAG is non-`nil', this will
     cause the debugger to be entered when that frame exits.

       The debug-on-exit flag is an entry in the stack frame of a
     function call.  This flag is examined on every exit from a
     function.

       Normally, this function is only called by the debugger.



File: lispref,  Node: Syntax Errors,  Next: Compilation Errors,  Prev: Debugger,  Up: Debugging

Debugging Invalid Syntax
========================

  It is easy to make invalid syntax in an Emacs Lisp program by
omitting a parenthesis.  The Lisp reader will detect an error, but
cannot tell you where the real problem is.  For example, if a
close-parenthesis is omitted, the reader will detect an imbalance at
the end of the file, but it cannot tell anything about where the
close-parenthesis should have been.

excess open-parenthesis
       The first step is to find the defun which is unbalanced.  If
     there is an excess open-parenthesis, the way to do this is to
     insert a close-parenthesis at the end of the file and type
     `C-M-b' (`backward-sexp').  This will move you to the beginning
     of the defun you seek.  (Then type `C-SPC C-_ C-u C-SPC' to set
     the mark, undo the insertion of the close-parenthesis, and
     return to the mark.)

       The next step is to determine precisely what is wrong.  There is
     no way to be sure of this except to study the program, but often
     the existing indentation is a clue to where the parentheses
     should have been.  The easiest way to use this clue is to
     reindent with `C-M-q' and see what moves.

       Before you can do this, you must make sure the defun has enough
     close-parentheses.  Otherwise, `C-M-q' will get an error, or
     will reindent all the rest of the file until the end.  So move
     to the end of the defun and insert a close-parenthesis there. 
     Don't use `C-M-e' to move there, since that too will fail to
     work until the defun is balanced.

       Then go to the beginning of the defun and type `C-M-q'.  Usually
     all the lines from a certain point to the end of the function
     will shift to the right.  There is probably a missing
     close-parenthesis, or a superfluous open-parenthesis, near that
     point.  But don't assume this is true; study the code to make
     sure.

       After you think you have fixed the problem, use `C-M-q' again. 
     It should not change anything.

excess close-parenthesis
       To deal with an excess close-parenthesis, first insert an
     open-parenthesis at the beginning of the file and type `C-M-f'
     to find the end of the unbalanced defun.  (Then remove the extra
     open-parenthesis.)

       Then find the actual matching close-parenthesis by typing
     `C-M-f' at the beginning of the defun.  This will leave you
     somewhere short of the place where the defun ought to end.  It
     is possible that you will find a spurious close-parenthesis in
     that vicinity.

       If you don't see a problem at that point, the next thing to do
     is to type `C-M-q' at the beginning of the defun.  A range of
     lines will probably shift left; if so, the missing
     open-parenthesis or spurious close-parenthesis is probably near
     the first of those lines.

other problems
       If the problem is not simply an imbalance of parentheses, a
     useful technique is to try `C-M-e' at the beginning of each
     defun, and see if it goes to the place where that defun appears
     to end.  If it does not, there is a problem in that defun.



File: lispref,  Node: Compilation Errors,  Prev: Syntax Errors,  Up: Debugging

Debugging Problems in Compilation
=================================

  When an error happens during byte compilation, it is normally due to
an error in the program you are compiling.  The compiler itself can't
tell you where in the file the error occurred; but there is a way to
find out.

  What you should do is switch to the buffer ` *Compiler Input*'. 
(Note that the buffer name starts with a space, so that it will not
show up in `M-x list-buffers'.)  This buffer contains the program
being compiled, and point shows how far the byte compiler was able to
read.

  If the error was due to invalid Lisp syntax, point shows exactly
where the invalid syntax was *detected*.  The cause of the error is
not necessarily near by!  Use the techniques in the previous section
to find the error.

  If the error was detected while compiling a form that had been read
successfully, then point is located at the end of the form.  In this
case, it can't localize the error precisely, but can still show you
which function to look in.



File: lispref,  Node: Streams,  Next: Minibuffers,  Prev: Debugging,  Up: Top

Reading and Printing Lisp Objects
*********************************

  "Printing" and "reading" are the operations of converting Lisp
objects to textual form and vice versa.  They use the printed
representations and syntax described in *Note Types of Lisp Object::.

  This chapter describes the Lisp functions for reading and printing. 
It also describes "streams", which specify where to get the text (if
reading) or where to put it (if printing).

* Menu:

* Streams Intro::     Overview of streams, reading and printing.
* Input Streams::     Various data types that can be used as input streams.
* Input Functions::   Functions to read Lisp objects from text.
* Output Streams::    Various data types that can be used as input streams.
* Output Functions::  Functions to print Lisp objects as text.

 

File: lispref,  Node: Streams Intro,  Next: Input Streams,  Prev: Streams,  Up: Streams

Introduction to Reading and Printing
====================================

  "Reading" a Lisp object means parsing a Lisp expression in textual
form and producing a corresponding Lisp object.  This is how Lisp
programs get into Lisp from files of Lisp code.  For example, reading
the text `(a . 5)' returns a cons cell whose CAR is `a' and whose CDR
is the number 5.

  "Printing" a Lisp object means producing the text which represents
that object.  Printing that cons cell produces the text `(a . 5)'.

  Generally speaking, reading and printing are inverse operations. 
Printing the object that results from reading a given piece of text
usually produces the same text, and reading the text that results
from printing an object usually produces a similar-looking object. 
For example, printing the symbol `foo' produces the text `foo', and
reading that text returns the symbol `foo'.  Printing a list whose
elements are `a' and `b' produces the text `(a b)', and reading that
text produces a list (but not the same list) with elements are `a'
and `b'.

  However, these two operations are not precisely inverses.  There are
two kinds of exceptions:

   * Printing can produce text that cannot be read.  For example,
     buffers, windows, subprocesses and markers print into text that
     starts with `#'; if you try to read this text, you get an error.
     There is no way to read those data types.

   * One object can have multiple textual representations.  For
     example, `1' and `01' represent the same integer, and `(a b)'
     and `(a . (b))' represent the same list.  Reading will accept
     any of the alternatives, but evidently printing must choose one
     of them.



File: lispref,  Node: Input Streams,  Next: Input Functions,  Prev: Streams Intro,  Up: Streams

Input Streams
=============

  Most of the Lisp functions for reading text take an "input stream" as
argument.  The input stream specifies where or how to get the
characters of the text to be read.  Here are the possible types of
input stream:

BUFFER
     The input characters are read from BUFFER, starting with the
     character directly after point.  Point advances as characters
     are read.

MARKER
     The input characters are read from the buffer that MARKER is in,
     starting with the character directly after the marker.  Its
     position advances as characters are read.  The value of point in
     the buffer has no effect when the stream is a marker.

STRING
     The input characters are taken from STRING, starting at the
     first character in the string and advancing through as many
     character as required.

FUNCTION
     The input characters are generated by FUNCTION, one per call.

     In version 18, FUNCTION is always called with no arguments and
     should return a character.

`t'
     `t' used as a stream means that the input is read from the
     minibuffer.  In fact, the minibuffer is invoked once and the
     text given by the user is made into a string which is then used
     as the input stream.

`nil'
     `nil' used as a stream means that the value of `standard-input'
     should be used instead; that value must be a non-`nil' input
     stream.

  Here is an example of reading from a stream which is a buffer.  We
show where point is before and after.

     --------- Buffer: foo ---------
     This-!- is the contents of foo.
     --------- Buffer: foo ---------
     
     (read (get-buffer "foo"))
     => is
     (read (get-buffer "foo"))
     => the
     
     --------- Buffer: foo ---------
     This is the -!-contents of foo.
     --------- Buffer: foo ---------

Note that the first read skips a space at the beginning.  Reading
always skips any amount of whitespace preceding the significant text.

Note also how the second read skips the space which terminates the
symbol `the'.  It has to read this space in order to know that no
more letters follow.

  Here is an example of reading from a stream which is a marker.  The
marker is initialized to point at the beginning of the buffer shown. 
The value of the read is the symbol `This'.

     --------- Buffer: foo ---------
     This is the contents of foo.
     --------- Buffer: foo ---------
     
     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
     => #<marker at 1 in foo>
     (read m)
     => This
     m
     => #<marker at 6 in foo>   ;; After the first space.

   Here we read from the text of a string:

     (read "(When in) the course")
     => (When in)

  The following example reads from the minibuffer, prompting with `Lisp
expression: '.  (That is always the prompt used when you read from
the stream `t'.)  The user's input is shown following the prompt.

     (read t)
     => 23
     --------- Buffer: Minibuffer ---------
     Lisp expression: `23 RET'

  Finally, here is an example of a stream which is a function, named
`useless-stream'.  The variable `useless-list' is initialized to a
list of characters.  Each call to the function `useless-stream'
produces the next letter in the list.

     (setq useless-list (append "XY()" nil))
     => (88 89 40 41)
     
     (defun useless-stream ()
       (prog1 (car useless-list)
              (setq useless-list (cdr useless-list))))
     => useless-stream

  Now we read using this stream.

     (read 'useless-stream)
     => XY
     
     useless-list
     => (41)

Note that only the close-parenthesis remains in the list.  This is
because the open-parenthesis was read before the Lisp reader knew it
had found the end of the symbol.  A second attempt to read from the
stream at this point would get an error due to the unmatched
close-parenthesis.

 * Function: get-file-char

     This function is used internally as an input stream to read from
     the input file opened by the function `load'.  Don't use this
     function yourself.



File: lispref,  Node: Input Functions,  Next: Output Streams,  Prev: Input Streams,  Up: Streams

Input Functions
===============

  This section describes the Lisp functions and variables that pertain
to reading.

  In the functions below, STREAM stands for an input stream.  See the
previous section for a description of input streams.  If STREAM is
`nil' or omitted, it defaults to the value of `standard-input'.

 * Variable: standard-input

     This global variable is the stream that `read' reads from when
     the STREAM argument is `nil'.

 * Function: read &optional STREAM

     This function reads one Lisp expression from STREAM, returning
     it as a Lisp object.  This is the basic Lisp input function.

 * Function: read-from-string STRING &optional START END

     This function reads the first Lisp-expression from the text in
     STRING.  It then returns a cons cell whose CAR is that
     expression and and whose CDR is an integer, giving the position
     of the next character in the string (the first one not read).

     If START is supplied, then reading begins at that index in the
     string (where the first character is at index 0).  If END is
     also supplied, then reading ends at that index, as if the rest
     of the string were not there.

     An `end-of-file' error will result if an unterminated list or
     vector is found.

          (read-from-string "(setq x 55) (setq y 5)")
          => ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
          ("A short string" . 16)
          
          ;; Read starting at the first character.
          (read-from-string "(list 112)" 0)
          ((list 112) . 10)
          ;; Read starting at the second character.
          (read-from-string "(list 112)" 1)
          (list . 6)
          ;; Read starting at the seventh character, and ending at the ninth.
          (read-from-string "(list 112)" 6 8)
          (11 . 8)



File: lispref,  Node: Output Streams,  Next: Output Functions,  Prev: Input Functions,  Up: Streams

Output Streams
==============

  An output stream specifies what to do with the characters produced by
printing.  Most print functions accept an output stream as an
optional argument.  Here are the possible types of output stream:

BUFFER
     The output characters are inserted into BUFFER at point.  Point
     advances as characters are inserted.

MARKER
     The output characters are inserted into the buffer that MARKER
     is in at the marker position.  The position advances as
     characters are inserted.  The value of point in the buffer has
     no effect when the stream is a marker.

FUNCTION
     FUNCTION is called with one output character as the argument. 
     It is called as many times as there are characters to be output.
     The function is free to do anything at all with the characters.

`t'
     `t' as an output stream means that the output characters should
     be printed in the echo area.

`nil'
     `nil' specified as an output stream means that the value of
     `standard-output' should be used as the output stream; that
     value must be a non-`nil' output stream.

  Here is an example of a buffer as output stream.  At the end, point
is located directly before that same `h'.

     --------- Buffer: foo ---------
     This is t-!-he contents of foo.
     --------- Buffer: foo ---------
     
     (print "This is the output" (get-buffer "foo"))
     => "This is the output"
     
     --------- Buffer: foo ---------
     This is t
     "This is the output"
     -!-he contents of foo.
     --------- Buffer: foo ---------

  Now we show a use of a marker as an output stream.  Initially, the
marker points in buffer `foo', between the `t' and the `h' in the
word `the'.  At the end, the marker has been advanced over the
inserted text so that it still points before the same `h'.

     --------- Buffer: foo ---------
     "This is t-!-he output"
     --------- Buffer: foo ---------
     
     m
     => #<marker at 11 in foo>
     
     (print "More output for foo." marker)
     => "More output for foo."
     
     --------- Buffer: foo ---------
     "This is t
     "More output for foo."
     -!-he output"
     --------- Buffer: foo ---------
     
     m
     => #<marker at 35 in foo>

  This example shows output to the echo area.

     (print "Echo Area output" t)
     => "Echo Area output"
     --------- Echo Area ---------
     "Echo Area output"
     --------- Echo Area ---------

  Finally, we show an output stream which is a function.  The function
`eat-output' takes each character that it is given and conses it onto
the front of the list `last-output'.  At the end, the list contains
all the characters output, but in reverse order.

     (setq last-output nil)
     => nil
     
     (defun eat-output (c)
       (setq last-output (cons c last-output)))
     => eat-output
     
     (print "This is the output" 'eat-output)
     => "This is the output"
     
     last-output
     => (10 34 116 117 112 116 117 111 32 101 104 116 32 115 105
         32 115 105 104 84 34 10)

Now we can put the output in the proper order by reversing the list:

     (concat (nreverse last-output))
     => "
     \"This is the output\"
     "



File: lispref,  Node: Output Functions,  Prev: Output Streams,  Up: Streams

Output Functions
----------------

  This section describes the Lisp functions and variables that pertain
to printing.

  There are actually two different ways of printing a Lisp object,
depending on the purpose of printing: with or without quoting
characters.  You specify quoting or no quoting by the choice of
printing function.

  If the text is to be read back into Lisp, then it is best to print
with quoting characters to avoid ambiguity.  (The quoting characters
used are `\' and `"'.)  *Note Printed Representation::, for the
details of how quoting characters are used.

  However, if the purpose of the output is to look nice for humans,
then it is better to print without quoting.

  In the functions below, STREAM stands for an output stream.  See the
previous section for a description of output streams.  If STREAM is
`nil' or omitted, it defaults to the value of `standard-output'.

 * Variable: standard-output

     The value of this variable is default output stream, used when
     the STREAM argument is omitted.

 * Function: print OBJECT &optional STREAM

     This function is the most convenient and simple interface to
     printing.  It outputs the printed representation of OBJECT to
     STREAM.  It also prints one newline before OBJECT and another
     after it.  It returns OBJECT.

     The output of `print' includes any escape and quoting characters
     (`\' and `"') required to allow the object to be read back in.

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
          -| 
          -| The\ cat\ in
          -| 
          -| "the hat"
          -| 
          -| " came back"
          -| 
          => " came back"

 * Function: prin1 OBJECT &optional STREAM

     This function outputs the printed representation of OBJECT to
     STREAM.  It does not print any spaces or newlines to separate
     output as `print' does, but it does use quoting characters just
     like `print'.  It returns OBJECT.

          (progn (prin1 'The\ cat\ in) 
                 (prin1 "the hat") 
                 (prin1 " came back"))
          -| The\ cat\ in"the hat"" came back"
          => " came back"

 * Function: prin1-to-string OBJECT

     This function returns a string which is what the function
     `prin1' would have printed.  See `format', in *Note String
     Conversion::, for other ways to convert objects to string
     representation.

          (prin1-to-string 'foo)
          => "foo"
          (prin1-to-string (mark-marker))
          => "#<marker at 2773 in strings.texinfo>"

 * Function: princ OBJECT &optional STREAM

     This function outputs the printed representation of OBJECT to
     STREAM.  It returns OBJECT.

     This function is intended to produce output that is readable by
     people, not `read', so no quoting characters are used, and
     double quotes are not printed around the contents of strings. 
     It does not add any spacing between calls.

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
          -| The cat in the "hat"
          => " in the \"hat\""

 * Function: terpri &optional STREAM

     This function outputs a newline to STREAM.  The name stands for
     ``terminate print''.

 * Variable: print-escape-newlines

     Non-`nil' means print newlines in strings as `\n'.  Normally
     they are printed as actual newlines.

     This variable affects the print functions `prin1' and `print';
     it does not affect `princ' in Emacs 18, but this may be changed.
     Here is an example using `prin1':

          (prin1 "a\nb")
          -| "a
          -| b"
          => "a
          => b"
          
          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
          -| "a\nb"
          => "a
          => b"

     In the second expression, the local binding of
     `print-escape-newlines' is in effect during the call to `princ'
     but not during the printing of the result.

 * Variable: print-length

     The value of this variable is the maximum number of elements of
     a list that will be printed.  If the list being printed is
     longer than this, then it is abbreviated with an ellipsis.

     If the value is `nil' (the default), then there is no limit.

          (setq print-length 2)
          => 2
          (print '(1 2 3 4 5))
          -| (1 2 ...)
          => (1 2 ...)

 * Function: write-char CHARACTER &optional STREAM

     This function outputs CHARACTER to STREAM.  It returns CHARACTER.



File: lispref,  Node: Minibuffers,  Next: Command Loop,  Prev: Streams,  Up: Top

Minibuffers
***********

  A "minibuffer" is a special buffer used by Emacs commands to read
arguments more complicated than the single numeric prefix argument. 
These include file names, buffer names, and command names (as in
`M-x').

  In most ways, a minibuffer is a normal Emacs buffer.  Although some
operations for managing buffers do not apply to minibuffers, most
operations *within* a buffer, such as editing commands, work normally
in the minibuffer.  But minibuffers cannot be deleted or renamed. 
(In fact, a minibuffer, once created, is never deleted by Emacs, even
after the user exits from the minibuffer.)

  The minibuffer has its own window, from which it cannot be separated.
The window is the single line at the bottom of the screen; it can be
temporarily resized with the window sizing commands.  The minibuffer
reverts to its normal size when exited.

  A "recursive minibuffer" may be created when there is an active
minibuffer and a command is invoked that requires input from a
minibuffer.  Recursive minibuffers may be allowed or disallowed by
setting the variable `enable-recursive-minibuffers'.  Of several
recursive minibuffers, the innermost, or most recently entered, one
is the active minibuffer.  It is the only one that is displayed in a
window.  We usually call this ``the'' minibuffer.

  The first minibuffer is named ` *Minibuf-0*'.  Recursive minibuffers
are named by incrementing the number at the end of the name.  All
minibuffer names begin with a space so that they won't show up in
normal buffer lists.

  The minibuffer may use one of several local keymaps (*note
Keymaps::.); they contain various completion and exit commands. 
*Note Completion::.

   * `minibuffer-local-map' is used for ordinary input (no completion).

   * `minibuffer-local-ns-map' is similar, except that SPC exits just
     like RET.  This is used mainly for MockLisp compatibility.

   * `minibuffer-local-completion-map' is for permissive completion.

   * `minibuffer-local-must-match-map' is for strict completion and
     for cautious completion.

   * `repeat-complex-command-map' is for use in `C-x ESC'.

* Menu:

* Reading Text or Objects::   Using the minibuffer to read strings or forms.
* Completion::                How to invoke and customize completion.
* Yes or No Queries::         Asking a question with a simple answer.
* Minibuffer Misc::           Various customization hooks and variables.

 

File: lispref,  Node: Reading Text or Objects,  Next: Completion,  Prev: Minibuffers,  Up: Minibuffers

Reading Text or Objects
=======================

  The main use of the minibuffer is to read text.  One extension of
that is to treat the text as a Lisp object, and return that.

* Menu:

* Text from Minibuffer::    How to read a straight text string.
* Object from Minibuffer::  How to read a Lisp object or expression.

 

File: lispref,  Node: Text from Minibuffer,  Next: Object from Minibuffer,  Prev: Reading Text or Objects,  Up: Reading Text or Objects

Reading Text Strings in the Minibuffer
--------------------------------------

 * Function: read-from-minibuffer PROMPT-STRING &optional INITIAL
KEYMAP READ

     This function is the most general way to get input in the
     minibuffer: it reads an arbitrary string and returns it.

     First, PROMPT-STRING is printed in the minibuffer. 
     PROMPT-STRING must be a string.

     Then, if INITIAL is non-`nil', the value of INITIAL is inserted
     into the minibuffer.  INITIAL is considered to be part of the
     user's input, at least to begin with, and so it can be edited
     normally.

     If KEYMAP is non-`nil', that keymap is the local keymap to use
     while reading.  If KEYMAP is omitted or `nil', the value of
     `minibuffer-local-map' is used as the keymap.

     Finally, if READ is non-`nil', Emacs interprets the result as a
     Lisp object and `read-from-minibuffer' returns that object,
     unevaluated.  Otherwise, it returns the minibuffer contents as a
     string.

     For example, suppose you save the last string the user searched
     for in the variable `last-search-string', and offer it for
     editing the next time.  To get a search string, you might want
     to call `read-from-minibuffer' as follows.

          (read-from-minibuffer "Find string: " last-search-string)

     Assuming the value of `last-search-string' is `No', and the user
     wants to search for `Nope', the interaction looks like this:

          (setq last-search-string "No")
          
          (read-from-minibuffer "Find string: " last-search-string)
               => "Nope"

     Here is the minibuffer after evaluating the call to
     `read-from-minibuffer' but before typing in the characters `pe'
     and RET

          --------- Buffer: Minibuffer ---------
          Find string: No-!-
          --------- Buffer: Minibuffer ---------

 * Function: read-string PROMPT &optional INITIAL

     This function reads a string from the minibuffer, and returns it.
     pROMPT and INITIAL are the same as in `read-from-minibuffer'.

     This function is a simplified call to `read-from-minibuffer'.

          (read-string PROMPT INITIAL)
          ==
          (read-from-minibuffer PROMPT INITIAL nil nil)

 * Function: read-no-blanks-input PROMPT &optional INITIAL

     This function reads a string from the minibuffer, but does not
     allow the user to type blanks.  PROMPT and INITIAL are the same
     as in `read-from-minibuffer'.  Typing a blank *exits* the
     minibuffer.

     This function is a simplified call to `read-from-minibuffer'. 
     The `read-no-blanks-input' function uses the
     `minibuffer-local-ns-map' keymap.  Since `read-no-blanks-input'
     does not redefine `quoted-insert', it *is* possible to put a
     space into the string, by quoting it.  Also, of course, you may
     rebind the keys in `minibuffer-local-ns-map'.

          (read-no-blanks-input PROMPT INITIAL)
          ==
          (read-from-minibuffer PROMPT INITIAL minibuffer-local-ns-map)

 * Variable: minibuffer-local-ns-map

     This built-in variable is the keymap passed by the function
     `read-no-blanks-input' to `read-from-minibuffer'.  By default,
     it makes the following bindings:

    LFD
          `exit-minibuffer'

    SPC
          `exit-minibuffer'

    TAB
          `exit-minibuffer'

    RET
          `exit-minibuffer'

    C-g
          `abort-recursive-edit'

    ?
           `self-insert-and-exit'

 * Variable: minibuffer-local-map

     This is the default keymap for reading from the minibuffer.  It
     is the keymap used by the minibuffer for local bindings when
     spaces are allowed in the minibuffer.

     By default, it makes the following bindings:

    LFD
          `exit-minibuffer'

    RET
          `exit-minibuffer'

    `C-g'
          `abort-recursive-edit'



File: lispref,  Node: Object from Minibuffer,  Prev: Text from Minibuffer,  Up: Reading Text or Objects

Reading Lisp Objects in the Minibuffer
--------------------------------------

  This section describes functions for reading Lisp objects from the
minibuffer.

 * Function: read-minibuffer PROMPT &optional INITIAL

       This function reads a Lisp object in the minibuffer and returns
     it, unevaluated.  PROMPT and INITIAL are the same as in
     `read-from-minibuffer'.

       This function is a simplified call to `read-from-minibuffer'.

          (read-minibuffer PROMPT INITIAL)
          ==
          (read-from-minibuffer PROMPT INITIAL nil t)

     Here is an example:

          (read-minibuffer "Enter an expression: " (format "%s" '(testing)))
          
          ;;  After the preceding expression is evaluated,
          ;;  the following appears in the minibuffer:
          
          --------- Buffer: Minibuffer ---------
          Enter an expression: (testing)
          --------- Buffer: Minibuffer ---------

     In this example, `(testing)' is inserted initially, and may be
     edited by the user.

 * Function: eval-minibuffer PROMPT &optional INITIAL

       This function reads a Lisp expression in the minibuffer, then
     evaluates it, returning the result.  PROMPT and INITIAL are the
     same as in `read-from-minibuffer'.

       This function simply evaluates the result of a call to
     `read-minibuffer'.

          (eval-minibuffer PROMPT INITIAL)
          ==
          (eval (read-minibuffer PROMPT INITIAL))

 * Function: edit-and-eval-command PROMPT FORM

       This function reads a Lisp expression in the minibuffer, and
     then evaluates it.  The difference between this command and
     `eval-minibuffer' is that here the initial FORM is not optional
     and it is not expected to be a string.  FORM is printed with
     `prin1', so if it is a string, double-quote characters (`"')
     will appear in the initial text.  *Note Output Functions::.

       First, PROMPT is printed in the minibuffer.  Then FORM is
     converted to its print representation and inserted into the
     minibuffer as input, like INITIAL in `read-from-minibuffer'. 
     When the user exits the minibuffer, the new form is evaluated. 
     The resulting value is the value of  `edit-and-eval-command'.

       In the following example, the user is offered an expression with
     an incomplete name for a function call within it:

          (edit-and-eval-command "Please edit: " '(forward-))
          
          ;; After evaluating the preceding expression, 
          ;; the following appears in the minibuffer:
          
          --------- Buffer: Minibuffer ---------
          Please edit: (forward-)-!-
          --------- Buffer: Minibuffer ---------

     The user may edit the minibuffer, for example, by typing: `DEL
     word 1)'.  This action edits the form to create a complete
     expression: `(forward-word 1)'.  Typing RET then evaluates the
     expression, which will move point forward one word. 
     `edit-and-eval-command' returns `nil' in this example.



File: lispref,  Node: Completion,  Next: Yes or No Queries,  Prev: Reading Text or Objects,  Up: Minibuffers

Completion
==========

  Emacs will attempt to complete the name of a symbol, file, or buffer
if you type a part of it.  This saves typing and makes life easier. 
For example, when you type `C-x b' (`switch-to-buffer') and then type
the first few letters of the name of the buffer to which you wish to
switch, and then type TAB (`minibuffer-complete'), Emacs will try to
extend the name as far as it can.

  Completion works for functions such as `switch-to-buffer' or
`describe-function' because Emacs keeps track of the names of all the
buffers and the names of all the functions and is able to search
through those names to locate those that begin with the letters you
type.

  The functions described in this section handle completion in a fairly
general way.  The `try-completion' function is at the heart of the
completion routines.  It returns the longest determined completion of
a given initial string, with a given set of strings to match against.
Other functions perform completion for various other specifications.

  The function `completing-read' provides a higher-level interface for
completion.  A call to `completing-read' specifies what should be
completed, and how.  The function then switches to the minibuffer
where the local keymap binds a few keys to functions useful for
completion.

The functions described in this chapter deal with general completion
in the minibuffer.  Emacs Lisp also provides functions for filename
completion (*note Filename Completion::.) and Lisp symbol completion
(*note Lisp Symbol Completion::.).

* Menu:

* Basic Completion::       Low-level functions for completing strings.
                             (These are too low level to use the minibuffer.)
* Completion Reading::     Invoking the minibuffer with completion.
* High-level Completion::  Convenient special cases of completion
                             (reading buffer name, file name, etc.)



File: lispref,  Node: Basic Completion,  Next: Completion Reading,  Prev: Completion,  Up: Completion

Basic Completion Functions
--------------------------

 * Function: try-completion STRING ALIST-OR-OBARRAY &optional PREDICATE

       This function returns the longest common substring of all
     possible completions of STRING in ALIST-OR-OBARRAY.

       If ALIST-OR-OBARRAY is an alist (*note Association Lists::.),
     the first element of each pair in the association list is tested
     to see whether it begins with STRING.  All elements that match
     are then compared.  The longest initial sequence common to all
     matches is returned as a string.  If none is matched,
     `try-completion' returns `nil'.  If only one element is matched,
     and the match is exact, then `try-completion' returns `t'.

       If ALIST-OR-OBARRAY is an obarray (*note Creating Symbols::.),
     the print names of all symbols in the obarray are tested for
     matches.  (The global variable `obarray' holds an obarray
     containing the names of all interned Lisp symbols.)

       If PREDICATE is passed to `try-completion', then it must be a
     function of one argument.  It is used to test each possible
     match, and the match is a candidate only if PREDICATE returns
     non-`nil'.  The argument given to PREDICATE is either the alist
     element (which is a pair, the CAR of which is a string) or else
     it is the symbol (*not* the symbol name) from the obarray.

       In the first of the following examples, the string `foo' is
     matched by three of the alist pairs.  All of the matches begin
     with the characters `fooba', so that is the result.  In the
     second example, there is only one possible match, and it is
     exact, so `t' is returned.

          (try-completion "foo"
               '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               => "fooba"
          
          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               => t

       In the following example, numerous symbols begin with the
     characters `forw', and all of them begin with the word
     `forward', but only one does not contain the additional
     character `-'.

          (try-completion "forw" obarray)
               => "forward"

       Finally, in the following example, only two of the three
     possible matches pass the predicate `test' (the string `foobaz'
     is too short).  Both of those begin with the string `foobar'.

          (defun test (s) 
            (> (length (car s)) 6))
          => test
          (try-completion "foo"
               '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)) 
               'test)
          => "foobar"

 * Function: all-completions STRING ALIST-OR-OBARRAY &optional
PREDICATE

       This function returns a list of all possible completions,
     instead of the longest substring they share.  The parameters to
     this function are the same as to `try-completion'.

       Here is an example, using the same function `test' used in the
     example for `try-completion':

          (defun test (s) 
            (> (length (car s)) 6))
          => test
          
          (all-completions  "foo"
               '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
               (function test))
          => ("foobar1" "foobar2")

The two functions `try-completion' and `all-completions' have nothing
in themselves to do with minibuffers.  However, completion is most
often used there, which is why it is described in this chapter.



File: lispref,  Node: Completion Reading,  Next: High-level Completion,  Prev: Basic Completion,  Up: Completion

Functions and Variables for Reading with Completion
---------------------------------------------------

Here are the functions and variables for dealing with  completion
while reading from the minibuffer.

 * Function: completing-read PROMPT ALIST-OR-OBARRAY &optional
PREDICATE REQUIRE-MATCH INITIAL

       This function reads a string in the minibuffer, assisting the
     user by providing completion.  First, it prints PROMPT, which
     must be a string.  If INITIAL is non-`nil', `completing-read'
     inserts it into the minibuffer as part of the input.  Then it
     allows the user to edit the input, providing several commands to
     attempt completion.

       The function performs completion using ALIST-OR-OBARRAY and
     PREDICATE in the same way that `try-completion' does.

       If REQUIRE-MATCH is `t', the user will not be allowed to exit
     unless the input completes to an element of ALIST-OR-OBARRAY. 
     If REQUIRE-MATCH is neither `nil' nor `t', then
     `completing-read' does not exit unless the input typed is itself
     an element of ALIST-OR-OBARRAY.  To accomplish this,
     `completing-read' calls `read-minibuffer' with the keymap
     `minibuffer-local-completion-map' if REQUIRE-MATCH is `nil', or
     else with the keymap `minibuffer-local-must-match-map', if
     REQUIRE-MATCH is non-`nil'.

       Case is ignored if the built-in variable
     `completion-ignore-case' is non-`nil'.

       The `completing-read' function also binds three special
     variables, the first two of which are passed to the
     `read-minibuffer' function, the last of which is checked by the
     `minibuffer-complete-and-exit' function.

    `minibuffer-completion-table'
          This variable is bound to ALIST-OR-OBARRAY argument.

    `minibuffer-completion-predicate'
          This variable is bound to the PREDICATE argument.

    `minibuffer-completion-confirm'
          This variable is bound to the REQUIRE-MATCH argument.

     For example:

          (completing-read "Complete a foo: "
               '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
               nil t "fo")
          
          ;; After evaluating the preceding expression, 
          ;; the following appears in the minibuffer:
          
          --------- Buffer: Minibuffer ---------
          Complete a foo: fo
          --------- Buffer: Minibuffer ---------

     If in this case, the user types `DEL DEL b RET', Emacs will
     return `barfoo'.

 * Variable: minibuffer-local-completion-map

       `completing-read' uses this value as the local map when an exact
     match of one of the completions is not required.

       By default, this keymap makes the following bindings:

    `?'
          `minibuffer-completion-help'

    `SPC'
          `minibuffer-complete-word'

    `TAB'
          `minibuffer-complete'

    `LFD'
          `exit-minibuffer'

    `RET'
          `exit-minibuffer'

    `C-g'
          `abort-recursive-edit'

 * Variable: minibuffer-local-must-match-map

       `completing-read' uses the value of this variable as the local
     map when an exact match of one of the completions is required. 
     Therefore, no keys are bound to `exit-minibuffer'.

     By default, this variable makes the following bindings:

    `?'
          `minibuffer-completion-help'

    `SPC'
          `minibuffer-complete-word'

    `TAB'
          `minibuffer-complete'

    `LFD'
          `minibuffer-complete-and-exit'

    `RET'
          `minibuffer-complete-and-exit'

    `C-g'
          `abort-recursive-edit'

 * Variable: minibuffer-completion-table

       The value of this variable is the alist or obarray used for
     completion in the minibuffer.  This is the global variable that
     contains what `completing-read' passes to `read-minibuffer'.  It
     is used by all the minibuffer completion functions, such as
     `minibuffer-complete-word'.

 * Variable: minibuffer-completion-predicate

         The value of this variable is the predicate that
     `completing-read' passes to `read-minibuffer'.  The variable is
     also used by the other minibuffer completion functions.

  Here are the interactive commands and user options that people use
directly for completion in the minibuffer.

 * Command: minibuffer-complete-word

       This function completes the minibuffer contents by at most a
     single word.  Even if the minibuffer contents has only one
     completion, `minibuffer-complete-word' will not add any
     characters beyond the first character that is not a word
     constituent.  *Note Syntax Tables::.

 * Command: minibuffer-complete

       This function completes the minibuffer contents as far as
     possible.

 * Command: minibuffer-complete-and-exit

       This function completes the minibuffer contents, and exits if
     confirmation is not required, i.e., if
     `minibuffer-completion-confirm' is non-`nil'.  If confirmation
     *is* required, and is given, repeating this command will exit.

 * Variable: minibuffer-completion-confirm

       When the value of this variable is non-`nil', Emacs asks for
     confirmation of a completion before exiting the minibuffer.  The
     function `minibuffer-complete-and-exit' checks the value of this
     variable before it exits.

 * Command: minibuffer-completion-help

       This function creates a list of the possible completions of the
     current minibuffer contents.  It works by calling
     `all-completions'; the values of `minibuffer-completion-table'
     and `minibuffer-completion-predicate' are used as arguments. 
     Emacs displays the list in the buffer named `*Completions*'.

 * Function: display-completion-list COMPLETIONS

       This function displays COMPLETIONS to the stream
     `standard-output' (usually a buffer).  (*Note Streams::, for
     more information about streams.)  COMPLETIONS is normally the
     list of completions just made.  Each element may be a symbol or
     a string, either of which is simply printed, or a list of two
     strings, which are printed as if concatenated.

       This function is called by `minibuffer-completion-help'.

 * Variable: completion-ignore-case

       If the value of this variable is  non-`nil', Emacs does not
     consider case significant in completion.



File: lispref,  Node: High-level Completion,  Prev: Completion Reading,  Up: Completion

High-level Completion  Functions
--------------------------------

Here are functions for reading from the minibuffer with completion.

 * Function: read-buffer PROMPT &optional DEFAULT EXISTING

       This function reads the name of a buffer and returns it as a
     string.  DEFAULT (which must be a string if it is supplied) is
     printed along with the prompt and is the value to return if the
     user simply exits.  (DEFAULT is therefore not an initial value
     in the sense  of `read-from-minibuffer'.)

       If EXISTING is non-`nil', then any name the user types must be
     the name of an existing buffer.  (However, even if EXISTING is
     non-`nil', DEFAULT need not be the name of an existing buffer.)

       In the following example, the user enters `minibuffer.t', and
     then types RET.  The only buffer name starting with that string
     is `minibuffer.texinfo', so that name is returned.

          (read-buffer "Buffer name? " "foo" t)
          
          ;; After evaluating the preceding expression, 
          ;; the following appears in the minibuffer:
          
          --------- Buffer: Minibuffer ---------
          Buffer name? (default foo) 
          --------- Buffer: Minibuffer ---------

 * Function: read-file-name PROMPT DIRECTORY &optional DEFAULT EXISTING

       This function reads a file name in the minibuffer, prompting
     with PROMPT.  The function provides completion for the name.  If
     DEFAULT is non-`nil', then the value of DEFAULT will be returned
     by the function if the user just types RET.

       If EXISTING is non-`nil', then the name must refer to an
     existing file.  If the value of EXISTING is neither non-`nil'
     nor non-`t', then Emacs also requires confirmation after
     completion.

     DIRECTORY defaults to the current buffer's default directory.

     For example:

          (read-file-name "The file is ")
          
          ;; After evaluating the preceding expression, 
          ;; the following appears in the minibuffer:
          
          --------- Buffer: Minibuffer ---------
          The file is /gp/gnu/elisp/-!-
          --------- Buffer: Minibuffer ---------

     Typing `manual TAB' results in the following:

          --------- Buffer: Minibuffer ---------
          The file is /gp/gnu/elisp/manual.texinfo
          --------- Buffer: Minibuffer ---------

     Then, if you type RET, Emacs returns
     `"/gp/gnu/elisp/manual.texinfo"'.

 * Option: insert-default-directory

       This variable is used by `read-file-name'.  The value of the
     variable determines if, when reading a filename in the
     minibuffer, Emacs should start by placing the name of the
     default directory in the minibuffer.  If the value of this
     variable is `nil', then Emacs will not place anything into the
     minibuffer.  In that case, the default directory will still be
     used, but it will not be displayed.

          (let ((insert-default-directory t))
            (read-file-name "The file is "))
          
          --------- Buffer: Minibuffer ---------
          The file is ~lewis/manual/ 
          --------- Buffer: Minibuffer ---------
          
          (let ((insert-default-directory nil))
            (read-file-name "The file is "))
          
          --------- Buffer: Minibuffer ---------
          The file is
          --------- Buffer: Minibuffer ---------

 * Function: read-command PROMPT

       This function reads the name of a command and returns it as a
     Lisp symbol.  PROMPT is the same as in `read-from-minibuffer'. 
     Recall that a command is anything for which `commandp' returns
     `t', and a command name is a symbol for which `commandp' returns
     `t'.  *Note Interactive Call::.

          (read-command "Command name? ")
          
          ;; After evaluating the preceding expression, 
          ;; the following appears in the minibuffer:
          
          --------- Buffer: Minibuffer --------- 
          Command name?  
          --------- Buffer: Minibuffer ---------

     If the user types `forward-c RET', then Emacs returns
     `forward-char'.

       The `read-command' function is a simplified call to
     `completing-read'.  The `read-command' function uses the
     `commandp' predicate to allow only commands to be entered; and
     it uses the `obarray' global variable so as to be able to
     complete all extant Lisp symbols.

          (read-command PROMPT)
          ==
          (intern (completing-read PROMPT obarray 'commandp t nil))

 * Function: read-variable PROMPT

       This function reads the name of a user variable and returns it
     as a symbol.  This function is analogous to `read-command'; it 
     uses the predicate `user-variable-p' instead of `commandp'.

          (read-variable PROMPT)
          ==
          (intern (completing-read PROMPT obarray 'user-variable-p t nil))
          
          (read-variable "Variable name? ")
          
          ;; After evaluating the preceding expression, 
          ;; the following appears in the minibuffer:
          
          --------- Buffer: Minibuffer ---------
          Variable name? -!-
          --------- Buffer: Minibuffer ---------

     If in this case, the user types `fill-p RET', then Emacs will
     return `fill-prefix'.



File: lispref,  Node: Yes or No Queries,  Next: Minibuffer Misc,  Prev: Completion,  Up: Minibuffers

Yes or No Queries
=================

 * Function: y-or-n-p PROMPT

       This function asks the user a question, expecting input in the
     echo area.  It returns `t' if the user types `y', `nil' if the
     user types `n'.  The answer is just a single character, with no
     RET needed to terminate it.  The function also accepts SPC to
     mean yes and DEL to mean no.  Upper and lowercase are not
     equivalent.

       This function does not actually use the minibuffer, since it
     does not allow editing of the answer.  It looks as if it did use
     the minibuffer, but really it is just echoing the input in the
     same way that command keystrokes sometimes echo.

       ``Asking the question'' means printing PROMPT in the echo area,
     followed by the string `(y or n) '.  If the input is not one of
     the expected answers (`y', `n', `SPC', or `DEL'), the function
     responds `Please answer y or n.', and repeats the request.

       In the following example, the user first types `q', which is
     invalid.  At the next prompt the user types `n'.  Note that we
     show successive lines of minibuffer prompts here.  In fact, only
     one will appear at any time.

          (y-or-n-p "Do you need a lift? ")
          
          ;; After evaluating the preceding expression, 
          ;; the following appears in the minibuffer:
          
          --------- Echo area ---------
          Do you need a lift? (y or n) 
          --------- Echo area ---------

     If the user then types `q', the following appears:

          --------- Echo area ---------
          Please answer y or n.  Do you need a lift? (y or n) 
          --------- Echo area ---------

 * Function: yes-or-no-p PROMPT

       This function asks the user a question, expecting input in
     minibuffer.  It returns `t' if the user types `yes', `nil' if
     the user types `no'.  A return must be typed to end the 
     response.  Upper and lowercase are not equivalent.

       `yes-or-no-p' requires more work from the user than `y-or-n-p'
     and is used for correspondingly more critical actions.

       `yes-or-no-p' prints PROMPT in the echo area, followed by the
     string `(yes or no) '.  The user must type one of the expected
     responses; otherwise, the function responds `Please answer yes
     or no.', waits about two seconds and repeats the request.

     For example:

          (yes-or-no-p 
            "Do you really want to remove your entire directory? ")
          
          ;; After evaluating the preceding expression, 
          ;; the following appears in the minibuffer:
          
          --------- Buffer: minibuffer ---------
          Do you really want to remove your entire directory? (yes or no) 
          --------- Buffer: minibuffer ---------

     If the user first enters `y', which is invalid because it must
     be the entire word `yes', Emacs responds by erasing the `y' and
     displaying:

          --------- Buffer: minibuffer ---------
          Please answer yes or no.
          Do you really want to remove your entire directory? (yes or no)
          --------- Buffer: minibuffer ---------



File: lispref,  Node: Minibuffer Misc,  Prev: Yes or No Queries,  Up: Minibuffers

Minibuffer Miscellany
=====================

  Some basic minibuffer functions and variables are described here.

 * Command: exit-minibuffer

       This function terminates the present minibuffer read.  It is
     only useful if bound to a key.

 * Command: self-insert-and-exit

       This function terminates minibuffer input after inserting
     `last-command-char' (*note Command Loop Info::.).

Some objects are special to the minibuffer:

 * Variable: minibuffer-help-form

       The global or ambient value of this variable is used to rebind
     `help-form' locally inside the minibuffer (*note Help
     Functions::.).

 * Function: minibuffer-window

       This function returns the window that is used for the minibuffer.
     This is always the same window.  It cannot be deleted.

 * Variable: minibuffer-scroll-window

       If the value of this built-in variable is non-`nil', it should
     be a window object.  When the function `scroll-other-window' is
     called in the minibuffer, Emacs will scroll the
     `minibuffer-scroll-window' window.

Finally, some functions and variables deal with recursive minibuffers
(*note Recursive Editing::.):

 * Function: minibuffer-depth

       This function returns the current depth of activations of the
     minibuffer, a nonnegative integer.  If no minibuffers are
     active, it returns zero.

 * Option: enable-recursive-minibuffers

       If this variable is non-`nil', you can invoke commands, such as
     `find-file', which use minibuffers, while in the minbuffer window.
     This produces a recursive editing level for a new minbuffer. 
     The outer-level minibuffer is invisible while you are editing
     the inner one.

     This variable only affects invoking the minibuffer while in the
     minibuffer itself, since it is always possible to invoke a
     minibuffer from a different window, even if the minibuffer is
     active.



File: lispref,  Node: Command Loop,  Next: Keymaps,  Prev: Minibuffers,  Up: Top

Command Loop
************

  When you run Emacs, it enters the "editing command loop" almost
immediately.  This loop reads key sequences, executes their
definitions, and displays the results.  In this chapter, we describe
how these things are done, and the subroutines which allow Lisp
programs to do them.

* Menu:

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Keyboard Input::      How your program can read characters from the keyboard.
* Quitting::            How `C-g' works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.

 

File: lispref,  Node: Command Overview,  Next: Defining Commands,  Prev: Command Loop,  Up: Command Loop

Command Loop Overview
=====================

  The first thing the command loop must do is read a key sequence,
which is a sequence of characters that translates into a command.  It
does this by calling the function `read-key-sequence'.  Your Lisp
code can call this function, too (*note Keyboard Input::.).  Lisp
programs can also do input at a lower level with `read-char' or
discard the input with `discard-input'.

  The key sequence is translated into a command through the keymaps. 
*Note Keymaps::, for information on how this is done.  The result is
a keyboard macro or an interactively callable function, or a symbol
which leads to one of them.  If the key is `M-x', then it reads the
name of another command which is used instead.  This is done by the
command `execute-extended-command' (*note Interactive Call::.).

  Now it is time to execute the command, which includes reading
arguments to be given to it.  This is done by calling
`command-execute' (*note Interactive Call::.).  For commands written
in Lisp, the `interactive' specification says how to read the
arguments.  This may use the prefix argument (*note Prefix Command
Arguments::.), or may read with prompting in the minibuffer (*note
Minibuffers::.).

  For example, the command `find-file' has an `interactive'
specification which says to read a file name using the minibuffer. 
The command's function body does not use the minibuffer; if you call
this command from Lisp code as a function, you must supply the file
name string as an ordinary Lisp function argument.

  If the command is a string (i.e., a keyboard macro) then the function
`execute-kbd-macro' is used to execute it.  You can call this
function yourself.  *Note Keyboard Macros::.

  If a command runs away, typing `C-g' will terminate its execution
immediately.  This is called "quitting" (*note Quitting::.).



File: lispref,  Node: Defining Commands,  Next: Interactive Call,  Prev: Command Overview,  Up: Command Loop

Defining Commands
=================

  A Lisp function becomes a command when its body contains, at top
level, a form which calls the special form `interactive'.  This form
does nothing when actually executed, but its mere presence is a flag
noticed by the command loop, and its argument controls the reading of
arguments, with the minibuffer or otherwise.

* Menu:

* Using Interactive::     General rules for `interactive'.
* Interactive Codes::     The standard letter-codes for reading arguments
                             in various ways.
* Interactive Examples::  Examples of how to read interactive arguments.

 

File: lispref,  Node: Using Interactive,  Next: Interactive Codes,  Prev: Defining Commands,  Up: Defining Commands

Using `interactive'
-------------------

 * Special form: interactive ARG-DESCRIPTOR

     This special form declares that the function in which it appears
     is a command, and therefore it may be called interactively (via
     `M-x' or by entering a key sequence bound to it). 
     ARG-DESCRIPTOR declares how the arguments to the command are to
     be computed when the command is called interactively.  The
     command may also be called from Lisp programs like any other
     function, but then the arguments are supplied by the caller, and
     ARG-DESCRIPTOR has no effect.

     The `interactive' form has its effect because the command loop
     (actually, its subroutine `call-interactively') scans through
     the function definition looking for it, before calling the
     function.  Once the function is called, all its body forms
     including the `interactive' form are executed, but at this time
     `interactive' simply returns `nil' without even evaluating its
     argument.

There are three possibilities for the argument ARG-DESCRIPTOR:

   * It may be omitted or `nil'.  Then the command is called with no
     arguments.  This leads quickly to an error if the command
     requires one or more arguments.

   * It may be a Lisp expression which is not a string.  Then it must
     be a form which is evaluated to get a list of arguments to pass
     to the command.

   * It may be a string.  The string should consist of a code
     character, followed by a prompt (if required for that code
     character).  The prompt ends either with the end of the string
     or with a newline.  Here is a simple example:

          (interactive "bFrobnicate buffer: ")

     The code letter `b' says to read the name of an existing buffer,
     with completion.  The buffer will be the sole argument passed to
     the command.  The rest of the string is a prompt.

     If the prompt ends with a newline, a second code character and
     prompt may follow, specifying a second argument.  Any number of
     arguments may be specified in this way.

     If the first character in the string is `*', then an error is
     signaled if the buffer is read-only.  Otherwise, the following
     character is the first code character.



File: lispref,  Node: Interactive Codes,  Next: interactive Examples,  Prev: Using interactive,  Up: Defining Commands

Code Characters for `interactive'
---------------------------------

  The code character descriptions below contain a number of key words
with the following meanings.

Completion
     Provide completion.  TAB, SPC, and RET will perform name
     completion according to the function `completing-read' (*note
     Completion::.).  `?' displays a list of possible completions.

Existing
     Require the name of an existing object.  An incorrect name will
     not be accepted (Emacs will complain `[No Match]' and continue
     to prompt for a name).

Default
     A default string is supplied by Emacs, which depends on the code
     character.

Prompt
     A prompt immediately follows the code character.  The prompt
     ends either with the end of the string or with a newline.

No I/O
     This code letter computes an argument without reading any input.
     Therefore, it does not use a prompt string, and any prompt
     string you supply is ignored.

  Here are the code character descriptions for use with `interactive':

`a'
     A function name (i.e., a symbol which is `fboundp').  Existing,
     Completion, Prompt.

`b'
     The name of a buffer.  By default, use the name of the current
     buffer (*note Buffers::.).  Existing, Completion, Default, Prompt.

`B'
     The name of a buffer.  By default, use the name of a recently
     used buffer other than the current buffer.  Completion, Prompt.

`c'
     A character.  The cursor does not move into the echo area. 
     Prompt.

`C'
     A command name (i.e., an interactive function).  Existing,
     Completion, Prompt.

`d'
     Use the position of point as a number.  No I/O.

`D'
     A directory name.  Default is current directory associated with
     the current buffer (*note System Environment::.).  Existing,
     Completion, Default, Prompt.

`f'
     A file name.  Default is the `default-directory'.  Existing,
     Completion, Default, Prompt.

`F'
     A file name.  The file need not exist.  Completion, Default,
     Prompt.

`k'
     A key sequence.  This keeps reading characters until a command
     (or undefined command) is found in the current key maps.  The
     key sequence is handed to the command as a string.  The cursor
     does not move into the echo area.  Prompt.

     This kind of input is used by commands such as `describe-key'
     and `global-set-key'.

`m'
     The position of the mark as a number.  No I/O.

`n'
     The minibuffer is used to read a number.  If the input is not a
     number, the user is asked to try again.  The prefix argument, if
     any, is not used.  Prompt.

`N'
     The unprocessed prefix argument is passed to the command.  If
     the prefix argument is `nil', then a number is read as with `n'.
     Requires a number.  Prompt.

`p'
     (lower case) The processed prefix argument is passed to the
     command.  No I/O.

`P'
     (upper case) The unprocessed prefix argument is passed to the
     command.  No I/O.  *Note Prefix Command Arguments::

`r'
     Point and the mark are passed to the command as two numeric
     arguments, smallest first.  No I/O.

`s'
     A string is read, without quotes, terminated with either LFD or
     RET.  `C-q' may be used to include either into the string. 
     Prompt.

`S'
     A string is read, without quotes, terminated with any whitespace
     character, and it is interned as a symbol.  `C-q' may be used to
     include whitespace into the string.  Other characters which
     normally terminate a symbol (e.g., `()[]') do not do so here. 
     Prompt.

`v'
     A variable declared to be a user option (i.e., satisfying
     `user-variable-p').  Existing, Completion, Prompt.

`x'
     A Lisp form is read and terminated with a LFD or RET.  The form
     is not evaluated.  Prompt.

`X'
     A Lisp form is read as with `x', but it is then evaluated and
     its value becomes the argument for the command.  Prompt.



File: lispref,  Node: Interactive Examples,  Prev: Interactive Codes,  Up: Defining Commands

Examples of Using `interactive'
-------------------------------

  Here are some more examples of `interactive':

     (defun foo1 ()                ; `foo1' takes no arguments,
         (interactive)             ; just moves forward two words.
         (forward-word 2))
          => foo
     
     (defun foo2 (n)               ; `foo2' takes one argument,
         (interactive "p")         ; which is the processed prefix.
         (forward-word (* 2 n)))
          => foo2
     
     (defun foo3 (n)               ; `foo3' takes one argument,
         (interactive "nCount:")   ; which is read from the Minibuffer.
         (forward-word (* 2 n)))
          => foo3
     
     (defun three-b (b1 b2 b3)
       "Select three existing buffers (prompting for them in
     the Minibuffer).  Put them into three windows, selecting the
     last one."
         (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
         (delete-other-windows)
         (split-window (selected-window) 8)
         (switch-to-buffer b1)
         (other-window 1)
         (split-window (selected-window) 8)
         (switch-to-buffer b2)
         (other-window 1)
         (switch-to-buffer b3)
       )
          => three-b
     (three-b "*scratch*" "declarations.texinfo" "*mail*")
          => nil



File: lispref,  Node: Interactive Call,  Next: Command Loop Info,  Prev: Defining Commands,  Up: Command Loop

Interactive Call
================

  After the command loop has translated a key sequence into a
definition, it invokes the definition using the function
`command-execute'.  If the definition is an ordinary command, that
function calls `call-interactively', which reads the arguments and
calls the command.  You can also call these functions yourself.

 * Function: commandp OBJECT

     Returns `t' if OBJECT is suitable for calling interactively;
     that is, if OBJECT is a command.  Otherwise, returns `nil'.

     The interactively callable objects are strings (treated as
     keyboard macros), lambda expressions that contain a top-level
     call to `interactive', autoload-objects that are declared as
     interactive (non-`nil' fourth argument to `autoload'), and some
     of the primitive functions.

     Also, a symbol is `commandp' if its function definition is
     `commandp'.

     Keys and keymaps are not commands.  Rather, they are used to
     look up commands (*note Keymaps::.).

     See `documentation' in *Note Accessing Documentation::, for a
     realistic example of using `commandp'.

 * Function: call-interactively COMMAND &optional RECORD-FLAG

     This function calls COMMAND, reading arguments according to its
     interactive calling specifications.  An error is signaled if
     COMMAND is not an interactively callable function (a command).

     If RECORD-FLAG is non-`nil', then this command and its arguments
     are unconditionally added to the value of `command-history'. 
     Otherwise, this is done only if the minibuffer is used to read
     an argument.  *Note Command History::.

 * Function: command-execute COMMAND &optional RECORD-FLAG

     This function executes COMMAND as an editor command.  COMMAND
     must satisfy the `commandp' predicate: it must be an
     interactively callable function or a string.

     A string is executed with `execute-kbd-macro'.  Along with the
     optional RECORD-FLAG, a function is passed to
     `call-interactively'.

     A symbol is handled by using its function definition in its
     stead.  A symbol with an `autoload' definition counts as a
     command if it was declared to stand for an interactively
     callable function.  Such a definition is handled by loading the
     library and then rechecking the definition of the symbol.

 * Command: execute-extended-command PREFIX-ARGUMENT

     This primitive function reads a command name from the
     minibuffer.  It calls the `completing-read' function (*note
     Completion::.).  Then `execute-extended-command' the command
     read by `completing-read', reading the arguments according to
     the command's `interactive' specifications.  Whatever that
     command returns becomes the value of `execute-extended-command'.

     If the command asks for a prefix argument, the value
     PREFIX-ARGUMENT is supplied to it.  If
     `execute-extended-command' is called interactively, the raw
     prefix argument is used for PREFIX-ARGUMENT, and thus passed on
     to whatever command is run.

     `execute-extended-command' is the normal definition of `M-x'. 
     It uses the string `M-x ' as a prompt.  It would be better to
     take the prompt from whatever characters were used to invoke
     `execute-extended-command', but that is painful to implement.  A
     description of the value of the prefix argument, if any, also
     becomes part of the prompt.

          (execute-extended-command 1)
          --------- Buffer: Minibuffer ---------
          M-x forward-word RET
          --------- Buffer: Minibuffer ---------
               => t

 * Function: interactive-p

     This function returns `t' if the containing function (the one
     which called `interactive-p') was called interactively, with
     `call-interactively'.  It makes no difference whether
     `call-interactively' was called from Lisp or by the editor
     command loop.  But if the containing function was called from
     Lisp, then it was not called interactively.

     The usual use of `interactive-p' is for deciding whether to
     print an informative message.

     As a special exception, `interactive-p' returns `nil' whenever a
     keyboard macro is being run.  This is to suppress the
     informative messages and speed execution of the macro.

     For example:

          (defun foo ()
            (interactive)
            (and (interactive-p)
                 (message "foo")))
               => foo
          (defun bar ()
            (interactive)
            (setq foobar (list (foo) (interactive-p))))
               => bar
          
          ;; Type `M-x foo'.
               -| foo
          ;; Although you cannot see it, this returns `"foo"'.
          
          ;; Type `M-x bar'.
          ;; This does not print anything.
          
          foobar
               => (nil t)



File: lispref,  Node: Command Loop Info,  Next: Keyboard Input,  Prev: Interactive Call,  Up: Command Loop

Information from the Command Loop
=================================

The editor command loop sets several Lisp variables to keep status
records for itself or to provide them for commands that are run.

 * Variable: last-command

     This global variable records the name of the previous command
     executed by the command loop, the one before the current
     command.  Normally the value is a symbol with a function
     definition, but this is not guaranteed.

     This variable is set by copying the value of `this-command' when
     each command returns to the command loop, except for commands
     that specify a prefix argument.

 * Variable: this-command

     This global variable records the name of the command now being
     executed by Emacs.  As for `last-command', normally it is a
     symbol with a function definition.

     This variable is set by the command loop just before the command
     is run, and its value is copied into `last-command' when the
     command finishes (unless the command specifies a prefix
     argument).

     Some commands change the value of this variable during their
     execution, simply as a flag for whatever command runs next.  In
     particular, the functions that kill text always set
     `this-command' to `kill-region' so that any kill commands
     immediately following will know to append the killed text to the
     previous kill.

 * Function: this-command-keys

     This function returns a string of the key sequence that invoked
     the present command.  It includes the characters that generated
     the prefix argument, if any.

          (this-command-keys) ;; Now type `C-u C-x C-e'.
               => "^U^X^E"

 * Variable: last-command-char

     This global variable is set to the last character that was typed
     on the terminal and was part of a command.  The principal use of
     this variable is in `self-insert-command', which uses it to
     decide which character to insert.

          last-command-char ;; Now type `C-u C-x C-e'.
               => 5

     The value is 5 because that is the ASCII code for `C-e'.

 * Variable: echo-keystrokes

     This global variable determines how much time should elapse
     before command characters are echoed.  Its value must be a
     number.  If the user has typed a prefix key (say `C-x') and then
     delays this many seconds before continuing, then the key `C-x'
     will be echoed in the echo area.  Any subsequent keys will be
     echoed as well.

     If the value is 0, then prefix keys are never echoed.



File: lispref,  Node: Keyboard Input,  Next: Quitting,  Prev: Command Loop Info,  Up: Command Loop

Keyboard Input
==============

  The editor command loop reads keyboard input using
`read-key-sequence', which uses `read-char'.  These functions and
others are also available for use in Lisp programs.

  Also, see `momentary-string-display' in *Note Temporary Displays::.

 * Function: input-pending-p

     This function determines whether command input is currently
     available.  It returns immediately, with value `t' if there is
     input, `nil' otherwise.

     On rare occasions this command may return `t' even when no input
     is available.

 * Function: discard-input

     This function discards the contents of the terminal input buffer
     and flushes any keyboard macro that might be in the process of
     definition.  It returns `nil'.

     In the example, the user may type a bunch of characters right
     after starting the evaluation of the form.  After the
     `sleep-for' finishes sleeping, any characters that have been
     typed are discarded.

          (progn (sleep-for 2)
            (discard-input))
               => nil

 * Function: read-char

     This function reads a character from the command input (which is
     either direct keyboard input or characters coming from an
     executing keyboard macro), and returns it.  It does not move the
     cursor or provide any sort of a prompt or other indication that
     it is waiting to read a character.  However, if the user pauses,
     previous keystrokes may echo; see `echo-keystrokes' in *Note
     Command Loop Info::.

     In the first example, the user types `1' (which is ASCII code
     49).  The second example shows a keyboard macro definition which
     calls `read-char' from the minibuffer.  The keyboard macro's
     very next character is the digit 1.  This is the character read
     by `read-char'.

          (read-char)
               => 49
          
          (symbol-function 'foo)
               => "^[^[(read-char)^M1"
          (execute-kbd-macro foo)
               -| 49
               => nil

 * Function: read-quoted-char &optional PROMPT

     This function is like `read-char', except that if the first
     character read is an octal digit, it reads up to two more octal
     digits (0-7) until a non-octal digit is found and returns the
     character represented by the octal number consisting of those
     digits.

     Also, quitting is suppressed.  *Note Quitting::.

     If PROMPT is supplied, it specifies a string to use to prompt
     the user.  The prompt string is always printed in the echo area
     and followed by a single `-'.

     In the example, the user types in the octal number 177.  This is
     127 in decimal.

          (read-quoted-char "What character")
          
          --------- Echo Area ---------
          What character-177
          --------- Echo Area ---------
          
               => 127

 * Function: read-key-sequence PROMPT

     This function reads a key sequence and returns it as a string. 
     Characters are read until the sequence is sufficient to specify
     a (non-prefix) command using the current local and global keymaps.

     For each character, if it is an uppercase letter that does not
     have a binding in either the local or global keymaps, then the
     corresponding lowercase letter is tried; if that is successful,
     the character is converted.  This function is used to read
     command input; the key lookup is different from that of
     `lookup-key' because of this automatic downcasing.

     Quitting is suppressed inside `read-key-sequence'.  In other
     words, a `C-g' typed while reading with this function is treated
     like any other character, and `quit-flag' is not set.  *Note
     Quitting::.

     PROMPT is either a string that is displayed in the echo area as
     a prompt, or `nil', in which case no prompt is displayed.

     In the example, the prompt `?' is displayed in the echo area,
     and the user types `C-x C-f'.

          (read-key-sequence "?")
          
          --------- Echo Area ---------
          ?C-x C-f
          --------- Echo Area ---------
          
               => "^X^F"

 * Variable: unread-command-char

     This global variable is set to the character to be read as the
     next input from the command input stream, or `-1' if there is no
     such character.  Basically, this is the character that is
     ``unread'', when an input function has to read an extra
     character to finish parsing its input.

     For example, the function that governs prefix arguments reads
     any number of digits.  When it finds a non-digit character, it
     must unread that so that it becomes input for the next command.

  For more information, see `waiting-for-user-input-p' in *Note Output
from Processes::.  See `sit-for' in *Note Waiting::.  *Note Terminal
Input::, for other functions and variables related to command key
input.



File: lispref,  Node: Quitting,  Next: Prefix Command Arguments,  Prev: Keyboard Input,  Up: Command Loop

Quitting
========

  Typing `C-g' while the command loop has run a Lisp function causes
Emacs to "quit" whatever it is doing.  This means that control
returns to the innermost active command loop.

  Typing `C-g' while the command loop is waiting for keyboard input
does not cause a quit.  It acts as an ordinary input character.  In
the simplest case, you cannot tell the difference, because `C-g'
normally runs the command `keyboard-quit', whose effect is to quit. 
However, when `C-g' follows a prefix key, the result is an undefined
key.  All this does is cancel the prefix key and any prefix argument.

  In the minibuffer, `C-g' has a different definition, which aborts out
of the minibuffer.  This means, in effect, that it exits the
minibuffer and then quits.  (Simply quitting would return to the
command loop *within* the minibuffer.)  This feature is the reason
why `C-g' does not quit directly when the command reader is reading
input.  `C-g' following a prefix key is not redefined in the
minibuffer; it has its normal effect, canceling the prefix key and
prefix argument as usual.

  Certain functions such as `read-key-sequence' or `read-quoted-char'
prevent quitting entirely even though they wait for input.  Instead
of quitting, `C-g' serves as the requested input.  In the case of
`read-key-sequence', this serves to bring about the special behavior
of `C-g' in the command loop.  In the case of `read-quoted-char',
this is so that `C-q' can be used to quote an `C-g'.

  The only direct effect of typing `C-g' is to set the variable
`quit-flag' to a non-`nil' value.  Appropriate places inside Emacs
check this variable and quit if it is not `nil'.  Setting `quit-flag'
non-`nil' in any other way also causes a quit.

  At the level of C code, quits cannot happen just anywhere; only at
particular places which check `quit-flag'.  This is so quitting will
not leave an inconsistency in Emacs's internal state.  Instead, the
quit is delayed until a safe point, such as when the primitive
finishes or tries to wait for input.

  You can prevent quitting for a portion of a Lisp function by binding
the variable `inhibit-quit' to a non-`nil' value.  `C-g' still sets
`quit-flag' to `t' as usual, but the usual result of this--a quit--is
prevented.  When the binding is unwound at the end of the `let' form,
if `quit-flag' is still non-`nil', the requested quit happens
immediately.  This is exactly what you want for a ``critical
section'', where you simply wish quitting not to happen at a certain
point in the program.

  If you wish to handle `C-g' in a completely different way, so there
should be no quit at all, then you should set `quit-flag' to `nil'
before unbinding `inhibit-quit'.  This excerpt from the definition of
`read-quoted-char' shows how this is done; it also shows that normal
quitting is permitted after the first character of input.

     (defun read-quoted-char (&optional prompt)
       "...DOCUMENTATION..."
       (let ((count 0) (code 0) char)
         (while (< count 3)
           (let ((inhibit-quit (zerop count))
                 (help-form nil))
             (and prompt (message "%s-" prompt))
             (setq char (read-char))
             (if inhibit-quit (setq quit-flag nil)))
           ...)
         (logand 255 code)))

 * Variable: quit-flag

     If this variable is non-`nil', then Emacs quits immediately,
     unless `inhibit-quit' is non-`nil'.  Typing `C-g' sets
     `quit-flag' non-`nil', regardless of `inhibit-quit'.

 * Variable: inhibit-quit

     This variable determines whether Emacs should quit when
     `quit-flag' is set to `t'.  If `inhibit-quit' is non-`nil', then
     `quit-flag' has no special effect.

 * Command: keyboard-quit

     This function signals the `quit' condition with `(signal
     'quit)'.  This is the same thing that quitting does.   (See
     `signal' in *Note Errors::.)



File: lispref,  Node: Prefix Command Arguments,  Next: Recursive Editing,  Prev: Quitting,  Up: Command Loop

Prefix Command Arguments
========================

  Most Emacs commands can use a "prefix argument", a number specified
before the command itself.  (Don't confuse prefix arguments with
prefix keys.)  The prefix argument is represented by a value which is
always available (though it may be `nil', meaning there is no prefix
argument); each command may use it or ignore it.

  There are two representations of the prefix argument: "raw" and
"numeric".  Emacs uses the raw representation internally, and so do
the Lisp variables which store the information, but commands can
request either representation.

  Here are the possible values of a raw prefix argument:

   * `nil', meaning there is no prefix argument.  Its numeric value
     is 1, but numerous commands make a distinction.

   * An integer, which stands for itself.

   * A list of one element, that being an integer.  This form of
     prefix argument results from a succession of `C-u''s with no
     digits.  The numeric value is that integer, but some commands
     make a distinction.

   * The symbol `-'.  This indicates that `M--' or `C-u -' was typed
     without digits.  The numeric value is -1, but some commands make
     a distinction.

  There are two variables used to store the prefix argument:
`prefix-arg' and `current-prefix-arg'.  Commands such as
`universal-argument' which create prefix arguments store them in
`prefix-arg'.  In contrast, `current-prefix-arg' conveys the prefix
argument to the current command; setting that variable has no effect
on the prefix arguments for future commands.

  Normally, commands specify which kind of the argument they want to
see, either processed or unprocessed, in the `interactive'
declaration.  (*Note Interactive Call::.)  Alternatively, functions
may look at the value of the prefix argument directly in the variable
`current-prefix-arg'.  Don't call `universal-argument',
`digit-argument', or `negative-argument' unless you intend to let the
user enter the prefix argument for the *next* command.

 * Command: universal-argument

     This command reads input and specifies a prefix argument for the
     following command.  Don't call this command yourself unless you
     are a real wizard.

 * Command: digit-argument ARG

     This command constructs part of the prefix argument for the
     following command.  The argument ARG is the raw prefix argument
     as it was before this command; it is used to compute the updated
     prefix argument.  Don't call this command yourself unless you
     are a real wizard.

 * Command: negative-argument ARG

     This command constructs part of the numeric argument for the
     next command.  The argument ARG is the raw prefix argument as it
     was before this command; its value is negated to form the new
     prefix argument.  Don't call this command yourself unless you
     are a real wizard.

 * Function: prefix-numeric-value ARG

     This function returns the numeric meaning of the raw prefix
     argument, ARG.  A raw prefix argument may be a symbol, a number,
     or a list.  If it is `nil', then the value 1 is returned.  If it
     is any other symbol, then the value -1 is returned.  If it is a
     number, that number is returned, and if it is a list, then the
     CAR of that list (which should be a number) is returned.

 * Variable: current-prefix-arg

     This variable is the value of the raw prefix argument for the
     *current* command.  Commands may examine it directly, but the
     usual way to access it is with `(interactive "P")'.

 * Variable: prefix-arg

     The value of this variable is the raw prefix argument for the
     *next* editing command.  Commands which specify prefix arguments
     set this variable.



File: lispref,  Node: Recursive Editing,  Next: Disabling Commands,  Prev: Prefix Command Arguments,  Up: Command Loop

Recursive Editing
=================

  The Emacs command loop is entered automatically when Emacs starts up.
This top-level invocation of the command loop is never exited until
the Emacs is killed.  Lisp programs can also invoke the command loop.
Since this makes more than one activation of the command loop, we
call it "recursive editing".  A recursive editing level has the
effect of suspending whatever command invoked it and permitting the
user to do arbitrary editing before resuming that command.

  The same commands are available during recursive editing as are
available in the top-level editing loop, depending on the major mode,
of course.  Only a few special commands exit the recursive editing
level; the others remain within it.  (These special commands are
always available, but are useless when recursive editing is not in
progress.)

  All command loops, including recursive ones, set up all-purpose error
handlers so that an error in a command run from the command loop will
not exit the loop.

  Minibuffer input is a special kind of recursive editing.  It has a
few special wrinkles, such as enabling display of the minibuffer and
the minibuffer window, but fewer than you might suppose.  Keystrokes
behave differently in the minibuffer, but that is only because of the
minibuffer's local map; if you switch windows, you get the usual
Emacs commands.

  To invoke a recursive editing level, call the function
`recursive-edit'.  This function contains the command loop.  It also
contains a call to `catch' with tag `exit'; this makes it possible to
exit the recursive editing level by throwing to `exit'.  *Note Catch
and Throw::.

  If you throw a value other than `t', then `recursive-edit' returns
normally to the function which called it.  The command `C-M-c'
(`exit-recursive-edit') does this.  Throwing a `t' value causes
`recursive-edit' to quit, so that control returns to the command loop
one level up.  This is called "aborting", and is done by `C-]'
(`abort-recursive-edit').

  Most applications should not use recursive editing, except for the
minibuffer.  Usually it is better for the user to change the major
mode of the current buffer temporarily to a special, new mode, which
has a command to go back to the previous mode.  This technique is
used by the `w' command in Rmail, for example.  Or, if you wish to
give the user different text to edit ``recursively'', create and
select a new buffer in a special mode.  In this mode, define a
command to complete the processing and go back to the previous
buffer.  The `m' command in Rmail does this.

  One place where recursive edits are useful is in debugging.  You can
insert a call to `recursive-edit' into a function as a sort of
breakpoint, so that you can look around when you get there.  Even
better, instead of calling `recursive-edit' directly, call `debug',
which uses a recursive edit but also provides the other features of
the debugger.

  Recursive editing levels are also used when you type `C-r' in
`query-replace' or use `C-x q' (`kbd-macro-query').

 * Function: recursive-edit

     This function invokes the editor command loop.  It is called
     automatically by the initialization of Emacs to begin editing. 
     When called from a Lisp program, it enters a recursive editing
     level.

       In the example, the function `simple-rec' first advances point
     one word, then enters a recursive edit, printing out a message
     in the echo area.  The user can then do any editing desired,
     then type `C-M-c' to exit and continue executing `simple-rec'.

          (defun simple-rec ()
            (forward-word 1)
            (message "Recursive edit in progress.")
            (recursive-edit)
            (forward-word 1))
               => simple-rec
          (simple-rec)
               => nil

 * Command: exit-recursive-edit

     This function exits from the innermost recursive edit (including
     minibuffer input).  Its definition is effectively `(throw 'exit
     nil)'.

 * Command: abort-recursive-edit

     This function aborts the command that requested the innermost
     recursive edit (including minibuffer input), by signaling a
     `quit' error after exiting the recursive edit.  Its definition
     is effectively `(throw 'exit t)'.

 * Command: top-level

     This function exits all recursive editing levels.  It does not
     return a value, as it essentially jumps completely out of any
     computation directly back into the main command loop.

 * Function: recursion-depth

     This function returns the current depth of recursive edits. 
     When no recursive edit is active, it returns 0.



File: lispref,  Node: Disabling Commands,  Next: Command History,  Prev: Recursive Editing,  Up: Command Loop

Disabling Commands
==================

  "Disabling a command" marks the command as requiring user
confirmation before it can be executed.  The purpose of disabling a
command is to prevent users from executing it by accident, which
could be confusing or damaging.

  The direct mechanism for disabling a command is to have a non-`nil'
`disabled' property on the Lisp symbol for the command.  These
properties are normally set up by the user's `.emacs' file with Lisp
expressions such as

     (put 'upcase-region 'disabled t)

For a few commands, these properties are present by default and may
be removed by the `.emacs' file.

  If the value of the `disabled' property is a string, that string is
included in the message printed when the command is used:

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

  *Note : (emacs)Disabling,  for the details on what happens when a
disabled command is invoked.  Disabling a command has no effect on
calling it as a function from Lisp programs.

 * Command: enable-command COMMAND

     Allow COMMAND to be executed without special confirmation from
     now on.  The user's `.emacs' file is optionally altered so that
     this will apply to future sessions.

 * Command: disable-command COMMAND

     Require special confirmation to execute COMMAND from now on. 
     The user's `.emacs' file is optionally altered so that this will
     apply to future sessions.

 * Variable: disabled-command-hook

     The value of this variable is a function to be called instead of
     any command that is disabled (i.e., that has a non-`nil'
     disabled property).  By default, the value of
     `disabled-command-hook' is a function defined to ask the user
     whether to proceed.



File: lispref,  Node: Command History,  Next: Keyboard Macros,  Prev: Disabling Commands,  Up: Command Loop

Command History
===============

  Emacs keeps a history of the complex commands that have been
executed, to make it easy to repeat these commands.  A "complex
command" is defined to be one whose arguments are read using the
minibuffer.  This includes any `M-x' command, any `M-ESC' command,
and any command whose `interactive' specification reads an argument
from the minibuffer.  It does *not* include commands because they use
the minibuffer explicitly once they are called.

 * Variable: command-history

     This global variable's value is a list of recent commands.  Each
     command is represented as a form to evaluate.  It continues to
     accumulate all complex commands for the duration of the editing
     session, but at garbage collection time all but the first (most
     recent) thirty elements are deleted.

          command-history
          => ((switch-to-buffer "chistory.texinfo")
                  (describe-key "^X^[")
                  (visit-tags-table "~/emacs/src/")
                  (find-tag "repeat-complex-command"))

  There are a number of commands and even two entire modes devoted to
facilitating the editing and recall of previous commands.  The
commands `repeat-complex-command', and `list-command-history' are
described in the user manual (*note : (emacs)Repetition.).

 * Variable: repeat-complex-command-map

     The value of this variable is a sparse keymap used by the
     minibuffer when attempting to repeat a ``complex'' command.



File: lispref,  Node: Keyboard Macros,  Prev: Command History,  Up: Command Loop

Keyboard Macros
===============

  A "keyboard macro" is a canned sequence of keystrokes that can be
considered a command and made the definition of a key.  Don't confuse
keyboard macros with Lisp macros (*note Macros::.).

 * Function: execute-kbd-macro MACRO &optional COUNT

     This function executes MACRO as a string of editor commands.  If
     MACRO is a string, then the characters in that string are
     executed exactly as if they had been typed to Emacs.

     If MACRO is a symbol, then its function definition is used in
     place of MACRO.  If that is another symbol, this process repeats.
     Eventually the result should be a string.  If the result is
     neither a symbol nor a string, an error is signaled.

     The argument COUNT is a repeat count; MACRO is executed that
     many times.  If COUNT is omitted or `nil', MACRO is executed
     once.  If it is 0, MACRO is executed over and over until it
     encounters an error or a failing search.

 * Variable: last-kbd-macro

     This variable is the definition of the most recently defined
     keyboard macro.  Its value should be a string of characters, or
     `nil'.

 * Variable: defining-kbd-macro

     This variable indicates whether a keyboard macro is being
     defined.  It is set to `t' by `start-kbd-macro', and `nil' by
     `end-kbd-macro'.  Do not set this variable yourself!

 * Variable: executing-macro

     This variable contains the string that defines the keyboard
     macro that is currently executing.  It is `nil' if no macro is
     currently executing.

 * Variable: executing-macro-index

     This variable is the number of characters already executed from
     the currently executing keyboard macro.  It increments as the
     macro is executed.

  The user-level commands for defining, running and editing keyboard
macros include `call-last-kbd-macro', `insert-kbd-macro',
`start-kbd-macro', `end-kbd-macro', `kbd-macro-query', and
`name-last-kbd-macro'.  They are described in the user's manual
(*note : (emacs)Keyboard Macros.).



File: lispref,  Node: Keymaps,  Next: Modes,  Prev: Command Loop,  Up: Top

Keymaps
*******

  The bindings between keyboard input and commands are recorded in data
structures called "keymaps".  Each binding in a keymap is between an
individual character and either another keymap or a command.  When a
character is bound to another keymap, the next character in the key
sequence is looked up in that keymap, and so on until a command is
found.  This process is called "key lookup".

* Menu:

* Keymap Terms::	Definitions of terms pertaining to keymaps.
* Creating Keymaps::	Functions to create and copy keymaps.
* Key Lookup::	        Extracting elements from keymaps.
* Prefix Keys::	        Defining a key with a keymap as its definition.
* Global and Local Keymaps::	Each buffer has a local keymap
                                   to override the standard (global) bindings.
* Changing Key Bindings::	Redefining a key in a keymap.

 

File: lispref,  Node: Keymap Terms,  Next: Creating Keymaps,  Prev: Keymaps,  Up: Keymaps

Keymaps: Terminology
====================

  A sequence of keyboard input characters, or "keystrokes" is called a
"key".  Thus, a key is not necessarily a single character.

  A key is said to have a "key binding" if all the characters in the
sequence of keyboard input characters are bound; this is the case
when each character is bound to a keymap in which the rest of the key
is looked up.

  A "complete key" is one that is bound to a command.  A "prefix key"
is one that is bound to a keymap.  Therefore, any initial sequence of
a complete key is a prefix key.  But the characters that follow a
prefix key may or may not complete the key.  An "undefined key" is
one that is not bound to either a keymap or a command.  *Note Prefix
Keys::, for a more details.

  Examples of complete keys are `X', RET, and `C-x 4 C-f'.  Examples of
prefix keys are `C-c', `C-x', and `C-x 4'.  Examples of undefined
keys are `C-x C-g', and `C-c 3'.

  At any one time, two primary keymaps are in use: the "global map",
which is available in all buffers, and the "local keymap", which is
usually associated with a major mode.  The local keymap bindings
shadow (i.e., are used in place of) the corresponding global bindings.
*Note Global and Local Keymaps::, for the details.

  Note that a command is any action that may be called interactively
(*note Command Overview::.), including keyboard macros (*note
Keyboard Macros::.).



File: lispref,  Node: Creating Keymaps,  Next: Key Lookup,  Prev: Keymap Terms,  Up: Keymaps

Creating Keymaps
================

  A keymap can be represented as one of two kinds of Lisp object: a
vector or a list.  A "full keymap" is a vector of length 128.  The
binding for a character in such a keymap is found by indexing into
the vector with the character as the index.

  A "sparse keymap" is a list whose CAR is the symbol `keymap', and
whose remaining elements are pairs of the form `(CHAR . BINDING)'. 
Such a list is called a "sparse keymap" because most of the entries
would be `nil' in a full keymap.  Use a sparse keymap when you expect
only a few entries.  (Also, Emacs automatically creates sparse
keymaps for intermediate keymaps, when `define-key' requires them.)

  Keymaps are only of length 128, and so are unable to handle META
characters, whose codes are from 128 to 255.  Instead, Emacs
represents a META character as a sequence of two characters, the
first of which is ESC (the usual value of `meta-prefix-char').  Thus,
the key `M-a' is really represented as `ESC a', and its binding is
found at the slot for `a' in `esc-map'.

For example, the Lisp mode keymap uses `C-c C-l' for the `run-lisp'
command, `M-C-q' for `indent-sexp', and `M-C-x' for `lisp-send-defun'.

     lisp-mode-map
     => 
     (keymap 
      (9 . lisp-indent-line)                 ; TAB
      (127 . backward-delete-char-untabify)  ; DEL
      (3 keymap 
         (12 . run-lisp))                    ; `C-c C-l'
      (27 keymap 
          (17 . indent-sexp)                 ; `M-C-q'
          (24 . lisp-send-defun)))           ; `M-C-x'

 * Function: keymapp OBJECT

       This function returns `t' if OBJECT is a keymap, `nil'
     otherwise.  A keymap is either a vector of length 128, or a list
     with the form `(keymap PAIRS...)', where PAIRS is a series of
     pairs of the form `(CHAR . BINDING)'.

          (keymapp '(keymap))
              => t
          (keymapp (current-global-map))
              => t

 * Function: make-keymap

       This function creates and returns a new full keymap (i.e., a
     vector of length 128).  All entries in the keymap are `nil',
     which means that each command is undefined in this keymap.

          (make-keymap)
              => [nil nil nil ... nil nil]

 * Function: make-sparse-keymap

       This function creates and returns a new sparse keymap with no
     entries.

          (make-sparse-keymap)
              => (keymap)

 * Function: copy-keymap KEYMAP

       This function returns a copy of KEYMAP.  Starting with Emacs
     version 18.50, `copy-keymap' is done recursively so any keymaps
     that are components of KEYMAP are copied as well.

          (setq map (copy-keymap (current-local-map)))
          => (keymap
               (27 keymap         ; (This implements META characters.)
                 (83 . center-paragraph)
                 (115 . center-line))
               (9 . tab-to-tab-stop))
          
          (eq map (current-local-map))
              => nil
          (equal map (current-local-map))
              => t



File: lispref,  Node: Key Lookup,  Next: Prefix Keys,  Prev: Creating Keymaps,  Up: Keymaps

Key Lookup
==========

  "Key lookup" is the process by which Emacs searches through keymaps
to find the non-keymap object bound to the key.  (Note that the key
lookup process should be distinguished from the process of calling
the command that is found by the key lookup.)

  There are several types of "keymap entry" that may appear in either
full or sparse keymaps.  Indeed, any Lisp object may appear in a
keymap, but only a few types of object have meaning either for
looking up keys or for calling commands.

  When Emacs looks up a key, the lookup process starts from a
particular keymap that is determined by Emacs's current mode.  Emacs
uses each character of the key in sequence, determining the binding
of the character.  If the binding of the character in the keymap is
another keymap, the next character in the key, if any, is used to
lookup the next object.  This process repeats until any non-keymap
object is found; that object is the result of the key lookup.  If the
key is not long enough to lead to a non-keymap object, then a keymap
is the result of the lookup.

  The recognized keymap entries and their meanings are listed below.

`nil'
     As a special case, `nil' means that the characters used so far
     in the lookup are undefined in this keymap.  A `nil' entry is
     also returned if a sparse keymap has no binding for the character.

KEYMAP
     The characters used so far in the lookup are a prefix key. 
     Subsequent characters are looked up starting in KEYMAP, which
     may be full or sparse.

LIST
     The characters used so far in the lookup may or may not be a
     prefix key, depending on the form of the list.

        * If the CAR of LIST is the symbol `keymap', then this is
          really a keymap entry and is used as described above.

        * As a special case, if LIST looks like `(KEYMAP . CHAR)',
          then the binding of CHAR in the keymap called KEYMAP is
          used as if it had been the entry.  This permits you to
          define one key as an alias for another key, so it uses
          whatever definition the othr key has.

        * If the CAR of LIST is `lambda', then this is a lambda
          expression, which should be interactive.  It is the
          definition of the key.

STRING
     STRING represents a keyboard macro.  When the characters used so
     far in the lookup is entered as a command, the characters in
     STRING are used as if they had been typed instead of the key. 
     (*note Keyboard Macros::., for the details.)

SYMBOL
     SYMBOL's function definition is found by dereferencing.  *Note
     Classifying Lists::, to find out how symbols are dereferenced. 
     One of the following objects should be found.

        * As a special case, if a keymap is found in the symbol's
          function cell, it is used as if the entry had been that
          keymap.  A keymap is not a function, so this symbol would
          not be valid in a function call.

        * If a function is found, it is the result of the key lookup.
          When the key is entered, that function is called; it must
          be interactive.

          Two commands are available for special purposes: `ignore'
          and `undefined'.

          The command `ignore' means that the key does nothing
          (`ignore' just returns `nil').  The command `undefined'
          means to treat the key as undefined; this command calls
          `ding' to ring the bell, but does not cause an error.

        * If a string is found, it represents a keyboard macro, as
          above.

        * If a list of the form `(KEYMAP . CHAR)' is found, it is
          *not* used as if it had been the entry.  This sort of list
          is meaningful only if it appears directly in the keymap.

ANYTHING ELSE
     If any other type of object is found, the lookup terminates.

  In short, a keymap entry may be another keymap, or a command.  Three
special cases are `nil', meaning that the characters used so far are
undefined in this keymap; a list that starts with a keymap; and a
symbol with a keymap in the function cell.

 * Function: lookup-key KEYMAP KEY

       This function returns the definition of KEY in KEYMAP.  If it
     returns a number, this means KEY is ``too long''; that is, the
     characters fail to be a valid sequence in KEYMAP.  The number is
     how many characters at the front of KEY that compose a
     meaningful key sequence.

       If KEY contains a meta-character, that character is replaced by
     a two-character sequence: the value of `meta-prefix-char',
     followed by the corresponding non-meta character.

       This function does not perform automatic downcasing like that of
     `read-key-sequence' (*note Keyboard Input::.).  All the other
     functions described in this chapter that lookup keys use
     `lookup-key'.

          (lookup-key (current-global-map) "\C-x\C-f")
              => find-file
          (lookup-key (current-global-map) "\C-x\C-f12345")
              => 2

 * Function: ignore &rest ARGS

     Ignore any arguments and return `nil'.  Used in keymaps to
     ignore keys.

 * Command: undefined

     Used in keymaps to undefine keys.  It calls `ding', but does not
     cause an error.

 * Variable: meta-prefix-char

       This global variable is the meta-prefix character code. 
     Normally its value is ESC, which has the value of the decimal
     integer 27.  It is used when translating a meta-character to a
     two-character sequence so it can be looked up in a keymap.  For
     useful results, the value should be a prefix character (*note
     Prefix Keys::.).

       Thus, as long as the value of `meta-prefix-char' remains 27, key
     lookup translates `M-b' into `ESC b', which is normally defined
     as the `backward-word' command.  However, if you set
     `meta-prefix-char' to 24, the code for `C-x', then Emacs will
     translate `M-b' into `C-x b'; this will call the
     `switch-to-buffer' command.

          meta-prefix-char                    ; The default value.
               => 27
          (key-binding "\M-b")
               => backward-word
          ?\C-x                               ; The print representation
               => 24                          ; of a character.
          (setq meta-prefix-char 24)
               => 24      
          (key-binding "\M-b")
               => switch-to-buffer            ; Now, typing `M-b' is
                                              ; like typing `C-x b'.
          
          (setq meta-prefix-char 27)          ; Avoid confusion!
               => 27                          ; Restore the default value!

 

File: lispref,  Node: Prefix Keys,  Next: Global and Local Keymaps,  Prev: Key Lookup,  Up: Keymaps

Prefix Keys
===========

  A "prefix key" has an associated keymap which defines what to do with
key sequences that start with the prefix key.  For example,
`ctl-x-map' is the keymap used for characters following the prefix
key `C-x'.  The following keymaps are reached via the global keymap
when looking up the associated prefix key.

   * `ctl-x-map' is the variable name for the map used for characters
     that follow `C-x'.  This map is also in the function cell of
     `Control-X-prefix'.

   * `ctl-x-4-map' is for characters that follow `C-x 4'.

   * `esc-map' is for characters that follow ESC.  Thus, all Meta
     characters are actually defined by this map.  This map is also
     in the function cell of `ESC-prefix'.

   * `help-map' is used for characters that follow `C-h'.

   * `mode-specific-map' is for characters that follow `C-c'.

  The binding of a prefix key is the keymap to use for looking up the
characters that follow the prefix key.  In many cases, the binding is
to a Lisp symbol whose function definition is a keymap.  The effect
is the same, but the use of a symbol doubles as a description of what
the prefix key is for.  Thus, the binding of `C-x' is the symbol
`Control-X-prefix', whose function definition is the keymap for `C-x'
commands.  This keymap is also the value of `ctl-x-map'.

  Prefix key definitions of this sort can appear in either the global
map or a local map.  The definitions of `C-c', `C-x', `C-h' and ESC
as prefix keys appear in the global map, so these prefix keys are
always available.  Major modes can locally redefine a key as a prefix
by putting a prefix key definition for it in the local map.

  If a key is defined as a prefix in both the local map and the global,
the two definitions are effectively merged: the commands defined in
the local map's prefix definition take priority; those not defined
there are taken from the global map.

  In this example, `C-p' is made a prefix key in the local keymap (so
that `C-p' is identical to `C-x').  The binding for `C-p C-f' is the
function `find-file', just like `C-x C-f'.  The key sequence `C-p 6'
is not found in either the local map or global map.

     (use-local-map (make-sparse-keymap))
         => nil
     (local-set-key "\C-p" ctl-x-map)
         => nil
     (key-binding "\C-p\C-f")
         => find-file
     
     (key-binding "\C-p6")
         => nil

 * Function: define-prefix-command SYMBOL

       This function defines SYMBOL as a prefix command.  It creates a
     full keymap and stores it as SYMBOL's function definition.  This
     can be used to create a keymap that is used like the
     `ESC-prefix' keymap.  It may be convenient to also store the
     keymap in a variable.  This function returns SYMBOL.

     In version 18, the function definition of SYMBOL is set, but not
     the value.

     In version 19, both the function definition and value are set.



File: lispref,  Node: Global and Local Keymaps,  Next: Changing Key Bindings,  Prev: Prefix Keys,  Up: Keymaps

Global and Local Keymaps
========================

  The "global keymap" holds the bindings of keys that are defined
regardless of the current buffer, such as `C-f'.  The variable
`global-map' holds this keymap.

  Each buffer may have another keymap, its "local keymap", which may
contain new or overriding definitions for keys.  Each buffer records
which local keymap is used with it.

  Both the global and local keymaps are used to determine what command
to execute when a key is entered.  The key lookup proceeds as
described earlier (*note Key Lookup::.), but Emacs *first* searches
for the key in the local map; if Emacs does not find a local
definition, Emacs then searches the global map.

  Since every buffer that uses the same major mode normally uses the
very same local keymap, it may appear as if the keymap is local to
the mode.  A change to the local keymap in one buffer (using
`define-key', for example) will only be seen in other buffers that
use that keymap.

  The minibuffer has local keymaps, too; they contain various
completion and exit commands.  *Note Minibuffers::.

  The local keymaps that are used for Lisp mode, C mode, and several
other major modes always exist even when they are not in use.  These
local maps are the values of the variables `lisp-mode-map',
`c-mode-map', and so on.  Other modes are less frequently used, and
the local keymaps for these modes are constructed only when the mode
is used for the first time in a session.

  *Note Standard Keymaps::, for a list of standard keymaps.

 * Variable: global-map

       This variable contains the default global keymap that maps Emacs
     keyboard input to commands.  The value of `global-map' is a
     keymap which is usually (but not necessarily) Emacs's global
     map.  The default global keymap is a full keymap that binds
     `self-insert-command' to all of the visible characters.

 * Function: current-global-map

       This function returns the current global keymap.  Normally, this
     is the same as the value of the `global-map'.

          (current-global-map)
          => [set-mark-command beginning-of-line ... delete-backward-char]

 * Function: current-local-map

       This function returns the current buffer's local keymap, or
     `nil' if it has none.  In the following example, the keymap for
     the `*scratch*' buffer (using Lisp Interaction mode) is a sparse
     keymap in which the entry for ESC, 27, is another sparse keymap.

          (current-local-map)
          => (keymap 
              (10 . eval-print-last-sexp) 
              (9 . lisp-indent-line) 
              (127 . backward-delete-char-untabify) 
              (27 keymap 
                  (24 . eval-defun) 
                  (17 . indent-sexp)))

 * Function: use-global-map KEYMAP

       This function makes KEYMAP the new current global keymap.  The
     KEYMAP map must be a full keymap (a vector of length 128).  It
     returns `nil'.

       It is very unusual to change the global keymap (there are few
     standard modes that do so).

 * Function: use-local-map KEYMAP

       This function makes KEYMAP the new current local keymap of the
     current buffer.  If KEYMAP is `nil', then there will be no local
     keymap.  It returns `nil'.  Most major modes use this function.

 * Function: key-binding KEY

       This function returns the definition for KEY in the current
     keymaps trying the current buffer's local map and then the
     global map.  The result is `nil' if KEY is undefined in the
     keymaps.

     An error is signaled unless KEY is a string.

          (key-binding "\C-x\C-f")
              => find-file

 * Function: local-key-binding KEY

       This function returns the definition for KEY in the current
     local keymap, or `nil', if it is undefined there.

 * Function: global-key-binding KEY

       This function returns the definition for command KEY in the
     current global keymap, or `nil', if it is undefined there.

 * Function: accessible-keymaps KEYMAP

       This function returns a list of all the keymaps that can be
     accessed, via prefix keys, from KEYMAP.  The list returned is an
     association list with elements of the form `(KEY . MAP)', where
     KEY is a prefix whose definition in KEYMAP is MAP.

       The elements of the alist are ordered so that the KEY increases
     in length.  The first element is always `("" . KEYMAP)', which
     means that the empty string prefix gets you to the keymap you
     start with.

       In the example below, the returned alist indicates that by
     typing ESC, which is displayed as `"^["', you will get to the
     sparse keymap `(keymap (83 . center-paragraph) (115 . foo))'.

          (accessible-keymaps (current-local-map))
          =>(("" keymap 
                (27 keymap   ; Note this keymap for ESC appears below.
                    (83 . center-paragraph)
                    (115 . center-line))
                (9 . tab-to-tab-stop))
          
             ("^[" keymap 
              (83 . center-paragraph) 
              (115 . foo)))

       In the following example, typing `C-h' will get you to the
     sparse keymap starting `(118 . describe-variable) ...'.  Typing
     `C-x 4', will get you to the full keymap beginning `[nil ...]'
     (which happens to be `ctl-x-4-map').

          (accessible-keymaps (current-global-map))
          => (("" . [set-mark-command beginning-of-line ... 
                        delete-backward-char])
              ("^C" keymap (13 . x-flush-mouse-queue))
              ("^H" keymap (118 . describe-variable) ... (8 . help-for-help))
              ("^X" . [x-flush-mouse-queue  ... backward-kill-sentence])
              ("^[" . [mark-sexp backward-sexp ... backward-kill-word])
              ("^X4" . [nil ... find-file-other-window nil ... 
                        nil nil]))

 * Function: where-is-internal COMMAND &optional KEYMAP FIRSTONLY

       This function returns list of key sequences (of any length) that
     are bound to COMMAND in KEYMAP and the global keymap.  COMMAND
     can be any object; it is compared with all keymap entries using
     `eq'.  If KEYMAP is not supplied, then the global map is used.

       If FIRSTONLY is non-`nil', then it returns a string representing
     the first key sequence found, rather than a list of all possible
     key sequences.

       This function is used by `where-is' (*note : (emacs)Help.).

          (where-is-internal 'kill-word)
              => ("^[d" "^[OC")               ; Locally, `kill-word' is
                                              ; bound to a function key
                                              ; as well as to `M-d'.

  * Command: describe-bindings

       This function creates a listing of all defined keys, and their
     definitions.  The listing is put in a buffer named `*Help*',
     which then is displayed in a window.

       A command using the META key is shown as ESC followed by the
     rest of the key sequence.  A command using the control key is
     shown as `C-' followed by the rest of the key sequence.

       A number of keys that all share the same definition are shown as
     the first character followed by two dots, followed by the last
     character.  It does help to know ASCII codes for this instance. 
     In the default global map, `SPC .. ~' are all bound to
     `self-insert-command'.  SPC is ASCII 32, `~' is ASCII 126, and
     all the normal printing characters, (e.g., letters, digits,
     punctuation, etc.) lie between these two.



File: lispref,  Node: Changing Key Bindings,  Prev: Global and Local Keymaps,  Up: Keymaps

Changing Key Bindings
=====================

  The way to rebind a key is to change its binding in a keymap.  You
can change the global keymap, in which case the change is effective
in all buffers (except those that have their own overriding local
definitions for the same key).  Or you can change the current
buffer's local map, which usually affects the local keymap for all
buffers using the same major mode.  In addition, you can change
bindings in any map that you can access.

The `global-set-key' and `local-set-key' functions are easiest to
use.  People often use `global-set-key' in their `.emacs' file for
simple customization.

``(global-set-key KEY CMD)''
     Defines KEY globally to run CMD.

``(local-set-key KEY CMD)''
     Defines KEY locally (in the major mode now in effect) to run CMD.

  For example,

     (global-set-key "\C-x\C-\\" 'next-line)

redefines `C-x C-\' to move down a line.

  A special read syntax is provided to represent control and meta
characters (*note String Type::.).  In a string, the syntax `\C-'
means that the following character is a control character and `\M-'
means that the following character is a META character.  Thus, the
string `"\M-x"' is read as `M-x', `"\C-f"' is read as `C-f', and
`"\M-\C-x"' and `"\C-\M-x"' are both read as `C-M-x'.

  However, the most general way to modify a keymap is to use the
`define-key' function.  `define-key' takes three arguments: the
keymap, the key to modify in it, and the new definition. 
(`global-set-key' is equivalent to `define-key' with
`current-global-map' as its first argument.)

  For the functions below, an error is signaled if an argument named
KEYMAP is not a keymap or if an argument named KEY is not a string
representing characters to be typed.

 * Function: define-key KEYMAP KEY DEFINITION

       This function adds a binding for KEY in KEYMAP.  If KEY is more
     than one character long, the change is actually made in another
     keymap reached from KEYMAP.  The DEFINITION can be any Lisp
     object, but only certain types are meaningful.  (To see a list
     of these objects, see *Note Key Lookup::.)  The value returned
     by `define-key' is DEFINITION.

       Every prefix of KEY must be a prefix key (i.e., bound to a
     keymap) or undefined; otherwise an error is signaled (with data
     `(error "Key sequence KEY uses invalid prefix characters")'). 
     If some prefix of KEY is undefined, then DEFINE-KEY
     automatically defines it as a prefix key so that the rest of KEY
     may be defined as specified.

       In the following example, a sparse keymap is created and a
     number of bindings are added to it.

          (setq map (make-sparse-keymap))
              => (keymap)
          (define-key map "\C-f" 'forward-char)
              => forward-char
          map
              => (keymap (6 . forward-char))
          
          ;; Build sparse map for `C-x' and bind `f' in that.
          (define-key map "\C-xf" 'forward-word)
              => forward-word
          map
          => (keymap 
              (24 keymap                ; `C-x'
                  (102 . forward-word)) ;      `f'
              (6 . forward-char))       ; `C-f'
          
          ;; Bind `C-p' to the `ctl-x-map'.
          (define-key map "\C-p" ctl-x-map)
          => [nil ...  find-file ... backward-kill-sentence] ; `ctl-x-map'
          
          ;; Bind `C-f' to `foo' in the `ctl-x-map'.
          (define-key map "\C-p\C-f" 'foo)
          => 'foo
          map
          => (keymap     ; Note `foo' in `ctl-x-map'.
              (16 . [nil ...  foo ... backward-kill-sentence])
              (24 keymap 
                  (102 . forward-word))
              (6 . forward-char))

     In this example, `C-x C-f' has been changed in the default
     global map as a result of this change in `ctl-x-map'.

       Note also that typing `C-p C-f' will execute the function `foo'
     as will `C-x C-f', since `ctl-x-map' was changed.

 * Command: global-set-key KEY DEFINITION

       This function gives KEY a definition of DEFINITION in the global
     keymap.

          (global-set-key KEY DEFINITION)
          ==
          (define-key (current-global-map) KEY DEFINITION)

 * Command: global-unset-key KEY

       This function removes the definition of KEY from the current
     global map.  One use of this function is to unset a key so that
     a longer key may use the first key as a prefix--which would not
     be allowed otherwise.

          (global-unset-key KEY)
          ==
          (define-key (current-global-map) KEY nil)

     For example:

          (global-unset-key "\C-l")
              => nil
          (global-set-key "\C-l\C-l" 'redraw-display)
              => nil

 * Command: local-set-key KEY DEFINITION

       This function gives KEY a definition of DEFINITION in the local
     keymap.

          (local-set-key KEY DEFINITION)
          ==
          (define-key (current-local-map) KEY DEFINITION)

 * Command: local-unset-key KEY

       This function removes the definition of KEY from the current
     local  map.

          (local-unset-key KEY)
          ==
          (define-key (current-local-map) KEY nil)

 * Function: substitute-key-definition OLDDEF NEWDEF KEYMAP

       This function replaces OLDDEF with NEWDEF for any keys in KEYMAP
     that were bound to OLDDEF.  In other words, OLDDEF is replaced
     with NEWDEF wherever it appears.

       It returns `nil'.

       Prefix keymaps that appear within KEYMAP are not checked
     recursively for keys bound to OLDDEF; they are not changed at
     all.  Perhaps they ought to be checked recursively.

          (setq map '(keymap 
          	    (?1 . olddef-1) 
          	    (?2 . olddef-2) 
          	    (?3 . olddef-1)))
          => (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))
          
          (substitute-key-definition 'olddef-1 'newdef map)
          => nil
          map
          => (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))
          
          ;; The following will redefine `C-x C-f', if you do it in an
          ;; Emacs with standard bindings.
          
          (substitute-key-definition 
           'find-file 'find-file-read-only (current-global-map))

 * Function: suppress-keymap KEYMAP &optional NODIGITS

       This function changes the contents of the full keymap KEYMAP by
     replacing the self insertion commands for numbers with the
     `digit-argument' function, unless NODIGITS is non-`nil', and by
     replacing the functions for the rest of the printing characters
     with `undefined'.  This means that you are unable to type text
     into a buffer after calling `suppress-keymap'.

       The function returns `nil'.

       Since this function does change KEYMAP, you probably wish to use
     it either with a new keymap or with a copy of a keymap, and use
     the modified map locally.  Suppressing `global-map' would make
     it impossible to use most of Emacs.

     In `emacs/lisp/dired.el', for example, a keymap is made for
     Dired mode.  The beginning of the `define-key' sequence looks
     like this:

            ...
            (setq dired-mode-map (make-keymap))
            (suppress-keymap dired-mode-map)
            (define-key dired-mode-map "r" 'dired-rename-file)
            (define-key dired-mode-map "\C-d" 'dired-flag-file-deleted)
            (define-key dired-mode-map "d" 'dired-flag-file-deleted)
            (define-key dired-mode-map "v" 'dired-view-file)
            (define-key dired-mode-map "e" 'dired-find-file)
            (define-key dired-mode-map "f" 'dired-find-file)
            ...

      The `suppress-keymap' function does not make it impossible to
     modify a buffer, as it does not suppress commands such as `yank'
     and `quote-insert'.  (To prevent any modification of a buffer,
     make it read-only.  (*Note Read Only Buffers::.)

       The `suppress-keymap' function changes a keymap by replacing the
     self insertion commands for numbers with the `digit-argument'
     function and by replacing the functions for the rest of the
     printing characters with `undefined'.

       In the following illustration, the first three lines containing
     `self-insert-command' represent the ten digits.  The following
     line represents all of the other printing characters.  The
     `suppress-keymap' function replaces the `self-insert-command'
     function with `digit-argument' and `undefined'.

          (setq map (copy-keymap (current-global-map)))
          => [set-mark-command ...         ; `C-a'
              self-insert-command ...             ; SPC
              self-insert-command                 ; 0
              self-insert-command                 ; 1
              self-insert-command ...             ; 2
              self-insert-command ...             ; other printing characters
              delete-backward-char]               ; DEL
          
          (suppress-keymap map)
          => nil
          
          map
          => [set-mark-command ...         ; `C-a'
              undefined ...                       ; SPC
              digit-argument                      ; 0                        
              digit-argument                      ; 1                        
              digit-argument ...                  ; 2                        
              undefined                           ; what were 
              undefined ...                       ; other printing characters
              delete-backward-char]               ; DEL



File: lispref,  Node: Modes,  Next: Documentation,  Prev: Keymaps,  Up: Top

Major and Minor Modes
*********************

  A "mode" is a set of definitions which customize Emacs for editing
text of a particular sort.  There are two varieties of modes: the
major modes, which are used for specialized editing tasks; and minor
modes, which provide features that several different major modes may
use.

  This chapter covers major and minor modes, the `mode-line-format',
and hooks.  Other related topics such as keymaps and syntax tables
are covered in separate chapters.  (*Note Keymaps::, and *Note Syntax
Tables::.)

* Menu:

* Major Modes::        Defining major modes.
* Minor Modes::        Defining minor modes.
* Mode Line Format::   Customizing the text that appears in the mode line.
* Hooks::              How to use hooks; how to write code that provides hooks.

 

File: lispref,  Node: Major Modes,  Next: Minor Modes,  Prev: Modes,  Up: Modes

Major Modes
===========

  The major modes are mutually exclusive; each buffer has only one
major mode at a time.  The least specialized major mode is called
"Fundamental mode".  This mode has no mode-specific definitions or
variable settings, so each Emacs command behaves in its default
manner, and each option is in its default state.  In contrast, Lisp
Interaction mode provides special key bindings for LFD
(`eval-print-last-sexp'), TAB (`lisp-indent-line'), and other keys.

  When you need to write large quantities of code to help you perform a
specialized editing task, you are likely to want to create a new
major mode.  By writing a new major mode, rather than adding to an
existing mode, you avoid having the one mode do double duty, and you
thereby avoid making the code, and its use, confusing.  Also, in
practice, writing a major mode is often simple (this is a sharp
contrast to writing a minor mode, which is often complicated).

  For example, Rmail Edit mode, which is in `emacs/lisp/rmailedit.el',
is a major mode that is very similar to Text mode except that it
provides three additional commands.

The additions to Rmail Edit mode are so small that you might not
think to use a major mode for such a job; instead, you might think to
use a recursive edit.  But recursive edits don't change any commands,
and so are not useful.  In a few circumstances, a recursive edit
might be an alternative to temporarily changing a buffer to a
different mode; but recursive edits are confusing to the user and
should only be used when there is no alternative, as in the Emacs
debugger.  For mail editing, a major mode is better.  *Note Recursive
Editing::.

  The standard GNU Emacs `lisp' library contains the code for several
major modes, including `text-mode.el', `texinfo.el', `lisp-mode.el',
`c-mode.el', and `rmail.el'.  You can look at these libraries to see
how modes are written.  Text mode is perhaps the simplest major mode,
besides Fundamental mode.  Rmail mode is a rather complicated,
full-featured mode.

* Menu:

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Example Major Modes::	    Text mode and Lisp modes.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::		    Finding out how to use a mode.

 

File: lispref,  Node: Major Mode Conventions,  Next: Example Major Modes,  Prev: Major Modes,  Up: Major Modes

Major Mode Conventions
----------------------

  The code for existing major modes follows various coding conventions,
including conventions for local keymap and syntax table
initialization, global names, and hooks.   When you create a new
major mode, please keep these conventions in mind.

   * An apparently trivial, yet important convention is that a user
     should be able to initialize a new major mode with a command
     that has a `-mode' suffix to its name.  You may also create
     other ways to enter the mode, but you should have one function
     that can be called to initialize the keymap, syntax table, and
     local variables in an existing buffer without changing the
     buffer's text.  In addition, the documentation string for this
     function is what `describe-mode' should use.

   * This major mode function should include documentation that is
     displayed by typing `C-h m' (`describe-mode').

     The documentation string may include the special documentation
     substrings, `\[COMMAND]', `\{KEYMAP}', and `\<KEYMAP>', that
     permit you to change the values of keymaps without having to
     update the documentation string.  When the `describe-mode'
     function sees these special documentation substrings, Emacs
     reads their current values.  (*Note Accessing Documentation::.)

   * The major mode function should set the variable `major-mode' to
     the major mode function symbol.  This is how `describe-mode'
     discovers which documentation to print.

   * The major mode function should set the variable `mode-name' to
     the ``pretty'' name of the mode, as a string.  This appears in
     the mode line.

   * Since all global names are in the same name space, you should
     take care to prefix the names of all global variables,
     constants, and functions with the major mode name (or with an
     abbreviation of it if the name is long).

   * Each major mode typically has its own keymap, which is used as
     the local keymap in all buffers in that mode.  The major mode
     function should just call `use-local-map' with the keymap
     variable.  *Note Global and Local Keymaps::, for more information.

     This keymap should be kept in a global variable named
     `MODENAME-mode-map'.  This variable is usually set up when the
     library that defines the mode is loaded.

     Use `defvar' to set the variable, so that it is not
     reinitialized if it already has a value.  Such reinitialization
     could discard customizations made by the user.

   * It is good practice to use both a syntax table variable and an
     abbrev table variable.  The reasons for this are the same as for
     using a keymap variable.  You can use the tables of a related
     mode, if they serve without change.

   * To give variables a buffer-local binding, you should use
     `make-local-variable' in the major mode function rather than
     `make-variable-buffer-local'.  The `make-local-variable'
     function makes a variable local to just the current buffer;
     while the `make-variable-buffer-local' function makes a variable
     local to *every* buffer, even ones that are created later.  Use
     of `make-local-variable' has fewer unexpected consequences. 
     (*Note Buffer Local Variables::.)

   * If hooks are appropriate for the mode, the major mode function
     should run the hooks after completing all other initialization
     so the user may further customize any of the settings.

   * If this mode is appropriate only for text specially made by
     Emacs, then the major mode command symbol should have a property
     named `mode-class' with value `special', put on as follows:

          (put funny-mode 'mode-class 'special)

     This tells Emacs that new buffers created while a buffer in
     Funny mode is current should not inherit Funny mode.  Modes such
     as Dired, Rmail, and Buffer List use this feature.

   * The top level forms in the mode library should be written in
     such a manner that they may be evaluated more than once without
     adverse consequences.  Even if you never load your library more
     than once, someone else will.

   * In the documentation, you should provide an example `autoload'
     form and an example `auto-mode-alist' addition that users can
     include in their `.emacs' files.



File: lispref,  Node: Example Major Modes,  Next: Auto Major Mode,  Prev: Major Mode Conventions,  Up: Major Modes

Major Mode Examples
-------------------

  Text mode is perhaps the simplest mode besides Fundamental mode. 
Here are excepts from  `text-mode.el' that illustrate many of the
conventions listed above:

     ;; Create mode-specific tables.
     (defvar text-mode-syntax-table nil 
       "Syntax table used while in text mode.")
     
     (if text-mode-syntax-table
         ()              ; Do not change the table if it is already set.
       (setq text-mode-syntax-table (make-syntax-table))
       (set-syntax-table text-mode-syntax-table)
       (modify-syntax-entry ?\" ".   " text-mode-syntax-table)
       (modify-syntax-entry ?\\ ".   " text-mode-syntax-table)
       (modify-syntax-entry ?' "w   " text-mode-syntax-table))
     
     (defvar text-mode-abbrev-table nil
       "Abbrev table used while in text mode.")
     (define-abbrev-table 'text-mode-abbrev-table ())
     
     (defvar text-mode-map nil "")   ; Create a mode-specific keymap.
     
     (if text-mode-map
         ()              ; Do not change the keymap if it is already set.
       (setq text-mode-map (make-sparse-keymap))
       (define-key text-mode-map "\t" 'tab-to-tab-stop)
       (define-key text-mode-map "\es" 'center-line)
       (define-key text-mode-map "\eS" 'center-paragraph))

  Here is the complete major mode function definition for Text mode:

     (defun text-mode ()
       "Major mode for editing text intended for humans to read. 
      Special commands: \\{text-mode-map}
     Turning on text-mode calls the value of the variable text-mode-hook,
     if that value is non-nil."
       (interactive)
       (kill-all-local-variables)
       (use-local-map text-mode-map)     ; This provides the local keymap.
       (setq mode-name "Text")           ; This name goes into the mode line.
       (setq major-mode 'text-mode)      ; This is how `describe-mode'
                                         ;     finds out what to describe.
       (setq local-abbrev-table text-mode-abbrev-table)
       (set-syntax-table text-mode-syntax-table)
       (run-hooks 'text-mode-hook))      ; Finally, this permits the user to
                                         ;     customize the mode with a hook.

 Each of the three Lisp modes (Lisp mode, Emacs Lisp mode, and Lisp
Interaction mode) have more features than Text mode and the code is
correspondingly more complicated.  Here are excerpts from
`lisp-mode.el' that illustrate how these modes are written.

     ;; Create mode-specific table variables.
     (defvar lisp-mode-syntax-table nil "")  
     (defvar emacs-lisp-mode-syntax-table nil "")
     (defvar lisp-mode-abbrev-table nil "")
     
     (if (not emacs-lisp-mode-syntax-table) ; Do not change the table
                                            ; if it is already set.
         (let ((i 0))
           (setq emacs-lisp-mode-syntax-table (make-syntax-table))
     
           ;; Set syntax of chars up to 0 to class of chars that are
           ;; part of symbol names but not words.
           ;; (The number 0 is `48' in the ASCII character set.)
           (while (< i ?0) 
             (modify-syntax-entry i "_   " emacs-lisp-mode-syntax-table)
             (setq i (1+ i)))
           ...
           ;; Set the syntax for other characters.
           (modify-syntax-entry ?  "    " emacs-lisp-mode-syntax-table)
           (modify-syntax-entry ?\t "    " emacs-lisp-mode-syntax-table)
           ...
           (modify-syntax-entry ?\( "()  " emacs-lisp-mode-syntax-table)
           (modify-syntax-entry ?\) ")(  " emacs-lisp-mode-syntax-table)
           ...
           ))
     ;; Create an abbrev table for lisp-mode.
     (define-abbrev-table 'lisp-mode-abbrev-table ())

  Much code is shared among the three Lisp modes; the code is all in
one library.  Here is one function that sets various variables.  This
function is called by each of the major Lisp mode functions.

     (defun lisp-mode-variables (lisp-syntax)
       ;; The `lisp-syntax' argument is `nil' in Emacs Lisp mode,
       ;; and `t' in the other two Lisp modes.
       (cond (lisp-syntax
              (if (not lisp-mode-syntax-table)
     	     ;; The Emacs Lisp mode syntax table always exists, but
     	     ;; the Lisp Mode syntax table is created the first time a
     	     ;; mode that needs it is called.  This is to save space.
                   (progn (setq lisp-mode-syntax-table
                             (copy-syntax-table emacs-lisp-mode-syntax-table))
                          ;; Change some entries for Lisp mode.
                          (modify-syntax-entry ?\| "\"   "
                                               lisp-mode-syntax-table)
                          (modify-syntax-entry ?\[ "_   "
                                               lisp-mode-syntax-table)
                          (modify-syntax-entry ?\] "_   "
                                               lisp-mode-syntax-table)))
               (set-syntax-table lisp-mode-syntax-table)))
       (setq local-abbrev-table lisp-mode-abbrev-table)
       ...
       ...

   Functions such as `forward-word' use the value of the
`paragraph-start' variable.  Since Lisp code is different from
ordinary text, the `paragraph-start' variable needs to be set
specially to handle Lisp.  Also, comments are indented in a special
fashion in Lisp and the Lisp modes need their own mode-specific
`comment-indent-hook'.  The code to set these variables is the rest
of `lisp-mode-variables'.

       (make-local-variable 'paragraph-start)
       (setq paragraph-start (concat "^$\\|" page-delimiter))
       ...
       (make-local-variable 'comment-indent-hook)
       (setq comment-indent-hook 'lisp-comment-indent))

  Each of the different Lisp modes has a slightly different keymap. 
For example, Lisp mode binds `C-c C-l' to `run-lisp', but the other
Lisp modes do not.  However, all Lisp modes have some commands in
common.  The following function adds these common commands to a given
keymap.

     (defun lisp-mode-commands (map)
       (define-key map "\e\C-q" 'indent-sexp)
       (define-key map "\177" 'backward-delete-char-untabify)
       (define-key map "\t" 'lisp-indent-line))

  Here is an example of using `lisp-mode-commands' to initialize a
keymap, as part of the code for Emacs Lisp mode.

  First, `defvar' is used to create a mode-specific keymap variable if
one does not exist.  Then an `if' expression tests whether the
`emacs-lisp-mode-map' variable has a value.  If the variable does
have a value, the expression does not change it.  This protects the
else part of the `if' expression against duplicate evaluation; and it
lets the user customize the keymap if he or she so wishes.  But if
the `emacs-lisp-mode-map' variable lacks a value, the expression
creates a sparse keymap and defines some keys.

     (defvar emacs-lisp-mode-map () "") 
     
     (if emacs-lisp-mode-map
         ()
       (setq emacs-lisp-mode-map (make-sparse-keymap))
       (define-key emacs-lisp-mode-map "\e\C-x" 'eval-defun)
       (lisp-mode-commands emacs-lisp-mode-map))

  Finally, here is the complete major mode function definition for
Emacs Lisp mode.

     (defun emacs-lisp-mode ()
       "Major mode for editing Lisp code to run in Emacs.
     Commands:
     Delete converts tabs to spaces as it moves back.
     Blank lines separate paragraphs.  Semicolons start comments.
     \\{emacs-lisp-mode-map}
     Entry to this mode calls the value of emacs-lisp-mode-hook
     if that value is non-nil."
       (interactive)
       (kill-all-local-variables)
       (use-local-map emacs-lisp-mode-map)    ; This provides the local keymap.
       (set-syntax-table emacs-lisp-mode-syntax-table)
       (setq major-mode 'emacs-lisp-mode)     ; This is how `describe-mode'
                                              ;   finds out what to describe.
       (setq mode-name "Emacs-Lisp")          ; This goes into the mode line.
       (lisp-mode-variables nil)              ; This define various variables.
       (run-hooks 'emacs-lisp-mode-hook))     ; This permits the user to use a
                                              ;   hook to customize the mode.

 

File: lispref,  Node: Auto Major Mode,  Next: Mode Help,  Prev: Example Major Modes,  Up: Major Modes

How Emacs Chooses a Major Mode Automatically
--------------------------------------------

  Based on information in the file name or in the file itself, Emacs
automatically selects a major mode for the new buffer when a file is
visited.

 * Command: fundamental-mode

       Fundamental mode is a major mode that not specialized for
     anything in particular.  Other major modes are defined by
     comparison with this one.  The `fundamental-mode' function does
     *not* run any hooks, so it is not readily customizable.

 * Function: set-auto-mode

       This function selects the major mode that is appropriate for the
     current buffer.  It may base its decision on the value of the
     `-*-' line, on the visited file name (using `auto-mode-alist'),
     or on the value of a local variable).  *Note : (emacs)Choosing
     Modes.

       However, this function does not look for the `mode:' local
     variable near the end of a file.  The `hack-local-variables'
     function does that.

 * Command: normal-mode &optional FIND-FILE

       This function automatically chooses the major mode for the
     current buffer.  The mode is determined by first calling
     `set-auto-mode'.  After calling the major mode function selected
     by `set-auto-mode', the `normal-mode' function then runs
     `hack-local-variables' to parse, and bind or evaluate as
     appropriate, any local variables.

       If the FIND-FILE argument to `normal-mode' is non-`nil', Emacs
     assumes that the `find-file' function is calling `normal-mode'. 
     In this case, if `inhibit-local-variables' is non-`nil', Emacs
     requires confirmation before processing a local variables list. 
     If you run `normal-mode' yourself, the argument `find-file' is
     `nil', so confirmation is never requested.

       `normal-mode' uses `condition-case' around the call to the major
     mode function, so errors are caught and reported as a `File mode
     specification error',  followed by the original error message.

 * Option: default-major-mode

       This variable holds the default major mode for new buffers.  The
     standard value is `fundamental-mode'.  If the value of
     `default-major-mode' is `nil', Emacs uses the (previously)
     current buffer's major mode for major mode of a new buffer.

 * Variable: auto-mode-alist

       This variable contains an association list of filename patterns
     (regular expressions) and corresponding major mode functions. 
     Usually, the filename patterns are suffixes, such as `.el' and
     `.c', but this need not be the case.  Each element of the alist
     looks like `(REGEXP . MODE-FUNCTION)'.

     For example,

          ("^/tmp/fol/" . text-mode)
          ("\\.texinfo$" . texinfo-mode)
          ("\\.el$" . emacs-lisp-mode)
          ("\\.c$" . c-mode) 
          ("\\.h$" . c-mode)

       When you visit a file whose *full* path name matches REGEXP,
     Emacs calls MODE-FUNCTION.  This feature is used to cause Emacs
     to select the major mode appropriate to the file.

       Here is an example of how to prepend several pattern pairs to an
     existing `auto-mode-alist'.  (You might use this sort of
     expression in your `.emacs' file to customize your
     `auto-mode-alist'.)

          (setq auto-mode-alist
            (append 
             '(("/\\.[^/]*$" . fundamental-mode)  ; Filename starts with a dot.
               ("[^\\./]*$" . fundamental-mode)   ; Filename has no dot.
               ("\\.C$" . c++-mode))
             auto-mode-alist))

 * Function: hack-local-variables &optional FORCE

       This function parses, and binds or evaluates as appropriate, any
     local variables for the current buffer.  If non-`nil', the
     optional argument FORCE overides the effect of a non-`nil' value
     for `inhibit-local-variables'.  *Note : (emacs)File variables,
     for the syntax of the `hack-local-variables' section of a file.

 * Option: inhibit-local-variables

       When this variable is non-`nil', Emacs will query the user
     before obeying a file's local-variables list.  Emacs checks this
     variable when the local-variables list is scanned automatically
     after you find a file.  However, if you yourself call
     `normal-mode', there is no query, regardless of the value of
     this variable.

 * Variable: initial-major-mode

       The value of this variable determines the major mode of the
     initial `*scratch*' buffer.  The value of the variable is a
     symbol, the name of the mode.  The default value is
     `lisp-interaction-mode'.



File: lispref,  Node: Mode Help,  Prev: Auto Major Mode,  Up: Major Modes

Getting Help about a Major Mode
-------------------------------

  The `describe-mode' function is used to provide information about
major modes.  It is normally called with `C-h m'.  The
`describe-mode' function uses the value of `major-mode', which is why
every major mode function needs to set the `major-mode' variable.

 * Command: describe-mode

       This function displays the documentation of current major mode.

       The `describe-mode' function calls the `documentation' function
     using the value of `major-mode' as an argument.  Thus, it
     displays the documentation string of the major mode function. 
     (*Note Accessing Documentation::.)

 * Variable: major-mode

       This variable holds the symbol for the current buffer's major
     mode.  This symbol should be the name of the function which is
     called to initialize the mode.  The `describe-mode' function
     uses the documentation string of this symbol as the
     documentation of the major mode.



File: lispref,  Node: Minor Modes,  Next: Mode Line Format,  Prev: Major Modes,  Up: Modes

Minor Modes
===========

  A "minor mode" provides features that users may enable or disable
independently of the choice of major mode.  Minor modes can be
enabled individually or in combination.

  A minor mode is not merely a modification of single major mode.  For
example, you may use `auto-fill-mode' and `auto-justify-mode' in any
major mode that permits text insertion.

  Minor modes would be better named `Generally available, optional
feature modes' except that such a name is unwieldy.

  A minor mode is often much more difficult to implement than a major
mode.  There are several reasons for this.  One is that you should be
able to deactivate a minor mode and restore the environment of the
major mode to the state it was in before the minor mode was activated.

  Often, in implementing a minor mode, the biggest problem is finding a
way to insert the necessary hook into the running system.  For
example, some minor modes, such as Auto Fill mode, change how text is
inserted into a buffer.  Without `auto-fill-hook', Auto Fill mode
would be implemented only at great pain and great cost in editing
efficiency.

* Menu:

* Minor Mode Conventions::	Tips for writing a minor mode.
* Limits of Minor Modes::	Minor modes are of limited generality.

 

File: lispref,  Node: Minor Mode Conventions,  Next: Limits of Minor Modes,  Prev: Minor Modes,  Up: Minor Modes

Conventions for Writing Minor Modes
-----------------------------------

  There are conventions for writing minor modes just as there are for
major modes.  Several of the major mode conventions apply to minor
modes as well: those regarding the name of the mode initialization
function, the names of global symbols, and the use of keymaps and
other tables.

  In addition, there are several conventions that are specific to minor
modes.

   * A minor mode initialization function should toggle the mode on
     and off with each call, or turn the mode on if given a positive
     integer.

   * The minor mode function should set a variable with the same name
     as the minor mode to a non-`nil' value.  This variable is used
     in conjunction with the `minor-mode-alist' to display the minor
     mode name in the mode line.

     If you want the minor mode to be enabled separately in each
     buffer, make the variable buffer-local.

   * Add an element to `minor-mode-alist' for each minor mode (*note
     Mode Line Variables::.).  This element should be a list of the
     following form:

          (MODE-VARIABLE STRING)

     Here MODE-VARIABLE is the variable that indicates the enablement
     of the minor mode, and STRING is a *short* string, starting with
     a space, to represent the mode in the mode line.

     When you add the element to `minor-mode-alist', use `assq' to
     check for an existing element, so you can avoid duplication. 
     For example:

          (or (assq 'leif-mode minor-mode-alist)
              (setq minor-mode-alist
                    (cons '(leif-mode " Leif") minor-mode-alist)))

   * If the minor mode adds new keybindings to the local keymap, you
     should be able to restore the keymap to its original value when
     you deactivate the minor mode.



File: lispref,  Node: Limits of Minor Modes,  Prev: Minor Mode Conventions,  Up: Minor Modes

Limitations of Minor Modes
--------------------------

  It is very difficult to write a minor mode that responds to arbitrary
self-inserting characters.  The principal problem is that
`self-insert-command', the command to insert the last key typed, is a
primitive function written in C.  It does not call any hooks, except
in special cases.

  Unfortunately, you cannot simply substitute your own definition of
`self-insert-command' for the existing one, as you can with most
functions.  This is a consequence of the way Emacs's command loop
works: in the command loop, Emacs checks whether a key is bound to
`self-insert-command' and, if it is, Emacs calls the primitive
`self-insert-command' function directly.  Emacs does not check to see
whether you have written another version of the function to
substitute for it.  This is done for speed.

  (Indeed, in general, if you substitute a Lisp function for a
primitive, the C code within Emacs will continue to call the original
primitive, but Lisp code will call your substitute Lisp function.)

  Instead of attempting to replace the function definition for
`self-insert-command', you could rebind all keys that call
`self-insert-command' using `substitute-key-definition'.  This
solution works fine if you are using only one minor mode.  But if you
are using several minor modes at the same time, and you want to
deactivate them, you must deactivate them in the reverse order that
they were activated to ensure that keymaps are properly restored.



File: lispref,  Node: Mode Line Format,  Next: Hooks,  Prev: Minor Modes,  Up: Modes

Mode Line Format
================

  The `mode-line-format' is a buffer-local variable that holds a
template used to display the mode line of the current buffer.  All
windows for the same buffer use the same `mode-line-format' and the
mode lines will appear the same (except, possibly, for the percentage
of the file scrolled off the top).  The mode-line contains
information about the buffer such as its name, associated file, depth
of recursive editing, and, of course, the major and minor modes of
the buffer.

  The mode line of a window is normally updated whenever a different
buffer is shown in the window, or when the buffer's modified-status
changes from `nil' to `t' or vice-versa.  If you modify any of the
variables referenced by `mode-line-format', you may want to force an
update of the mode line so as to display the new information.  You
can do this with the following expression:

     (set-buffer-modified-p (buffer-modified-p))

* Menu:

* Mode Line Data::        The data structure that controls the mode line.
* Mode Line Variables::   Variables used in that data structure.
* %-constructs::          Putting information into a mode line.

 

File: lispref,  Node: Mode Line Data,  Next: Mode Line Variables,  Prev: Mode Line Format,  Up: Mode Line Format

The Data Structure of the Mode Line
-----------------------------------

  The mode line contents are controlled by a data structure of lists,
strings, symbols and numbers kept in the buffer-local variable
`mode-line-format'.  The data structure is called a "mode line
construct", and it is built in recursive fashion out of simpler mode
line constructs.

 * Variable: mode-line-format

     The value of this variable is a mode line construct with overall
     responsibility for the mode line format.  The value of this
     variable controls which other variables are used to form the
     mode line text, and where they go.

  A mode line construct may be as simple as a fixed string of text, but
usually it specifies how to use other variables to construct the text.
Many of these variables are themselves defined to have mode line
constructs as their values--for example, `minor-mode-alist'.

  The default value of `mode-line-format' incorporates the values of
variables such as `mode-name' and `minor-mode-alist'.  Because of
this, very few modes will need to alter `mode-line-format' or
`default-mode-line-format'.  For most tasks, it is sufficient to
alter the variables referenced by `mode-line-format'.  In fact,
`mode-line-format' is very rarely changed.

  A mode line construct may be a list, cons cell, symbol, or string. 
If the value is a list, each element may be a list, a cons cell, a
symbol, or a string.

`STRING'
     A string as a mode line construct is displayed verbatim in the
     mode line except for "`%'-constructs".  Decimal digits after the
     `%' specify the field width for space filling on the right
     (i.e., the data is left justified).  *Note %-constructs::.

`SYMBOL'
     A symbol as a mode line construct stands for its value.  The
     value of SYMBOL is used in place of SYMBOL unless SYMBOL is `t',
     `nil', or void, in which case SYMBOL is ignored.

     There is one exception: if the value of SYMBOL is a string, it
     is processed verbatim in that the "%-constructs" described below
     are not recognized.

`(STRING REST) or (LIST REST)'
     A list whose first element is a string or list, means to
     concatenate all the elements.  This is the most common form of
     mode line construct.

`(SYMBOL THEN ELSE)'
     A list as a mode line construct whose first element is a symbol
     is a sort of conditional.  Its meaning depends on the value of
     SYMBOL.  If the value is non-`nil', the second element of the
     list (THEN) is processed recursively as a mode line element. 
     But if the value of SYMBOL is `nil', the third element of the
     list (if there is one) is processed recursively.

`(WIDTH REST)'
     A list as a mode line construct whose first element is an
     integer specifies truncation or padding.  The remaining elements
     are processed recursively as mode line constructs and
     concatenated together.  Then they are and space filled (if WIDTH
     is positive) or truncated (to width -WIDTH, if WIDTH is
     negative) on the right.

     For example, the usual way to show what percentage of a buffer
     is above the top of the window is to use a list that looks like
     this: `(-3 .  "%p")'.

  If you do alter `mode-line-format' itself, the new value should use
all the same variables that are used by the default value, rather
than duplicating their contents or displaying the information in
another fashion.  This permits customizations made by the user, by
libraries (such as `display-time') or by major modes via changes to
those variables remain effective.

  Here is an example of a `mode-line-format' that might be useful for
`shell-mode' since it contains the hostname and default directory.

     (setq mode-line-format
       (list ""
        'mode-line-modified
        "%b--" 
        (getenv "HOST") 
        ":" 
        'default-directory
        "   "
        'global-mode-string
        "   %[(" 'mode-name 
        'minor-mode-alist 
        "%n" 
        'mode-line-process  
        ")%]---"
        '(-3 . "%p")
        "-%-"))



File: lispref,  Node: Mode Line Variables,  Next: %-constructs,  Prev: Mode Line Data,  Up: Mode Line Format

Variables Used in the Mode Line
===============================

  This section describes variables which are incorporated by the
standard value of `mode-line-format' into the text of the mode line. 
There is nothing inherently special about these variables; any other
variables could have the same effects on the mode line, if
`mode-line-format' is changed appropriately.

 * Variable: mode-line-modified

       This variable holds the mode-line control for displaying whether
     the current buffer is modified.

       The default value `mode-line-modified' is `("--%1*%1*-")'.  This
     means that the mode line displays `--**-' if the buffer is
     modified, `----' if the buffer is not modified, and `--%%-' if
     the buffer is read only.

     Changing this variable does not force an update of the mode line.

 * Variable: mode-line-buffer-identification

       This variable's job is to identify the buffer being displayed in
     the window.  Its default value is `Emacs: %17b', which means
     that it displays `Emacs:' before the buffer name.  You may want
     to change this, when you write modes that do not behave like a
     ``normal'' Emacs.

 * Variable: global-mode-string

       This variable holds a string that is displayed in the mode line
     if the variable is included in `mode-line-format' (the default)
     or if a `%M' specification is included.  Currently, only
     `display-time' modifies `global-mode-string'.

 * Variable: mode-name

       This buffer-local variable holds the ``pretty'' name of the
     current buffer's major mode.  Every major mode sets this
     variable so that the mode name will appear in the mode line.

 * Variable: minor-mode-alist

       This variable holds an association list the elements of which
     specify how Emacs should indicate in the mode line that a minor
     mode is active.  The usual procedure is to print a short name
     for the mode when it is active.

     Each element of the `minor-mode-alist' looks consists of the two
     element list:

          (MINOR-MODE-VARIABLE MODE-LINE-STRING)

       MODE-LINE-STRING is included in the mode line when the value of
     MINOR-MODE-VARIABLE is non-`nil' and not otherwise. 
     Conventionally, the MINOR-MODE-VARIABLE for a specific mode is
     set to a non-`nil' value when that minor mode is activated.

     The default value of `minor-mode-alist' looks like this:

          minor-mode-alist
          => ((abbrev-mode " Abbrev") 
               (overwrite-mode " Ovwrt") 
               (auto-fill-hook " Fill")         
               (defining-kbd-macro " Def"))

     (Note that in version 19, `auto-fill-hook' will be renamed to
     `auto-fill-function'.  Also, note the space at the beginning of
     each MODE-LINE-STRING.)

       `minor-mode-alist' is not buffer-local.  The variables in the
     alist should be buffer-local if the minor mode can be enabled
     separately in each buffer.

  There are several other mode-line related variables in addition to
those listed here.  For `mode-line-process', see *Note Process
Information::; for `mode-line-inverse-video', see *Note Screen
Attributes::.



File: lispref,  Node: %-constructs,  Prev: Mode Line Variables,  Up: Mode Line Format

`%'-constructs in the Mode Line
===============================

  The following table lists the recognized `%'-constructs and what they
mean.

`%b'
     prints the buffer name; uses the `buffer-name' function.

`%f'
     prints the visited file name; uses the `buffer-file-name'
     function.

`%*'
     prints `*' if the buffer is modified (see `buffer-modified-p'); 
      prints `-' if the buffer is not modified; 
      prints `%' if the buffer is read only (see `buffer-read-only').

`%s'
     prints the process status (see `process-status').

`%p'
     prints the percent of the buffer above the top of window, or
     Top, Bottom or All.

`%n'
     prints `Narrow' when a narrowing restriction is in effect (see
     `narrow-to-region').

`%['
     print one `[' for each recursive editing level.  `%]' is similar.

`%%'
     prints `%'

`%-'
     prints dashes that fill the remainder of line, ignoring the
     remainder of the template.

The following two `%'-constructs are still supported but are obsolete
since use of the `mode-name' and `global-mode-string' variables will
produce the same results.

`%m'
     the value of `mode-name'.

`%M'
     the value of `global-mode-string'.  Currently, only
     `display-time' modifies `global-mode-string'.

 * Variable: default-mode-line-format

       This variable holds the default `mode-line-format' for buffers
     that do not override it.  This is the same as `(default-value
     'mode-line-format)'.

       The default value of `default-mode-line-format' is:

            (list ""
             'mode-line-modified
             'mode-line-buffer-identification
             "   "
             'global-mode-string
             "   %[("
             'mode-name 
             'minor-mode-alist 
             "%n" 
             'mode-line-process
             ")%]---"
             '(-3 . "%p")
             "-%-"))



File: lispref,  Node: Hooks,  Prev: Mode Line Format,  Up: Modes

Hooks
=====

  A "hook" is a variable whose value is a "hook function" or a list of
hook functions.  These functions are called by parts of Emacs on
well-defined occasions.  The function or functions used in a hook may
be any valid functions; anything that `funcall' accepts.  *Note What
Is a Function::.

  Hooks are used for customization.  The functions referenced by a hook
may be changed by the user or by other functions.

  Most modes run hooks as the last step in the modes' initialization. 
This makes its easy for a user to customize the behavior of a mode. 
But hooks may also be used in other contexts.  For example, the
functions named by `find-file-not-found-hooks' are called whenever a
file is not found by `find-file'.

  *Note Standard Hooks::, for a list of hooks.

  Typically, the hooks for a mode are run after the mode has completed
all its other initialization.  You may, for example, use a hook to
change the initial values of buffer-local variables.

  For example, you can put the following expression in your `.emacs'
file if you want to turn on Auto Fill mode in Lisp Interaction mode:

     (setq lisp-interaction-mode-hook 'turn-on-auto-fill)

  If you want to permit use of several independent hooks in one hook
list, here is how you can add one, without removing any others and
without creating duplicates.

     (or (memq 'turn-on-auto-fill lisp-interaction-mode-hook)
         (setq lisp-interaction-mode-hook
               (cons 'turn-on-auto-fill lisp-interaction-mode-hook)))

  The following example shows how to use a hook to customize the way
Emacs formats C code.  (People often have strong personal preferences
for one format compared to another.)  Here the hook function is an
anonymous `lambda' expression.

     (setq c-mode-hook 
           (function (lambda ()
                       (setq c-indent-level 4
                             c-argdecl-indent 0
                             c-label-offset -4
                             c-continued-statement-indent 0
                             c-brace-offset 0
                             comment-column 40
                             ))))
     
     (setq c++-mode-hook c-mode-hook)

  Finally, here is an example of how to use the Text mode hook to
provide a customized mode line for buffers in Text mode.  This hook
displays the directory in addition to the standard components of the
mode line.  (If you have very long path names or display the time and
load, you may run out of space on the mode line.)

     (setq text-mode-hook
           (function (lambda ()
                       (setq mode-line-format
                             (list ""
                                   'mode-line-modified
                                   "Emacs: %14b"
                                   "  "  
                                   'default-directory
                                   " "
                                   'global-mode-string
                                   "%[(" 
                                   'mode-name 
                                   'minor-mode-alist 
                                   "%n" 
                                   'mode-line-process  
                                   ") %]--"
                                   '(-3 . "%p")
                                   "-%-")))))

  At the apprpriate time, Emacs uses the `run-hooks' function to run
the hooks you have specified.  Most major modes have lines in their
functions defintions that look like these, from Text mode, C mode and
Mail mode respectively.  Note that Mail mode runs two hooks in
succession.

     (run-hooks 'text-mode-hook)
     
     (run-hooks 'c-mode-hook)
     
     (run-hooks 'text-mode-hook 'mail-mode-hook)

 * Function: run-hooks &rest HOOKVAR

       This function takes one or more hook names as arguments and runs
     each one in turn.  Each HOOKVAR argument should be a symbol
     which is a hook variable.  These arguments are processed in the
     order specified.

       If a hook variable has a non-`nil' value, that value may be a
     function or a list of functions.  If the value is a function
     (either a lambda expression or a symbol with a function
     definition), it is called.  If it is a list, the elements are
     called, in order.

     The hook functions are all called with no arguments.

          (run-hooks 'emacs-lisp-mode-hook)

     Major mode functions may use this function to call any hooks
     defined by the user.



File: lispref,  Node: Documentation,  Next: Files,  Prev: Modes,  Up: Top

Documentation
*************

  GNU Emacs Lisp has a simple-to-use facility for displaying the
documentation strings associated with functions and variables.  In
addition, Emacs has powerful on-line help facilities.

  Documentation strings are not the same thing as a manual, even though
both can be examined inside Emacs (using Info, for the manual).  A
manual is defined by its own source file; documentation strings are
specified in the source of the functions and variables they apply to.

* Menu:

* Documentation Basics::      Good style for doc strings.
                                Where to put them.  How Emacs stores them.
* Accessing Documentation::   How Lisp programs can access doc strings.
* Help Functions::            Subroutines used by Emacs help facilities.

 

File: lispref,  Node: Documentation Basics,  Next: Accessing Documentation,  Prev: Documentation,  Up: Documentation

Documentation Basics
====================

  A documentation string is written between double quotes, `"like this"'.

  In a function definition, the documentation string follows the
argument list in a variable definition, the documentation string
follows the initial value of the variable.

  When you write a documentation string, you should make the first line
a complete sentence (or two complete sentences) since some commands,
such as `apropos', print only the first line of a multi-line
documentation string.  Also, you should not indent the second line of
a documentation string, if you have one, because that looks odd when
you use `C-h f' (`describe-function') or `C-h v' (`describe-variable').

  In Emacs Lisp, the underlying principle is that a documentation
string is kept with the function or variable which it describes:

   * The documentation for a function is stored in the function
     definition itself (*note Lambda Expressions::.).  The function
     `documentation' knows how to extract it.

   * The documentation for a variable is stored on the variable's
     property list under the property name `variable-documentation'. 
     The function `documentation-property' knows how to extract it.

  However, to save space, the documentation for preloaded functions and
variables (including primitive functions and autoloaded functions)
are stored in the `emacs/etc/DOC-VERSION' file.  Both the
`documentation' and the `documentation-property' functions know how
to access `emacs/etc/DOC-VERSION', and the process is transparent to
the user.  In this case, the `variable-documentation' property of the
symbol is an integer offset into the `emacs/etc/DOC-VERSION' file. 
Keeping the documentation strings out of the Emacs core image saves a
significant amount of space.

  See `where-is-internal' and `describe-bindings' in *Note Global and
Local Keymaps::.  Also, see *Note : (emacs)Help.

  The `emacs/etc' directory contains two utilities for printing the
`emacs/etc/DOC-VERSION' file in hardcopy.  These are `sorted-doc.c'
and `digest-doc.c'.

  In addition, documentation strings may contain several special
substrings.  These substrings allow the functions which retrieve them
to substitute the actual (current) key bindings into the strings,
using the `substitute-command-keys' function.  (*Note Accessing
Documentation::.)



File: lispref,  Node: Accessing Documentation,  Next: Help Functions,  Prev: Documentation Basics,  Up: Documentation

Access to Documentation Strings
===============================

 * Function: documentation-property SYMBOL PROPERTY

       This function returns the documentation string that is SYMBOL's
     PROPERTY.  Use of this function differs from using `get', since
     `documentation-property' is also able to access documentation
     strings that are stored in the `emacs/etc/DOC-VERSION' file.  In
     addition, `documentation-property' runs
     `substitute-command-keys' on the resulting string, so Emacs will
     display the actual (current) keybindings.

          (documentation-property 'command-line-processed
             'variable-documentation)
               => "t once command line has been processed"
          (symbol-plist 'command-line-processed)
               => (variable-documentation 188902)

 * Function: documentation FUNCTION

       This function returns the documentation string of FUNCTION.  If
     the documentation string is stored in the
     `emacs/etc/DOC-VERSION' file, this function will access it there.

       In addition, `documentation' runs `substitute-command-keys' on
     the resulting string, so the value contains the actual (current)
     keybindings.

       Emacs signals a `void-function' error unless FUNCTION has a
     function definition.  However, FUNCTION does not need to have a
     documentation string.  If there is no documentation string, the
     function returns `nil'.

       Here is a function which uses `documentation' and
     `documentation-property' to display the documentation strings
     for several symbols in a `*Help*' buffer.

          (defun describe-symbols (pattern)
            "Describe the Emacs Lisp symbols matching PATTERN.
          All symbols that have PATTERN in their name are described
          in the *Help* buffer."
            (interactive "sDescribe symbols matching: ")
            (let ((describe-func
                   (function 
                    (lambda (s)
                      ;; Print description of symbol.
                      (if (fboundp s)             ; It is a function.
                          (princ
                           (format "%s\t%s\n%s\n\n" s
                                   (if (commandp s) 
                                       (concat "Command: "
                                               (or (mapconcat 
                                                    'key-description 
                                                    (where-is-internal s) 
                                                    " ")))
                                     "Function")
                                   (or (documentation s) 
                                       "not documented"))))
                      
                      (if (boundp s)              ; It is a variable.
                          (princ
                           (format "%s\t%s\n%s\n\n" s
                                   (if (user-variable-p s) 
                                       "Option "
                                     "Variable")
                                   (or 
                                    (documentation-property 
                                     s 
                                     'variable-documentation)
                                    "not documented"))))))
                   sym-list)
                  
                  ;; Build a list of symbols that match pattern.
                  (mapatoms (function 
                             (lambda (sym)
                               (if (string-match pattern
                                                 (symbol-name sym))
                                   (setq sym-list (cons sym sym-list))
                                 ))))      
                  
                  ;; Display the data.
                  (with-output-to-temp-buffer "*Help*"
                    (mapcar describe-func (sort sym-list 'string<))
                    (print-help-return-message))))

       The `describe-symbols' function works like `apropos', but
     provides more information.

          (describe-symbols "goal")
          
          --------- Buffer: *Help* ---------
          goal-column     Option 
          *Semipermanent goal column for vertical motion, 
          as set by C-x C-n, or nil.
          
          set-goal-column Command: C-x C-n
          Set the current horizontal position as a goal for C-n and C-p.
          Those commands will move to this position in the line moved to
          rather than trying to keep the same horizontal position.
          With a non-nil argument, clears out the goal column
          so that C-n and C-p resume vertical motion.
          
          temporary-goal-column   Variable
          Current goal column for vertical motion.
          It is the column where point was at the start of current run 
          of vertical motion commands.
          --------- Buffer: *Help* ---------

 * Function: Snarf-documentation FILENAME

       This function is used only during Emacs initialization.  It is
     executed before the system dumps a runnable Emacs. 
     `Snarf-documentation' finds the file-offsets of the
     documentation strings stored in the file FILENAME, and records
     them in the in-core function definitions in place of the
     documentation strings.

       FILENAME is found in the `emacs/etc' directory (usually FILENAME
     is `"DOC-VERSION"').  When the dumped Emacs is later executed,
     the file is found in the `exec-directory'.

 * Function: substitute-command-keys STRING

       This function returns STRING with modifications made to
     specially formatted substrings such that the actual (current)
     keybindings are listed.  This permits the documentation to
     provide information that is updated to contain information about
     the current key bindings.  (The key bindings may change between
     the time Emacs is built and the time that the documentation is
     asked for.)

       The following table lists the forms of the special substrings
     that are recognized by `substitute-command-keys' and the forms
     with which the special substrings are replaced.

    `\[COMMAND]'
          replaced by either a keystroke sequence that will invoke
          COMMAND or `M-x COMMAND' if COMMAND is not bound to a key
          sequence.

    `\{MAPVAR}'
          replaced by a summary (made by `describe-bindings') of the
          value of MAPVAR, taken as a keymap.

    `\<MAPVAR>'
          make `substitute-command-keys' use the value of MAPVAR as
          the keymap for future `\[COMMAND]' substrings.  This
          special string does not produce any replacement text
          itself; it only affects the replacements done later.

          Note:  Each `\' must be doubled when written in a string in
          Emacs Lisp.

       Here are examples of each special substring:

          (substitute-command-keys 
             "To abort recursive edit, type: \\[abort-recursive-edit]")
          
          => "To abort recursive edit, type:  C-]"
          
          (substitute-command-keys 
             "The keys which are defined for the minibuffer here are:
            \\{minibuffer-local-must-match-map}")
          
          => "The keys which are defined for the minibuffer here are:
          
          ?               minibuffer-completion-help
          SPC             minibuffer-complete-word
          TAB             minibuffer-complete
          LFD             minibuffer-complete-and-exit
          RET             minibuffer-complete-and-exit
          C-g             abort-recursive-edit
          "
          
          (substitute-command-keys
             "To abort a recursive edit from the minibuffer, type
              \\<minibuffer-local-must-match-map>\\[abort-recursive-edit]")
          => "To abort a recursive edit from the minibuffer, type C-g"

 * Function: key-description STRING

       This function returns a string for printing the Emacs standard
     notation of the characters in STRING.  See the examples for
     `single-key-description'.

 * Function: single-key-description CHARACTER

       This function returns a string for printing CHARACTER in the
     standard Emacs notation.  Normal printing characters don't
     change, control characters turn into a string starting with
     `C-', meta characters turn into a string starting with `M-', and
     space, linefeed, etc. are transformed to SPC, LFD, etc.

          (single-key-description ?\C-x)
          => "C-x"
          (key-description "\C-x \M-y \n \t \r \f123")
          => "C-x SPC M-y SPC LFD SPC TAB SPC RET SPC C-l 1 2 3"

 * Function: text-char-description CHARACTER

       This function returns a string for printing CHARACTER--like
     `single-key-description', except that that control characters
     are represented with a leading caret (which is how control
     characters in Emacs buffers are usually displayed).

          (text-char-description ?\C-c)
               => "^C"
          (text-char-description ?\M-m)
               => "M-m"
          (text-char-description ?\C-\M-m)
               => "M-^M"



File: lispref,  Node: Help Functions,  Prev: Accessing Documentation,  Up: Documentation

Help Functions
==============

  Emacs provides a variety of on-line help functions.  You can get to
all of them by typing `C-h' and then a key.  Here we describe some
program-level interfaces.  For more information about the interactive
help commands, see *Note : (emacs)Help.

  In addition, `M-.' (`find-tag') is useful for finding the source code
for a function or variable in Emacs.  However, to use it for this
purpose, you must first visit the tag table for Emacs itself.  *Note
: (emacs)Tags.

  Emacs loads the default help commands from the `emacs/lisp/help.el'
library.  In addition, Emacs has a `emacs/lisp/helper.el' library of
utilities.  This latter library is for modes that want to provide
help without relinquishing control, such as the `electric' modes. 
(To distinguish them from the regular help functions, all the
functions in the `emacs/lisp/helper.el' library have names beginning
with `Helper'.)

 * Command: apropos REGEXP &optional PREDICATE NOPRINT

       This function finds all symbols whose names contain a match for
     the regular expression REGEXP, and returns a list of them. 
     Normally it will also pop up a window with the `*Help*' buffer
     in it, displaying the symbols and a one line description. 
     (Since only the first lines of documentation strings are
     displayed, try to make the first lines of your documentation
     strings whole sentences.)  If NOPRINT is non-`nil', it does not
     display them, but just returns the list.

       If PREDICATE is non-`nil', then that predicate is called on each
     symbol that has matched REGEXP and only symbols for which that
     predicate returns a non-`nil' value are listed (and displayed).

       When you call `apropos' interactively, Emacs prompts for REGEXP
     in the minibuffer.

       In the first of the following examples, Emacs finds all the
     matches to `exec'.  They are returned but not displayed.  In the
     second example, Emacs finds and returns only those symbols that
     are also commands; in addition, they are then displayed in the
     `*Help*' buffer.

          (apropos "exec" nil t)
               => (Buffer-menu-execute command-execute exec-directory
              exec-path execute-extended-command execute-kbd-macro
              executing-kbd-macro executing-macro)
          
          (apropos "exec" 'commandp)
               => (Buffer-menu-execute execute-extended-command)
          
          --------- Buffer: *Help* ---------
          Buffer-menu-execute
            Function: Save and/or delete buffers marked with
            M-x Buffer-menu-save or M-x Buffer-menu-delete commands.
          execute-extended-command      ESC x
            Function: Read function name, then read its arguments and call it.
          --------- Buffer: *Help* ---------

       Typing `C-h a' (`command-apropos') calls `apropos', but the
     command only displays information about symbols that are
     commands.  In the body of the `command-apropos' function, the
     call to `apropos' looks like this:

          (apropos string 'commandp)

 * Option: completion-auto-help

       If this variable is non-`nil', Emacs automatically displays a
     list of possible completions, whenever the user asks for
     completion but nothing can be completed because the next
     character is not unique.

 * Function: help-command

       This function is a keymap equivalent to `help-map'.  It is
     defined in `help.el' as follows:

          (define-key global-map "\C-h" 'help-command)
          (fset 'help-command help-map)

 * Variable: help-map

       The value of this variable is a local keymap for characters
     following the Help key.

 * Function: print-help-return-message &optional FUNCTION

       This function builds a message explaining how to restore the
     previous state of the windows after a help command.  After
     building the message, it applies FUNCTION to it if FUNCTION is
     non-`nil'.  Otherwise it applies `message' to it, thus printing
     it in the echo area.

     This function expects to be called inside of a
     `with-output-to-temp-buffer' special form, and expects the value
     of `standard-output' to be the temporary buffer used by that
     special form, which is what it will be if you do not change it.

     See the example in the section describing the `documentation'
     function (*note Accessing Documentation::.).

       The constructed message will be one of the forms shown below.

          (print-help-return-message)
          
          --------- Echo Area ---------
          Type C-x 1 to remove help window.
          --------- Echo Area ---------
          
          --------- Echo Area ---------
          Type C-x 4 b RET to restore old contents of help window.
          --------- Echo Area ---------

       Also, see the description of `where-is-internal';  this function
     returns list of key sequences (of any length) that are bound to
     COMMAND in the local keymap and the global keymap.  *Note Global
     and Local Keymaps::.

  The following two functions are found in the library `helper'.  You
must load that library with `(require 'helper)' in order to use them.

 * Command: Helper-describe-bindings

       This command pops up a window displaying the help buffer
     containing a listing of all of the key bindings from both the
     local and global keymaps.  It works by calling
     `describe-bindings'.

 * Command: Helper-help

       This command provides help for the current mode.  It prompts the
     user in the minibuffer with a message: `Help (Type ? for further
     options)', and then provides assistance for finding out what the
     key bindings are, and what the mode is intended for.  It returns
     `nil'.

       This can be customized by changing the map `Helper-help-map'.

 * Variable: help-char

       The value of this variable is the character that Emacs
     recognizes as meaning Help.  When Emacs reads this character
     (which is usually 8, the value of `C-h'), Emacs evaluates `(eval
     help-form)', and displays the result if it is a string.  If
     `help-form''s value is `nil', this character is read normally.

 * Variable: help-form

       The value of this variable is a form to execute when the
     character `help-char' is read.  If the form returns a string,
     that string is displayed.  If `help-form' is `nil', then the
     help character is not recognized.



File: lispref,  Node: Files,  Next: Backups and Auto Saving,  Prev: Documentation,  Up: Top

Files
*****

  In Emacs, you can find, create, view, save, and otherwise work with
files and directories.  Not all of the file-related functions are
described in this chapter; some are described in *Note Buffers::;
and, functions related to backups and auto saving are described in
*Note Backups and Auto Saving::.

* Menu:

* Visiting Files::           Reading files into Emacs buffers for editing.
* Saving Buffers::           Writing changed buffers back into files.
* Reading from Files::       Reading files into other buffers.
* Writing to Files::         Writing new files from parts of buffers.
* File Locks::               Locking and unlocking files, to prevent
                               simultaneous editing by two people.
* Information about Files::  Testing existence, accessibility, size of files.
* Contents of Directories::  Getting a list of the files in a directory.
* Changing File Attributes:: Renaming files, changing protection, etc.
* File Names::               Decomposing and expanding file names.

 

File: lispref,  Node: Visiting Files,  Next: Saving Buffers,  Prev: Files,  Up: Files

Visiting Files
==============

  Visiting a file means reading a file into a buffer.  Once this is
done, we say that the buffer is "visiting" that file, and call the
file ``the visited file'' of the buffer.

  A file and a buffer are two different entities.  A file is
information recorded permanently in the computer (unless you delete
it).  A buffer, on the other hand, is information inside of Emacs
that will vanish at the end of the editing session (or when you kill
the buffer).  Usually, a buffer contains information that you have
copied from a file; thus, we say the buffer is visiting that file. 
This copy is what you work on and modify.  Changes to the buffer do
not change the file, until you save the file.  When you save the
file, the buffer is copied to the file and is thus saved permanently.

  In spite of the distinction between files and buffers, people often
refer to a file when they mean a buffer and vice-versa.  Indeed, most
people say, ``I am editing a file,'' rather than saying, ``I am
editing a buffer which I will soon save as a file of the same name.''
It is almost always clear from context what people mean.  When
dealing with a computer program, however, it is well to keep the
distinction in mind.

* Menu:

* Visiting Functions::         The usual interface functions for visiting.
* Subroutines of Visiting::    Lower-level subroutines that they use.

 

File: lispref,  Node: Visiting Functions,  Next: Subroutines of Visiting,  Prev: Visiting Files,  Up: Visiting Files

Functions for Visiting Files
----------------------------

  This section describes the functions normally used to visit files. 
For historical reasons, these functions are called `find-...', rather
than `visit-...'.  *Note Buffer File Name::, for functions and
variables that access the visited file name of a buffer or that find
an existing buffer by its visited file name.

 * Command: find-file FILENAME

       This function reads FILENAME into a buffer and displays that
     buffer in the selected window, in which the user may edit it.

     The body of the `find-file' function is very simple and looks
     like this:

          (switch-to-buffer (find-file-noselect filename))

     (See `switch-to-buffer' in *Note Changing Buffers::.)

       When `find-file' is called interactively, Emacs prompts for
     FILENAME in the minibuffer.

 * Function: find-file-noselect FILENAME

       This function is the guts of all the file-visting functions.  It
     reads a file into a buffer and returns the buffer.  You may then
     display the buffer in a window if you wish, but this function
     does not do so.  The buffer is not made the current buffer.  (If
     you wish to edit the file, you have to switch to it.)

       If no buffer is currently visiting FILENAME, then one is created
     and the file is visited.  If FILENAME does not exist, it is
     created as empty, and Emacs displays a message `New file' in the
     echo area.

       If a buffer is already visiting FILENAME, then
     `find-file-noselect' verifies that the file has not changed
     since it was last visited or saved, and returns that buffer.  If
     the file has changed, then this function offers to re-read the
     changed file.  If the user says `yes', any changes previously
     made in the buffer will be lost.

       The `find-file-noselect' function calls `after-find-file' after
     the file is found.  The `after-find-file' function sets the
     buffer major mode, parses local variables, warns the user if
     there exists an auto-save file more recent than the file just
     visited, and finishes by running the hooks in `find-file-hooks'.

       The `find-file-noselect' function returns the buffer visiting
     the file.

          (find-file-noselect "foo")
               => #<buffer foo>

       Note that the `find-file-noselect' function checks whether a
     buffer is already visiting FILENAME; if it is, the function
     verifies that the file has not changed since it was last visited
     or saved, and returns that buffer.  If the file has changed,
     Emacs offers to read in the changed file.  If the user says
     `yes', any changes made to the buffer will be lost.

 * Command: find-alternate-file FILENAME

       This function reads in the file FILENAME, and selects its
     buffer, killing the previous buffer.  If your current buffer
     contains an empty file that you just visited by mistake, use
     this command to visit the file you really want.

       When this function is called interactively, Emacs prompts you
     for FILENAME.

 * Command: find-file-other-window FILENAME

       This function visits the file FILENAME, and displays its buffer
     in a window other than the selected window.  If there are two or
     more windows on the screen, then the non-selected window will be
     used.  If there is only one window, it will be split.  The
     function returns `nil'.

       When this function is called interactively, Emacs prompts for
     FILENAME.

 * Command: find-file-read-only FILENAME

       This function visits the file named FILENAME and selects its
     buffer, just like `find-file', but it marks the buffer as
     read-only.  *Note Read Only Buffers::, for related functions and
     variables.

       When this function is called interactively, Emacs prompts for
     FILENAME.

 * Command: view-file FILENAME

       This function views FILENAME in View mode, returning to the
     previous buffer when done.  View mode is a mode that allows you
     to skim rapidly through the file but does not let you modify it.

       After loading the file, `view-file' calls the value of
     `view-hook' if that is non-`nil'.

       When this function is called interactively, Emacs prompts for
     FILENAME in the minibuffer.

 * Variable: find-file-hooks

       The value of this variable is a list of functions to be called
     after a file is visited.  The file's local-variables
     specification (if any) will have been processed before the hooks
     are run.  The buffer visiting the file is current when the hooks
     are run.

 * Variable: find-file-not-found-hooks

       The value of this variable is a list of functions to be called
     when `find-file' or `find-file-noselect' is passed a nonexistent
     FILENAME.  These functions are called as soon as the error is
     detected.  `buffer-file-name' is already set up.  The functions
     are called in the order given, until one of them returns
     non-`nil'.



File: lispref,  Node: Subroutines of Visiting,  Prev: Visiting Functions,  Up: Visiting Files

Subroutines of Visiting
-----------------------

  The `find-file-noselect' function uses the `create-file-buffer' and
`after-find-file' functions as subroutines.  Sometimes it is useful
to call them directly.

 * Function: create-file-buffer FILENAME

       This function creates a suitably named buffer for visiting
     FILENAME, and returns it.  The string FILENAME (sans directory)
     is used unchanged if that name is free; otherwise a string such
     as `<2>' is appended to get an unused name.  See also *Note
     Creating Buffers::.

       Note: `create-file-buffer' does *not* associate the new buffer
     with any file and does not make it the current buffer.

          (create-file-buffer "foo")
               => #<buffer foo>
          (create-file-buffer "foo")
               => #<buffer foo<2>>
          (create-file-buffer "foo")
               => #<buffer foo<3>>

       This function is used by `find-file-noselect'.

 * Function: after-find-file &optional ERROR WARN

       This function is called by `find-file-noselect' and by the
     default revert function (*note Reverting::.).  It sets the
     buffer major mode, and parses local variables.

        If there was an error in opening the file, the calling function
     should pass ERROR a non-`nil' value.  In that case,
     `after-find-file' issues a warning: `(New File)'.  Note that,
     for serious errors, you would not even call `after-find-file'. 
     Only ``file not found'' errors get here with a non-`nil' ERROR.

       If WARN is non-`nil', then Emacs will issue a warning if there
     exists an auto-save file more recent than the visited file.

       The last thing `after-find-file' does is call all the functions
     in `find-file-hooks'.



File: lispref,  Node: Saving Buffers,  Next: Reading from Files,  Prev: Visiting Files,  Up: Files

Saving Buffers
==============

  When you work on a file in Emacs, you are actually working on a
buffer that is visiting that file--that is, the contents of the file
are copied into the buffer and the copy is what you work on and modify.
Changes to the buffer do not change the file, until you save the
buffer as a newly written file.  The save buffer commands do this.

 * Command: save-buffer &optional BACKUP-OPTION

       This function saves the contents of the current buffer in its
     visited file if the buffer has been modified.  Otherwise, it
     does nothing.

       If BACKUP-OPTION is `nil', the `save-buffer' function makes a
     backup file only if this is the first save or if the buffer was
     previously modified.

       The `save-buffer' function is designed for interactive use; and
     the value of BACKUP-OPTION then depends of the number of `C-u'
     keystrokes prefixing the `save-buffer' command.

        * With 1 or 3 `C-u''s, the `save-buffer' function marks this
          version of the buffer to be backed up.

        * With 2 or 3 `C-u''s, the `save-buffer' function
          unconditionally backs up previous version.

       If a file's name is `foo', the names of its numbered backup
     versions are `foo.~V~', for various integers V, like this:
     `foo.~1~', `foo.~2~', `foo.~3~', ..., `foo.~259~', and so on.  A
     non-numbered backup file is called `foo~'.

       Numeric backups (rather than `foo~') will be made if the value
     of `version-control' is not the symbol `never', and either there
     are already numeric versions of the file being backed up or else
     `version-control' is non-`nil'.  (Thus, numeric backups will be
     kept if the value of `version-control' is `t'.)

       `dired-kept-versions' controls `dired''s `dired-clean-directory'
     (`.') command.  No one wants to save too many versions of a
     file, since that takes up too much disk space.  The variable
     `kept-old-versions' tells the system how many of the oldest
     versions to keep; and the variable `kept-new-versions' tells the
     system how many new versions to keep.  The defaults values are
     two old versions and two new.  Thus, if you had made a total of
     77 versions of `foo', your directory would contain `foo.~1~',
     `foo.~2~', `foo.~75~', `foo.~76~', and `foo', the current version.

       If the value of the `trim-versions-without-asking' variable is
     `nil', the system queries the user before deleting excess
     versions.  Otherwise it does it silently.

 * Command: save-buffers-kill-emacs &optional KILL-SILENTLY-P

       This function offers to save each buffer that needs to be saved,
     and then kills this Emacs session.  Called with a non-`nil'
     value of the optional KILL-SILENTLY-P argument, this function
     saves all the file-visiting buffers without querying the user or
     displaying any message about saving, and then kills the session.

     The body of the `save-buffers-kill-emacs' function consists of
     the two following lines:

          (save-some-buffers arg t)
          (kill-emacs)

 * Command: save-some-buffers &optional SAVE-SILENTLY-P EXITING

       This command saves some modified file-visiting buffers. 
     Normally, Emacs asks the user about each buffer.  If the
     function is called with a non-`nil' value of the optional
     SAVE-SILENTLY-P argument, this function saves all the
     file-visiting buffers without querying the user.

       The optional EXITING argument, if non-`nil', requests this
     function to offer to save in addition certain other buffers that
     are not visiting files.  These are buffers that have a non-`nil'
     local value of `buffer-offer-save'.  (A user who says yes to
     saving one of these will be asked to specify a file name to
     use.)  The `save-buffers-kill-emacs' function passes a non-`nil'
     value for this argument.

 * Variable: buffer-offer-save

       When this variable is non-`nil' in a buffer, Emacs offers to
     save the buffer on exit even if the buffer is not visiting a
     file.  The variable is automatically local in all buffers. 
     Normally, Mail mode (used for editing outgoing mail) sets this
     to `t'.

 * Command: write-file FILENAME

       This function writes the current buffer into file FILENAME,
     makes the buffer visit that file, and marks it not modified.

 * Variable: write-file-hooks

       The value of this variable is a list of functions to be called
     before writing out a buffer to its visited file.  If one of them
     returns non-`nil', the file is considered already written and
     the rest are not called, nor is the usual code for writing the
     file executed.

       If the `file-precious-flag' variable is `nil', the file is moved
     to the backup file before any of the hooks are called, so if
     none of the hooks save the file, but one returns non-`nil', the
     file will not exist, although the backup will.

       Here is an example of how to add a hook to the
     `write-file-hooks' just once.

          (or (memq 'my-write-file-hook write-file-hooks)
              (setq write-file-hooks 
                    (cons 'my-write-file-hook write-file-hooks)))

 * Variable: file-precious-flag

       If this global variable is non-`nil', then `save-buffer'
     protects against I/O errors while saving files, by renaming the
     original file to a temporary name before writing the new
     contents of the file.  If the new contents are successfully
     written, the renamed original file is deleted.  Otherwise, it is
     renamed back to the original name.  This procedure prevents
     problems such as a lack of disk space from resulting in an
     invalid file.

     Some modes set this non-`nil' locally in particular buffers.

 * Option: require-final-newline

       This global variable determines whether files may be written out
     that do *not* end with a newline.  If the value of the variable
     is `t', then Emacs silently puts a newline at the end of the
     file whenever the file being saved does not already end in one. 
     If the value of the variable is non-`nil', but not `t', then
     Emacs asks the user whether to add a newline in each such case.

       If the value of the variable is `nil', then Emacs doesn't add
     newlines at all.  `nil' is the default value, but a few major
     modes change it to `t'.



File: lispref,  Node: Reading from Files,  Next: Writing to Files,  Prev: Saving Buffers,  Up: Files

Reading from Files
==================

  You can copy a file directly from the disk and insert it into a
buffer using the `insert-file-contents' function, or its interactive
envelope, `insert-file'.

 * Command: insert-file FILENAME

       This function inserts the contents of file FILENAME into the
     current buffer after point.  An error is signaled if FILENAME is
     not the name of a file that can be read.  This function is for
     interactive use and does little more than call
     `insert-file-contents'.

 * Function: insert-file-contents FILENAME VISIT

       This function inserts the contents of file FILENAME into the
     current buffer after point.  If VISIT is non-`nil', the buffer's
     visited filename and last save file modtime are set, and it is
     marked unmodified, so that it is now visiting the file FILENAME.

       An error is signaled if FILENAME is not the name of a file that
     can be read.

       This function returns a list of the absolute file name and the
     length of the data inserted.



File: lispref,  Node: Writing to Files,  Next: File Locks,  Prev: Reading from Files,  Up: Files

Writing to Files
================

  You can write the contents of a buffer, or part of a buffer, directly
to a file on disk using the `append-to-file' and `write-region'
functions.  Normally, this is done for files not visited by the
buffer in question.

 * Command: append-to-file START END FILENAME

       This function appends the contents of the region delimited by
     START and END in the current buffer to the end of file FILENAME.
     If that file does not exist, it is created.

       This function returns `nil'.

       An error is signaled if FILENAME specifies a nonwritable file,
     or a nonexistent file in a nonwritable directory.

 * Command: write-region START END FILENAME &optional APPEND VISIT

     This function writes the region (of the current buffer)
     delimited by START and END into the file specified by FILENAME.

     If APPEND is non-`nil', then the region will be appended to the
     existing file contents (if any).

     If VISIT is `t', then Emacs establishes an association between
     the buffer and the file: the buffer is then visiting that file. 
     It also sets the last file modification time for the current
     buffer to FILENAME's modtime, and marks the buffer as not
     modified.

     Normally, this function prints a message `Wrote file FILENAME'
     in the echo area.  If VISIT is neither `t' nor `nil', then this
     message is inhibited.  This feature is useful for programs which
     use files for internal purposes, files which the user does not
     need to know about.



File: lispref,  Node: File Locks,  Next: Information about Files,  Prev: Writing to Files,  Up: Files

File Locks
==========

  When two different people attempt to modify and save the same file at
the same time, the changes made by one person are lost as the changes
made by the other overwrite them.  File locks are used to help avoid
such an unfortunate occurrence.  Instead of destroying on person's
work, Emacs, aided by locks, will ask you what to do.

 * Function: file-locked-p FILENAME

       This function returns `nil' if the FILENAME is not locked by
     this Emacs process.  It returns `t' if it is locked by this
     Emacs, and it returns the name of the user who has locked it if
     it is locked by someone else.

          (file-locked-p "foo")
               => nil

 * Function: lock-buffer &optional FILENAME

       This function locks FILENAME, if the current buffer is modified.
     fILENAME defaults to the current buffer's visited file.  Nothing
     is done if the current buffer is not visiting a file, or is not
     modified.

 * Function: unlock-buffer

     This function unlocks the file being visited in the current
     buffer, if the buffer is modified.  If the buffer is not
     modified, then the file should not be locked, so this function
     does nothing.  It also does nothing if the current buffer is not
     visiting a file.

 * Function: ask-user-about-lock FILE OTHER-USER

     When a user tries to modify FILE, but it is locked by another
     user name OTHER-USER, Emacs calls this function to decide what
     to do.  The default definition of this function asks the user to
     choose.

     The `ask-user-about-lock' function will do one of the following:

        * Return `t', which tells Emacs to grab the lock on the file.
          Then this user may edit the file; and OTHER-USER loses the
          lock.

        * Return `nil', which tells Emacs to ignore the lock and let
          this user edit the file anyway.

        * Signal a `file-locked' error, in which case the change
          which the user was about to make does not happen.

          The error message for this error looks like this:

               error--> "File is locked" FILE OTHER-USER

          where `file' is the name of the file and OTHER-USER is the
          name of the user who has locked the file.

       If you wish, you can replace the `ask-user-about-lock' function
     with your own version that does what you prefer.  The code for
     its usual definition is in `userlock.el'.



File: lispref,  Node: Information about Files,  Next: Contents of Directories,  Prev: File Locks,  Up: Files

Information about Files
=======================

  The functions described in this section are similar in as much as
they all operate on strings which are interpreted as file names.  All
have names that begin with the word `file'.  These functions all
return information about actual files or directories, so their
arguments must all exist as actual files or directories unless
otherwise noted.

  Most of the file-oriented functions take a single argument, FILENAME,
which must be a string.  The file name is expanded using
`expand-file-name', so `~' is handled correctly, as are relative file
names (including `../').  Environment variables in filenames, such as
`$HOME', etc., are not substituted by these functions.

* Menu:

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A link?
* File Attributes::         How large is it?  Any other names?  Etc.

 

File: lispref,  Node: Testing Accessibility,  Next: Kinds of Files,  Prev: Information about Files,  Up: Information about Files

Testing Accessibility
---------------------

 * Function: file-exists-p FILENAME

       This function returns `t' if a file named FILENAME exists.  This
     does not mean you can necessarily read the file, only that you
     can find out its attributes.  On Unix, this is true if you can
     do a directory listing on the containing directory.

       If you do not have permission to do a directory listing on the
     directory containing FILENAME, then the result will be `nil'.

 * Function: file-readable-p FILENAME

       This function returns `t' if a file named FILENAME exists and
     you can read it.  It returns `nil' otherwise.

          (file-readable-p "file.texinfo")
               => t
          (file-exists-p "/usr/spool/mqueue")
               => t
          (file-readable-p "/usr/spool/mqueue")
               => nil

 * Function: file-writable-p FILENAME

       This functions returns `t' if FILENAME can be written or created
     by you.  It is writable if the file exists and you can write it.
     It is creatable if the file does not exist, but the directory it
     would be in does exist and you can write in that directory. 
     `file-writable-p' returns `nil' otherwise.

       In the third example below, `foo' is not writable because the
     parent directory does not exist, even though the user could
     create it.

          (file-writable-p "~rms/foo")
               => t
          (file-writable-p "/foo")
               => nil
          (file-writable-p "~rms/no-such-dir/foo")
               => nil

 * Function: file-newer-than-file-p FILENAME1 FILENAME2

       This functions returns `t' if the file FILENAME1 is newer than
     file FILENAME2.  If FILENAME1 does not exist, it returns `nil'. 
     If FILENAME2 does not exist, it returns `t'.

       In the example, assume that the file `aug-19' was written on the
     19th, and `aug-20' was written on the 20th.  The file `no-file'
     doesn't exist at all.

          (file-newer-than-file-p "aug-19" "aug-20")
               => nil
          (file-newer-than-file-p "aug-20" "aug-19")
               => t
          (file-newer-than-file-p "aug-19" "no-file")
               => t
          (file-newer-than-file-p "no-file" "aug-19")
               => nil



File: lispref,  Node: Kinds of Files,  Next: File Attributes,  Prev: Testing Accessibility,  Up: Information about Files

Distinguishing Kinds of Files
-----------------------------

 * Function: file-symlink-p FILENAME

       If FILENAME is a symbolic link, the `file-symlink-p' function
     returns the file name to which it is linked.  This may be the
     name of a text file, a directory, or even another symbolic link,
     or of no file at all.

       If FILENAME is not a symbolic link (or there is no such file),
     `file-symlink-p' returns `nil'.

          (file-symlink-p "foo")
               => nil
          (file-symlink-p "sym-link")
               => "foo"
          (file-symlink-p "sym-link2")
               => "sym-link"
          (file-symlink-p "/bin")
               => "/pub/bin"

 * Function: file-directory-p FILENAME

       This function returns `t' if FILENAME is the name of an existing
     directory, `nil' otherwise.

          (file-directory-p "~rms")
               => t
          (file-directory-p "~rms/lewis/file.texinfo")
               => nil
          (file-directory-p "~rms/lewis/no-such-file")
               => nil
          (file-directory-p "$HOME")
               => nil
          (file-directory-p (substitute-in-file-name "$HOME"))
               => t



File: lispref,  Node: File Attributes,  Prev: Kinds of Files,  Up: Information about Files

Other Information about Files
-----------------------------

 * Function: file-attributes FILENAME

       This function returns a list of attributes of file FILENAME.  If
     the specified file cannot be opened, it returns `nil'.

       The elements of the list, in order, are:

       1. `t' for a directory, a string for a symbolic link (the name
          linked to), or `nil' for a text file.

       2. The number of links to the file.

       3. The file's UID.

       4. The file's GID.

       5. The time of last access, as a list of two integers.  The
          first integer has the high-order 16 bits of time, the
          second has the low 16 bits.

       6. The time of last modification as a list of two integers
          (see above).

       7. The time of last status change as a list of two integers
          (see above).

       8. The size of the file in bytes.

       9. The file's modes, as a string of ten letters or dashes as
          in `ls -l'.

      10. `t' if the file's GID would change if file were deleted and
          recreated.

      11. The file's inode number.

     For example, here are the file attributes for `file.texinfo':

          (file-attributes "file.texinfo")
               =>  (nil 
                          1 
                          2235 
                          75 
                          (8489 20284) 
                          (8489 20284) 
                          (8489 20285)
                          14906 
                          "-rw-rw-rw-" 
                          nil 
                          20920)

     and here is how the result is interpreted:

    `nil'
          is neither a directory nor a symbolic link.

    `1'
          has only one link to it, the name `file.texinfo'.

    `2235'
          is owned by the user with UID 2235.

    `75'
          is in the group with GID 75

    `(8489 20284)'
          was last accessed on Aug 19 00:09.  Unfortunately, you
          cannot convert this number into a time string in Emacs.

    `(8489 20284)'
          was last accessed on Aug 19 00:09.  Unfortunately, you
          cannot convert this number into a time string in Emacs.

    `(8489 20285'
          last had its inode changed on Aug 19 00:09.  Unfortunately,
          you cannot convert this number into a time string in Emacs.

    `14906'
          has 14906 characters in it.

    `"-rw-rw-rw-"'
          has a mode of read and write access for the owner, group,
          and world.

    `nil'
          would retain the same `gid' if it were recreated.

    `20920'
          has an inode number of 20920

 * Function: file-modes FILENAME

       This function returns the mode bits of FILENAME, as a decimal
     integer.  The mode bits are the usual Unix mode bits.  If the
     low-order bit is 1, then the file is executable by others, if
     the second lowest-order bit is 1, then the file is writable by
     others, etc.

       The highest value returnable is 4095 (7777 octal), meaning that
     everyone has read, write, and execute permission, that the file
     has the SUID bit set for both others and group, and that the
     file has the sticky bit set.

          (file-modes "~/junk/diffs")
               => 492               ; decimal integer
          (format "%o" 492)
               -| 754               ; convert to octal
          
          (set-file-modes "~/junk/diffs" 4095)
               => nil
          
          % ls -l diffs
               => -rwxr-xr--  1 lewis    0    3063 Oct 30 16:00 diffs

 * Function: file-nlinks FILENAME

       This functions returns the number of names (i.e., hard links)
     that file FILENAME has.  If the file does not exist, then this
     function returns `nil'.

          % ls -l foo*
            -rw-rw-rw-  2 rms             4 Aug 19 01:27 foo
            -rw-rw-rw-  2 rms             4 Aug 19 01:27 foo1
          
          (file-nlinks "foo")
               => 2
          (file-nlinks "doesnt-exist")
               => nil



File: lispref,  Node: Contents of Directories,  Next: Changing File Attributes,  Prev: Information about Files,  Up: Files

Contents of Directories
=======================

  A directory is a kind of file which contains other files entered
under various names.  Directories belong to Unix, not to Emacs.

  Emacs can list the names of the files in a directory as a Lisp list,
or display the names in a buffer using the `ls' shell command.  In
the latter case, Emacs will display information about each file,
depending on the value of switches passed to the `ls' command.

 * Function: directory-files DIRECTORY &optional FULL-NAME MATCH-REGEXP

       This function returns a list of the names of the files in the
     directory DIRECTORY.

     If FULL-NAME is non-`nil', the function returns the files'
     absolute file names.  Otherwise, if MATCH-REGEXP is non-`nil',
     function returns only those file names that contain that regular
     expression--the other file names are discarded from the list.

          (directory-files "~lewis")
               => ("#foo#" "#foo.el#" "." ".."
              "dired-mods.el" "file.texinfo" "file.texinfo.~1~")

       An error is signaled if DIRECTORY is not the name of a directory
     that can be read.

 * Function: file-name-all-versions FILE DIRNAME

       This function returns a list of all versions of the file named
     FILE in directory DIRNAME.

 * Command: list-directory DIRNAME &optional VERBOSE

       This command displays a list of files in or matching DIRNAME. 
     It calls the shell command `ls', optionally passing it an
     appropriate switch.

     Wildcards in DIRNAME are processed by the shell.

     A prefix argument (the function's second argument if it is
     called noninteractively) causes the function to pass the value
     of `list-directory-verbose-switches' to `ls' as a switch. 
     Otherwise, the function passes `list-directory-brief-switches'
     to `ls'.

 * Variable: list-directory-brief-switches

       This variable contains switches for `list-directory' to pass to
     `ls' for a short or `brief' listing.  The default value is
     `"-CF"'.

 * Variable: list-directory-verbose-switches

       This variable contains switches for `list-directory' to pass to
     `ls' for a verbose or `long' listing.  The default value is
     `"-l"'.



File: lispref,  Node: Changing File Attributes,  Next: File Names,  Prev: Contents of Directories,  Up: Files

Changing File Names and Attributes
==================================

  You can use the functions in this section to rename, copy, delete,
link, and set the modes of files.

 * Function: add-name-to-file OLDNAME NEWNAME &optional
OK-IF-ALREADY-EXISTS

       This function gives the file named OLDNAME the additional name
     NEWNAME.  This means that NEWNAME will be a new ``hard link'' to
     OLDNAME.

       This function is meaningless on VMS, where multiple names for
     one file are not allowed.

       If a file by the name of NEWNAME already exists:

        * A `file-already-exists' error is signaled if
          OK-IF-ALREADY-EXISTS is `nil'.

        * Confirmation is requested if OK-IF-ALREADY-EXISTS is a
          number.

        * No confirmation is requested if OK-IF-ALREADY-EXISTS is any
          other value, in which case the old file is removed.

       In the first part of the following example, we list two files,
     `foo' and `foo3'.

          % ls -l fo*
          -rw-rw-rw-  1 rms            29 Aug 18 20:32 foo
          -rw-rw-rw-  1 rms            24 Aug 18 20:31 foo3

     Then we evaluate the form `(add-name-to-file "~/lewis/foo"
     "~/lewis/foo2")'.  Again we list the files.  This shows two
     links to `foo' and `foo2'.

          (add-name-to-file "~/lewis/foo1" "~/lewis/foo2")
               => nil
          
          % ls -l fo*
          -rw-rw-rw-  2 rms            29 Aug 18 20:32 foo
          -rw-rw-rw-  2 rms            29 Aug 18 20:32 foo2
          -rw-rw-rw-  1 rms            24 Aug 18 20:31 foo3

       Finally, we evaluate `(add-name-to-file "~/lewis/foo"
     "~/lewis/foo3" t)', and list the files again.  Now there are
     three links to `foo', `foo2', and `foo3').  The old contents of
     `foo3' are lost.

          (add-name-to-file "~/lewis/foo1" "~/lewis/foo3")
               => nil
          
          % ls -l fo*
          -rw-rw-rw-  3 rms            29 Aug 18 20:32 foo
          -rw-rw-rw-  3 rms            29 Aug 18 20:32 foo2
          -rw-rw-rw-  3 rms            29 Aug 18 20:32 foo3

 * Command: rename-file FILENAME NEWNAME &optional OK-IF-ALREADY-EXISTS

       This function renames FILENAME as NEWNAME.

       If FILENAME has names (i.e., hard links) other than filename, it
     continues to have those names.

     If a file by the name of NEWNAME already exists:

        * The function signals a `file-already-exists' error, unless
          OK-IF-ALREADY-EXISTS is non-`nil'.

        * Emacs requests confirmation if NEWNAME already exists if
          OK-IF-ALREADY-EXISTS is numeric.

       When called interactively, Emacs prompts for FILENAME and
     NEWNAME in the minibuffer.  In interactive use, Emacs requests
     confirmation if NEWNAME already exists.

 * Function: copy-file OLDNAME NEWNAME &optional OK-IF-EXISTS TIME

       This function copies the file OLDNAME to NEWNAME.  An error is
     signaled if OLDNAME does not exist.

       If a file by the name of NEWNAME already exists:

        * A `file-already-exists' error is signaled if OK-IF-EXISTS
          is either `nil' or not supplied.

        * Emacs requests confirmation if OK-IF-EXISTS is a number.

        * Emacs does *not* request confirmation if OK-IF-EXISTS is
          any other value, in which case the old file is removed.

       If TIME is non-`nil', then this functions gives the new file the
     same last-modified time that the old one has.  (This works on
     only some operating systems.)

 * Function: delete-file FILENAME

       This function deletes the file FILENAME.  This function is
     essentially the same as the shell command `rm FILENAME'.

       If FILENAME has multiple names, it continues to exist with the
     other names.

       A suitable kind of `file-error' error is signaled if the file
     does not exist, or is not deletable.  (In Unix, a file is
     deletable if its directory is writable.)

 * Command: make-symbolic-link FILENAME NEWNAME &optional OK-IF-EXISTS

       This function makes a symbolic link to FILENAME, named NEWNAME. 
     It signals a `file-already-exists' error if NEWNAME already
     exists unless OK-IF-EXISTS is non-`nil'.  If OK-IF-EXISTS is
     numeric, then Emacs requests confirmation if NEWNAME already
     exists.  If it is `t', then the old file is simply deleted.

       When called interactively, FILENAME and NEWNAME are prompted for
     in the minibuffer.  OK-IF-EXISTS is set to the processed prefix
     argument.

 * Function: set-file-modes FILENAME MODE

       This function sets mode bits of FILENAME to MODE (which must be
     a integer).  Only the 12 low bits of MODE are used.



File: lispref,  Node: File Names,  Prev: Changing File Attributes,  Up: Files

File Names
==========

  Files are generally referred to by their names; Emacs is no exception
to this.  File names in Emacs are represented as strings.  The
functions which read, write or move files all expect a file name
argument.

  In addition to operating on files themselves, Emacs Lisp programs
often need to operate on the names: to take them apart, and use the
pieces to construct related file names.  This section describes how
to manipulate file names.

  The functions in this section do not actually operate on files, so
they can operate on file names which do not refer to an existing file
or directory.

  On VMS, all these functions understand both VMS file name syntax and
Unix syntax.  This is so that all the standard Lisp libraries can
specify file names in Unix syntax and then work properly on either
system without change.

* Menu:

* File Name Components::  The directory part of a file name, and the rest.
* Directory Names::       A directory's name as a directory
                            is different from its name as a file.
* Relative File Names::   Some file names are relative to a current directory.
* File Name Expansion::   Converting relative file names to absolute ones.
* Unique File Names::     Generating names for temporary files.
* Filename Completion::   Finding the completions for a given file name.

 

File: lispref,  Node: File Name Components,  Next: Directory Names,  Up: File Names

File Name Components
--------------------

  The operating system groups files into directories.  To specify a
file, you must specify the directory, and the file's name in that
directory.

  Therefore, a file name in Emacs is considered to have two main parts:
the "directory name" part, and the "nondirectory" part (or "file name
within the directory").  Concatenating these two parts reproduces the
original file name.  Either part may be empty.  On Unix, the
directory part is everything up to and including the last slash; the
nondirectory part is the rest.  The rules in VMS syntax are
complicated.

  For some purposes, the nondirectory part is further subdivided into
the name and the version number.  On Unix, only backup files have
version numbers in their names; on VMS, every file has a version
number, but most of the time the file name actually used in Emacs
omits the version number.  Version numbers are found mostly in
directory lists.

 * Function: file-name-directory FILENAME

       This function returns the directory part of FILENAME.  It
     returns `nil' if FILENAME does not include a directory.  On
     Unix, the function returns a string ending in a slash.  On VMS,
     it returns a string ending in one of the three characters `:',
     `]', or `>'.

          (file-name-directory "lewis/foo")     ; Unix example
               => "lewis/"
          (file-name-directory "foo")           ; Unix example
               => nil
          (file-name-directory "[X]FOO.TMP")    ; VMS example
               => [X]

 * Function: file-name-nondirectory FILENAME

       This function returns the file name from FILENAME without its
     directory part (if any).

          (file-name-nondirectory "lewis/foo")
               => "foo"
          (file-name-nondirectory "foo")
               => "foo"
          ;; The following example is accurate only on VMS.
          (file-name-nondirectory "[X]FOO.TMP")
               => "FOO.TMP"

 * Function: file-name-sans-versions FILENAME

       This function returns FILENAME without any file version numbers,
     backup version numbers, or trailing tildes.

          (file-name-sans-versions "~rms/foo.~1~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo")
               => "~rms/foo"
          ;; The following example applies to VMS only.
          (file-name-sans-versions "foo;23")
               => "foo"



File: lispref,  Node: Directory Names,  Next: Relative File Names,  Prev: File Name Components,  Up: File Names

Directory Names
---------------

  A "directory name" is the name of a directory, which is a special
kind of file.  This file also has a file name, which is its name when
considered as a file in its own right.  These two different names for
the same entity are related by a syntactic transformation.  On Unix,
this is simple: a directory name ends in a slash, whereas the
directory's name as a file lacks that slash.  (This is not quite
identical to the conventions of Unix terminology.)  On VMS, the
relationship is more complicated.

  Though the difference between a directory name and its name as a file
may be small, it is crucial.  When an Emacs variable or function
argument is described as being a directory name, a file name of a
directory is not acceptable.

  All of these functions take a single argument, FILENAME, which must
be a string.  Environment variables such as `$HOME', and the symbols
`~', and `..', are *not* expanded.  Use `expand-file-name' or
`substitute-in-file-name' for that (*note Relative File Names::.).

 * Function: file-name-as-directory FILENAME

       This function returns a string representing FILENAME in a form
     that the operating system will interpret as the name of a
     directory.  In Unix, this means that the string has a slash
     appended to it.  In VMS, the function converts a string of the
     form `[X]Y.DIR.1' to the form `[X.Y]'.

          (file-name-as-directory "~rms/lewis")
               => "~rms/lewis/"

 * Function: directory-file-name DIRNAME

       This function returns a string representing DIRNAME in a form
     that the operating system will interpret as the name of a file. 
     On Unix, this means that the string has a final slash removed. 
     On VMS, the function converts a string of the form `[X.Y]' to
     `[X]Y.DIR.1'.

          (directory-file-name "~lewis/")
               => "~lewis"



File: lispref,  Node: Relative File Names,  Next: File Name Expansion,  Prev: Directory Names,  Up: File Names

Absolute and Relative File Names
--------------------------------

  All the directories in the file system form a tree starting at the
root directory.  A file name can specify all the directory names
starting from the root of the tree; then it is called an "absolute"
file name.  Or it can specify the position of the file in the tree
relative to a default directory; then it is called an "relative" file
name.  On Unix, an absolute file name starts with a slash or a tilde
(`~'), and a relative one does not.  The rules on VMS are complicated.

 * Function: file-name-absolute-p FILENAME

       This function returns `t' if file FILENAME specifies an absolute
     file name, `nil' otherwise.  On VMS, this function understands
     both Unix syntax and VMS syntax.

          (file-name-absolute-p "~rms/foo")
               => t
          (file-name-absolute-p "rms/foo")
               => nil
          (file-name-absolute-p "$HOME")
               => nil
          (file-name-absolute-p "/user/rms/foo")
               => t



File: lispref,  Node: File Name Expansion,  Next: Unique File Names,  Prev: Relative File Names,  Up: File Names

Functions that Expand Filenames
-------------------------------

  "Expansion" of a file name means converting a relative file name to
an absolute one.  Since this is done relative to a directory, you
must specify the directory name as well as the file name to be
expanded.

  Expansion also canonicalizes file names by simplifying redundancies
such as `./' and `NAME/../'.

 * Function: expand-file-name FILENAME &optional DIRECTORY

       This function converts FILENAME to an absolute file name.  If
     DIRECTORY is supplied, then it is the directory to start with if
     FILENAME is relative.  Otherwise, the current buffer's value of
     `default-directory' is used.

       Filenames containing `.' or `..' are expanded to their canonical
     form.  Adjacent `/'s are condensed into a single `/'.  `~' as a
     file is expanded into the user's home directory.  See
     `substitute-in-file-name' below for the details.

       But note that `expand-file-name' does *not* expand environment
     variables.  (That is done by `substitute-in-file-name'.)

          (expand-file-name "foo")
               => "/xcssun/users/rms/lewis/foo"
          (expand-file-name "../foo")
               => "/xcssun/users/rms/foo"
          (expand-file-name "foo" "/usr/spool")
               => "/usr/spool/foo"
          (expand-file-name "$HOME/foo")
               => "/xcssun/users/rms/lewis/$HOME/foo"

 * Variable: default-directory

       The value of this buffer-local variable is the default directory
     for the current buffer.  It is local in every buffer. 
     `expand-file-name' uses the default directory when its second
     argument is `nil'.

       On Unix systems, the value is always a string ending with a slash.

          default-directory
               => "/user/lewis/manual/"

 * Function: substitute-in-file-name FILENAME

       This function replaces environment variables names in FILENAME
     with the values to which they are set by the operating system. 
     Following standard Unix shell syntax, `$' begins an environment
     variable.

       The environment variable name is the series of alphanumeric
     characters (including underscores) that follow the `$'.  If the
     character following the `$' is a `{', then the variable name is
     everything up to the matching `}'.

     If a `~' or a `/' appears following a `/', everything through
     the first `/' is discarded.

     Here we assume that the environment variable `HOME', which is
     the user's home directory name, is `/xcssun/users/rms'.

          (substitute-in-file-name "bar/~/foo")
               => "~/foo"
          (substitute-in-file-name "$HOME/foo")
               => "/xcssun/users/rms/foo"
          (substitute-in-file-name "/usr/local/$HOME/foo")
               => "/xcssun/users/rms/foo"

     On VMS, `$' substitution is not done; this function does little
     on VMS.



File: lispref,  Node: Unique File Names,  Next: Filename Completion,  Prev: File Name Expansion,  Up: File Names

Generating Unique File Names
----------------------------

  Some programs need to construct temporary files.  Here is the usual
way to construct a name for such a file:

     (concat "/tmp/" (make-temp-name NAME-OF-APPLICATION))

The directory `/tmp/' is chosen because that is the standard place on
Unix for temporary files.  The task of `make-temp-name' is to prevent
two different users or two different jobs from trying to use the same
name.

 * Function: make-temp-name STRING

     This function generates string that can be used as a unique name.
     The name will start with the prefix STRING, and finish with a
     number which is different in each Emacs job.

          (make-temp-name "foo")
               => "foo021304"
          (make-temp-name "foo")
               => "foo021304"

     To prevent conflicts among different application libraries run
     in the same Emacs, each application should have its own STRING. 
     The number added to the end of the name distinguishes between
     the same application running in different Emacses.



File: lispref,  Node: Filename Completion,  Prev: Unique File Names,  Up: File Names

Filename Completion
-------------------

  This section describes low-level subroutines for completing a filename.

  For other completion functions, see *Note Completion::, and *Note
Lisp Symbol Completion::.

 * Function: file-name-all-completions PARTIAL-FILENAME DIRECTORY

       This function returns a list of all possible completions for a
     file whose name starts with PARTIAL-FILENAME in directory
     DIRECTORY.  The order of the completions is the order of the
     files in DIRECTORY, which is not normally sorted.

       PARTIAL-FILENAME must contain no directory and no slash.  The
     current buffer's default directory is prepended to DIRECTORY, if
     DIRECTORY is not an absolute file name.

       In the following example, suppose that the current default
     directory, `~rms/lewis', has five files whose names begin with
     `f': `foo', `file~', `file.c', `file.c.~1~', and `file.c.~2~'.

          (file-name-all-completions "f" "~rms/lewis")
               => ("foo" "file~" "file.c.~2~" 
                     "file.c.~1~" "file.c")
          
          (file-name-all-completions "fo" "")  
               => ("foo")

 * Function: file-name-completion FILENAME DIRECTORY

       This function completes the file name FILENAME in directory
     DIRECTORY.  It returns the longest prefix common to all
     filenames in DIRECTORY that start with FILENAME.

       If only one match exists, and FILENAME matches exactly, the
     function returns `t'.  The function returns `nil' if DIRECTORY
     contains no name starting with FILENAME.

       In the following example, suppose that the current default
     directory, `~rms/lewis', has five files whose names begin with
     `f': `foo', `file~', `file.c', `file.c.~1~', and `file.c.~2~'.

          (file-name-completion "fi" "")
               => "file"
          
          (file-name-completion "file.c.~1" "")
               => "file.c.~1~"
          
          (file-name-completion "file.c.~1~" "")
               => t
          
          (file-name-completion "file.c.~3" "")
               => nil

 * Option: completion-ignored-extensions

       The filename completion functions usually ignore all filenames
     that end in any string in this list.

       A typical value might look like this:

          completion-ignored-extensions
               => (".o" ".elc" "~" ".dvi")



File: lispref,  Node: Backups and Auto Saving,  Next: Buffers,  Prev: Files,  Up: Top

Backups and Auto Saving
***********************

  Backup files and auto-save files are two methods by which Emacs tries
to protect the user from the consequences of crashes or of the user's
own errors.  Auto-saving preserves the text from earlier in the
current editing session.  Backup files preserve file contents prior
to the current session.

* Menu:

* Backup Files::   How backup files are made; how their names are chosen.
* Auto Saving::    How auto save files are made; how their names are chosen.
* Reverting::      `revert-buffer', and how to customize what it does.

 

File: lispref,  Node: Backup Files,  Next: Auto Saving,  Prev: Backups and Auto Saving,  Up: Backups and Auto Saving

Backup Files
============

  A "backup file" is a copy of the old contents of a file you are
editing.  Emacs makes a backup file the first time you save a buffer
into its visited file.  Normally, this means that the backup file
contains the contents of the file as it was before editing started in
the current editing session.  The contents of the backup file
normally remain unchanged once the file exists.

  By default, Emacs makes a single backup file for each file you edit. 
You can alternatively request numbered backups; then each new backup
file gets a new name.  It is up to you to delete old numbered backups
when you don't want them any more.

  Backups are usually made by renaming the visited file to a new name. 
Optionally, you can specify that backup files should be made by
copying the visited file.  This choice makes a difference for files
with multiple hard links; it also can affect the owner of the file.

* Menu:

* Making Backups::   How Emacs makes backup files, and when.
* Rename or Copy::   Two alternatives: renaming the old file or copying it.
* Backup Names::     How backup file names are computed; customization.

 

File: lispref,  Node: Making Backups,  Next: Rename or Copy,  Prev: Backup Files,  Up: Backup Files

Making Backup Files
-------------------

 * Function: backup-buffer

       This function makes a backup of the file visited by the current
     buffer, if appropriate.  It is called by `save-buffer' before
     saving the buffer the first time.

 * Variable: buffer-backed-up

       This buffer-local variable indicates whether this buffer's file
     has been backed up on account of this buffer.  If it is
     non-`nil', then the backup file has been written.  The file is
     backed up just before the file is saved for the first time.

 * Variable: make-backup-files

       This global variable determines whether or not backup files will
     be created.  If it is non-`nil', then Emacs will create a backup
     of each file when it is saved for the first time.

       The following example shows how to change the
     `make-backup-files' variable only in your `RMAIL' buffer and not
     elsewhere.  Setting it `nil' stops Emacs from making backups of
     your `RMAIL' file, which may save disk space.  (You would put
     this code in your `.emacs' file.)

          (setq rmail-mode-hook 
                (function (lambda ()
                            (make-local-variable 'make-backup-files)
                            (setq make-backup-files nil)))



File: lispref,  Node: Rename or Copy,  Next: Backup Names,  Prev: Making Backups,  Up: Backup Files

Backup by Renaming or by Copying?
---------------------------------

  There are two ways that Emacs can make a backup:

   * Emacs can rename the original file so that it becomes a backup
     file, and then write the buffer being saved into a new file.  In
     this case, any other names (i.e., hard links) that the original
     file had will now refer to the backup file.  The new file will
     be owned by the user and its group will be the default for the
     user or the directory.

   * Emacs can copy the original file into a backup file, and then
     overwrite the original file with new contents.  In this case,
     any other names (i.e., hard links) that the original file had
     will still refer to the most current version of the file.  The
     file's owner and group will be unchanged.

  The first method, of renaming, is the default.

  The variable `backup-by-copying', if non-`nil', says to use the
second method, which is to copy the file and then write the buffer on
top of the original.

  The variable `file-precious-flag', if non-`nil', also has this
effect, as a sideline of its other significance.  *Note Saving
Buffers::.

  The variables `backup-by-copying-when-linked' and
`backup-by-copying-when-mismatch', if non-`nil', cause the second
method to be used in certain special cases.  They have no effect on
the treatment of files that don't fall into the special cases.

 * Variable: backup-by-copying

       This global variable determines whether backup files will be
     made by copying.  If it is non-`nil', then Emacs will always
     copy the current contents of the file into the backup file
     before writing the buffer to be saved to the file.  (In many
     circumstances, this has the same effect as `file-precious-flag'.)

 * Variable: backup-by-copying-when-linked

       This global variable determines whether backups for files with
     multiple names (hard links) will be made by copying.  If it is
     non-`nil', then Emacs will use copying to create backups for
     those files.

       This variable is relevant only if `backup-by-copying' is `nil',
     since copying is always used when that variable is non-`nil'.

 * Variable: backup-by-copying-when-mismatch

       This global variable determines whether Emacs will make backups
     by copying when renaming would cause either the owner or the
     group of the file to change.  If it is non-`nil' then Emacs will
     create backups for those file by copying.

       Renaming may still be used (subject to control of other
     variables) when it would not result in changing the owner or
     group of the file; that is, for files which are owned by the
     user and whose group matches the default for a new file created
     there by the user.

       This variable is relevant only if `backup-by-copying' is `nil',
     since copying is always used when that variable is non-`nil'.



File: lispref,  Node: Backup Names,  Prev: Rename or Copy,  Up: Backup Files

Naming Backup Files
-------------------

  The functions in this section are documented mainly because you can,
by redefining them, customize how Emacs names backup files.

 * Function: backup-file-name-p FILENAME

     This function returns a non-`nil' value if FILENAME is a
     possible name for a backup file.  A file with the name FILENAME
     need not exist; the function just checks the name.

          (backup-file-name-p "foo")
               => nil
          (backup-file-name-p "foo~")
               => 3

     In the standard Emacs release, the body of this function
     consists of the following line:

          (string-match "~$" file)

     In other words, the function returns a non-`nil' value if the
     filename ends with a `~'

     This simple expression is given its own name as a function so
     that you can redefine it for customization.

 * Function: make-backup-file-name FILENAME

     This function creates a non-numeric backup file name to be used
     when FILENAME is backed up.  On Unix, the value is just FILENAME
     with a tilde appended.

     In the standard release, the body of this function consists of
     the following line:

          (concat file "~")

     You can change the backup file names for all backup files by
     redefining this function.  In the following example,
     `make-backup-file-name' is redefined to prepend a `.' as well as
     to append a tilde.

          (defun make-backup-file-name (filename)
            (concat "." filename "~"))
          
          (make-backup-file-name "backups.texinfo")
               => ".backups.texinfo~"

     Be sure to redefine `backup-file-name-p' and
     `find-backup-file-name' as well.

 * Function: find-backup-file-name FILENAME

       This function computes the file name for a new backup file for
     FILENAME.  If numerous backup files for FILENAME exist (which
     implies that the backups must be numeric backups), then this
     function also makes a list of old backup files that are ripe for
     deletion.

       The global variables `kept-old-versions' and `kept-new-versions'
     determine which old backup versions Emacs will keep (by not
     including them in the list of backup files ripe for deletion).

       `find-backup-file-name' returns a list whose CAR is the name for
     the new backup file and whose CDR is a list of old versions.

       In the example, `~rms/foo.~5~' is the name for the new backup
     file and `~rms/foo.~3~' is the ``excess'' version that you
     should consider deleting now.

          (find-backup-file-name "~rms/foo")
               => ("~rms/foo.~5~" "~rms/foo.~3~")

 * Option: kept-old-versions

       The value of this variable is the number of oldest versions to
     keep when a new numbered backup is made.  If there are backups
     numbered 1, 2, 3, 5, and 6, and the value of `kept-old-versions'
     is 2, then the ``oldest'' backups 1 and 2 will be kept, and 3
     will be flagged for deletion, unless (in this example) the value
     of `kept-new-versions' is greater than 2.

 * Option: kept-new-versions

       The value of this variable is the number of a file's most recent
     versions to keep when a new numbered backup is made.  It
     includes the new backup.  It must be greater than 0.  Thus, if
     the value of `kept-new-versions' is 2, then the two most recent
     backups of a file will be kept.



File: lispref,  Node: Auto Saving,  Next: Reverting,  Prev: Backup Files,  Up: Backups and Auto Saving

Auto Saving
===========

  Emacs saves all files that you are visiting from time to time without
being asked.  This is called ``auto saving''.  (Emacs counts your
keystrokes; by default, your work is saved after 300 keystrokes.) 
Auto saving prevents you from losing more than a limited amount of
work if the system crashes.  *Note Auto Save: (emacs)Auto Save.

 * Variable: buffer-auto-save-file-name

       This buffer-local variable is the name of the file used for auto
     saving the current buffer.  It is `nil' if the buffer should not
     be auto saved.

          buffer-auto-save-file-name
          => "/xcssun/users/rms/lewis/#file.texinfo#"

 * Command: auto-save-mode ARG

       When used interactively without being passed an argument this
     command is a toggle switch.  It turns on auto saving of the
     contents of the current buffer if it is off and vice-versa. 
     When passed ARG, the command turns auto saving on if the value
     of ARG is positive, otherwise it turns auto saving off.

 * Function: auto-save-file-name-p FILENAME

       This function returns a non-`nil' value if FILENAME is a string
     that could possibly be returned by `make-auto-save-file-name'.

       According to the usual naming convention, any name that begins
     and ends with hash marks (`#') is a possible auto-save file
     name, and any other name isn't.

          (make-auto-save-file-name)
               => "/xcssun/users/rms/lewis/#file.texinfo#"
          (auto-save-file-name-p "#file.texinfo#")
               => 0
          (auto-save-file-name-p "file.texinfo")
               => nil

       In the standard release, the body of this function consists of
     the following line:

          (string-match "^#.*#$" filename)

       This function exists so that you can customize it if you wish to
     change the naming convention for auto-save files.

 * Function: make-auto-save-file-name

       This function returns the file name to use for auto saving the
     current buffer.  This is just the file name with hash marks
     (`#') appended and prepended to it.

       This function does not look at the variable
     `auto-save-visited-file-name'; that should be checked before
     this function is called.

          (make-auto-save-file-name)
               => "/xcssun/users/rms/lewis/#file-backup.texinfo#"

       The body of `make-auto-save-file-name' consists of the following
     lines:

          (if buffer-file-name
              (concat (file-name-directory buffer-file-name)
                      "#"
                      (file-name-nondirectory buffer-file-name)
                      "#")
            (expand-file-name (concat "#%" (buffer-name) "#"))))

       This exists as a separate function so that you can redefine it
     to customize the naming convention for auto-save files.  Be sure
     to change `auto-save-file-name-p' in a corresponding way.

 * Variable: auto-save-visited-file-name

       If this global variable is non-`nil', then Emacs will auto save
     buffers in the files they are visiting.  That is, the same name
     is used as the file currently has.  Normally, this variable is
     `nil', so auto-save files have distinct names that are created
     by `make-auto-save-file-name'.

 * Function: recent-auto-save-p

       This function returns `t' if the current buffer has been
     auto-saved since the last time it was read in or saved.

 * Function: set-buffer-auto-saved

       This function marks the current buffer as auto-saved.  The
     buffer will not be auto-saved again until the buffer text is
     changed again.  The function returns `nil'.

 * Option: auto-save-interval

       The value of this variable is the number of characters that
     Emacs may read from the keyboard between auto-saves.  When this
     number is reached, then Emacs will auto-save each file again.

 * Option: auto-save-default

       If this variable is non-`nil', buffers that are visiting files
     have auto-saving enabled by default.  Otherwise, they do not.

       You can enable or disable auto-saving in any buffer with the
     command `auto-save-mode'.

 * Command: do-auto-save &optional NO-MESSAGE

       This function auto-saves all buffers that need to be auto-saved.
     This is all buffers for which auto-saving is enabled and that
     have been changed since the last time they were auto-saved.

       If NO-MESSAGE is non-`nil', then Emacs will not print out its
     standard message: `Auto-saving...'.

 * Function: delete-auto-save-file-if-necessary

       This function deletes the auto-save files for the current buffer
     if variable `delete-auto-save-files' is non-`nil'.  This
     function is called every time you save the buffer.

 * Variable: delete-auto-save-files

       This global variable is used by the function
     `delete-auto-save-file-if-necessary'.  If it is non-`nil', then
     auto-save files for the buffers will be deleted when you save
     the buffer.

       In other words, if the value of `delete-auto-save-files' is
     non-`nil', Emacs will delete auto-save files when a true save is
     done (in the visited file).  This saves on disk space and
     unclutters your directory.

 * Function: rename-auto-save-file

       This function adjusts the current buffer's auto-save file name
     for current conditions.  Assuming that the visited file has been
     renamed, this function renames the auto-save file, too.  If the
     visited file name has not changed, this function does nothing.



File: lispref,  Node: Reverting,  Prev: Auto Saving,  Up: Backups and Auto Saving

Reverting
=========

  If you have made extensive changes to a file and then change your
mind about them, you can get rid of them by reading in the previous
version of the file with the `revert-buffer' command.  *Note :
(emacs)Reverting.

 * Command: revert-buffer &optional NO-AUTOSAVE-OFFER-P NOCONFIRM

       This command replaces the buffer text with the text of the
     visited file on disk.  This action undoes all changes since the
     file was visited or saved.  If the latest auto-save file is more
     recent than the visited file, Emacs asks the user whether to use
     that instead.

       When the value of the NO-AUTOSAVE-OFFER-P argument is non-`nil',
     Emacs does not offer to use the auto-save file.  This argument
     is the prefix argument when the function is called interactively.

       When the value of the NOCONFIRM argument is non-`nil', Emacs
     does not ask for confirmation for the reversion action.  This
     means that the buffer is deleted and replaced by the text from
     the file on the disk, without asking the user if he or she
     really wants that.

       If the value of the `revert-buffer-function' variable is
     non-`nil', it is called as a function to do the work.

 * Variable: revert-buffer-function

       The value of this variable is the function to use to revert this
     buffer; but if the value of this variable is `nil', then the
     `revert-buffer' function carries out its default action.

       Modes such as Dired mode, in which the text being edited does
     not consist of a file's contents but can be regenerated, set
     this variable locally.

 * Command: recover-file FILENAME

       This function visits FILENAME, but gets the contents from its
     last auto-save file.

       The `after-find-file' function displays a message suggesting the
     use of `recover-file' if the auto-save file is newer than the
     file just visited.  This situation may be the result of a crash.
     By using `recover-file', you may recover a great deal of work.

       An error is signaled if there is no auto-save file for FILENAME,
     or if FILENAME is newer than its auto-save file.  If FILENAME
     does not exist, but its auto-save file does, that is ok.  This
     last situation may occur if you visited a nonexistent file and
     never actually saved it.

       This function is for interactive use.



File: lispref,  Node: Buffers,  Next: Windows,  Prev: Backups and Auto Saving,  Up: Top

Buffers
*******

  A "buffer" is a Lisp object containing characters.  Buffers are used
to hold the contents of files that have been visited; there may also
be buffers which are not visiting files.  While several buffers may
exist at one time, exactly one buffer is designated the "current
buffer" at any time.  Most editing commands act on the contents of
the current buffer.  Each buffer, including the current buffer, may
or may not be displayed in a window.

* Menu:

* Buffer Basics::       What is a buffer?
* Buffer Names::        Accessing and changing buffer names.
* Buffer File Name::    The buffer file name indicates which file is visited.
* Buffer Contents::     Access to the text in a buffer, and its size.
* Buffer Modification:: A buffer is "modified" if it needs to be saved.
* Modification Time::   Determining whether the visited file was changed
                         ``behind Emacs's back''.
* Read Only Buffers::   Modifying text is not allowed in a read-only buffer.
* The Buffer List::     How to look at all the existing buffers.
* Creating Buffers::    Functions that create buffers.
* Killing Buffers::     Buffers exist until explicitly killed.
* Changing Buffers::    Making a buffer current, or displaying it in a window.

 

File: lispref,  Node: Buffer Basics,  Next: Buffer Names,  Prev: Buffers,  Up: Buffers

Buffer Basics
=============

  Buffers in Emacs editing are conceptual objects which have distinct
names and hold text that can be edited.  Buffers appear to Lisp
programs as a special data type.

  The contents of a buffer may be viewed as an extendible string. 
Insertions and deletions may occur in any part of the buffer.

  A Lisp buffer object contains numerous pieces of information.  Some
of this information is directly accessible to the programmer through
variables; other information is only accessible through functions
that modify it or return it.  For example, the width of a tab
character is directly accessible through a variable, while the value
of point is accessible only through a primitive function.

  Buffer-specific information that is directly accessible is stored in
"buffer-local" variables.  These buffer-local bindings exactly
parallel the global value cell of a symbol, if any, but they are
``seen'' by the evaluator before the actual global value cell.  This
means you can set buffer-local variables, such as `fill-column' or
`comment-column', to different values for different buffers.  For
more information about buffer-local variables and functions that
relate to them, see *Note Buffer Local Variables::.

  For functions and variables that relate to saving the contents of
buffers to files, see *Note Writing to Files::.  For functions and
variables that relate to the display of buffers in windows, see *Note
Windows::.

 * Function: bufferp OBJECT

       This function returns `t' if OBJECT is a buffer, `nil' otherwise.

 * Function: current-buffer

       This function returns the current buffer.  There is always one
     and only one buffer designated the current buffer.  Many editing
     commands act on the current buffer.  It need not be displayed in
     a window.

          (current-buffer)
               => #<buffer buffers.texinfo>



File: lispref,  Node: Buffer Names,  Next: Buffer File Name,  Prev: Buffer Basics,  Up: Buffers

Buffer Names
============

  Each buffer has a unique name, which is a string.  The buffer name
may be used in place of the buffer object in many functions that
operate on buffers.  Buffers that are generally ephemeral and
uninteresting to the user have names starting with a space; this
prevents the buffer from being listed by the `list-buffers' or
`buffer-menu' commands.

  Many of the following functions accept either a buffer or a buffer
name (a string) as an argument.  Any argument called BUFFER-OR-NAME
is assumed to be one or the other, and an error is signaled if it is
not.  Any argument called BUFFER must be an actual buffer object, not
a string.

 * Function: buffer-name &optional BUFFER

       This function returns the name of BUFFER as a string.  If BUFFER
     is not supplied, it defaults to the current buffer.

       If `buffer-name' returns `nil', it means that BUFFER has been
     killed.

          (buffer-name)
               => "buffers.texinfo"
          
          (setq foo (get-buffer "temp"))
               => #<buffer temp>
          (kill-buffer foo)
               => nil
          (buffer-name foo)
               => nil
          foo
               => #<killed buffer>

 * Command: rename-buffer NEWNAME

       This function renames the current buffer to NEWNAME.  An error
     is signaled if NEWNAME is not a string, or if there is already a
     buffer with that name.  It returns `nil'.

       One use of this command is to rename the `*shell*' buffer to
     some other name, which makes it possible for you to create a
     second shell buffer with its own shell.

 * Function: get-buffer BUFFER-OR-NAME

       This function returns the buffer BUFFER-OR-NAME.  If
     BUFFER-OR-NAME is a string and there is no buffer with that
     name, `nil' is returned.

       The argument passed to `get-buffer' is almost always the name of
     a buffer.  Although BUFFER-OR-NAME may be a buffer, this would
     not be very useful.

          (setq b (get-buffer "lewis"))
               => #<buffer lewis>
          (get-buffer b)
               => #<buffer lewis>
          (get-buffer "Frazzle-nots")
               => nil



File: lispref,  Node: Buffer File Name,  Next: Buffer Contents,  Prev: Buffer Names,  Up: Buffers

Buffer File Name
================

  The "buffer file name" is the name of the file that is visited in
that buffer.  When a buffer is not visiting a file, its buffer file
name is `nil'.  Most of the time, the buffer name is the same as the
last part of the buffer file name; but the buffer file name and the
buffer name are distinct, and can be set independently.

  For functions and variables that relate to saving the contents of
buffers to files, see *Note Writing to Files::.

 * Function: buffer-file-name &optional BUFFER

       This function returns the absolute file name of the file that
     the buffer is visiting.  If BUFFER is not supplied, it defaults
     to the current buffer.  If the buffer is not visiting any file,
     this returns `nil'.

          (buffer-file-name (other-buffer))
               => "/usr/user/lewis/manual/files.texinfo"

 * Variable: buffer-file-name

       This buffer-local variable contains the name of the file being
     visited in the current buffer, or `nil' if it is not visiting a
     file.

          buffer-file-name
               => "/usr/user/lewis/manual/buffers.texinfo"

       It is risky to change this variable's value without doing
     various other things.  See the definition of
     `set-visited-file-name'; some of the things done there, such as
     changing the buffer name, are not necessary, but others are
     essential to avoid confusing Emacs.

 * Function: get-file-buffer FILENAME

       This function returns the buffer visiting file FILENAME.  If
     there is no such buffer, it returns NIL.  FILENAME must be a
     string.  It will be expanded (*note File Name Expansion::.) and
     then compared against the visited file names of all live buffers.

          (get-file-buffer "buffers.texinfo")
          => #<buffer buffers.texinfo>

       In unusual circumstances, there can be more than one buffer
     visiting the same file name.  In such cases, this function
     returns the first such buffer in the buffer list.

 * Command: set-visited-file-name FILENAME

       This function changes the name of the file visited in current
     buffer to FILENAME.  FILENAME should be a non-empty string.  If
     the buffer had no visited file, this gives it one.  The *next
     time* the buffer is saved it will go in the newly specified
     file.  The buffer is always marked as modified, since it does
     not (as far as Emacs knows) match the contents of the new
     visited file, even if it matched its former visited file.

       If FILENAME is `nil' or the empty string, that stands for ``no
     visited file''.  In this case, the buffer will not have a
     visited file when this function returns, whether or not it had
     one previously.  Also see `clear-visited-file-modtime' and
     `verify-visited-file-modtime' in *Note Buffer Modification::.

       When `set-visited-file-name' is called interactively, Emacs
     prompts for FILENAME in the minibuffer.



File: lispref,  Node: Buffer Contents,  Next: Buffer Modification,  Prev: Buffer File Name,  Up: Buffers

Buffer Contents
===============

  The following functions return information about the buffer contents,
including their limits.  *Note Text::, for functions that modify the
contents, and *Note Searching and Matching::, for functions that
search the contents.

 * Function: buffer-substring START END

       This function returns a string containing a copy of the text of
     the region defined by positions START and END in the current
     buffer.  If the arguments are not between the values returned by
     `(point-min)' and `(point-max)', Emacs signals an
     `args-out-of-range' error.

       It is not necessary for START to be less than END; the arguments
     can be given in either order.  But normally the smaller argument
     is written first.

          --------- Buffer: foo ---------
          This is the contents of buffer foo
          
          --------- Buffer: foo ---------
          
          (buffer-substring 1 10)
          => "This is t"
          (buffer-substring (point-max) 10)
          => "he contents of buffer foo
          "

 * Function: buffer-string

       This function returns the contents of the visible portion of the
     current buffer as a string.  This is the portion between
     `(point-min)' and `(point-max)'.

          --------- Buffer: foo ---------
          This is the contents of buffer foo
          
          --------- Buffer: foo ---------
          
          (buffer-string)
               => "This is the contents of buffer foo
          "

 * Function: buffer-size

       This function returns the total number of characters in the
     current buffer.  This number is one less than the number
     `point-max' returns in the absence of a clipping restriction
     (*note Clipping Restrictions::.).

          (buffer-size)
               => 35
          (point-max)
               => 36

 * Variable: buffer-saved-size

       The value of this buffer-local variable is the length of the
     current buffer, as of when it was last read in, saved or
     auto-saved.

 * Function: buffer-end FLAG

       This function returns `(point-min)' if FLAG is less than `1',
     `(point-max)' otherwise.  FLAG must be a number.

 * Function: point-min

       This function returns the minimum accessible value of point in
     the current buffer.  This is `1', unless a clipping restriction
     is in effect, in which case it is the position of the start of
     the clipping restriction.  (*Note Clipping Restrictions::.)

 * Function: point-max

       This function returns the maximum accessible value of point in
     the current buffer.  This is `(1+ (buffer-size))', unless a
     clipping restriction is in effect, in which case it is the
     position of the end of the clipping restriction.  (*Note
     Clipping Restrictions::).



File: lispref,  Node: Buffer Modification,  Next: Modification Time,  Prev: Buffer Contents,  Up: Buffers

Buffer Modification
===================

  Emacs keeps a flag called the "modified flag" for each buffer, to
record whether you have changed the text of the buffer.  This flag is
set to `t' whenever you alter the contents, and cleared to `nil' when
you save the buffer.  Thus, the flag shows whether there are unsaved
changes.  The flag value is normally shown in the mode line (*note
Mode Line Variables::.), and controls saving (*note Saving
Buffers::.) and auto-saving (*note Auto Saving::.).

  Some Lisp programs set the flag explicitly.  For example, the Lisp
function `set-visited-file-name' sets the flag to `t'.  This is
because the text does not match the new visited file, even if it is
unchanged since some other file was visited in the buffer.

  The functions that modify buffers are described in *Note Text::.

 * Function: buffer-modified-p &optional BUFFER

       This function returns `t' if the buffer has been modified since
     it was last read in from a file or saved, or `nil' otherwise. 
     If BUFFER is not supplied, the current buffer is tested.

 * Function: set-buffer-modified-p FLAG

       This function marks the current buffer as modified if FLAG is
     non-`nil'.  It marks the buffer as unmodified if the flag is
     `nil'.

       Another effect of calling this function is to cause redisplay of
     the mode line for the current buffer, unconditionally.

 * Command: not-modified

       Mark current buffer as unmodified, not needing to be saved. 
     Don't use this function in programs, since it prints a message! 
     Use `set-buffer-modified-p' (above) instead.



File: lispref,  Node: Modification Time,  Next: Read Only Buffers,  Prev: Buffer Modification,  Up: Buffers

Comparison of Modification Time
===============================

  If you visit a file and make changes in the buffer, and meanwhile the
file itself is changed on disk, saving the buffer would overwrite the
changes in the file.  Occasionally, if the file was changed
inadvertently, this may be what you want.  Most of the time, it would
lose valuable information.  Emacs therefore checks the file's
modification time using the functions described below before saving
the file.

 * Function: verify-visited-file-modtime BUFFER

       This function compares Emacs's record of the modification time
     for the file that the buffer is visiting and compares it to the
     actual modification time of the file as recorded by the
     operating system.  The two will be the same unless some other
     process has written the file since Emacs visited or saved it.

       The function returns `t' if the last actual modification time
     and Emacs's recorded modification time are the same, `nil'
     otherwise.

 * Function: clear-visited-file-modtime

       This function clears out the record of the last modification
     time of the file being visited by the current buffer.  This
     means that the next attempt to save this buffer will certainly
     not complain of a discrepancy among file modification times.

       This function is called in `set-visited-file-name' and other
     exceptional places where the usual test to avoid overwriting a
     changed file should not be done.

 * Function: ask-user-about-supersession-threat FN

       Ask a user who is about to modify an obsolete buffer what to do.
     An "obsolete buffer" is an unmodified buffer for which the
     associated file on disk is newer than the last save-time of the
     buffer.  This means some other program has probably altered the
     file.

       This function is called automatically by Emacs on the proper
     occasions.  You can redefine this function to do what you prefer.

       Depending on the user's answer, the function may return
     normally, in which case the modification of the buffer proceeds,
     or it may signal a `file-supersession' error (with data `(FN)'),
     in which case the proposed buffer modification is not allowed.



File: lispref,  Node: Read Only Buffers,  Next: The Buffer List,  Prev: Modification Time,  Up: Buffers

Read-Only Buffers
=================

  A buffer may be designated as "read-only".  This means that the
buffer's contents may not be modified, although you may change your
view of the contents by scrolling, narrowing, or widening, etc.

  Read-only buffers are used in two kinds of situations:

   * A buffer visiting a file is made read-only if the file is
     write-protected.

     Here, the purpose is to show the user that editing the buffer is
     probably futile.  If the user wants to make changes anyway, he
     or she can use `toggle-read-only'.

   * Modes such as Dired and Rmail make buffers read-only when
     altering the contents with the usual editing commands is
     probably a mistake.

     The special commands of the mode in question bind
     `buffer-read-only' to `nil' (with `let') around the places where
     they change the text.

 * Variable: buffer-read-only

       This buffer-local variable specifies whether the buffer is
     read-only.  The buffer is read-only if this variable is non-`nil'.

 * Command: toggle-read-only

       This command changes whether the current buffer is read-only,
     regardless of whether it is visiting a file.

       This command is intended for interactive use.  Don't use it in
     programs!  In a program, you should know, at any given point,
     whether you want the read-only flag on or off; so set
     `buffer-read-only' explicily to the proper value, `t' or `nil'.

 * Function: barf-if-buffer-read-only

       This function signals a `buffer-read-only' error if the current
     buffer is read-only.  *Note Interactive Call::, for another way
     to signal an error if the current buffer is read-only.



File: lispref,  Node: The Buffer List,  Next: Creating Buffers,  Prev: Read Only Buffers,  Up: Buffers

The Buffer List
===============

  The "buffer list" is a list of all buffers that have not been killed.
The order of the buffers in the list is based primarily on how
recently each buffer has been displayed in the selected window. 
Several functions, notably `other-buffer', make use of this ordering.

 * Function: buffer-list

       This function returns a list of all buffers, including those
     whose names begin with a space.  The elements are actual
     buffers, not their names.

          (buffer-list)
               => (#<buffer buffers.texinfo> #<buffer  *Minibuf-1*>
                   #<buffer buffer.c>  #<buffer *Help*> #<buffer TAGS>)
          
          ;; Notice the name of the minibuffer begins with a space!
          
          (mapcar (function buffer-name) (buffer-list))
          => ("buffers.texinfo" " *Minibuf-1*" "buffer.c" "*Help*" "TAGS")

 * Command: list-buffers &optional FILES-ONLY

       This function displays a listing of the names of existing
     buffers.  It clears the buffer `*Buffer List*', then inserts the
     listing into that buffer and displays it in a window.

       All buffers that have names starting with spaces are omitted
     from the display.

       If FILES-ONLY is non-`nil', then the list shows only buffers
     that are visiting files.

       In the listing, the current buffer has a dot in the first column.
     If the column labeled `M' contains a `*', then that buffer has
     been modified.  If the column labeled `R' contains a `%', then
     that buffer is `read-only'.

       `list-buffers' returns `nil'.

       The buffers are listed in the order that they appear in the
     buffer list.  This is the order in which they are chosen as the
     default buffer by such functions as `other-buffer'.

          (list-buffers)
               => nil
          
          --------- Buffer: *Buffer List* ---------
           MR Buffer         Size  Mode           File
           -- -----         ---  ---           ---
          .*  buffers.texinfo  17870 Texinfo      /lewis/buffers.texinfo
              buffer.c       43204 C              /lewis/buffer.c
           *  *Help*         131   Fundamental
              TAGS           190930 Fundamental   /lewis/TAGS
           *% *Buffer List*  0     Buffer Menu
          --------- Buffer: *Buffer List* ---------
          
          (list-buffers t)
               => nil
          
          --------- Buffer: *Buffer List* ---------
           MR Buffer         Size  Mode           File
           -- -----         ---  ---           ---
          .*  buffers.texinfo  17870 Texinfo      /lewis/buffers.texinfo
              buffer.c       43204 C              /lewis/buffer.c
            % TAGS           190930 Fundamental   /lewis/TAGS
          --------- Buffer: *Buffer List* ---------

 * Command: bury-buffer &optional BUFFER-OR-NAME

       This function puts BUFFER-OR-NAME at the end of the buffer list
     without changing the order of any of the other buffers on the
     list.  There it is the least desirable candidate for
     `other-buffer' to return, and appears last in the list displayed
     by `list-buffers'.

       If BUFFER-OR-NAME is not supplied, it defaults to the current
     buffer.

       If BUFFER-OR-NAME is the current buffer, then it is replaced in
     the selected window by the buffer selected by `other-buffer'. 
     If the buffer is displayed in a window other than the selected
     one, it remains there.

       When called interactively, this function buries the current
     buffer.

 * Function: other-buffer &optional BUFFER-OR-NAME

       This function returns the buffer first buffer in the buffer list
     other than BUFFER-OR-NAME.  Usually this is the buffer most
     recently shown in the selected window, aside from
     BUFFER-OR-NAME, but  buffers that are buried are moved to the
     end of the list.  Also, buffers whose names start with a space
     do not count.

       If BUFFER-OR-NAME is not supplied (or if it is not a buffer),
     then `other-buffer' returns the first buffer on the buffer list
     that is not visible in any window.

       If no other buffer exists, the buffer `*scratch*' is returned
     (and created, if necessary).



File: lispref,  Node: Creating Buffers,  Next: Killing Buffers,  Prev: The Buffer List,  Up: Buffers

Creating Buffers
================

  This section describes the two primitives for creating buffers. 
`get-buffer-create' creates a buffer if it finds no existing buffer;
`generate-new-buffer' always creates a new buffer, and gives it a
unique name.

  Two other functions to create buffers are
`with-output-to-temp-buffer' (*note Temporary Displays::.) and
`create-file-buffer' (*note Visiting Files::.).

 * Function: get-buffer-create NAME

       This function returns a buffer named NAME.  If such a buffer
     already exists, it is returned.  If such a buffer does not
     exist, one is created and returned.  The buffer does not become
     the current buffer--this function does not change which buffer
     is current.

       An error is signaled if NAME is not a string.

          (get-buffer-create "foo")
               => #<buffer foo>

 * Function: generate-new-buffer NAME

       This function returns a newly created, empty buffer.  If there
     is no buffer named NAME, then that is the name of the new
     buffer.  If there is a buffer with that name, then suffixes of
     the form `<N>' are added to NAME, where N stands for successive
     integers starting with 2.  New suffixes are tried until an
     unused name is found.

       An error is signaled if NAME is not a string.

          (generate-new-buffer "bar")
               => #<buffer bar>
          (generate-new-buffer "bar")
               => #<buffer bar<2>>
          (generate-new-buffer "bar")
               => #<buffer bar<3>>



File: lispref,  Node: Killing Buffers,  Next: Changing Buffers,  Prev: Creating Buffers,  Up: Buffers

Killing Buffers
===============

  "Killing a buffer" makes its name unknown to Emacs and makes its
space available for other use.

  The buffer object for the buffer which has been killed remains in
existence as long as anything refers to it; but it is marked
specially so that you cannot make it current or display it.  Killed
buffers retain their identity, however; two distinct buffers, when
killed, remain distinct according to `eq'.

  The `buffer-name' of a killed buffer is `nil'.  You can use this
feature to test whether a buffer has been killed:

     (defun killed-buffer-p (buffer)
       "Return t if BUFFER is killed."
       (not (buffer-name buffer)))

 * Command: kill-buffer BUFFER-OR-NAME

       This function kills the buffer BUFFER-OR-NAME, freeing all its
     memory for use as space for other buffers.  (In Emacs version
     18, the memory is not returned to the operating system.)  It
     returns `nil'.

       If the buffer is visiting a file when `kill-buffer' is called
     and the buffer has not been saved since it was last modified,
     the user is asked if he or she *really* wants to kill the
     buffer.  This is done even if `kill-buffer' is not called
     interactively.  To prevent the request for confirmation, clear
     the modified flag before calling `kill-buffer'.

          (kill-buffer "foo.unchanged")
               => nil
          (kill-buffer "foo.changed")
          
          --------- Buffer: Minibuffer ---------
          Buffer foo.changed modified; kill anyway? (yes or no) yes
          --------- Buffer: Minibuffer ---------
          
               => nil



File: lispref,  Node: Changing Buffers,  Prev: Killing Buffers,  Up: Buffers

Changing Buffers
================

  There are two principle ways to change to another buffer: one way is
to make it "current"; the other is to "switch" to the buffer.

  The current buffer is the one in which most editing takes place; but
it is not necessarily displayed on the screen.  You may not be able
to see the current buffer.  Programs work on the current buffer--a
computer program does not have eyes and does not look at the buffer
on the screen.

  Switching to a buffer, on the other hand, not only makes the buffer
the current buffer, which is the one in which editing takes place; it
also displays the buffer in the selected window so you can see it. 
Humans must switch to a buffer they wish to work on since they have
to see what they are doing.

  Thus, directing Emacs's attention to a buffer means just one thing:
making it the current buffer; switching to a buffer means two things:
making it the current buffer, and displaying it on the screen.

  `set-buffer' changes the current buffer (i.e., makes another buffer
current), but leaves the buffer that was displayed in the selected
window still displayed.

  `switch-to-buffer' is an example of a switch command; it changes the
current buffer (the one in which editing takes place) and displays it
in the selected window (the one with the cursor in it).

  Note that when it comes time to get more keyboard input, or when
keyboard input is provided, the buffer displayed in the selected
window becomes the current buffer, regardless of previous calls to
`set-buffer'.  This prevents confusion: the buffer you see, when
Emacs reads a command, is the one to which your next command will
apply.  *Note Command Loop::.

  However, Lisp programs should not rely on this, because they may be
called as subroutines from other programs.  It is convenient for the
caller if the subroutine does not change the current buffer (unless,
of course, that is the subroutine's purpose).  Therefore, always use
`set-buffer' within a `save-excursion' that will restore the current
buffer when your program is done.  (*Note Excursions::.)  Here is an
example: the code for the command `append-to-buffer' (with the
documentation string abridged):

     (defun append-to-buffer (buffer start end)
       "Append to specified buffer the text of the region.
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))

In this function, a local variable is bound to the current buffer,
and then `save-excursion' records the values of point, mark, and the
original buffer.  Next, `set-buffer' makes a new buffer current. 
Finally, `insert-buffer-substring' copies the string from the
original current buffer to the new current buffer.  Because the
current buffer is not necessarily displayed in the selected window,
you normally cannot see the insertion.  To see it, you have to switch
to the other buffer.

 * Function: set-buffer BUFFER-OR-NAME

       This function makes BUFFER-OR-NAME the current buffer in which
     editing takes place.  However, it does not display the buffer in
     the currently selected window or in any other window.  This
     means that the user cannot necessarily see the buffer, but Lisp
     programs can work on it.

        This function returns the buffer identified by BUFFER-OR-NAME. 
     An error is signaled if BUFFER-OR-NAME does not identify an
     existing buffer.

       The `set-buffer' function is usually used within a
     `save-excursion', so that the previously current buffer will be
     restored when the program is done.  See the example above.

 * Command: switch-to-buffer BUFFER-OR-NAME &optional NORECORD

       This command makes BUFFER-OR-NAME the current buffer (the buffer
     in which editing takes place).  The command also displays the
     buffer in the selected window, which is the window with the
     cursor in it.  This means that a human can see the buffer and
     commands will apply to it.

       It returns `nil'.

       If BUFFER-OR-NAME does not identify an existing buffer, then a
     new buffer by that name is created.

       If NORECORD is non-`nil', then this buffer is not put on the
     front of the buffer list.  This affects the value of
     `other-buffer'.  *Note The Buffer List::.

       The `switch-to-buffer' function is often used interactively, as
     the binding of `C-x b'.  It is also used frequently in programs.

     (Contrast `switch-to-buffer' with `set-buffer', which makes
     BUFFER-OR-NAME the current buffer, but does not display it in
     the selected window.)

 * Command: switch-to-buffer-other-window BUFFER-OR-NAME

       This function makes BUFFER-OR-NAME be the current buffer and
     switches to it in another window, definitely not the window
     previously selected.  If there is only one window, then it is
     split to make a distinct window for this purpose--even if the
     one window is already displaying BUFFER-OR-NAME.

     The other window used becomes the selected window, with the
     cursor there.

 * Function: pop-to-buffer BUFFER-OR-NAME &optional OTHER-WINDOW

       This function makes BUFFER-OR-NAME be the current buffer and
     switches to it in some window, preferably not the window
     previously selected.  The ``popped-to'' window becomes the
     selected window.

       If the variable `pop-up-windows' is non-`nil', windows may be
     split to create a new window that is different from the original
     window.

       If OTHER-WINDOW is non-`nil', `pop-to-buffer' finds or creates
     another window even if BUFFER-OR-NAME is already visible in the
     selected window.  Thus BUFFER-OR-NAME could end up displayed in
     two windows.  On the other hand, if BUFFER-OR-NAME is already
     displayed in the selected window and OTHER-WINDOW is `nil',
     Emacs will stay with the same window.

       If BUFFER-OR-NAME is a string that does not name an existing
     buffer, a buffer by that name is created.

       An example use of this function is found at the end of *Note
     Filter Functions::.

 * Function: display-buffer BUFFER-OR-NAME &optional NOT-THIS-WINDOW

       This function makes BUFFER-OR-NAME appear in some window, like
     `pop-to-buffer', but it does not select that window and does not
     make the buffer current.  The selected window is unaltered by
     this function.

       If NOT-THIS-WINDOW is non-`nil' and BUFFER-OR-NAME is shown
     already in the selected window, then the buffer is displayed in
     a second window as well.  Otherwise, if BUFFER-OR-NAME is
     already shown in any window, that is good enough, so this
     function does nothing.

       If the variable `pop-up-windows' is non-`nil', windows can be
     split to display the buffer.  If there are multiple windows,
     `display-buffer' will split the largest window if it has more
     than the number of lines specified by the variable
     `split-height-threshold'.

       `display-buffer' returns the window displaying BUFFER-OR-NAME.

 * Option: pop-up-windows

       This global variable controls whether `display-buffer' may make
     new windows.  If it is `t' and there is only one window on the
     screen, then that window is split.  If it is `nil', then
     `display-buffer' does not split the single window, but rather
     replaces its buffer.

       This variable also affects `pop-to-buffer', which uses
     `display-buffer' as a subroutine.

 * Option: split-height-threshold

       This global variable determines when `display-buffer' may split
     a window, if there are multiple windows.  `display-buffer'
     splits the largest window if it has at least this many lines.

       If there is only one window, it is split regardless of this
     value, provided `pop-up-windows' is non-`nil'.



File: lispref,  Node: Windows,  Next: Positions,  Prev: Buffers,  Up: Top

Windows
*******

  This chapter describes most of the functions and variables related to
Emacs windows.  However, see *Note Emacs Display::, and *Note
Changing Buffers::, for more information.

* Menu:

* Basic Windows::          Basic information on using windows.
* Splitting Windows::      Splitting one window into two windows.
* Deleting Windows::       Deleting a window gives its space to other windows.
* Selecting Windows::      The selected window is the one that you edit in.
* Cyclic Window Ordering:: Moving around the existing windows.
* Buffers and Windows::    Each window displays the contents of a buffer.
* Window Point::           Each window has its own location of point.
* Vertical Scrolling::     Moving the window up and down in its buffer.
* Horizontal Scrolling::   Moving text sideways on the window.
* Size of Window::         Accessing and changing the size of a window.
* Window Configurations::  Saving and restoring the state of the screen.

 

File: lispref,  Node: Basic Windows,  Next: Splitting Windows,  Prev: Windows,  Up: Windows

Basic Concepts of Emacs Windows
===============================

  A "window" is the physical area of a terminal in which a buffer is
displayed.  But the term is also used to refer to a Lisp object. 
Which is meant should be clear from the context.

  There is always at least one window displayed on the screen, and
there is exactly one window that we call the "selected window".  The
cursor is in the selected window.  The selected window's buffer is
usually the current buffer; the exception is when `set-buffer' has
been used.  (*Note Changing Buffers::.)

  For all intents, a window only exists while it is displayed on the
terminal.  Once removed from the display, the window is effectively
deleted and should not be used, *even though there may still be
references to it* from other Lisp objects.  (*Note Deleting Windows::.)

  Each window has the following attributes:

   * window height

   * window width

   * window edges with respect to the screen

   * the buffer it displays

   * position within the buffer at the upper left of the window

   * how many horizontally scrolled columns

   * point

   * mark

   * how recently this window was selected

  Applications use multiple windows for a variety of reasons, but most
often to give different views of the same object.  In Rmail, for
example, you can move through a summary buffer in one window, while
the other window shows messages one at a time, as you reach them.

  For information about other techniques, see *Note Major Modes:
(emacs)Major Modes.  Also, see *Note  Key Bindings: (emacs)Key
Bindings.

  Use of the word ``window'' to refer to a view of a buffer was
established long ago in Emacs.  The metaphor was inspired by how you
look out a house window--at part (or sometimes all) of an overall view.
You see part (or sometimes all) of a buffer through an Emacs window. 
In Emacs, each window may look on a different view, like different
windows of a house.

  The term ``window'' as used in this manual means something different
from the term as used in a window system like X.  In this manual, the
term ``window'' refers to the nonoverlapping subdivisions of the
Emacs display.  If Emacs is displaying on a window system, the Emacs
display may itself be one window among many on the screen.  But Emacs
version 18 knows nothing of that.

  For those familiar with windowing systems, Emacs's windows are
rectangles tiled onto the rectangle of the screen, and every portion
of the screen is part of some window, except (sometimes) the
minibuffer area.  This limitation helps avoid wasting the
historically scarce resource of screen space.  It also works well
with character-only terminals.  Because of the way in which Emacs
creates new windows and resizes them, you can't create every
conceivable tiling on an Emacs screen.  *Note Splitting Windows::. 
Also, see *Note Size of Window::.

  *Note Emacs Display::, for functions related to the Emacs screen.

 * Function: windowp OBJECT

       This function returns `t' if object is a window.



File: lispref,  Node: Splitting Windows,  Next: Deleting Windows,  Prev: Basic Windows,  Up: Windows

Splitting Windows
=================

  The functions described here are the primitives to split a window
into two windows.  Two higher level functions can also do this:
`pop-to-buffer' and `display-buffer' (*note Changing Buffers::.).

  The distinction between these functions and the `pop-to-buffer' and
`display-buffer' functions is that the latter refer specifically to
buffers, while the functions described in this section do not.  These
functions let the two ``halves'' of the split window display the
previously visible buffer in the window that was split.

  The `split-window-horizontally' and the `split-window-vertically'
functions described in this section are interfaces to the
`split-windows' function.

 * Function: one-window-p &optional NO-MINI

     This function returns non-`nil' if there is only one window. 
     Optional argument NO-MINI, if non-`nil', means don't count the
     minibuffer even if it is active.

 * Command: split-window &optional WINDOW SIZE HORIZONTAL

     This function splits WINDOW into two, leaving SIZE lines in
     WINDOW (which becomes the top window), and putting the rest of
     the lines that WINDOW had into a new window.

     `split-window' returns the new window.  The original window,
     WINDOW, remains the selected window.

       If HORIZONTAL is non-`nil', then WINDOW splits side by side,
     leaving SIZE columns in WINDOW (which becomes the left-hand
     window), and putting the rest of the columns that WINDOW had
     into the new window.

       If WINDOW is omitted, then the selected window is split.

       If SIZE is omitted, then WINDOW is divided evenly into two
     parts.  (If there is an odd line, it is allocated to the new
     window.)

       When `split-window' is called interactively, WINDOW defaults to
     the selected window, and SIZE and HORIZONTAL default to `nil'.

       The following example starts with one window on a screen that is
     50 lines high by 80 columns wide; then the window is split. 
     (*note Window Point::.).

          (setq w (selected-window))
               => #<window 8 on windows.texinfo>
          (window-edges)               ; Edges in order: left--top--right--bottom
               => (0 0 80 49)
          
          (setq w2 (split-window w 15))   ; Returns window created
               => #<window 28 on windows.texinfo>
          (window-edges w2)
               => (0 15 80 49)  ; Bottom window; top is line 15
          (window-edges w)
               => (0 0 80 15)   ; Top window

     The screen looks like this:

                   __________   line 0
                  |          |  
                  |    w     |
                  |__________|  line 15
                  |          |
                  |    w2    |
                  |__________|  line 49
          
           column 1   column 80

     Next, the top window is split horizontally:

          (setq w3 (split-window w 35 t))
               => #<window 32 on windows.texinfo>
          (window-edges w3)
               => (35 0 80 15)  ; Left edge at column 35
          (window-edges w)
               => (0 0 35 15)   ; Right edge at column 35
          (window-edges w2)
               => (0 15 80 49)  ; Bottom window unchanged

     Now, the screen looks like this:

               column 35
                   __________   line 0
                  |   |      |  
                  | w |  w3  |
                  |___|______|  line 15
                  |          |
                  |    w2    |
                  |__________|  line 49
          
           column 1   column 80

 * Command: split-window-vertically SIZE

       This function splits the selected window into two, one above the
     other, leaving the selected window with SIZE lines.

       This function is simply an interface to `split-windows'.  Here
     is the complete function definition for it:

          (defun split-window-vertically (&optional arg)
            "Split selected window into two windows, one above the other.
          This window becomes the uppermost of the two, and gets
          ARG lines.  No arg means split equally."
            (interactive "P")
            (split-window nil (and arg (prefix-numeric-value arg))))

 * Command: split-window-horizontally SIZE

       This function splits the selected window into two, side-by-side,
     leaving the selected window with SIZE lines.

       This function is simply an interface to split-windows.  Here is
     the complete definition for `split-window-horizontally', except
     that part of the documentation has been deleted to save space:

          (defun split-window-horizontally (&optional arg)
            "Split selected window into two windows side by side."
            (interactive "P")
            (split-window nil (and arg (prefix-numeric-value arg)) t))



File: lispref,  Node: Deleting Windows,  Next: Selecting Windows,  Prev: Splitting Windows,  Up: Windows

Deleting Windows
================

  A "deleted window" no longer appears on the screen.  In Emacs
version 18, the space it took up is divided proportionally among all
siblings; in version 19, the space is given to one adjacent sibling.

 * Command: delete-window &optional WINDOW

       This function removes WINDOW from the display.  If WINDOW is
     omitted, then the selected window is deleted.  An error is
     signaled if there is only one window being displayed when
     `delete-window' executes.

          *Warning:* erroneous information or fatal errors may result
          by using a deleted window.  You can test whether a window
          has been deleted with `(window-point WINDOW)', which
          returns `nil' for a deleted window.

       This function returns `nil'.

       When `delete-window' is called interactively, WINDOW defaults to
     the selected window.

 * Command: delete-other-windows WINDOW

       This function makes WINDOW the only window on the screen by
     deleting all the other windows.  If WINDOW is omitted, then the
     selected window is the one remaining.

       The result is `nil'.

 * Command: delete-windows-on BUFFER

       This function deletes all windows showing BUFFER.  If there are
     no windows showing BUFFER, then this function does nothing.  If
     all windows are showing BUFFER (including the case where there
     is only one window), then the screen reverts to having a single
     window showing the buffer chosen by `other-buffer'.  *Note The
     Buffer List::.

       If there are several windows showing different buffers, then
     those showing BUFFER are removed, and the others are expanded to
     fill the void.

       The result is `nil'.



File: lispref,  Node: Selecting Windows,  Next: Cyclic Window Ordering,  Prev: Deleting Windows,  Up: Windows

Selecting Windows
=================

When a window is selected, the buffer in the window becomes the
current buffer.  The cursor will appear in it.

 * Function: selected-window

       This function returns the selected window.  This is the window
     in which the cursor appears and to which many commands apply.

 * Function: select-window WINDOW

       This function makes WINDOW the selected window.  The cursor then
     appears in WINDOW (on redisplay).  The current buffer changes to
     WINDOW's buffer

       It returns WINDOW.

          (setq w (next-window))
          (select-window w)
               => #<window 65 on windows.texinfo>

  Often you want to try to select the ``best'' window.  These functions
give you a choice of criteria with which to choose.

 * Function: get-lru-window

       This function returns the window least recently used or selected
     for display.  The selected window is always the most recently
     used window.

       The selected window can be the least recently used window if it
     is the only window.  A newly created window becomes the least
     recently used window until it is selected.  The minibuffer
     window is never returned by this function.

 * Function: get-largest-window

       This function returns the window with the largest area (height
     times width).  If the screen is not divided horizontally, then
     this is just the window with the most lines.

       If there are two windows of the same size, then the function
     returns the window which is first in the cyclic ordering of
     windows (see following section), starting from the selected
     window.  The minibuffer is never considered for ``largest''.



File: lispref,  Node: Cyclic Window Ordering,  Next: Buffers and Windows,  Prev: Selecting Windows,  Up: Windows

Cycling Ordering of Windows
===========================

  When you use the command `C-x o' (`other-window') to move to the next
window, it moves through all the windows on the screen in cyclic
order.  For any given configuration of windows, this order never
varies.  It is called the "cyclic ordering of windows".

  This ordering generally goes from top to bottom, and from left to
right.  But it may go down first or go right first, depending on the
order in which the screen or the windows within the screen were split.

  If the screen was first split vertically (into windows one above each
other), and then the subwindows were split horizontally, then the
ordering is left to right in the top, and then left to right in the
next lower part of the screen, and so on.  If the screen was first
split horizontally, the ordering is top to bottom in the left part,
and so on.  In general, within each set of siblings at any level in
the window tree, the order is left to right, or top to bottom.

 * Function: next-window WINDOW &optional MINIBUF

       This function returns the next window after WINDOW in the cyclic
     ordering of windows.  This is the window which `C-x o' would
     select if done when WINDOW is selected.

     The value of the argument MINIBUF determines whether the
     minibuffer is in the window order.  Normally, when MINIBUF is
     `nil', the minibuffer is included if it is currently active;
     this is the behavior of `C-x o'.  *Note Minibuffers::, for what
     it means for the minibuffer to be active.

       If MINIBUF is `t', then the cyclic ordering includes the
     minibuffer window even if it is not active.  If MINIBUF is
     neither `t' nor `nil', then the minibuffer window is not
     included even if it is active.

       In the example, there are two windows in existence.  They both
     happen to be displaying the same buffer.

          (selected-window)
               => #<window 56 on windows.texinfo>
          (next-window (selected-window))
               => #<window 52 on windows.texinfo>
          (next-window (next-window (selected-window)))
               => #<window 56 on windows.texinfo>

       If WINDOW is the only window visible, then this function returns
     WINDOW.

 * Function: previous-window WINDOW

       This function returns the window preceding WINDOW in the cyclic
     ordering of windows.

 * Command: other-window COUNT

       This function selects the COUNT'th next window in the cyclic
     order.  If count is negative, then it selects the COUNT'th
     previous window.

       It returns `nil'.

       When called interactively, it uses the processed prefix argument
     for COUNT.



File: lispref,  Node: Buffers and Windows,  Next: Window Point,  Prev: Cyclic Window Ordering,  Up: Windows

Buffers and Windows
===================

  This section describes low level functions to examine windows or to
show buffers in windows in a precisely controlled fashion.

  *Note Changing Buffers::, for related functions that find a window to
use and specify a buffer for it.  The functions described there are
easier to use than those described here.  Use those described here
when you need complete control.

 * Function: set-window-buffer WINDOW BUFFER-OR-NAME

       This function makes WINDOW display BUFFER-OR-NAME as its
     contents.  It returns BUFFER-OR-NAME.

          (set-window-buffer (selected-window) "foo")
               => nil

 * Function: window-buffer &optional WINDOW

       This function returns the buffer that WINDOW is displaying.  If
     WINDOW is omitted, then this function returns the buffer for the
     selected window.

          (window-buffer)
               => #<buffer windows.texinfo>

 * Function: get-buffer-window BUFFER-OR-NAME

       This function returns a window currently displaying
     BUFFER-OR-NAME, or `nil' if there is none.  If there are several
     such windows, then the function returns the window which is
     first in the cyclic ordering of windows, starting from the
     selected window.  *Note Cyclic Window Ordering::.

 * Command: replace-buffer-in-windows BUFFER

       This function replaces BUFFER with some other buffer in all
     windows showing it.  The other buffer used is chosen with
     `other-buffer'; but in the usual applications of this function,
     you don't care which other buffer is used.

       This function returns `nil'.



File: lispref,  Node: Window Point,  Next: Vertical Scrolling,  Prev: Buffers and Windows,  Up: Windows

Window Point
============

  Each window has a value of point, which is independent of the value
of point in other windows on the same buffer.  This is what makes it
useful to have multiple windows showing one buffer.

   * The window point is established when a window is first opened on
     a buffer and the initial value of the window point is set to be
     the value of the buffer's point or the window point of another
     window opened on the buffer, if such a window exists.

   * While the selected window displays the current buffer, changing
     the value of point in the window changes the value of point in
     the buffer.

   * When the last window opened on a buffer is deleted, the value of
     point in the buffer is left set to the value of the window's
     point before the window was deleted.  *Note Positions::, for
     more details on positions.

  As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

 * Function: window-point WINDOW

       This function returns the current position of point in WINDOW. 
     For a nonselected window, this is the value point would have if
     that window were selected.

       When WINDOW is the selected window and its buffer is also the
     current buffer, the value returned is the same as `(point)'.

       Strictly speaking, it would be more correct to return the
     ``top-level'' value of point, outside of any `save-excursion'
     forms.  But that is hard to find.

 * Function: set-window-point WINDOW POSITION

       This function positions point in WINDOW at POSITION in WINDOW's
     buffer.

 * Function: window-start &optional WINDOW

       This function returns the position in the buffer displayed by
     WINDOW at which the display starts.  This is the same number
     that `(point)' returns when the cursor is positioned at the
     beginning of the top line in the window.

       If WINDOW is `nil', the selected window is used.

          (window-start)
               => 7058

       For a more complicated example of use, see the description of
     `count-lines' in *Note Lines::.

 * Function: set-window-start WINDOW POSITION &optional NOFORCE

       This function makes the display in WINDOW start at POSITION in
     WINDOW's buffer.  Normally the display starts at the beginning
     of a line, but this is not required.

       The display routines insist that the position of point must be
     visible when a buffer is displayed.  Normally, they change the
     window start location (that is, scroll the window) whenever
     necessary to make point visible.  However, when point is
     invisible at the next redisplay after you have specified the
     start location with this function, then provided NOFORCE was
     `nil', the display routines refrain from overriding your
     explicit command: instead of scrolling the window, they move
     point instead.  Point moves to the left margin of the middle
     line in the window.

       For example, if point is 1 and you attempt to set the start of
     the window to 2, then the position of point would be ``above''
     the top of the window.  The display routines would automatically
     move point if it is still 1 when redisplay occurs.  Here is an
     example:

          ;; Here is what `foo' looks like before executing
          ;; the `set-window-start' expression.
          
          --------- Buffer: foo ---------
          -!-This is the contents of buffer foo.
          2
          3
          4
          5
          6
          --------- Buffer: foo ---------
          
          (set-window-start (selected-window) (1+ (window-start)))
          
          ;; Here is what `foo' looks like after executing
          ;; the `set-window-start' expression.
          
          --------- Buffer: foo ---------
          his is the contents of buffer foo.
          2
          3
          -!-4
          5
          6
          --------- Buffer: foo ---------
          
               => 2

       However, when NOFORCE is non-`nil', `set-window-start' does
     nothing if the specified start position would make point
     invisible.

       The function returns the requested starting position of the
     window, regardless of whether the NOFORCE option caused that
     position to be overruled.

 * Function: pos-visible-in-window-p &optional POSITION WINDOW

       This function returns `t'  if POSITION is currently visible on
     the screen in WINDOW, or if POSITION is currently out of view
     only because it has been scrolled horizontally.  The function
     returns `nil' if POSITION is scrolled vertically out of view. 
     POSITION defaults to the current point; WINDOW, to the selected
     window.  You might call it like this:

          (or (pos-visible-in-window-p (point) (selected-window))
              (recenter 0))

      The `pos-visible-in-window-p' function returns `t' if POSITION
     is out of view only because WINDOW has been scrolled
     horizontally.  Here is how you could test whether POSITION is
     visible, considering any horizontal scrolling:

          (save-excursion 
            (goto-char POSITION)
            (and 
             (>= (- (current-column) (window-hscroll WINDOW)) 0)
             (< (- (current-column) (window-hscroll WINDOW))
                (window-width WINDOW))))



File: lispref,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Window Point,  Up: Windows

Vertical Scrolling
==================

  Vertical scrolling means moving the text up or down in a window.  It
works by changing the value returned by `window-start'.  It may also
change the value of `window-point' to keep it on the screen.

  In the commands `scroll-up' and `scroll-down', the directions ``up''
and ``down'' refer to the motion of the text in the buffer at which
you are looking through the window.  You can imagine that the text is
written on a long roll of paper and that the scrolling commands move
the paper up and down.  Thus, if you are looking at text in the
middle of a buffer and repeatedly call `scroll-down', you will
eventually see the beginning of the buffer.

  Some people have argued that the converse convention be used: that
the user imagine that the text does not move but the window does. 
Then ``down'' commands would take you to the end of the buffer. 
However, the position of a window on your terminal does not move, and
short scrolling commands clearly do move the text up or down, so the
chosen convention makes more sense.  If you keep moving the text
down, eventually the top of the text should appear.

  The scrolling functions (aside from `scroll-other-window') will have
unpredictable results if the current buffer is different from the
buffer that is displayed in the selected window.  *Note Changing
Buffers::.

 * Command: scroll-up &optional COUNT

       This function scrolls the text in the selected window upward
     COUNT lines.  If COUNT is negative, scrolling is actually
     downward.

       COUNT defaults to `nil'.  If COUNT is `nil', then the length of
     the scroll is `next-screen-context-lines' lines less than the
     usable height of the window (not counting its mode line).

       `scroll-up' returns `nil'.

 * Command: scroll-down &optional COUNT

       This function scrolls the text in the selected window downward
     COUNT lines.  If COUNT is negative, scrolling is actually upward.

       If COUNT is omitted or `nil', then the length of the scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window.

       `scroll-down' returns `nil'.

 * Command: scroll-other-window &optional COUNT

       This function scrolls the text in the next window upward COUNT
     lines.  Negative values of COUNT, or `nil', are handled as in
     `scroll-up'.

       The next window is the one following the selected window in the
     cyclic ordering of windows--the window that `next-window' would
     return.  *Note Cyclic Window Ordering::.

       If the selected window is the minibuffer, the next window is
     normally the one at the top left corner.  But you can override
     which window will be scrolled by binding the variable
     `minibuffer-scroll-window'.  This variable has no effect when
     any other window is selected.  *Note Minibuffer Misc::.

       When the minibuffer is active, it is the next window if the
     selected window is the one at the bottom right corner.  In this
     case, `scroll-other-window' will attempt to scroll the
     minibuffer.  If the minibuffer contains just one line, that line
     will be redisplayed after the echo area momentarily displays the
     message ``Beginning of buffer''.

 * Option: scroll-step

       The value of this variable is the number of lines Emacs should
     try scrolling a window, when point moves out of the window.  If
     this value is zero, the line that point is on always goes to the
     center of the window after point moves off screen.

       If scrolling by `scroll-step' would fail to bring point back on
     screen, then Emacs centers point anyway.

       The default value is `nil'.

 * Option: next-screen-context-lines

       The value of this variable is the number of lines of continuity
     to retain when scrolling by screenfulls.  For example, when
     `scroll-up' executes, this many lines that were visible at the
     bottom of the screen are now visible at the top of the screen.

       The default value is `2'.

 * Command: recenter &optional COUNT

       This function repositions the text displayed in the selected
     window.

       If COUNT is a number, it puts the line containing point COUNT
     lines down from the top of the window and redraws only that
     window.  The text displayed in the other windows does not move.

       If COUNT is `nil', then it puts the line containing point in the
     center of the window, and redisplays the entire screen.  If
     COUNT is a non-`nil' list, then it puts the line containing
     point in the center of the window, but only redisplays as much
     of the window as necessary to position the text--only with `nil'
     does it redisplay the entire screen.

       When `recenter' is called interactively, Emacs sets COUNT to the
     unprocessed prefix argument.  Thus, typing `C-u' as the prefix
     sets the COUNT to a non-`nil' list, while typing `C-u 4' sets
     COUNT to 4, which positions the current line four lines from the
     top.

       Typing `C-u 0 C-l' positions the current line at the top of the
     screen.  This action is so handy that some people bind the
     command to a function key.  For example,

          (defun line-to-top-of-screen ()
            "Moves line point is on to top of screen.
          Replaces three keystroke sequence C-u 0 C-l."
            (interactive) 
            (recenter 0))
          
          ;; Bind function key PF6 on AAA terminal.
          (global-set-key "\eOF" 'line-to-top-of-screen)



File: lispref,  Node: Horizontal Scrolling,  Next: Size of Window,  Prev: Vertical Scrolling,  Up: Windows

Horizontal Scrolling
====================

  Because we read English first from top to bottom and second from left
to right, horizontal scrolling is not like vertical scrolling. 
Vertical scrolling involves selection of a contiguous portion of text
to display.  Horizontal scrolling causes part of each line to go off
screen.  The amount of horizontal scrolling is therefore specified as
a number of columns rather than as a position in the buffer.  It has
nothing to do with the value returned by `window-start'.

  Usually, horizontal scrolling starts with the leftmost column at the
left edge of the window; in this case, the columns displayed cannot
be scrolled to the right.  Columns in the display can be scrolled to
the right only after they have first been scrolled left.  There is no
limit to left scrolling except the size of the largest integer, but
if you scroll farther than the length of the longest line on the
screen, you won't see anything but empty space.

 * Command: scroll-left COUNT

       This function scrolls the selected window COUNT columns to the
     left.  It scrolls to the right if COUNT is negative.

       The return value is the total amount of horizontal scrolling in
     effect after the change--just like the value returned by
     `window-hscroll'.

 * Command: scroll-right COUNT

       This function scrolls the selected window COUNT columns to the
     right.  It scrolls to the left if COUNT is negative.

       Once you scroll a window as far right as it can go, trying to
     scroll any farther has no effect.

       The return value is the total amount of horizontal scrolling in
     effect after the change--just like the value returned by
     `window-hscroll'.

 * Function: window-hscroll &optional WINDOW

       This function returns the number of columns by which WINDOW is
     scrolled from the left margin.

       When the leftmost column is at the left edge of the window, this
     function returns 0.  The value is never negative.

       If WINDOW is `nil', the selected window is used.

          (window-hscroll)
               => 0
          (scroll-left 5)
               => 5
          (window-hscroll)
               => 5

 * Function: set-window-hscroll WINDOW COLUMNS

       This function sets the number of columns from the left margin
     that WINDOW is scrolled to the value of COLUMNS.  COLUMNS should
     be zero or positive; if not, it is taken as zero.

       The value returned is COLUMNS.

          (set-window-hscroll (selected-window) 10)
               => 10



File: lispref,  Node: Size of Window,  Next: Window Configurations,  Prev: Horizontal Scrolling,  Up: Windows

The Size of a Window
====================

  The window size functions fit into two classes: high level commands
that change the size of windows; and low level functions that access
window size.  Emacs does not permit overlapping windows or gaps
between windows, so resizing one window affects other windows.

 * Command: enlarge-window SIZE &optional HORIZONTAL

       This function makes the selected window SIZE lines bigger,
     stealing lines from neighboring windows.  It generally tries to
     steal equal numbers of lines from the other windows.  If a
     window from which lines are stolen shrinks below
     `window-min-height', then that window disappears.

       If HORIZONTAL is non-`nil', then this function makes WINDOW
     wider by SIZE columns, stealing columns as it does lines.  If a
     window from which lines are stolen shrinks below
     `window-min-width', then that window disappears.

       If the screen is smaller than SIZE lines (or columns), then the
     function makes the window occupy the entire height (or width) of
     the screen.

       If SIZE is negative, this function shrinks the window by -SIZE
     lines.

       `enlarge-window' returns `nil'.

 * Command: enlarge-window-horizontally COLUMNS

       This function makes the selected window COLUMNS wider.  It could
     be defined as follows:

          (defun enlarge-window-horizontally (columns)
            (enlarge-window columns t))

 * Command: shrink-window SIZE &optional HORIZONTAL

       This function is like `enlarge-window' but negates the argument
     SIZE, making the selected window smaller by giving lines (or
     columns) to the other windows.  If the window shrinks below
     `window-min-height' or `window-min-width', then it disappears.

     If SIZE is negative, the window is enlarged by -SIZE lines.

 * Command: shrink-window-horizontally COLUMNS

       This function makes the selected window COLUMNS narrower.  It
     could be defined as follows:

          (defun shrink-window-horizontally (columns)
            (shrink-window columns t))

  The following three functions return size information about a window.

 * Function: window-height &optional WINDOW

       This function returns the number of lines in WINDOW, including
     its mode line.  If WINDOW fills the entire screen, this is one
     less than what `(screen-height)' would return (since the last
     line is always reserved for the minibuffer).

       If WINDOW is `nil', the function uses the selected window.

          (window-height)
               => 23
          (split-window-vertically)
               => #<window 4 on windows.texinfo>
          (window-height)
               => 11

 * Function: window-width &optional WINDOW

       This function returns the number of columns in WINDOW.  If
     WINDOW fills the entire screen, this is what `(screen-width)'
     would return.

       If WINDOW is `nil', the function uses the selected window.

          (window-width)
               => 80

 * Function: window-edges &optional WINDOW

       This function returns a list of the edge coordinates of WINDOW. 
     The order of the list is: `(LEFT TOP RIGHT BOTTOM)', all
     relative to 0, 0 at the top left corner of the screen.

       RIGHT is one more than the rightmost column used by WINDOW, and
     BOTTOM is one more than the bottommost row used by WINDOW and
     its mode-line.

       For example, the edges of the following window are `0 0 5 8'. 
     We assume that the screen has more than 8 columns, so the last
     column of the window (column 7) holds a border rather than text.
     The last row (row 4) holds the mode line, shown with `xxxxxxxxx'.

                     0    
                     _______
                  0 |       | 
                    |       |   
                    |       | 
                    |       | 
                    xxxxxxxxx  4
          
                            7

       If WINDOW fills the entire screen, then RIGHT and BOTTOM are the
     same as the values returned by `(window-width)' and
     `(window-height)' respectively.

       When there are side-by-side windows, then any window not at the
     right edge of the screen has a border in its last column.  This
     border counts as one column in the width of the window.  A
     window never includes a border on its left, since the border
     there belongs to the window to the left.

       In the following example, let's imagine that the screen is only
     7 columns wide.  Then the edges of the left window are `0 0 4 3'
     and the edges of the right window are `4 0 7 3'.

                     ___ ___
                    |   |   |    
                    |   |   |    
                    xxxxxxxxx 
          
                     0  34  7

       If WINDOW is `nil', the function uses the selected window.

          (window-edges (selected-window))
               => (0 0 80 49)
          
          (list 0 0 (window-width) (window-height))
               => (0 0 80 49)

  The following two variables constrain resizing functions to a minimum
height and width.

 * Option: window-min-height

       The value of this variable determines how short a window may
     become before it disappears.  When other windows are being
     enlarged, the window disappears when it becomes smaller than
     this.  No window may be created smaller than this.  The absolute
     minimum height is two (allowing one line for the mode line, and
     one line for the buffer display); actions which change window
     sizes reset this variable to two if it is less than two.

       The default value is 4.

 * Option: window-min-width

       The value of this variable determines how narrow a window may
     become before it disappears.  When other windows are being
     enlarged, the window disappears when it becomes narrower than
     this.  No window may be created narrower than this.  The
     absolute minimum width is one; any value below that is ignored.

       The default value is 10.



File: lispref,  Node: Window Configurations,  Prev: Size of Window,  Up: Windows

Window Configurations
=====================

  Window configurations record entire screen layouts--all windows,
their sizes, which buffers they contain, what part of each buffer is
displayed, and the values of point and mark.

  Sometimes you want Emacs to restore the window configuration to some
saved past pattern.  This can be done with the following functions
and special forms.

 * Function: current-window-configuration

       This function returns a new object representing Emacs's current
     window configuration, namely the number of windows, their sizes
     and current buffers, which window is the selected window, and
     for each displayed buffer, where display starts, and the
     positions of point and the mark.  An exception is made for point
     in the current buffer, whose value is not saved.  An example of
     how it could be used with `set-window-configuration' to emulate
     `save-window-excursion' appears below with
     `save-window-excursion'.

 * Function: set-window-configuration CONFIGURATION

       This function restores the configuration of Emacs's windows and
     buffers to the state specified by CONFIGURATION.  CONFIGURATION
     must be a value that was previously returned by
     `current-window-configuration'.

       Here is a way of using this function to get the same effect as
     `save-window-excursion':

          (let ((config (current-window-configuration)))
            (unwind-protect
                (progn (split-window-vertically nil)
                       ...)
              (set-window-configuration config)))

 * Special form: save-window-excursion FORMS...

       This special form executes FORMS in sequence, preserving window
     sizes and contents.  It restores each window with the same start
     of display of its buffer.  It does not restore the value of
     point in the current buffer (use `save-excursion' for that).

       The return value is the value of the final form in FORMS.

          (split-window)
          => #<window 25 on control-structure.texinfo>
          (setq w (selected-window))
          => #<window 19 on control-structure.texinfo>
          (save-window-excursion
            (delete-other-windows w)
            (switch-to-buffer "foo")
            'do-something)
          => do-something
          ;; The screen is now split again.

   Primitives to look inside of window configurations would make sense,
but none are implemented.  It is not clear they would be worth the
space they would occupy.



File: lispref,  Node: Positions,  Next: Markers,  Prev: Windows,  Up: Top

Positions
*********

  A "position" is a number denoting the offset of a character from the
beginning of a buffer.  The position of the first character in a
buffer is `1'.  Positions are always between two characters (or
before the first character in the buffer, or after the last character
of the buffer).  The character referred to as *at* or *after* a
position is always the one immediately following the position.

  Markers are another way to represent positions; they relocate
automatically when text is inserted or deleted so they stay with the
surrounding characters.  *Note Markers::.

* Menu:

* Point::                   The special position where editing takes place.
* Motion::                  Changing point.
* Excursions::              Temporary motion and buffer changes.
* Clipping Restrictions::   Restricting editing to a portion of the buffer.

 

File: lispref,  Node: Point,  Next: Motion,  Prev: Positions,  Up: Positions

Point
=====

  "Point" is a special buffer position used by many editing commands,
including the self-inserting typed characters and text insertion
functions.  Other commands move point through the text, so that you
can edit at different places in it.

  Like other positions, point is always between two characters (or
before the first character in the buffer, or after the last character
of the buffer).  Many terminals display the cursor over the character
that immediately follows point; on such terminals, point is between
the character on which the cursor sits and the preceding character.

  Each buffer has a value of point, which is independent of the value
of point in other buffers.  The value of point is always between `1'
and the buffer size plus one (*note Buffer Contents::.).  If there is
a clipping restriction in effect (*note Clipping Restrictions::.),
then  point is always constrained to fall between the restriction
boundaries.

  Each window also has a value of point, which is independent of the
value of point in other windows on the same buffer.  This is why
point can be in different places in each window that shows a given
buffer.  When a buffer appears in only one window, the buffer's point
and the window's point normally have the same value, so the
distinction is rarely important.  *Note Window Point::, for more
details.

 * Function: point

       This function returns the position of point in the current
     buffer, as an integer.

          (point)
               => 175

 * Function: bobp

       This function returns `t' if point is at the beginning of the
     buffer.  If a clipping restriction is in effect, this means the
     beginning of the visible text.  Also, see `point-min' in *Note
     Buffer Contents::.

 * Function: eobp

       This function returns `t' if point is at the end of the buffer. 
     If a clipping restriction is in effect, this means the end of
     visible text.  Also, see `point-max' in *Note Buffer Contents::.

 * Function: bolp

       This function returns `t' if point is at the beginning of a line.

 * Function: eolp

       This function returns `t' if point is at the end of a line.  The
     end of the buffer is always considered the end of a line.

  Many functions are provided to look at the characters around point. 
Three simple functions are described here.  Also, *note Searching and
Matching::..

 * Function: char-after POSITION

       This function returns the character in the current buffer at
     position POSITION.  If POSITION does not specify a character in
     the buffer, then it returns `nil'.

       (Remember that point is always between characters or before the
     first character in a buffer; therefore, on many terminals, the
     character returned by `char-after' is the character the cursor
     is over.)

       In the example, the first character in the buffer is `@'.

          (char-to-string (char-after 1))
               => "@"

 * Function: following-char

       This function returns the character following point in the
     current buffer.  This is similar to `(char-after (point))'. 
     However, point is the last position of the buffer, then the
     result of `following-char' is `0'.

       In this example, point is between the `a' and the `c'.

          Gentlemen may cry ``Pe-!-ace! Peace!,'' but there is no peace.
          
          (char-to-string (preceding-char))
               => "a"
          (char-to-string (following-char))
               => "c"

 * Function: preceding-char

        This function returns the character preceding point in the
     current buffer.  See above, under `following-char', for an
     example.  If point is the first position of the buffer, then the
     result of `preceding-char' is 0.



File: lispref,  Node: Motion,  Next: Excursions,  Prev: Point,  Up: Positions

Motion
======

  Motion functions change the value of point, either relative to the
current value of point, relative to the beginning or end of the
buffer, or relative to the edges of the selected window.

* Menu:

* Character Motion::       Moving in terms of characters and words.
* Lines::                  Moving in terms of lines.
* Goal Column::            The goal column alters how line motion works.
* List Motion::            Moving by parsing lists and sexps.
* Skipping Characters::    Skipping characters belonging to a certain set.

 

File: lispref,  Node: Character Motion,  Next: Lines,  Prev: Motion,  Up: Motion

Motion by Characters
--------------------

 * Command: goto-char POSITION

       This function sets point in the current buffer to that position
     in the current buffer.  If POSITION is less than 1, then point
     is set to the beginning of the buffer.  If it is greater than
     the length of the buffer, then point is set to the end of the
     buffer.

       If a clipping restriction is in effect, then the position is
     still measured from the beginning of the buffer, but any
     position specified outside of the clipped region will result in
     point being placed at either the beginning or the end of the
     clipped region.

       When called interactively, POSITION is the numeric prefix
     argument, if provided; otherwise it is read from the minibuffer.

     `goto-char' returns POSITION.

 * Command: forward-char &optional COUNT

       This function moves point forward, towards the end of the
     buffer, COUNT characters (or backward, towards the beginning of
     the buffer, if COUNT is negative).  If the function attempts to
     move point past the beginning or end of the buffer (or the
     limits of the accessible region when a restriction is in
     effect), an error is signaled, with error code
     `beginning-of-buffer' or `end-of-buffer'.

       When called interactively, COUNT is the numeric prefix argument.

 * Command: backward-char &optional COUNT

       This function moves point backward, towards the beginning of the
     buffer, COUNT characters (or forward, towards the end of the
     buffer, if COUNT is negative).  If the function attempts to move
     point past the beginning or end of the buffer (or the limits of
     the accessible region when a restriction is in effect), an error
     is signaled, with error code `beginning-of-buffer' or
     `end-of-buffer'.

       When called interactively, COUNT is the numeric prefix argument.

 * Command: forward-word COUNT

       This function moves point forward COUNT words (or backward if
     COUNT is negative).  Normally it returns `t'.  If point
     encounters the beginning or end of the buffer or the limits of
     the accessible region when a restriction is in effect, point is
     left there and `nil' is returned.

       When called interactively, COUNT is set to the numeric prefix
     argument.

 * Command: backward-word COUNT

       This function is the exact analog to `forward-word', save that
     it moves backward until encountering the front of a word.

       When called interactively, COUNT is set to the numeric prefix
     argument.

       In programs, it is faster to call `forward-word' with negative
     argument, as that is all that this function does anyway.

 * Command: beginning-of-buffer &optional N

       This function moves point to the beginning of the buffer (or the
     limits of the accessible region when a restriction is in
     effect), leaving the mark at the previous position.  If N is
     non-`nil', then it puts point N tenths of the way from the
     beginning of the buffer.

       When called interactively, N is the numeric prefix argument, if
     provided; otherwise N defaults to `nil'.

       Don't use this in Lisp programs!  `(goto-char (point-min))' is
     faster and does not set the mark.

 * Command: end-of-buffer &optional N

       This function moves point to the end of the buffer (or the
     limits of the accessible region when a restriction is in
     effect), leaving the mark at the previous position.  If N is
     non-`nil', then it puts point N tenths of the way from the end.

       When called interactively, N is the numeric prefix argument, if
     provided; otherwise N defaults to `nil'.

       Don't use this in Lisp programs!  `(goto-char (point-max))' is
     faster and does not set the mark.



File: lispref,  Node: Lines,  Next: Goal Column,  Prev: Character Motion,  Up: Motion

Lines
-----

  Also see `bolp' and `eolp' in *Note Point::.

 * Command: goto-line LINE

       This function sets point to the front of the LINE'th line,
     counting from line 1 at beginning of buffer.  If LINE is less
     than 1, then point is set to the top of the buffer.  If it is
     greater than the number of lines in the buffer, then point is
     set to the *end of the last line* of the buffer.

       If a clipping restriction is in effect, then the line is still
     measured from the beginning of the buffer, but any line
     specified outside of the clipped region will result in point
     being placed at either the beginning or end of the clipped region.

       The return value is the difference between LINE and the line
     number of the line to which point actually was able move,
     ignoring any clipping restriction.

       When called interactively, LINE is the numeric prefix argument
     if one has been provided.  Otherwise LINE is prompted for.

 * Command: beginning-of-line &optional COUNT

       This function moves point to the beginning of the current line. 
     With an argument COUNT not `nil' or 1, it moves forward, towards
     the end of the buffer, (COUNT - 1) lines first.  If it reaches
     the end of the buffer (or end of the accessible region if a
     restriction is in effect), it positions point at the beginning
     of the last line.  No error is signaled.

 * Command: end-of-line &optional COUNT

       This function moves point to the end of the current line.  With
     an argument COUNT not `nil' or 1, it moves forward, towards the
     end of the buffer, (COUNT - 1) lines first.  If it reaches the
     end of the buffer (or end of the accessible region if a
     restriction is in effect), it positions point at the end of the
     last line.  No error is signaled.

 * Command: forward-line &optional COUNT

       This function moves point to the first column of a line, COUNT
     lines forward, towards the end of the buffer, from the present
     position.  If COUNT is negative, it moves that many lines up.

       If there are not that COUNT available to mover over in the
     buffer (or the the accessible region if a restriction is in
     effect), then the function moves point to the beginning (or end)
     of the buffer (or end of the accessible region if a restriction
     is in effect).

       `forward-line' returns the difference between COUNT and the
     number of lines actually moved.  If you attempt to move down
     five lines from thebeginning of a buffer that has only three
     lines, point will positioned at the end of the last line, and a
     value of 2 will be returned.

       When called interactively, COUNT will be the numeric prefix
     argument.

 * Function: vertical-motion COUNT

       This function moves point to the start of the line COUNT screen
     lines down.  If COUNT is negative, it moves up.

       If Emacs is continuing a long line of text onto a second or
     third line on the diplay, rather than truncating it, this
     function will move point according to the number of lines of the
     display, not the number of lines that are terminated by newlines
     characters.

       Because continuation depends on the width of the display and
     whether truncation is set, this function may work different in
     different windows.

       If truncation is set, `vertical-motion' is essentially the same
     as `forward-line'.

       The `vertical-motion' function returns the number of lines moved.
     It may be closer to zero than COUNT if the beginning or end of
     the buffer was reached.

 * Command: move-to-window-line COUNT

       This function repositions point relative to the text currently
     displayed in the selected window.  Point is moved to the
     beginning of the line COUNT lines from the top of the window. 
     If COUNT is negative, point moves either to the beginning of the
     line -COUNT lines from the bottom or else to the last line of
     the buffer if that point is beyond the end of buffer.

       If COUNT is `nil', then point moves to the beginning of the line
     in the middle of the window.  If the absolute value of COUNT is
     greater than the size of the window, then the window scrolls and
     that line goes to the middle of the window.

       When called interactively, COUNT gets the value of the processed
     prefix argument.

       The result of the function call is the window line number, with
     the top line in the window numbered 0.

 * Function: count-lines START END

       This function returns the number of lines between the positions
     START and END (which are character offsets from the beginning of
     the buffer) in the current buffer.  If START and END are the
     same, then it returns 0.  Otherwise it returns at least 1, even
     if START and END are on the same line.

          (defun current-line ()
            "Return the vertical position of point in the selected window.  
          Top line is 0.  Counts each text line only once, even if it wraps."
            (+ (count-lines (window-start) (point))
               (if (= (current-column) 0) 1 0)
               -1))



File: lispref,  Node: Goal Column,  Next: List Motion,  Prev: Lines,  Up: Motion

Goal Column
-----------

  A goal column is useful if you want to edit a region of text, such as
a table, in which you want to move point to a certain column on each
line.  The goal column affects the commands `next-line' and
`previous-line'.

 * Variable: goal-column

       This global variable determines the goal column for vertical
     motion commands.  If it is an integer, than all vertical motion
     commands have this as their goal.  If it is `nil', then the
     commands set their own goal columns.  Any other value is invalid.

 * Variable: temporary-goal-column

       This global variable determines the temporary goal column for
     vertical motions commands.  It is overridden by `goal-column' if
     that is non-`nil', and it is set to 9999 if `track-eol' is
     non-`nil'.  It is set each time a vertical motion command is
     invoked, unless the previous command was also a vertical motion
     command.

 * Variable: track-eol

       This variable controls how the vertical motion commands
     (`next-line' and `previous-line') operate when starting at the
     end of a line.  If `track-eol' is non-`nil', then vertical
     motion starting at the end of a line will keep to the ends of
     lines.  This means moving to the end of each line moved onto.

 * Command: set-goal-column UNSET

       This command sets the permanent goal column for vertical
     movement.  If UNSET is `nil', then the goal column is set to the
     current column of point.  All future vertical motion commands
     will have that column as their goal, untill the setting is
     canceled.

       If UNSET is non-`nil', then the permanent goal column is
     cleared, and vertical motion commands resume their normal
     operation.

       This function is for interactive use; and when called
     interactively, UNSET is the unprocessed prefix argument.



File: lispref,  Node: List Motion,  Next: Skipping Characters,  Prev: Goal Column,  Up: Motion

Moving over Lists and Other Balanced Expressions
------------------------------------------------

  Here are several functions concerned with Lisp expressions.  Also
*note Streams::., for descriptions of related functions; and *note
Syntax Tables::., which control how these function move across text. 
For user-level commands, *Note : (emacs)Lists and Sexps.

 * Command: forward-list ARG

     Move forward across ARG balanced groups of parentheses.

 * Command: backward-list ARG

     Move backward across ARG balanced groups of parentheses.

 * Command: up-list ARG

     Move forward out of ARG levels of parentheses.  A negative
     argument means move backward but still to a less deep spot.

 * Command: down-list ARG

     Move forward down ARG levels of parentheses.  A negative
     argument means move backward but still go down a level.

 * Command: forward-sexp ARG

     Move forward across ARG balanced expressions.

 * Command: backward-sexp ARG

     Move backward across ARG balanced expressions.



File: lispref,  Node: Skipping Characters,  Prev: List Motion,  Up: Motion

Skipping Characters
-------------------

  The following two functions move point over a specified set of
characters, such as whitespace characters.

 * Function: skip-chars-forward CHARACTER-SET &optional LIMIT

       This function moves point in the current buffer forward,
     skipping over a given set of characters.   Emacs first examines
     the character following point.  If it is matched by
     CHARACTER-SET, then point is advanced and the next character is
     examined.  This continues until a character is found that is not
     matched.

       CHARACTER-SET is like the inside of a `[...]' in a regular
     expression except that `]' is never special and `\' quotes `^',
     `-' or `\'.  Thus, `"a-zA-Z"' skips over all letters, stopping
     before the first nonletter, and `"^a-zA-Z'" skips nonletters
     stopping before the first letter.

       If LIMIT is supplied (it must be a number or a marker), it will
     be the maximum position in the buffer that point can be skipped
     to.   Point will stop at or before LIMIT.

       In the example,  point is located directly before the `T'. 
     After evaluating the form, it is located at the end of that line
     (between the `t' of `hat' and the newline).  This regexp skipped
     all letters and spaces, but not newlines.

          --------- Buffer: foo ---------
          I read "-!-The cat in the hat
          comes back" twice.
          --------- Buffer: foo ---------
          
          (skip-chars-forward "a-zA-Z ")
               => nil
          
          --------- Buffer: foo ---------
          I read "The cat in the hat-!-
          comes back" twice.
          --------- Buffer: foo ---------

 * Function: skip-chars-backward CHARACTER-SET &optional LIMIT

       This function moves point backwards, skipping all characters in
     CHARACTER-SET.  It is the exact analog of `skip-chars-forward'.



File: lispref,  Node: Excursions,  Next: Clipping Restrictions,  Prev: Motion,  Up: Positions

Excursions
==========

  Sometimes you need to move point temporarily to another position
within the current buffer or to another buffer entirely.  An
"excursion" is such a temporary movement.  The `save-excursion'
function is used to keep track of the current buffer and its values
of point and mark, so they can be restored after the completion of
the excursion.

  The forms for saving and restoring the configuration of windows are
described elsewhere (*note Window Configurations::.).

 * Special form: save-excursion FORMS...

       The `save-excursion' special form saves the values of point and
     mark of the current buffer, records the identity of the buffer,
     evaluates FORMS, and then restores the buffer with the saved
     values of point and mark.  The buffer and its values of point
     and mark are restored even in case of an abnormal exit (via
     throw or error).

       The `save-excursion' special form is used more than 500 times in
     the Lisp sources.  It is the standard way to restore the current
     buffer and the values of point and mark after you have changed
     the position of point in the current buffer or changed the
     buffer.

       The values of point and mark for other buffers are not saved by
     `save-excursion', so any changes made to point and mark in the
     other buffers will remain after `save-excursion' exits.

       `save-excursion' does not restore window-buffer correspondences
     destroyed by functions such as `switch-to-buffer'.  One way to
     restore the selected window is to use `save-window-excursion'
     inside `save-excursion' (*note Window Configurations::.).

       The value returned by `save-excursion' is the result of the last
     evaluated form, or `nil' if no FORMS are given.

          (save-excursion
            FORMS)
          ==      
          (let ((old-buf (current-buffer))
                (old-pnt (point))
                (old-mark (marker-position (mark))))
            (unwind-protect
                (progn FORMS)
              (set-buffer old-buf)
              (goto-char old-pnt)
              (set-marker (mark) old-mark)
              ))



File: lispref,  Node: Clipping Restrictions,  Prev: Excursions,  Up: Positions

Clipping Restrictions
=====================

  "Narrowing" is the act of limiting the text addressable by Emacs
editing commands to a limited range of characters in a buffer.  This
is also known as setting a "clipping restriction".  A clipping
restriction is denoted by two buffer positions which are the
beginning and end of the restriction.  For most editing commands
these positions replace the values of the beginning and end of the
buffer.  However, some commands use the true beginning and end of the
buffer but signal an error if an attempt is made to modify text
outside the clipping restriction.  `Undo' is an example of this
(*note Undo::.).

  While a clipping restriction is in effect, no text outside the region
is displayed.  No buffer motion functions set the value of point
outside the current clipping restriction.  Functions that return
buffer positions are not affected by clipping restrictions.  The
position returned is always relative to the true beginning of the
buffer.

  Buffer saving commands are unaffected by narrowing; the entire buffer
is saved regardless of the current clipping restriction.

 * Command: narrow-to-region START END

     This function sets the current clipping restriction to start at
     START and end at END.  Both should be character positions.

     When called interactively, START and END are set to the bounds
     of the current region (`region-beginning' and `region-end').

 * Command: narrow-to-page MOVE-COUNT

     This function sets the clipping restriction to include just the
     current page.  An optional first argument MOVE-COUNT non-`nil'
     means to move forward or backward that many pages, then narrow.

     When called interactively, MOVE-COUNT is set to the processed
     prefix argument.

 * Command: widen

     This function removes the clipping restrictions from the current
     buffer.

 * Special form: save-restriction FORMS...

     This special form saves the current clipping restriction,
     evaluates FORMS and restores the clipping restriction.  The
     clipping restriction is restored even in the event of abnormal
     exit (throw or error).  Point and mark are *not* restored; use
     `save-excursion' for that.  This is the standard way to arrange
     that the clipping restriction be automatically restored if you
     need to temporarily change it.

     The `save-restriction' special form stores the values of the
     beginning and end of the restriction as distances from the
     beginning and of the buffer.  It records the amount of invisible
     text.  This is the right thing to do if you want to do further
     narrowing.

     However, `save-restriction' can be confused if, within the body,
     you widen and then make changes outside the area of the saved
     restrictions.  Instead, if you want to widen a restriction and
     change text, you may want to use the `point-min-marker' and
     `point-min-marker' functions to return markers to the beginning
     and end of the clipped region.  Even after text has been added
     or removed, the markers will continue to point to the beginning
     and end of the region.  In addition, you could use the
     `unwind-protect' function as a safeguard in the event of an
     abnormal exit.

     Note that if you use both `save-restriction' and
     `save-excursion', `save-excursion' should come first. 
     Otherwise, the old form would be restored with the temporary
     restriction in effect, and that action might move point as a
     side effect.

     The value returned by `save-restriction' is that returned by the
     last evaluated form, or `nil' if no forms were given.

          --------- Buffer: foo ---------
          This is the contents of foo
          This is the contents of foo
          This is the contents of foo
          --------- Buffer: foo ---------
          
          (save-excursion
            (save-restriction
              (narrow-to-region 1 80)
              (goto-char (point-min))
              (replace-string "foo" "bar")))
          
          --------- Buffer: foo ---------
          This is the contents of bar
          This is the contents of bar
          This is the contents of foo
          --------- Buffer: foo ---------



File: lispref,  Node: Markers,  Next: Text,  Prev: Positions,  Up: Top

Markers
*******

  A "marker" is a Lisp object used to specify a place in a buffer
relative to the surrounding text.  A marker changes its offset from
the beginning of the buffer automatically when text is inserted or
deleted so it stays with the surrounding characters.

  This is different from a position, which specifies a static offset
from the beginning of the buffer.  *Note Positions::, for a complete
description of positions.

  Markers have two attributes: a marker position, and a marker buffer. 
At any given moment, the position is an offset from the beginning of
the buffer.  But the marker position is automatically updated by
Emacs as the buffer is changed.  The idea is that a marker positioned
between two characters in a buffer will remain between those two
characters, despite any changes made to the contents of the buffer. 
Thus, a marker's offset from the beginning of a buffer may change
often during its life.

  If the text around a marker is deleted, the marker is repositioned
between the characters before and after the deleted text.  If text is
inserted at the position of a marker, the marker remains in front of
the new text unless it is inserted with `insert-before-markers'
(*note Insertion::.).  When text is inserted or deleted somewhere
before the marker position (not next to the marker), the marker moves
back and forth with the two surrounding characters.

  When a buffer is modified, the positions of all the markers that
follow the modified region in that buffer must be updated to reflect
their current offsets from the beginning of the buffer.  This slows
processing in a buffer with a large number of markers.  For this
reason, unused markers should be made to point nowhere before they
are discarded.  Unreferenced markers will eventually be garbage
collected, but until then, they will continue to be updated.

  Because it is quite common to perform arithmetic operations on a
marker position, most of the arithmetic operations (such as, `+' and
`-') accept markers as arguments.  In such cases, the current
position of the marker is used.

Here are examples of making, setting and going to markers:

     ;; Make a new marker that initially does not point anywhere:
     (setq m1 (make-marker))
          => #<marker in no buffer>
     
     ;; Set `m1' to point between the 100th and 101st characters.
     ;; in the current buffer:
     (set-marker m1 100)
          => #<marker at 100 in markers.texinfo>
     
     ;; Now insert one character at the beginning of the buffer:
     (goto-char (point-min))
          => 1
     (insert "Q")
          => nil
     
     ;; `m1' is updated appropriately.
     m1
          => #<marker at 101 in markers.texinfo>
     
     ;; Two markers that point to the same position
     ;; are not `eq', but they are `equal'.
     (setq m2 (copy-marker m1))
          => #<marker at 101 in markers.texinfo>
     (eq m1 m2)
          => nil
     (equal m1 m2)
          => t
     
     ;; When you are finished using a marker, make it point nowhere.
     (set-marker m1 nil)
          => #<marker in no buffer>

* Menu:

* Predicates on Markers::    Testing whether an object is a marker.
* Creating Markers::         Making empty markers or markers at certain places.
* Information from Markers:: Finding the marker's buffer or character position.
* Changing Markers::         Moving the marker to a new buffer or position.
* The Mark::                 How ``the mark'' is implemented with a marker.
* The Region::               How to access ``the region''.

 

File: lispref,  Node: Predicates on Markers,  Next: Creating Markers,  Prev: Markers,  Up: Markers

Predicates on Markers
=====================

  You can test an object to see whether it is of the type marker; or
whether it is either an integer or a marker.  The latter test is
useful for when you are using the arithmetric functions that work
with both markers and integers.

 * Function: markerp OBJECT

       This function returns `t' if OBJECT is a marker, `nil'
     otherwise.  In particular, integers are not markers, even though
     many functions will accept either a marker or an integer.

 * Function: integer-or-marker-p OBJECT

       This function returns `t' if OBJECT is an integer or a marker,
     `nil' otherwise.



File: lispref,  Node: Creating Markers,  Next: Information from Markers,  Prev: Predicates on Markers,  Up: Markers

Functions which Create Markers
==============================

  You can make markers that point nowhere initially, or point to the
present position of point, or point to the the beginning or end of
the accessible region of the buffer.  In addition, you can make a
second marker that points to the same place as a given marker.

 * Function: make-marker

       This functions returns a newly allocated marker which does not
     point anywhere.

          (make-marker)
               => #<marker in no buffer>

 * Function: point-marker

       This function returns a new marker which points to the present
     position of point in the current buffer.  (See the example for
     `copy-marker'.)

 * Function: point-min-marker

       This function returns a new marker that points to the beginning
     of the accessible region of the buffer.  This will be the
     beginning of the buffer unless a clipping restriction is in
     effect (i.e., unless you have called the `narrow-to-region'
     function or `narrow-to-page' function.)

 * Function: point-max-marker

       This function returns a new marker that points to the end of the
     accessible region of the buffer.  This will be the end of the
     buffer unless a clipping restriction is in effect (i.e., unless
     you have called the `narrow-to-region' function or
     `narrow-to-page' function.)

     Here are examples of this function and `point-min-marker', shown
     in a buffer containing a version of the source file for the text
     of this chapter.

          (point-min-marker)
               => #<marker at 1 in markers.texinfo>
          (point-max-marker)
               => #<marker at 15573 in markers.texinfo>
          
          (narrow-to-region 100 200)
               => nil
          (point-min-marker)
               => #<marker at 100 in markers.texinfo>
          (point-max-marker)
               => #<marker at 200 in markers.texinfo>

 * Function: copy-marker MARKER-OR-INTEGER

       If passed a marker as its argument, then `copy-marker' returns a
     new marker that points to the same place and the same buffer as
     does MARKER-OR-INTEGER.  If passed an integer as its argument,
     then `copy-marker' returns a new marker that points to position
     MARKER-OR-INTEGER in the current buffer.

       If passed an argument that is an integer whose value is less
     than 1, then `copy-marker' returns a new marker that points to
     the beginning of the current buffer.  If passed an argument that
     is an integer whose value is greater than the length of the
     buffer, then `copy-marker' returns a new marker that points to
     the end of the buffer.

       An error is signaled if MARKER is neither a marker nor an integer.

          (setq p (point-marker))
               => #<marker at 2139 in markers.texinfo>
          
          (setq q (copy-marker p))
               => #<marker at 2139 in markers.texinfo>
          
          (eq p q)
               => nil
          
          (equal p q)
               => t
          
          (copy-marker 0)
               => #<marker at 1 in markers.texinfo>
          
          (copy-marker 10000)
               => #<marker at 2324 in markers.texinfo>



File: lispref,  Node: Information from Markers,  Next: Changing Markers,  Prev: Creating Markers,  Up: Markers

Information from Markers
========================

  You can use information from markers to return to a position and a
buffer that you left earlier, even if you have modified the buffer.

 * Function: marker-position MARKER

       This function returns the position that MARKER points to, or
     `nil' if it points nowhere.

 * Function: marker-buffer MARKER

       This function returns the buffer that MARKER is in, or `nil' if
     it points nowhere.

          (setq m (make-marker))
               => #<marker in no buffer>
          (marker-position m)
               => nil
          (marker-buffer m)
               => nil
          
          (set-marker m 3770 (current-buffer))
               => #<marker at 3770 in markers.texinfo>
          (marker-buffer m)
               => #<buffer markers.texinfo>
          (marker-position m)
               => 3770

  Two markers will be found `equal' (but not `eq') to each other if
they have the same position and buffer, or if they both point nowhere.



File: lispref,  Node: Changing Markers,  Next: The Mark,  Prev: Information from Markers,  Up: Markers

Changing Markers
================

When you move the location of an existing marker object, be sure the
marker is not used outside of your program--otherwise, you may cause
unexpected consequences!

 * Function: set-marker MARKER POSITION &optional BUFFER

       This function moves MARKER to POSITION in BUFFER.  If BUFFER is
     not provided, it defaults to the current buffer.

       If POSITION is less than 1, then `set-marker' will move marker
     to the beginning of the buffer.  If the value of POSITION is
     greater than the size of the buffer, then `set-marker' will move
     marker to the end of the buffer.

       The value returned is MARKER.

          (setq m (point-marker))
               => #<marker at 4714 in markers.texinfo>
          (set-marker m 55)
               => #<marker at 55 in markers.texinfo>
          (setq b (get-buffer "foo"))
               => #<buffer foo>
          (set-marker m 0 b)
               => #<marker at 1 in foo>

 * Function: move-marker MARKER POSITION &optional BUFFER

       This is another name for `set-marker'.



File: lispref,  Node: The Mark,  Next: The Region,  Prev: Changing Markers,  Up: Markers

The Mark
========

  A special marker in each buffer is designated the "mark".  This
marker is for the user and should not normally be modified by Lisp
programs.  Lisp programs should set the mark only to values that have
a potential use to the user.  For example, the `replace-regexp'
command sets mark to the value of point before doing any replacements.
After the command completes, the user can go back to where the
command began by using `C-x C-x' (`exchange-point-and-mark').

  As a rule, commands should not look at mark directly.  Instead, the
command's definition should use `interactive' with the `r'
specification.  This will provide the values of point and mark, and
thereby the region between them.

  Each buffer has its own value of mark that is independent of the
value of mark in other buffers.  When a buffer is created the mark
exists, but it does not point anywhere.  We consider this state as
``the absense of a mark in that buffer''.

  In addition to the mark, each buffer has a "mark ring" which is a
list of markers that are the previous values of the mark.  When
editing commands change the mark, normally the old value of the mark
should be saved on the mark ring.  The mark ring may contain no more
than the maximum number of entries specified by the variable
MARK-RING-MAX; excess entries are discarded on a first-in-first-out
basis.

 * Function: mark

       This function returns the position of the current buffer's mark
     as an integer.  `nil' is returned if the mark is not yet set for
     this buffer.

 * Function: mark-marker

       This function returns the current buffer's mark.  A buffer's
     mark is a marker and obeys all the rules for markers.  This
     function does not return a copy of the mark, but rather the mark
     itself.  Changing this marker's position will directly affect
     region commands such as `kill-region'.

          (setq m (mark-marker))
               => #<marker at 3420 in markers.texinfo>
          (set-marker m 100)
               => #<marker at 100 in markers.texinfo>
          (mark-marker)
               => #<marker at 100 in markers.texinfo>

     Like any marker, this marker allows you to set it to point at
     any buffer you like.  We don't recommend that you make it point
     at any buffer other than the one of which it is the mark.  If
     you do, it will yield perfectly consistent, if rather odd,
     results.

 * Command: set-mark-command JUMP

       If JUMP is `nil', this command sets the mark to the value of
     point and pushes the previous value of mark on the mark ring. 
     The message `Mark set' is also displayed in the echo area.

       If JUMP is not `nil', this command sets point to the value of
     the mark, and sets the mark to the previous saved mark, which is
     popped off the mark ring.

       This function is *only* intended for interactive use.

 * Function: set-mark POSITION

       This function sets the mark to POSITION.  The old value of the
     mark is *not* pushed onto the mark ring.

       Don't use this function!  That is to say, don't use this
     function unless you want the user to see that the mark has
     moved, and you want the previous mark position to be lost.

       Normally, when a new mark is set, the old one should go on the
     `mark-ring'.  This is why most applications should use
     `push-mark' and `pop-mark', not `set-mark'.

       Novice Emacs Lisp programmers often try to use the mark for the
     wrong purposes.  The mark saves a location for the user's
     convenience.  Most editing commands should not alter the mark. 
     To remember a location for internal use in the Lisp program,
     store it in a Lisp variable.  Example:

             (let ((beg (point)))
                (forward-line 1)
                (delete-region beg (point))).

  * Variable: mark-ring

       The value of this buffer-local variable is the list of saved
     former marks of the current buffer, most recent first.

          mark-ring
          => (#<marker at 11050 in markers.texinfo> 
              #<marker at 10832 in markers.texinfo>
              ... )

 * Option: mark-ring-max

       The value of this global variable is the maximum size of
     `mark-ring'.  If more marks than this are pushed onto the
     `mark-ring', then it starts discarding marks on a first-in,
     first-out basis.

 * Function: push-mark &optional POSITION NOMSG

       This function sets the current buffer's mark to POSITION, and
     pushes a copy of the previous mark onto `mark-ring'.  If
     POSITION is `nil', then the value of point is used.

       A `Mark set' message will be displayed unless NOMSG is non-`nil'.

 * Function: pop-mark

       This function pops off the top element of `mark-ring' and makes
     that mark become the buffer's actual mark.  This does not change
     the buffer's point and does nothing if `mark-ring' is empty.



File: lispref,  Node: The Region,  Prev: The Mark,  Up: Markers

The Region
==========

  The text between point and mark is known as the "region".  Various
functions operate on text delimited by point and mark; only those
functions specifically related to the region itself are described here.

  Note that few programs ever need to use the `region-beginning' and
`region-end' functions.  Don't be tempted to use these functions in
commands designed to operate on a region.  It is better to use
`interactive' with the `r' specification instead, so that the same
function can be called with explicit arguments from programs.  (*Note
Interactive Codes::.)

 * Function: region-beginning

       This function returns the position of the beginning of the region.
     This will be the position of either point or mark, whichever is
     smaller.

       If the mark does not point anywhere, an error is signaled.

 * Function: region-end

       This function returns the position of the end of the region. 
     This will be the position of either point or mark, whichever is
     larger.

       If the mark does not point anywhere, an error is signaled.



File: lispref,  Node: Text,  Next: Searching and Matching,  Prev: Markers,  Up: Top

Text
****

  This chapter is about those functions that deal with the text of a
buffer.  Most of these functions insert or delete text in whichever
buffer is current.  Most of them are interactive functions and
perform their changes either directly in front of or directly
following point.

  Some text-related functions put text into the "kill ring", others do
not; but all the changes they make can be undone so long as the
buffer has undo enabled (*Note Undo::.)

  Many text-related functions operate on a region of text defined by
two locations in the buffer, named START and END.  These arguments
should be either markers or or numeric character positions that count
from the beginning of the buffer.  When these functions are called
interactively, usually the current region (*note The Region::.) is
used.

  Since text-related functions always operate on the text between the
two locations, START and END, the order in which the locations are
given is not important.  For example, `(delete-region 1 10)' and
`(delete-region 10 1)' perform identically.  It is an
`args-out-of-range' error if either location does not indicate an
existing position in the buffer.

  Throughout this chapter, `text' refers to the characters in the buffer.

* Menu:

* Insertion::        Adding new text to a buffer.
* Deletion::         Removing text from a buffer.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Filling::          Functions for explicit filling.
* Sorting::          Functions for sorting parts of the buffer.
* Indentation::      Functions to insert or adjust indentation.
* Indent Tabs::      Controlling when tab characters are used.
* Columns::          Computing horizontal positions, and using them.
* Case Changes::     Case conversion of parts of the buffer.
* Underlining::      Inserting or deleting underlining-by-overstrike.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.

 

File: lispref,  Node: Insertion,  Next: Deletion,  Prev: Text,  Up: Text

Insertion
=========

 Insertion takes place at point; normally markers which pointed at
point before the insertion end up pointing before the inserted text. 
Point may end up either before or after inserted text, depending on
the function used.  Any of these functions signals an error if the
current buffer is read-only.

 * Function: insert &rest ARGS

       This function inserts any number of strings or characters into
     the current buffer, at point, moving point forward.  An error is
     signaled unless all ARGS are either strings or characters.

       Any markers pointing after point are relocated.  Any markers
     pointing at point or before are unchanged.

 * Function: insert-before-markers &rest ARGS

       This function inserts any number of strings or characters into
     the current buffer, at point, moving point forward.  An error is
     signaled unless all ARGS are either strings or characters.

       Unlike `insert', any markers whose position equals point are
     relocated to come after the newly inserted text.

 * Function: insert-char CHARACTER COUNT

       This function inserts COUNT instances of CHARACTER into the
     current buffer before point.  COUNT must be a number, and
     CHARACTER must be a character.

 * Command: copy-to-buffer TO-BUFFER START END

       This function copies text from the current buffer to TO-BUFFER. 
     TO-BUFFER is first erased (with no questions asked), and then
     the text in the region defined by START and END is inserted into
     that buffer.

       When called interactively, TO-BUFFER is prompted for in the
     minibuffer, and START and END are bound to the value of point
     and mark (i.e., to the values of the beginning and end of the
     region).

 * Function: insert-buffer-substring FROM-BUFFER-OR-NAME START END

       This function inserts a substring of FROM-BUFFER-OR-NAME (which
     must exist) into the current buffer before point.  The string is
     those characters in the region defined by START and END.

       In the example, the form is executed with buffer `bar' as the
     current buffer.  We assume that buffer `bar' is initially empty.

          --------- Buffer: foo ---------
          We hold these truths to be self-evident, that all
          --------- Buffer: foo ---------
          
          (insert-buffer-substring "foo" 1 20)
               => nil
          
          --------- Buffer: bar ---------
          We hold these truth
          --------- Buffer: bar ---------

 * Function: insert-buffer FROM-BUFFER-OR-NAME

       This function inserts the entire contents of FROM-BUFFER-OR-NAME
     (which must exist) into the current buffer after point.  It
     leaves the mark after the inserted text.

 * Command: quoted-insert COUNT

         This function reads the next input character verbatim and
     inserts it.  It is primarily useful for inserting control
     characters.  You may also type up to 3 octal digits, to insert a
     character with that code.

       COUNT is the number of these characters to insert.  An error is
     signaled if COUNT is not a number.

       Programs rarely want to use this function, but might want to put
     it on a keymap.

       This function is primarily for interactive use.

 * Command: self-insert-command COUNT

       This function inserts the last character typed COUNT times. 
     This is the function that most printing characters are bound to.
     Programs rarely want to use this, but might want to put it on a
     keymap.

       This function calls `auto-fill-hook'.  (In version 19,
     `auto-fill-hook' will be renamed to `auto-fill-function' since
     it is not called by the `run-hooks' function.)

       In everyday use, `self-insert-command' is the most frequently
     called function in Emacs!

 * Command: newline &optional NUMBER-OF-NEWLINES

       This function inserts newlines into the current buffer before
     point.  If NUMBER-OF-NEWLINES is supplied (and is a number),
     that many newline characters are inserted.

       In Auto Fill mode, `newline' can break the preceding line if
     NUMBER-OF-NEWLINES is not supplied.  When this happens, it
     actually inserts two newlines at different places: one at point,
     and another earlier in the line.  `newline' does not auto-fill
     if NUMBER-OF-NEWLINES is non-`nil'.

       When called interactively, COUNT is the processed prefix argument.

 * Command: split-line

       This function splits the current line, moving the portion of the
     line after point down vertically, so that it is on the next line
     directly below where it was before.  Whitespace is inserted as
     needed at the beginning of the lower line, using the `indent-to'
     function.  `split-line' returns the position of point.

       In the example, point is located between the `t' and the `h'
     when `(split-line)' is called.  The second line in the result
     contains one tab and one space before the `h'.  Point is still
     located at the end of the first line, directly after the `t'.

          --------- Buffer: foo ---------
          This is t-!-he line before
          --------- Buffer: foo ---------
          
          (split-line)
               => 4433
          
          --------- Buffer: foo ---------
          This is t-!-
                   he line before
          --------- Buffer: foo ---------

     Programs hardly ever use this function.

 * Command: open-line COUNT

       This function inserts COUNT newlines into the current buffer
     after point, leaving point where it was.

       When called interactively, COUNT is the processed prefix argument.
     Programs hardly ever use this function.

 * Command: overwrite-mode ARGUMENT

       This function turns overwrite mode on and off.  If ARGUMENT is a
     positive number (greater than zero), then it is turned on,
     otherwise it is turned off.  In overwrite mode, typed-in
     printable characters replace existing text character for
     character, and do not push the existing text to the right.

       This function only effects the self-insertion command.

       When called interactively, ARGUMENT is set to the processed
     prefix argument.



File: lispref,  Node: Deletion,  Next: The Kill Ring,  Prev: Insertion,  Up: Text

Deletion
========

  All of the deletion functions operate on the current buffer, and they
all return a value of `nil'.  None of them put their deleted text
into the kill ring unless otherwise noted.

  In general, functions that have ``delete'' in their names do not put
text into the kill ring, while corresponding functions with ``kill''
in their names do (compare: `delete-region' and `kill-region').  From
programs, you will usually want to use a ``delete'' function as
opposed to a ``kill'' function, since the kill ring is for the user.

 * Function: erase-buffer

       This function deletes the entire text of the current buffer.  If
     the buffer is read-only, it signals a `buffer-read-only' error. 
     Otherwise it does not complain, even if erasing a buffer
     visiting a modified file.  It does not kill the buffer.

 * Command: delete-region START END

       This function deletes the text in the current buffer in the
     region defined by START and END.

 * Command: delete-horizontal-space

       This function deletes all spaces and tabs around point.

       In the examples, point is between the second and third
     characters on each of the lines when the function is called.

          --------- Buffer: foo ---------
          I -!-thought
          I -!-     thought
          We-!- thought
          Yo-!-u thought
          --------- Buffer: foo ---------
          
          (delete-horizontal-space)
               => nil
          
          --------- Buffer: foo ---------
          Ithought
          Ithought
          Wethought
          You thought
          --------- Buffer: foo ---------

 * Command: delete-indentation &optional JOIN-FOLLOWING-P

       This function joins the line point is on to the previous line
     and deletes all the whitespace at the join, save for one space. 
     If JOIN-FOLLOWING-P is non-`nil', `delete-indentation' joins
     this line to following line instead.

       In the example below, point is located on the line starting
     `events', and it makes no difference if there are trailing spaces.

          --------- Buffer: foo ---------
          When in the course of human
          -!-    events, it becomes necessary
          --------- Buffer: foo ---------
          
          (delete-indentation)
               => nil
          
          --------- Buffer: foo ---------
          When in the course of human-!- events, it becomes necessary
          --------- Buffer: foo ---------

 * Function: fixup-whitespace

       This function replaces white space between the objects on either
     side of point with either one space or no space as appropriate. 
     The function leaves one space if point is in the middle of a
     line that has printing characters somewhere before and after it
     (except in a few cases described below).  When point is at the
     beginning or end of a line, this function leaves no spaces.

       `fixup-whitespace' does not leave any space when point is
     located directly after a character whose syntax class is ``open
     parenthesis'' `(', directly before a character whose syntax
     class is ``close parenthesis'' `)', or directly before a
     character whose syntax class is ``Expression Prefix Operator''
     `''.

       In the example, point starts out at the beginning of the second
     line, when `fixup-whitespace' is called the first time.  It is
     located directly after the `(' for the second invocation.

          --------- Buffer: foo ---------
          This has too many spaces
          -!-     at the front of this line
          This has too many spaces at the start of (-!-   this list)
          --------- Buffer: foo ---------
          
          (fixup-whitespace)
               => nil
          (fixup-whitespace)
               => nil
          
          --------- Buffer: foo ---------
          This has too many spaces
          at the front of this line
          This has too many spaces at the start of (this list)
          --------- Buffer: foo ---------

 * Command: just-one-space

       Delete all spaces and tabs around point, leaving one space.

 * Command: delete-blank-lines

       This function deletes blank lines surrounding point.  If point
     is on a blank line with one or more blank lines before or after
     it, then all but one of them are deleted.  If point is on an
     isolated blank line, then it is deleted.  If point is on a
     nonblank line, it deletes all blank lines following it.

       A blank line is defined as any line consisting of a newline and
     nothing else except tabs and spaces.

       `delete-blank-lines' returns `nil'.

 * Command: delete-char COUNT &optional KILLP

       This function deletes COUNT characters directly after point
     (before, if COUNT is negative).

       If KILLP is non-`nil', then it saves the deleted characters in
     the kill ring.

       When called interactively, COUNT is the processed prefix
     argument, and KILLP is set to `t' if COUNT is greater than 1.

 * Command: delete-backward-char COUNT &optional KILLP

       This function deletes COUNT characters directly before point
     (after, if COUNT is negative).

       If KILLP is non-`nil', then it saves the deleted characters in
     the kill ring.

       When called interactively, COUNT is the processed prefix
     argument, and KILLP is set to `t' if COUNT is greater than 1.

 * Command: backward-delete-char-untabify COUNT &optional KILLP

       This function deletes COUNT characters backward, changing tabs
     into spaces.  When changing tabs into spaces, a sufficient
     number of spaces are inserted into the buffer to keep point in
     the same column.  These spaces are then deleted by
     `delete-backward-char'.

       If COUNT is negative, then tabs are not changed to spaces, and
     the characters are deleted by calling `delete-backward-char'
     with COUNT.

       If KILLP is non-`nil', then it saves the deleted characters in
     the kill ring.

       When called interactively, COUNT is the processed prefix
     argument, and KILLP is set to `t' if COUNT is greater than 1.



File: lispref,  Node: The Kill Ring,  Next: Undo,  Prev: Deletion,  Up: Text

The Kill Ring
=============

  Emacs keeps a number of the last sections of text that were deleted
by the user.  These sections of text are kept on a list called the
`kill-ring'.  Several functions manipulate this list; they treat it
as a ring rather than as a list.

  The kill ring and its associated functions help the user move text
around, make it easy to change his or her mind, and help him or her
recover from accidents.

  Some people think use of the word `kill' in Emacs is unfortunate,
since it refers to processes which specifically *do not* destroy the
entities `killed'.  This is in sharp contrast to ordinary life, in
which death is permanent, and `killed' entities seldom come back to
life.  A different metaphor might have been more intuitive.  For
example, the term `cut ring' makes sense to people who, in
pre-computer days, used scissors and paste to cut up and rearrange
manuscripts.  Others most readily understand a metaphor incorporating
concepts of `attic' or `closet'; and yet others, who think of text as
being `clipped' from the buffer, prefer a term such as `clip ring'.

* Menu:

* Data in Kill Ring::   What text looks like in the kill ring.
* Kill Functions::      Functions that kill text.
* Yank Commands::       Commands that access the kill ring.
* Kill Ring Internals:: Variables that hold kill-ring data.

 

File: lispref,  Node: Data in Kill Ring,  Next: Kill Functions,  Prev: The Kill Ring,  Up: The Kill Ring

Data Structures in the Kill Ring
--------------------------------

  Killed text is kept as strings in a list.  A short kill ring, for
example, might look like this:

     ("some text" "a different piece of text" "yet more text")

  Functions which push more text into the list first make a string of
the text in question (using `buffer-substring'), and then look at the
length of the list.  If the length is longer than the value of
`kill-ring-max', the last entry in the list is dropped off when the
new entry is put on.

  The `kill-ring-yank-pointer' global variable points to the kill ring
entry that a "yank" function will copy.  Several functions move this
pointer from one entry to another, and a user can thereby specify
which entry to copy.

  Here is a diagram that shows the variable `kill-ring-yank-pointer'
pointing to the second entry in the kill ring `("some text" "a
different piece of text" "yet more text")'.

     kill-ring       kill-ring-yank-pointer
       |               |
       |     ___ ___   |      ___ ___      ___ ___
        --> |   |   |   --> |   |   |    |   |   |
            |___|___|-----> |___|___|--> |___|___|--> nil
              |                |            |            
              |                |            |            
              |                |             -->"yet more text" 
              |                |
              |                 --> "a different piece of text" 
              |
               --> "some text"

(This circumstance occurs when `C-y' (`yank') is immediately followed
by `M-y' (`yank-pop').)

  Both `kill-ring' and `kill-ring-yank-pointer' are variables like
other Lisp variables.  Both are bound to lists.  The word `pointer'
is used in the name of the `kill-ring-yank-pointer' variable to tell
human readers that the purpose of the variable is to point to the
element of the list that will be copied to the buffer when the user
gives a yank command.

  The functions that change the entry to which the
`kill-ring-yank-pointer' points treat the kill ring (which is a list)
as if it were a ring; that is to say, a change that would otherwise
cause the pointer to point to an entry beyond the end of the list
(which would be useless) instead causes the pointer to point to the
first entry on the list.  Hence, movement of the
`kill-ring-yank-pointer' is called "rotation".

  The `kill-ring-yank-pointer' variable can be moved in the `reverse'
direction from the end of the list to the beginning; but only one
step at a time; and it cannot be moved from the first entry to the
last entry in the `reverse' direction.  The ring is a one way rotary.

  Kill commands always place their new text in the beginning of
`kill-ring', and they always reset `kill-ring-yank-pointer' to point
to the first entry of `kill-ring'.  The first entry will be the new
entry; consequently, the next `yank' command will copy the new entry
into a buffer, as the user expects.

  After `kill-ring-yank-pointer' is reset to point to the first entry
of `kill-ring', `kill-ring' and `kill-ring-yank-pointer' are `eq' to
each other.

  `kill-region' is the primary function for programs to use that kill
text.  Any command that calls this function is a ``kill command''
(and should contain the word ``kill'' in its name).

  When kill commands are interwoven with other commands, the killed
portions of text are put into separate entries in the kill ring.  But
when two or more kill commands are executed in sequence, the text
killed by the second (or third, etc.) kill command is appended to the
text killed by the first command so as to make one entry in the kill
ring.  The `kill-region' function uses the `last-command' variable to
keep track of whether the previous was a kill command, in which case,
it appends the killed text to the current entry.



File: lispref,  Node: Kill Functions,  Next: Yank Commands,  Prev: Data in Kill Ring,  Up: The Kill Ring

Entry Points for Killing
------------------------

 * Command: kill-region START END

       This function kills the text in the region defined by START and
     END.  The text is deleted but saved in the kill ring.

       When called interactively, START and END are point and mark.

 * Command: kill-line &optional COUNT

       This function kills the rest of the line following point, not
     including the newline.  If point is directly before a newline,
     or if there is only whitespace between point and the newline,
     then it kills the whitespace and newline.

       If COUNT is supplied, then it kills that many lines (*including*
     the newline).  (This makes executing `(kill-line 2)' different
     from executing `(kill-line)' two times.)  If COUNT is negative,
     then `kill-line' kills lines backwards.

       When called interactively, COUNT is the unprocessed prefix
     argument (which then gets processed if non-`nil').

 * Command: zap-to-char COUNT CHARACTER

       The Emacs Version 18 implementation of the function removes the
     text from point up to *but not including* the specified character.
     Thus, if the cursor were at the beginning of this sentence and
     the character were `s', `Thu' would be removed.  If the argument
     were two, `Thus, if the cur' would be removed, up to but not
     including the `s' in `cursor'.

       The Emacs Version 19 implementation of this function kills all
     text in the region from point up to and including the next COUNT
     occurrence of CHARACTER.  Thus, in the example shown in the
     previous paragraph, the terminating `s' *would* be removed.

       In addition, the Version 18 implementation will kill text to the
     end of the buffer if the specified character is not found; but
     the Version 19 implementation will simply generate an error (and
     not remove any text).

       The function zaps backward if COUNT is negative.  The killed
     text is put in the kill ring.

 * Command: copy-region-as-kill START END

       This function saves the region defined by START and END on the
     kill ring, but does not delete the text from the buffer.

       When called interactively, START and END are point and mark.



File: lispref,  Node: Yank Commands,  Next: Kill Ring Internals,  Prev: Kill Functions,  Up: The Kill Ring

Entry Points for Yanking
------------------------

 * Command: yank &optional ARG

       This function inserts the text in the first entry in the kill
     ring directly before point.  After the yank, the mark is
     positioned at the beginning and point is positioned after the
     end of the inserted text.

       If ARG is a list (which as passed an an interactive argument
     when a user types just `C-u'), then `yank' inserts the text as
     described above, but puts point in front of the yanked text and
     the mark at the end of the yanked text.  If ARG is a number,
     then `yank' inserts the ARG'th most recently killed text.

       `yank' does not alter the contents of the kill ring.

 * Command: yank-pop ARG

       This function replaces the just-yanked text with a different
     piece of killed text.  This command is allowed only immediately
     after a `yank' or a `yank-pop'.  At such a time, the region
     contains text that was just inserted by the previous `yank'. 
     `yank-pop' deletes that text and inserts in its place a
     different stretch of killed text.  The text that is deleted is
     not inserted into the kill ring, since it is already in the kill
     ring somewhere.

       If ARG is `nil', then the existing region contents are replaced
     with the previous element of the kill ring.  If ARG is numeric,
     then the ARG'TH previous kill is the replacement.  If ARG is
     negative, a more recent kill is the replacement.

       The sequence of kills wraps around, so that after the oldest one
     comes the newest one; and moving forward from the newest one
     goes to the oldest.



File: lispref,  Node: Kill Ring Internals,  Prev: Yank Commands,  Up: The Kill Ring

Internals of the Kill Ring
--------------------------

 * Variable: kill-ring

       List of killed text sequences.

 * Variable: kill-ring-yank-pointer

       This global variable's value is the cons cell in the kill ring
     whose CAR is the last thing yanked.  The functions `yank-pop'
     and `rotate-yank-pointer' move this pointer around in the kill
     ring.  A kill always resets this variable to point the beginning
     of the kill ring (that is, to bind the value of the variable to
     the whole kill ring).

 * Command: rotate-yank-pointer COUNT

       This function rotates `kill-ring-yank-pointer' COUNT positions
     in the kill ring.  In other words, it rebinds
     `kill-ring-yank-pointer' to a different CDR of the kill ring, or
     to the whole kill ring.

 * Option: kill-ring-max

       The value of this global variable is the maximum length to which
     the kill ring can grow, before elements are thrown away on a
     first-in, first-out basis.  The default value for
     `kill-ring-max' is 30.



File: lispref,  Node: Undo,  Next: Auto Filling,  Prev: The Kill Ring,  Up: Text

Undo
====

  A buffer can have an undo stack which records all changes made to the
buffer's text, so they can be undone.  (In general, all buffers have
undo stacks except special-purpose buffers for which Emacs guess that
one is not useful.)

  Stack size is limited, so large changes or a large number of changes
cannot be undone.

  Undoing an old change is itself a change, and is added to the undo
stack.  However, you are not limited to undoing just the single most
recent change; you can keep undoing older and older changes, even as
the undo's themselves are being added to the stack.

 * Command: undo &optional ARG

       This is a user-level command to undo some previous changes.  It
     uses `undo-more' and `undo-start'.  By repeating this command
     you can undo more changes.  A numeric argument serves as a
     repeat count.

 * Function: undo-boundary

       This function places a boundary between units of undo.  Each
     undo command stops at such a boundary; and the next undo command
     will undo to the previous boundary.

       There is an implicit undo boundary between each key-stroke
     command, such as `kill-word'.  Thus, each undo undoes the
     effects of one command.

       This function is used inside of `query-replace', between each
     replacement, so that individual replacements can be undone one
     by one.

 * Function: undo-more COUNT

       This function is used to undo changes back COUNT boundaries
     beyond what was already undone recently.

 * Function: undo-start

       This function moves the undo-pointer to the beginning of the
     undo stack.  This means that the next call to `undo-more' will
     undo the most recently made change.  This function breaks a
     sequence of undo's, so a subsequent call to `undo-more' will
     undo a previous change that is itself the result of an undo. 
     This is what you use to undo your undoing (i.e., redo).

       To prepare Emacs to undo a recent sequence of changes, call
     `undo-start'; then call `undo-more' one or more times to undo
     them.

       The command `undo' calls `undo-start' whenever the previous
     command was not an `undo'.

 * Command: buffer-enable-undo &optional BUFFER-OR-NAME

       This function starts keeping undo information for buffer
     BUFFER-OR-NAME.  If no argument is supplied, then the current
     buffer is used.  If the buffer is already keeping undo
     information, then nothing is changed.

       This function returns `nil'.

       When called interactively, BUFFER-OR-NAME is the current buffer.

 * Function: buffer-flush-undo BUFFER-OR-NAME

       This function makes the buffer BUFFER-OR-NAME stop keeping undo
     information, and flushes the information it has kept thus far. 
     If the buffer is not keeping undo information, then nothing is
     changed.

       This function returns `nil'.



File: lispref,  Node: Auto Filling,  Next: Filling,  Prev: Undo,  Up: Text

Auto Filling
============

  "Filling" breaks text into lines that are no more than a specified
number of columns wide.  Lines end between words, and thus may be
shorter than the maximum length, unless the line is "justified"
(which means that spaces are inserted between words so that the last
letter of the last word on the line is on the last column).

  In Auto Fill mode, Emacs fills lines automatically.  This section
describes the hook and the two variables used by Auto Fill mode.

  For a description of functions that you can call manually to fill and
justify text, see *Note Filling::.

  As a practical matter, if you are writing text that you hope other
people will read, you should set the value of `fill-column' to no
more than 70.  Otherwise the line will be too long for people to read
comfortably; and they will think your writing is clumsy even if it
isn't!

 * Variable: auto-fill-hook

       The value of this variable should be a function (of no
     arguments) to be called after self-inserting a space at a column
     beyond `fill-column'.  It may be `nil', in which case, nothing
     special is done.

       The default value for `auto-fill-hook' is `do-auto-fill', a
     function whose sole purpose is to implement the usual strategy
     for breaking a line.

       Since `auto-fill-hook' is not called by the `run-hooks'
     function, it is being re-named `auto-fill-function' in Version 19.

 * Option: fill-column

       This buffer-local variable controls how wide lines are filled. 
     It should be an integer which is interpreted as a column.  If
     automatic line-wrapping is turned on, then any text typed beyond
     this column is wrapped onto the next line.  The command
     `fill-paragraph' adjusts the lines of the paragraph which point
     is in so that they don't go past this column.

 * Variable: default-fill-column

       The value of this variable is the default value for
     `fill-column' in buffers that do not override it.  This is the
     same as `(default-value 'fill-column)'.

       The default value for `default-fill-column' is 70.



File: lispref,  Node: Filling,  Next: Sorting,  Prev: Auto Filling,  Up: Text

Filling
=======

  "Filling" means adjusting the lengths of lines (by moving words
between them) so that they are nearly, but no greater than, a
specified maximum length.  If a line is justified as well as filled,
then spaces are inserted between the words so that the last letter of
the last word on the line is on the specified column.  For ease of
reading, lines should be no longer than 70 or so columns.

  Emacs has facilities for automatically filling text as you write it,
but changes to existing text may leave it improperly filled.  Then
you must fill the text explicitly.

 * Command: fill-paragraph JUSTIFY-FLAG

        This function fills the paragraph at or after point.  If
     JUSTIFY-FLAG is non-`nil', each line is justified as well.

 * Command: fill-region START END &optional JUSTIFY-FLAG

       This function fills each of the paragraphs in the region from
     start to end.  The function justifies the paragraph if it is
     called interactively with a prefix argument, or if it is called
     from a program with a non-`nil' JUSTIFY-FLAG.

     The function uses the value of `paragraph-separate' to
     distinguish paragraphs.

 * Command: fill-individual-paragraphs START END &optional JUSTIFYP
MAILP

       This function fills each paragraph in the region according to
     its individual fill prefix.  Thus, if the lines of a paragraph
     are indented with spaces, the filled paragraph will continue to
     be indented in the same fashion.

       The first two arguments, START and END, are the beginning and
     end of the region that will be filled.  The third and fourth
     arguments, JUSTIFYP and MAILP, are optional.  If JUSTIFYP is
     non-`nil', the paragraphs are justified as well as filled.  If
     MAILP is non-`nil', the function is told that it is operating on
     a mail message and that it should not fill the header lines.

 * Command: fill-region-as-paragraph START END &optional JUSTIFY-FLAG

       This function considers a region of text as paragraph and fills
     it.  If the region was made up of many paragraphs, the blank
     lines between paragraphs are removed.  This function justifies
     the region when called interactively with a non-`nil' prefix
     argument, or when called from a program with a non-`nil' third
     argument.

 * Command: justify-current-line

       This function inserts spaces between the words of the line point
     is in so that the line ends at `fill-column'.



File: lispref,  Node: Sorting,  Next: Indentation,  Prev: Filling,  Up: Text

Sorting
=======

  The sorting commands described in this section all rearrange text in
a buffer.  This is in contrast to the function `sort', which
rearranges the order of the elements of a list (*note
Rearrangement::.).

 * Command: sort-regexp-fields REVERSE RECORD-REGEXP KEY START END

       This command sorts the region between START and END
     lexicographically as specified by RECORD-REGEXP and KEY.

        `Lexicographic' means that the function compares the first
     characters of each field, the second characters, and so on.  One
     field is less than a second field in the ordering when compared
     characters do not match; the field whose character is less than
     the other is the lesser field.  One character is considered to
     be less than another if its numerical value as a character is
     less than the other.  Since Emacs uses the ASCII character set,
     the ordering in that set determines lexicographic order.

       The value of the RECORD-REGEXP argument specifies the textual
     units or "records" that should be sorted.  For example, to sort
     lines, the value of RECORD-REGEXP would be `^.+$', which matches
     lines with at least one character besides a newline.

       (*Note Regular Expressions::, for a description of the syntax
     and meaning of regular expressions.)

       The value of the KEY argument specifies what of each record is
     to be used for sorting.  The KEY could match the whole record,
     but it may be just a part of the record.  In the latter case,
     the part of each record that is not used for sorting has no
     effect on the sort.

       The KEY argument can refer to match-fields within the regular
     expression for the record; or it can be a regular expression on
     its own.

       If KEY is:

    `\DIGIT'
          The DIGIT'th `\(...\)' match field from RECORD-REGEXP is
          used for sorting.

    `\&'
          The whole record is used for sorting.

    a regular-expression
          The function searches for a match for the
          regular-expression within the record.  If such a match is
          found, it is used for sorting.  If a match for KEY is not
          found within a record then that record is ignored, which
          means its position in the buffer is not changed.  (The
          other records may move around it.)

       The `sort-regexp-fields' function sorts in reverse order when
     the first argument, REVERSE, is negative.  Called interactively,
     it sorts in reverse order when passed a negative prefix argument.

       For example, if you plan to sort all the lines in the region by
     the first word on each line starting with the letter `f', you
     should set RECORD-REGEXP to `^.*$' and set KEY to `\<f\w*\>'.

       The resulting expression looks like this:

          (sort-regexp-fields nil
                              "^.*$"
                              "\\<f\\w*\\>"
                              (region-beginning)
                              (region-end))

       If you call  `sort-regexp-fields' interactively, you are
     prompted for RECORD-REGEXP and KEY and you can type them in
     without enclosing them in quotation marks and without inserting
     a second `\' to quote each `\'.

 * Command: sort-subr REVERSE NEXTRECFUN ENDRECFUN &optional
STARTKEYFUN ENDKEYFUN

       This command is the general text sorting routine that divides a
     buffer into records and sorts them.

       The functions `sort-lines', `sort-paragraphs', `sort-pages',
     `sort-fields', and `sort-numeric-fields' all use `sort-subr'.

       To understand how `sort-subr' works, consider the whole
     accessible portion of the buffer as being divided into disjoint
     pieces called "sort records".  A portion of each sort record
     (perhaps all of it) is designated as the sort key.  The records
     are rearranged in the buffer in order by their sort keys.  The
     records may or may not be contiguous.

       Usually, the records are rearranged in order of ascending sort
     key.  If the first argument to the `sort-subr' function,
     REVERSE, is non-`nil', the sort records are rearranged in order
     of descending sort key.

       The  next four arguments to `sort-subr'  are functions that are
     called to move point across a sort record.  They are called many
     times from within `sort-subr'.

       1. NEXTRECFUN is called with point at the end of the previous
          record.  This function moves point to the start of the next
          record.  The first record is assumed to start at the
          position of point when `sort-subr' is called.

       2. ENDRECFUN is called with point within the record.  It moves
          point to the end of the record.

       3. STARTKEYFUN may move point from the start of the record to
          the start of the key.  This argument is optional.  It will
          either return a non-nil value that will be used as the key,
          or it will return `nil' and the key will be the substring
          between the values of point before and after ENDKEYFUN is
          called.

       4. ENDKEYFUN moves point from the start of the sort key to the
          end of the sort key.  This argument is optional.  ENDKEYFUN
          may be `nil' if STARTKEYFUN returns a value that will be
          used as the key or if the key continues to the end of the
          record.

       For an example of `sort-subr', here is the complete function
     definition for `sort-lines':

          (defun sort-lines (reverse beg end)
            "Sort lines in region alphabetically; arg means reverse order.
          Called from a program, there are three arguments:
          REVERSE (non-nil means reverse order),
          and BEG and END (the region to sort)."
            (interactive "P\nr")
            (save-restriction
              (narrow-to-region beg end)
              (goto-char (point-min))
              (sort-subr reverse 'forward-line 'end-of-line)))

     In the `sort-lines' function, `forward-line' moves point to the
     start of the next record, and `end-of-line' moves point to the
     end of record.

     The `sort-paragraphs' function is very much the same, except
     that its `sort-subr' call looks like this:

          (sort-subr reverse
                     (function (lambda () (skip-chars-forward "\n \t\f")))
                     'forward-paragraph)))

 * Command: sort-lines REVERSE START END

       This command sorts lines in the region between START and END
     alphabetically.  If REVERSE is non-`nil', the sort is in reverse
     order.

 * Command: sort-paragraphs REVERSE START END

       This command sorts paragraphs in the region between START and
     END alphabetically.  If REVERSE is non-`nil', the sort is in
     reverse order.

 * Command: sort-pages REVERSE START END

       This command sorts pages in the region between START and END
     alphabetically.  If REVERSE is non-`nil', the sort is in reverse
     order.

 * Command: sort-fields FIELD START END

       This command sorts lines in the region between START and END
     lexicographically by the FIELD'th field of each line.  Fields
     are separated by whitespace and numbered from `1' up.  If
     `field' is negative, sorting is by the -FIELD'th field, in
     reverse order.  This command is useful for sorting tables.

 * Command: sort-numeric-fields FIELD START END

       This command sorts lines in the region between START and END
     numerically by the FIELD'th field of each line.  Fields are
     separated by whitespace and numbered from `1' up.  Specified
     field must contain a number in each line of the region.  If
     `field' is negative, sort by the -FIELD'th field, in reverse
     order.  This command is useful for sorting tables.

 * Command: sort-columns REVERSE &optional BEG END

       This command sorts lines in the region between BEG and END
     alphabetically by a certain range of columns.  For the purpose
     of this command, the region includes the entire line that point
     is in and the entire line containing END.  The column positions
     of BEG and END bound the range of columns to sort on.

       If REVERSE is non-`nil', the sort is in reverse order.

       Note that `sort-columns' uses the `sort' utility program and
     therefore cannot work properly on text containing tab
     characters.  (Use `M-x `untabify'' to convert tabs to spaces
     before sorting.) The `sort-columns' function cannot work in VMS.



File: lispref,  Node: Indentation,  Next: Indent Tabs,  Prev: Sorting,  Up: Text

Indentation
===========

  The indentation functions are used to examine, move to, and change
whitespace that is at the beginning of a line.  Some of the functions
can also change whitespace elsewhere on a line.  Indentation always
counts from zero at the beginning of a line.

 * Command: back-to-indentation

       This command moves point to the first non-whitespace character
     in the the current line (which is the line in which point is
     located).

 * Command: backward-to-indentation ARG

       This command moves point backward ARG lines and positions point
     at the first nonblank character.

 * Function: current-indentation

       This function returns the indentation of the current line.  This
     is the horizontal position of the character following any
     initial whitespace.

 * Command: forward-to-indentation ARG

       This command moves point forward ARG lines and positions it at
     the first nonblank character.

 * Variable: indent-line-function

       This variable's value is the function that will be called to
     indent the current line.  The default value is
     `indent-to-left-margin', and in Lisp mode it would be set to
     `lisp-indent-line' and in C mode it would be set to
     `c-indent-line'.

       A command such as `indent-according-to-mode' is no more than a
     `funcall' to this function.

       In Lisp mode, the value is the symbol `lisp-indent-line'; in C
     mode, `c-indent-line'; in Fortran mode, `fortran-indent-line'. 
     In Fundamental mode, Text mode, and many other modes with no
     standard for indentation, it is `indent-to-left-margin'.

 * Command: indent-according-to-mode

       This command calls the function in `indent-line-function' to
     indent the current line in a way appropriate for the current
     major mode.

 * Command: indent-for-tab-command

       This command calls the function in `indent-line-function' to
     indent the current line, except that if that function is
     `indent-to-left-margin', `insert-tab' is called instead.

 * Variable: left-margin

       This variable is the column to which the default
     `indent-line-function' will indent.  (That function is
     `indent-to-left-margin'.)  In Fundamental mode, LFD indents to
     this column.  This variable automatically becomes local when set
     in any fashion.

 * Function: indent-to-left-margin

       This is the default `indent-line-function'.  It is used in
     Fundamental mode, Text mode, etc.

       Its effect is to make the indentation at the beginning of the
     current line exactly the amount specified by the variable
     `left-margin'.  This may involve inserting additional
     indentation or deleting extra indentation.

 * Command: indent-region START END TO-COLUMN

       This command indents each nonblank line starting between START
     (inclusive) and END (exclusive).  If TO-COLUMN is `nil',
     `indent-region' indents each nonblank line according to the
     indentation function that is bound to TAB in that mode, such as
     `indent-to-left-margin' in Fundamental mode, `lisp-indent-line'
     in Lisp Interaction mode, and `c-indent-line' in C mode.  If
     TO-COLUMN is an integer, this function indents each line to that
     column.

 * Variable: indent-region-function

       The value of this variable is a function that can be used by
     `indent-region' as a short cut.  It ought to produce the same
     results as indenting the lines of the region one by one, which
     is the definition of `indent-region' with argument `nil'.

       If the value is `nil', there is no short cut, and
     `indent-region' actually works line by line.

       A short cut is useful in modes such as C mode and Lisp mode,
     where the `indent-line-function' must scan from the beginning of
     the function: applying it to each line would be quadratic in
     time.  The short cut can update the scan information as it moves
     through the lines indenting them; this takes linear time.  If
     indenting a line individually is fast, there is no need for a
     short cut.

       `indent-region' with a non-`nil' argument has a different
     definition and does not use this variable.

 * Command: indent-relative &optional UNINDENTED-OK

       This function inserts whitespace at point, extending to the same
     column as the next "indent point" of the previous nonblank line.
     An indent point is a non-whitespace character following
     whitespace.  The next indent point is the first one at a column
     greater than the current column of point.

       If the previous nonblank line has no next indent point (i.e.,
     none at a great enough column position), this function calls
     `tab-to-tab-stop'; except that if the optional argument,
     UNINDENTED-OK, is non-`nil', then, if the previous nonblank line
     has no indent points beyond the column at which point starts,
     this function does nothing.

       Thus, if point is underneath, but to the right of the last
     column of a short line of text, this function moves point to the
     next tab stop by inserting whitespace.  If point is underneath
     and to the left of the first non-blank character of a line of
     text, point is moved to that column by inserting whitespace.

       In the first example, point is at the beginning of the third line.

                      This line is indented twelve spaces.
          -!-The quick brown fox jumped over the lazy dog.

      Evaluation of the expression `(indent-relative nil)' produces
     the following:

                      This line is indented twelve spaces.
                      -!-The quick brown fox jumped over the lazy dog.

        In the next example, point is between the `m' and `p' of `jumped':

                      This line is indented twelve spaces.
          
          The quick brown fox jum-!-ped over the lazy dog.

      Evaluation of the expression `(indent-relative nil)' produces
     the following:

                      This line is indented twelve spaces.
          
          The quick brown fox jum  -!-ped over the lazy dog.

  * Command: indent-relative-maybe

       This command indents the line on which point is located like the
     previous nonblank line.  The function consists of a call to
     `indent-relative' with a non-`nil' value passed to the
     UNINDENTED-OK optional argument.

       If the previous line is not indented, then the line on which
     point is located is given no indentation; and if the previous
     nonblank line has no indent points beyond the column at which
     point starts, this function does not do any indentation.

 * Command: indent-rigidly START END COUNT

       This command indents all lines starting between START
     (inclusive) and END (exclusive) sideways by `count' columns.

       Thus, if you wish to indent all lines in a region by 3 spaces,
     you execute this command with a COUNT of 3.

       In Mail mode, `C-c C-y' (`mail-yank-original') uses
     `indent-rigidly' to indent the text copied from the message
     being replied to.

       This command adds indentation to lines that are already
     indented; it `preserves the shape' of the indented region,
     moving it sideways as a single unit.  Consequently, this command
     is useful not only for indenting regions of unindented text, but
     also for indenting regions of formatted code.

 * Option: indent-tabs-mode

       If this user option is non-`nil', indentation functions can
     insert tabs rather than spaces.  Setting this variable
     automatically makes it local to the current buffer.

 * Command: indent-to COL &optional MINIMUM

       This function indents from point with tabs and spaces until
     COLUMN is reached.  It always indents by at least MIN spaces
     even if that goes past COLUMN; by default, MIN is zero.

 * Command: newline-and-indent

       This function inserts a newline, and then indents the new line
     according to the major mode.

       Indentation is done using the current `indent-line-function'. 
     In programming language modes, this is the same as TAB.  In some
     text modes, where TAB inserts a tab, `newline-and-indent'
     indents to the value of `left-margin'.

 * Command: reindent-then-newline-and-indent

       This command reindents current line, inserts a newline at point,
     and then indents the new line.

     Indentation of both lines is done according to the current major
     mode; this means that the current value of
     `indent-line-function' is called.  In programming language
     modes, this is the same as TAB.  In some text modes, where TAB
     inserts a tab, `reindent-then-newline-and-indent' indents to the
     column specified by `left-margin'.



File: lispref,  Node: Indent Tabs,  Next: Columns,  Prev: Indentation,  Up: Text

Tabs for Indentation
====================

  The following tab functions insert indentation in user specified
amounts.  They do not simply insert tab characters.

 * Function: tab-to-tab-stop

       This function inserts spaces or tabs to the next defined
     "tab-stop" column.  The variable `tab-stop-list' is a list of
     columns at which there are tab stops.  The distance between tab
     stops need not be constant.  This feature is convenient if you
     are making tables with columns of differing width.

       Use `M-x edit-tab-stops' to edit the location of tab stops
     interactively.

 * Option: tab-stop-list

       This variable is the list of tab stop positions used by
     `tab-to-tab-stops'.  The tab stop positions need not be equally
     spaced.

       Note that `tab-stop-list' has nothing to do with the tab
     character and is not related to the `tab-width' variable.



File: lispref,  Node: Columns,  Next: Case Changes,  Prev: Indent Tabs,  Up: Text

Columns
=======

  The column functions do not take into account the width of windows,
or the amount of horizontal scrolling.  As a consequence, the value
of COLUMN can be arbitrarily high.

  The first (or leftmost) column is numbered `0'.

 * Function: current-column

       This function returns the horizontal position of point.  The
     beginning of a line is column 0.  The column is calculated by
     adding together the widths of all the displayed representations
     of the characters between the start of the current line and
     point.  This means control characters will be counted as
     occupying 2 or 4 columns, depending upon the value of
     `ctl-arrow', and tabs will be counted as occupying a number of
     columns that depends on the value of `tab-width'.

       The `current-column' function ignores the finite width of the
     screen, which means that this function may return values greater
     than `(screen-width)'.

       For a more complicated example of use of `current-column', see
     the description of `count-lines' in *Note Lines::.

 * Function: move-to-column COLUMN

       This function moves point to COLUMN in the current line.  The
     calculation of COLUMN takes into account the widths of all the
     displayed representations of the characters between the start of
     the line and point.  Thus control characters are calculated to
     occupy 2 or 4 columns, depending upon the setting of
     `ctl-arrow', and tabs to occupy a number of columns that depends
     on the value of `tab-width'.

       The `move-to-column' function may be passed values greater than
     the value returned by `(screen-width)'.  If the current line is
     not that wide, then point is moved to the end of the line.  If
     COLUMN is negative, point is moved to the beginning of the line.
     cOLUMN must be an integer.

       The result is the column number actually moved to.



File: lispref,  Node: Case Changes,  Next: Underlining,  Prev: Columns,  Up: Text

Case Changes
============

  These case change commands work on text in the current buffer.  *Note
Character Case::, for case conversion commands that work on strings
and characters.

 * Command: capitalize-region START END

       This function capitalizes all words in the region defined by
     START and END.  To `capitalize' means to convert each word's
     first character to upper case and convert the rest of each word
     to lower case.  The function returns `nil'.

       If one end of the region is in the middle of a word, the part of
     the word within the region is treated as an entire word.

       When `capitalize-region' is called interactively, START and END
     are point and mark, smallest first.

          --------- Buffer: foo ---------
          This is the contents of the 5th foo.
          --------- Buffer: foo ---------
          
          (capitalize-region 1 44)
          => nil
          
          --------- Buffer: foo ---------
          This Is The Contents Of The 5th Foo.
          --------- Buffer: foo ---------

 * Command: downcase-region START END

       This function converts all of the letters in the region defined
     by START and END to lower case.  The function returns `nil'.

       When `downcase-region' is called interactively, START and END
     are point and mark, smallest first.

 * Command: upcase-region START END

       This function converts all of the letters in the region defined
     by START and END to upper case.  The function returns `nil'.

       When `upcase-region' is called interactively, START and END are
     point and mark, smallest first.

 * Command: capitalize-word COUNT

       This function capitalizes COUNT words after point, moving point
     over as it does.  To `capitalize' means to convert each word's
     first character is upper case and convert the rest of each word
     to lower case.  If COUNT is negative, the function capitalizes
     the -COUNT previous words but does not move point.

       If point is in the middle of a word, the part of the before
     point (if moving forward) or after point (if operating backward)
     is ignored.  The rest is treated as an entire word.

       When `capitalize-word' is called interactively, COUNT is set to
     the numeric prefix argument.

 * Command: downcase-word COUNT

       This function converts the COUNT words after point to all lower
     case, moving point over as it does.  If COUNT is negative, it
     converts the -COUNT previous words but does not move point.

       When `downcase-word' is called interactively, COUNT is set to
     the numeric prefix argument.

 * Command: upcase-word COUNT

       This function converts the COUNT words after point to all upper
     case, moving point over as it does.  If COUNT is negative, it
     converts the -COUNT previous words but does not move point.

       When `upcase-word' is called interactively, COUNT is set to the
     numeric prefix argument.



File: lispref,  Node: Underlining,  Next: Registers,  Prev: Case Changes,  Up: Text

Underlining
===========

  The underlining commands are somewhat obsolete.  The
`underline-region' function actually inserts `_^H' before each
appropriate character in the region.  This command provides a minimal
text formatting feature that might work on your printer; but you are
encouraged to use more powerful text formatting facilities instead,
such as Texinfo.

 * Command: underline-region START END

       This function underlines all nonblank characters in the region
     defined by START and END.  That is, an underscore character and
     a backspace character are inserted just before each
     non-whitespace character in the region.  However, the backspace
     characters are displayed by Emacs as either `\010' or `^H',
     depending on the setting of `ctl-arrow'.

 * Command: ununderline-region START END

       This function removes all underlining (overstruck underscores)
     in the region defined by START and END.



File: lispref,  Node: Registers,  Prev: Underlining,  Up: Text

Registers
=========

  A register is a user-level variable in emacs that can hold a marker,
a string, or a rectangle.  Each register is named by a single
character.  All characters, including control and meta characters,
can be used to name registers, except for `C-g'.  There are thus 255
possible registers.

 * Variable: register-alist

       This variable is an alist of elements in the form `(NAME . 
     CONTENTS)'.  Normally, there is one element for each Emacs
     register that has been used.  NAME is a character (a number)
     identifying the register.  CONTENTS is a string, marker, or list.
     A list represents a rectangle; its elements are strings.

 * Command: view-register REG

       This command displays what is contained in the register named
     REG.  REG is a character.

 * Function: get-register REG

       This function returns the contents of the register named REG, or
     `nil' if it has no contents.  The name of the register is a
     character.

 * Function: set-register REG VALUE

       This function sets the contents of the register named REG to
     VALUE.  A register can be set to any value; however, the various
     other register functions know only about strings, markers, and
     lists.

 * Command: point-to-register REG

       This command stores both the current location of point and the
     current buffer in a register as a marker.  The argument REG must
     be a character, which names the register.

 * Command: register-to-point REG

       This command moves point to the location in the buffer that was
     stored in the register named by the argument.  The argument must
     be a character.  Since both the buffer and the location within
     the buffer are stored by the `point-to-register' function, this
     command can switch you to another buffer.

 * Command: insert-register REG &optional BEFOREP

       This command inserts contents of register REG into the current
     buffer.  REG is a character that names the register.

       Normally, this command puts point before and mark after the
     inserted text.  If the optional second argument BEFOREP is
     non-`nil', the command puts mark before and point after.  You
     can pass a non-`nil' second argument `beforep' to this function
     interactively by supplying it with a prefix argument.

 * Command: copy-to-register REG START END &optional DELETE-FLAG

       This command copies the region from START to END into register
     REG.  If DELETE-FLAG is non-`nil', this command deletes the
     region from the buffer after copying it into the register.

 * Command: prepend-to-register REG START END &optional DELETE-FLAG

       This command prepends the region from START to END into register
     REG.  If DELETE-FLAG is non-`nil', this command deletes the
     region from the buffer after copying it to the register.

 * Command: append-to-register REG START END &optional DELETE-FLAG

       This command appends the region from START to END to the text
     already in register REG.  If DELETE-FLAG is non-`nil', this
     command deletes the region from the buffer after copying it to
     the register.

 * Command: copy-rectangle-to-register REG START END &optional
DELETE-FLAG

       This command copies a rectangular region from START to END into
     register REG.  If DELETE-FLAG is non-`nil', this command deletes
     the region from the buffer after copying it to the register.



File: lispref,  Node: Searching and Matching,  Next: Syntax Tables,  Prev: Text,  Up: Top

Searching and Matching
**********************

  GNU Emacs provides two ways to search through a buffer for specified
text: exact string searches and regular expression searches. 
"Matching" may be used following a regular expression search to
specify the positions of sub-expressions found by a regular
expression search.  This chapter also describes replacement functions.

* Menu:

* String Search::         Search for an exact match.
* Regular Expressions::   Describing classes of strings.
* Regexp Search::         Searching for a match for a regexp.
* Replacement::           Replacing text that was just matched.
* Match Data::            Finding out which part of the text matched
                            various parts of a regexp, after regexp search.
* Standard Regexps::      Useful regexps for finding sentences, pages,...
* Searching and Case::    Case-independent or case-significant searching.

 

File: lispref,  Node: String Search,  Next: Regular Expressions,  Prev: Searching and Matching,  Up: Searching and Matching

Searching for Strings
=====================

  These are the primitive functions for searching through the text in a
buffer.  They are meant for use in programs, but you may call them
interactively.  If you do so, Emacs prompts you for the search
string; LIMIT and NOERROR, are set to `nil', and REPEAT is set to 1.

 * Command: search-forward STRING &optional LIMIT NOERROR REPEAT

       This function searches forward from point for an exact match for
     STRING.  It sets point to the end of the occurrence found, and
     returns `t'.  If no match is found, the value and side effects
     depend on NOERROR.

       In this example, point is positioned at the beginning of the line.
     Then `(search-forward "fox")' is evaluated in the minibuffer and
     point is left after the last letter of `fox':

          --------- Buffer: foo ---------
          -!-The quick brown fox jumped over the lazy dog.
          --------- Buffer: foo ---------
          
          (search-forward "fox")
               => t
          
          --------- Buffer: foo ---------
          The quick brown fox-!- jumped over the lazy dog.
          --------- Buffer: foo ---------

       If LIMIT is non-`nil' (it must be a position in the current
     buffer), then it is the upper bound to the search.  No match
     extending after that position is accepted.

       What happens when the search fails depends on the value of
     NOERROR.

       If NOERROR is `nil', a `search-failed' error is signaled.  If
     NOERROR is `t', `search-forward' returns `nil' and doesn't
     signal an error.  If NOERROR is neither `nil' nor `t', then
     `search-forward' moves point to LIMIT and returns `nil'.

       If REPEAT is non-`nil', then the search is repeated that many
     times.  Point is positioned at the end of the last match.

 * Command: search-backward STRING &optional LIMIT NOERROR REPEAT

       This function searches backward from point for STRING.  It is
     just like `search-forward' except that it searches backwards and
     leaves point at the beginning of the match.

 * Command: word-search-forward STRING &optional LIMIT NOERROR REPEAT

       This function searches forward from point for a ``word'' match
     for STRING.  It sets point to the end of the occurrence found,
     and returns `t'.

       A word search differs from a simple string search in that a word
     search *requires* that the words it searches for are entire
     words (searching for the word `ball' will not match the word
     `balls'), and punctuation and spacing are ignored (searching for
     `ball boy' will match `ball.  Boy!').

       In this example, point is first placed at the beginning of the
     buffer; the search leaves it between the `y' and the `!'.

          --------- Buffer: foo ---------
          -!-He said ``Please!  Find
          the ball boy!''
          --------- Buffer: foo ---------
          
          (word-search-forward "Please find the ball, boy.")
               => t
          
          --------- Buffer: foo ---------
          He said ``Please!  Find
          the ball boy-!-!''
          --------- Buffer: foo ---------

       If LIMIT is non-`nil' (it must be a position in the current
     buffer), then it is the upper bound to the search.  The match
     found must not extend after that position.

       If NOERROR is `t', then `word-search-forward' returns `nil' when
     a search fails, instead of signalling an error.  If NOERROR is
     neither `nil' nor `t', then `word-search-forward' moves point to
     LIMIT and returns `nil'.

       If REPEAT is non-`nil', then the search is repeated that many
     times.  Point is positioned at the end of the last match.

 * Command: word-search-backward STRING &optional LIMIT NOERROR REPEAT

       This function searches backward from point for a word match to
     STRING.  This function is just like `word-search-forward' except
     that it searches backward and normally leaves point at the
     beginning of the match.



File: lispref,  Node: Regular Expressions,  Next: Regexp Search,  Prev: String Search,  Up: Searching and Matching

Regular Expressions
===================

  A "regular expression" ("regexp", for short) is a pattern that
denotes a (possibly infinite) set of strings.  Searching for matches
for a regexp is a very powerful operation.  This section explains how
to write regexps; the following section says how to search for them.

* Menu:

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.

 

File: lispref,  Node: Syntax of Regexps,  Next: Regexp Example,  Prev: Regular Expressions,  Up: Regular Expressions

Syntax of Regular Expressions
-----------------------------

  Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary
character is a simple regular expression which matches that character
and nothing else.  The special characters are `$', `^', `.', `*',
`+', `?', `[', `]' and `\'; no new special characters will be defined
in the future.  Any other character appearing in a regular expression
is ordinary, unless a `\' precedes it.  If a regular expression is
malformed, an `invalid-regexp' error is signaled.

For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does *not* match the string `ff'.)  Likewise,
`o' is a regular expression that matches only `o'.

Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some
amount of the beginning of that string and B matches the rest of the
string.

As a simple example, we can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  Still trivial.  To do something more powerful, you need
to use one of the special characters.  Here is a list of them:

`. (Period)'
     is a special character that matches any single character except
     a newline.  Using concatenation, we can make regular expressions
     like `a.b' which matches any three-character string which begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a suffix, which means the
     preceding regular expression is to be repeated as many times as
     possible.  In `fo*', the `*' applies to the `o', so `fo*'
     matches one `f' followed by any number of `o's.  The case of
     zero `o's is allowed: `fo*' does match `f'.

     `*' always applies to the *smallest* possible preceding
     expression.  Thus, `fo*' has a repeating `o', not a repeating
     `fo'.

     The matcher processes a `*' construct by matching, immediately,
     as many repetitions as can be found.  Then it continues with the
     rest of the pattern.  If that fails, backtracking occurs,
     discarding some of the matches of the `*'-modified construct in
     case that makes it possible to match the rest of the pattern. 
     For example, matching `ca*ar' against the string `caaar', the
     `a*' first tries to match all three `a's; but the rest of the
     pattern is `ar' and there is only `r' left to match, so this try
     fails.  The next alternative is for `a*' to match only two `a's.
     With this choice, the rest of the regexp matches successfully.

`+'
     is a suffix character similar to `*' except that it requires
     that the preceding expression be matched at least once.  So, for
     example, `ca+r' will match the strings `car' and `caaaar' but
     not the string `cr', whereas `ca*r' would match all three strings.

`?'
     is a suffix character similar to `*' except that it can match
     the preceding expression either once or not at all.  For
     example, `ca?r' will match `car' or `cr'; nothing else.

`[ ... ]'
     `[' begins a "character set", which is terminated by a `]'.  In
     the simplest case, the characters between the two form the set. 
     Thus, `[ad]' matches either one `a' or one `d', and `[ad]*'
     matches any string composed of just `a's and `d's (including the
     empty string), from which it follows that `c[ad]*r' matches
     `cr', `car', `cdr', `caddaar', etc.

     Character ranges can also be included in a character set, by
     writing two characters with a `-' between them.  Thus, `[a-z]'
     matches any lower-case letter.  Ranges may be intermixed freely
     with individual characters, as in `[a-z$%.]', which matches any
     lower case letter or `$', `%' or a period.

     Note that the usual special characters are not special any more
     inside a character set.  A completely different set of special
     characters exists inside character sets: `]', `-' and `^'.

     To include a `]' in a character set, make it the first character.
     For example, `[]a]' matches `]' or `a'.  To include a `-', write
     `--', which is a range containing only `-', or write `-' as the
     first character in the range.

     To include `^', make it other than the first character in the set.

`[^ ... ]'
     `[^' begins a "complement character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]'
     matches all characters *except* letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (thus, `-' and `]' are not special there).

     Note that a complement character set can match a newline, unless
     newline is mentioned as one of the characters not to match.

`^'
     is a special character that matches the empty string, but only
     at the beginning of a line in the text being matched.  Otherwise
     it fails to match anything.  Thus, `^foo' matches a `foo' which
     occurs at the beginning of a line.

     When matching a string, `^' matches at the beginning of the
     string or after a newline character `\n'.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `x+$' matches a string of one `x' or more at the end of a line.

     When matching a string, `$' matches at the end of the string or
     before a newline character `\n'.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression which matches only `$', and `\[' is a regular
     expression which matches only `[', and so on.

     Note that `\' also has special meaning inside the read syntax of
     Lisp strings (*note String Type::.), and must be quoted with `\'.
     For example, the regular expression that matches the `\'
     character is `\\'.  When you want a Lisp string that contains
     `\\', Lisp syntax says that you must quote each `\' with another
     `\'.  The result is `"\\\\"'.

Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings
make no sense.  For example, `*foo' treats `*' as ordinary since
there is no preceding expression on which the `*' can act.  It is
poor practice to depend on this behavior; better to quote the special
character anyway, regardless of where is appears.

For the most part, `\' followed by any character matches only that
character.  However, there are several exceptions: characters which,
when preceded by `\', are special constructs.  Such characters are
always ordinary when encountered on their own.  Here is a table of
`\' constructs.

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches anything that
     either A or B matches.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other
     string.

     `\|' applies to the largest possible surrounding expressions. 
     Only a surrounding `\( ... \)' grouping can limit the grouping
     power of `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations.
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose a complicated expression for a suffix character
          such as `*' to operate on.  Thus, `ba\(na\)*' matches
          `bananana', etc., with any (zero or more) number of `na'
          strings.

       3. To record a matched substring for future reference.

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature which happens
     to be assigned as a second meaning to the same `\( ... \)'
     construct because there is no conflict in practice between the
     two meanings.  Here is an explanation of this feature:

`\DIGIT'
     after the end of a `\( ... \)' construct, the matcher remembers
     the beginning and end of the text matched by that construct. 
     Then, later on in the regular expression, you can use `\'
     followed by DIGIT to mean ``match the same text matched the
     DIGIT'th time by the `\( ... \)' construct.''

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through
     9 in order that the open-parentheses appear in the regular
     expression.  `\1' through `\9' may be used to refer to the text
     matched by the corresponding `\( ... \)' construct.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the
     first half, which may be anything, but the `\1' that follows
     must match the same exact text.

`\`'
     matches the empty string, provided it is at the beginning of the
     buffer.

`\''
     matches the empty string, provided it is at the end of the buffer.

`\b'
     matches the empty string, provided it is at the beginning or end
     of a word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

`\B'
     matches the empty string, provided it is *not* at the beginning
     or end of a word.

`\<'
     matches the empty string, provided it is at the beginning of a
     word.

`\>'
     matches the empty string, provided it is at the end of a word.

`\w'
     matches any word-constituent character.  The editor syntax table
     determines which characters these are.  *Note Syntax Tables::.

`\W'
     matches any character that is not a word-constituent.

`\sCODE'
     matches any character whose syntax is CODE.  CODE is a character
     which represents a syntax code: thus, `w' for word constituent,
     `-' for whitespace, `(' for open-parenthesis, etc.  *Note Syntax
     Tables::, for a list of the codes.

`\SCODE'
     matches any character whose syntax is not CODE.

 * Function: regexp-quote STRING

       This function returns a regular expression string which matches
     exactly STRING and nothing else.  This allows you to request an
     exact string match when calling a function that wants a regular
     expression.

          (regexp-quote "^The cat$")
               => "\\^The cat\\$"

     One use of `regexp-quote' is to combine an exact string match
     with context described as a regular expression.  For example,
     this searches for the string which is the value of `string',
     surrounded by whitespace:

          (re-search-forward (concat "\\s " (regexp-quote string) "\\s "))



File: lispref,  Node: Regexp Example,  Prev: Syntax of Regexps,  Up: Regular Expressions

Complex Regexp Example
----------------------

  Here is a complicated regexp, used by Emacs to recognize the end of a
sentence together with any whitespace that follows.  It is the value
of the variable `sentence-end'.

  First, the regexp is given in Lisp syntax to enable you to
distinguish the spaces from the tab characters.  In Lisp syntax, the
string constant begins and ends with a double-quote.  `\"' stands for
a double-quote as part of the regexp, `\\' for a backslash as part of
the regexp, `\t' for a tab and `\n' for a newline.

     "[.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*"

  In contrast, if you evaluate the variable `sentence-end', you will
see the following:

     sentence-end
     =>
     "[.?!][]\"')}]*\\($\\|  \\|  \\)[       
     ]*"

In this case, the tab and carriage return are the actual characters.

  This regular expression contains four parts in succession and can be
deciphered as follows:

`[.?!]'
     The first part of the pattern consists of three characters, a
     period, a question mark and an exclamation mark, within square
     brackets.  The match must begin with one or other of these
     characters.

`[]\"')}]*'
     The second part of the pattern is the group of closing braces
     and quotation marks, which can appear zero or more times.  These
     may follow the period, question mark or exclamation mark.  The
     `\"' is Lisp syntax for a double quote in a string.  The `*' at
     the end indicates that the items in the previous group (the
     group surrounded by square brackets, `[]') may be repeated zero
     or more times.

`\\($\\|\t\\|  \\)'
     The third part of the pattern is one or other of: either the end
     of a line, or a tab, or two blank spaces.  The double
     backslashes are needed to prevent Emacs from reading the
     parentheses and vertical bars as part of the search pattern; the
     parentheses are used to mark the group and the vertical bars are
     used to indicated that the patterns to either side of them are
     alternatives.  The dollar sign is used to indicate the end of a
     line.  The tab character is inserted using `\t' and the two
     spaces are inserted as is.

`[ \t\n]*'
     Finally, the last part of the pattern indicates that the end of
     the line or the whitespace following the period, question mark
     or exclamation mark may, but need not, be followed by additional
     whitespace.



File: lispref,  Node: Regexp Search,  Next: Replacement,  Prev: Regular Expressions,  Up: Searching and Matching

Regular Expression Searching
============================

  In GNU Emacs, you can search for the next match for a regexp either
incrementally or not.  Incremental search commands are described in
the ``The GNU Emacs Manual''.  *Note : (emacs)Regexp Search.  Here we
describe only the search functions useful in programs.  The primary
function is `re-search-forward'.

 * Command: re-search-forward REGEXP &optional LIMIT NOERROR REPEAT

       This function searches forward in the current buffer for a
     string of text that is matched by the regular expression REGEXP.
     The function skips over any amount of text that is not matched
     by REGEXP, and leaves point at the end of the first string of
     text that does match.

       If the search is successful (i.e., if there is text that is
     matched by REGEXP), then point is left at the end of that text,
     and the function returns `t'.

       What happens when the search fails depends on the value of
     NOERROR.

       If NOERROR is `nil', a `search-failed' error is signaled.  If
     NOERROR is `t', `re-search-forward' returns `nil' and doesn't
     signal an error.  If NOERROR is neither `nil' nor `t', then
     `search-forward' moves point to LIMIT and returns `nil'.

       If LIMIT is non-`nil' (it must be a position in the current
     buffer), then it is the upper bound to the search.  No match
     extending after that position is accepted.

     If REPEAT is supplied (it must be a positive number), then the
     search is repeated that many times, and point is left at the end
     of the last match found.

       In this example, point is located directly before the `T'. 
     After evaluating the form, it is located at the end of that line
     (between the `t' of `hat' and before the newline).

          --------- Buffer: foo ---------
          I read "-!-The cat in the hat
          comes back" twice.
          --------- Buffer: foo ---------
          
          (re-search-forward "[a-z]+" nil t 5)
               => t
          
          --------- Buffer: foo ---------
          I read "The cat in the hat-!-
          comes back" twice.
          --------- Buffer: foo ---------

 * Command: re-search-backward REGEXP &optional LIMIT NOERROR REPEAT

       This function searches backward in the current buffer for a
     string of text that is matched by the regular expression REGEXP,
     leaving point at the beginning of the first text found.  This
     function is the exact analog of `re-search-forward'.

 * Function: string-match REGEXP STRING &optional START

       This function returns the index of the start of the first match
     for the regular expression REGEXP in STRING, or `nil' if there
     is no match.  If START is non-`nil', the search is started at
     that index in STRING.

       For example,

          (string-match "quick" "The quick brown fox jumped quickly.")
               => 4
          (string-match "quick" "The quick brown fox jumped quickly." 8)
               => 27

     The index of the first character of the string is 0, the index
     of the second character is 1, and so on.

       After this function returns, the index of the first character
     beyond the match is available as `(match-end 0)'.  *Note Match
     Data::.

          (string-match "quick" "The quick brown fox jumped quickly." 8)
               => 27
          
          (match-end 0)
               => 32

       The `match-end' function is described along with
     `match-beginning'; see *Note Match Data::.

 * Function: looking-at REGEXP

       This function determines whether the text in the current buffer
     directly following point matches the regular expression REGEXP. 
     ``Directly following'' means precisely that: the search is
     ``anchored'' and it must succeed starting with the first
     character following point.  The result is `t' if so, `nil'
     otherwise.

       Point is not moved, but the match data is updated and can be
     used with `match-beginning' or `match-end'.  *Note Match Data::.

       In this example, point is located directly before the `T'.  If
     it were anywhere else, the result would have been `nil'.

          --------- Buffer: foo ---------
          I read "-!-The cat in the hat
          comes back" twice.
          --------- Buffer: foo ---------
          
          (looking-at "The cat in the hat$")
               => t



File: lispref,  Node: Replacement,  Next: Match Data,  Prev: Regexp Search,  Up: Searching and Matching

Replacement
===========

  Emacs has several replacement commands for interactive use.  They are
not recommended for use from programs.  They are:

`replace-regexp'
     This function replaces every match of REGEXP occurring between
     point and the maximum point by REPLACEMENT, which must be a
     string.

`replace-string'
     This function replaces occurrences of STRING with REPLACEMENT.

  For a full description of these, see *Note : ( emacs)Replace.

  The following function replaces characters, not strings, but is
included here since it involves replacement.

 * Function: subst-char-in-region START END OLD-CHAR NEW-CHAR
&optional NOUNDO

       This function replaces all occurrences of the character OLD-CHAR
     with the character NEW-CHAR in the region of the current buffer
     defined by START and END.

       If NOUNDO is non-`nil', then `subst-char-in-region' does not
     record the change for undo and does not mark the buffer as
     modified.  This optional argument is used for obscure purposes;
     for example, in Outline mode to change visible lines to
     invisible lines and vice versa.

       `subst-char-in-region' does not move point and returns `nil'.

          --------- Buffer: foo ---------
          This is the contents of the buffer before.
          --------- Buffer: foo ---------
          
          (subst-char-in-region 1 20 ?i ?X)
               => nil
          
          --------- Buffer: foo ---------
          ThXs Xs the contents of the buffer before.
          --------- Buffer: foo ---------



File: lispref,  Node: Match Data,  Next: Standard Regexps,  Prev: Replacement,  Up: Searching and Matching

Match Data
==========

  Emacs keeps track of the positions of the start and end of segments
of text found during a regular expression search.  This means, for
example, that you can search for a complex pattern, such as  a date
in an rmail message, and extract different parts of it.

 * Function: match-beginning COUNT

       This function returns the position of the start of text matched
     by the last regular expression searched for.  COUNT, a number,
     specifies which subexpression to return the start position of. 
     If COUNT is zero, then it returns the position of the text
     matched by the whole regexp.  If COUNT is greater than zero,
     then the position of the beginning of the text matched by the
     COUNT'th subexpression is returned, regardless of whether it was
     used in the final match.

     Subexpressions are those expressions grouped inside of
     parentheses, `\(...\)'.  The COUNT'th subexpression is found by
     counting occurrences of `\(' from the beginning of the whole
     regular expression.  The first subexpression is numbered 1, the
     second 2, and so on.

     The `match-end' function is similar to the `match-beginning'
     function except that it returns the position of the end of the
     matched text.

     Here is an example, with a comment showing the numbers of the
     positions in the text:

          (string-match "\\(qu\\)\\(ick\\)" "The quick fox jumped quickly.")
               => 4                         ;^^^^^^^^^^
                                            ;0123456789      
          
          (match-beginning 1)              ; The beginning of the match
               => 4                        ; with `qu' is at index 4.
          
          (match-beginning 2)              ; The beginning of the match
               => 6                        ; with `ick' is at index 6.
          
          (match-end 1)                    ; The end of the match
               => 6                        ; with `qu' is at index 6.
          
          (match-end 2)                    ; The end of the match
               => 9                        ; with `ick' is at index 9.

      The `match-end' function is used in functions such as
     `rmail-make-basic-summary-line'.

       Here is another example.  Before the form is evaluated, point is
     located at the beginning of the line.  After evaluating the
     search form, it is located on the line between the space and the
     word `in'.  The beginning of the entire match is at the 9th
     character of the buffer (`T'), and the beginning of the match
     for the first subexpression is at the 13th character (`c').

          (list
            (re-search-forward "The \\(cat \\)")
            (match-beginning 0)
            (match-beginning 1))
          => (t 9 13)
          
          --------- Buffer: foo ---------
          I read "The cat -!-in the hat comes back" twice.
                  ^   ^
                  9  13
          --------- Buffer: foo ---------

     (Note that in this case, the index returned is a buffer
     position; the first character of the buffer counts as 1.)

       It is essential that `match-beginning' be called after the
     search desired and before any other searches are performed. 
     `match-beginning' may not give the desired results if called in
     a separate command from the search.  The example below is the
     wrong way to call `match-beginning'.

          (re-search-forward "The \\(cat \\)")
               => t
          (foo)                   ; Perhaps `foo' does more regexp searching.
          (match-beginning 0)
               => 61              ; Unexpected result!

        See the discussion of `store-match-data' for an example of how
     to save match data and restore the information after an
     intervening search.

 * Function: match-end COUNT

       This function returns the position of the end of text matched by
     the last regular expression searched for.  This function is
     otherwise similar to `match-beginning'.

 * Function: replace-match REPLACEMENT &optional FIXEDCASE LITERAL

       This function replaces the text matched by the last search with
     REPLACEMENT.

       If FIXEDCASE is non-`nil', then the case of the replacement text
     is not changed.  Otherwise, the replacement text is converted to
     a different case depending upon the capitalization of the text
     to be replaced.  If the original text is all upper case, then
     the replacement text is converted to upper case, except when all
     of the words in the original text are only one character long. 
     In that event, the replacement text is capitalized.  If *all* of
     the words in the original text are capitalized, then all of the
     words in the replacement text will be capitalized.

       If LITERAL is non-`nil', then REPLACEMENT is inserted exactly as
     it is, the only alterations being a possible change in case.  If
     it is NIL (the default), then the character `\' is treated
     specially.  If a `\' appears in REPLACEMENT, then it must be
     followed by one of the following characters:

    `\&'
          `\&' is replaced by the entire original text.

    `\N'
          N is a digit.  `\N' is replaced by the N'th subexpression
          in the original regexp.  Subexpressions are those
          expressions grouped inside of `\(...\)'.

    `\\'
          `\\' is replaced by `\'.

     `replace-match' leaves point at the end of the replacement text,
     and returns `t'.

 * Function: match-data

       This function returns a new list containing all the information
     on what the last search matched.  The zero'th element is the
     beginning of the match for the whole expression; the first
     element is the end of the match for the expression.  The next
     two elements are the beginning and end of the match for the
     first subexpression.  In general, the

     2N'th

     element  corresponds to `(match-beginning N)'; and element

     2N + 1

     corresponds to `(match-end N)'.

     All the elements are markers, or `nil' if there was no match for
     that subexpression.  As with other search commands, there must
     be no possibility of intervening searches between the call to a
     search and the call to `match-data' that is intended to save the
     match-data for that search.

          (match-data)
               =>  (#<marker at 9 in foo> #<marker at 17 in foo>
                    #<marker at 13 in foo> #<marker at 17 in foo>)

 * Function: store-match-data MATCH-LIST

       This function sets the internal data structure for the ``last
     search match'' to the elements of MATCH-LIST.  MATCH-LIST should
     have been created by calling `match-data' previously.

     Together with `match-data', `store-match-data' may be used to
     avoid changing the `match-data' if you do a regexp search.  This
     is useful when such searches occur in subroutines whose callers
     may not expect searches to go on.

     The following example illustrates the canonical use of these two
     functions.

          (let ((data (match-data)))
            (unwind-protect
                ... ; May change the original match data.
              (store-match-data data)))

       All asynchronous process functions (filters and sentinels) and
     some modes that use `recursive-edit' should save and restore the
     match data if they do a search or if they let a user make a
     search.  Here is a function which will restore the match data if
     the buffer associated with it still exists.

          (defun restore-match-data (data)
            "Restore the match data DATA unless the buffer is missing."
            (catch 'foo
              (let ((d data))
                (while d
                  (and (car d)
                       (null (marker-buffer (car d)))
                       ;; match-data buffer is deleted.
                       (throw 'foo nil))
                  (setq d (cdr d)))
                (store-match-data data)
                )))



File: lispref,  Node: Standard Regexps,  Next: Searching and Case,  Prev: Match Data,  Up: Searching and Matching

Standard Regular Expressions Used in Editing
============================================

 * Variable: page-delimiter

     This is the regexp describing line-beginnings that separate
     pages.  The default value is `"^\014"' (i.e., `"^^L"' or
     `"^\C-l"').

 * Variable: paragraph-separate

     This is the regular expression for the beginning of a line that
     separates paragraphs.  (If you change this, you may have to
     change `paragraph-start' also.)  The default value is `"^[
     \t\f]*$"', which is a line that consists entirely of spaces,
     tabs, and form feeds.

 * Variable: paragraph-start

     This is the regular expression for the beginning of a line that
     starts *or* separates paragraphs.  The default value is `"^[
     \t\n\f]"', which matches a line starting with a space, tab,
     newline, or form feed.

 * Variable: sentence-end

     This is the regular expression describing the end of a sentence.
     All paragraph boundaries also end sentences, regardless. 
     Default value is `"[.?!][]\"')}]*\\($\\|\t\\| \\)[ \t\n]*"'. 
     This means a period, question mark or exclamation mark, followed
     by a closing brace, followed by tabs, spaces or new lines.

     For a full description of this regular expression, see *Note
     Regexp Example::.



File: lispref,  Node: Searching and Case,  Prev: Standard Regexps,  Up: Searching and Matching

Searching and Case
==================

  By default, searches in Emacs ignore the case of the text they are
searching through; if you specify searching for `FOO', then `Foo' and
`foo' are also considered a match.  Regexps, and in particular
character sets, are included: `[aB]' would match `a' or `A' or `b' or
`B'.

  If you do not want this feature, set the variable `case-fold-search'
to `nil'.  Then all letters must match exactly, including case.  This
is a per-buffer-local variable; altering the variable affects only
the current buffer.  (*Note Buffer Local Variables::.) 
Alternatively, you may change the value of
`default-case-fold-search', which is the default value of
`case-fold-search' for buffers that do not override it.

 * Option: case-replace

       This variable determines whether `query-replace' should preserve
     case in replacements.  If the variable is `nil', then case need
     not be preserved.

 * Option: case-fold-search

       This buffer-local variable determines whether searches should
     ignore case.  If the variable is `nil' they will not, if it is
     `t', then they will ignore case.

 * Variable: default-case-fold-search

       The value of this variable is the default value for
     `case-fold-search' in buffers that do not override it.  This is
     the same as `(default-value 'case-fold-search)'.



File: lispref,  Node: Syntax Tables,  Next: Lisp Expressions,  Prev: Searching and Matching,  Up: Top

Syntax Tables
*************

  A "syntax table" provides Emacs with the information that determines
the syntactic use of each character in a buffer.  This information is
used by the parsing commands, the complex movement commands, and
others, to determine where words, symbols, and other syntactic
constructs begin and end.

  A syntax table is a vector of 256 elements; it contains one entry for
each of the 256 ASCII characters of an 8-bit byte.  Each element is
an integer which encodes the syntax of the character in question.

  Syntax tables are used only for moving across text, not for the GNU
Emacs Lisp reader.  GNU Emacs Lisp uses built-in C code to read Lisp
expressions and does not use syntax tables.

  Each different buffer may be in a different major mode, and each
different major mode may have a different definition of the syntactic
class of a given character.  For example, in Lisp mode, the character
`;' begins a comment, but in C mode, it terminates a statement. 
Syntax tables are local to each buffer, but a major mode will usually
provide the same syntax table to all buffers that use the mode. 
*Note Major Modes::, for an example of how to set up a syntax table.

 * Function: syntax-table-p OBJECT

       This function returns `t' if OBJECT is a vector of length 256
     elements.  This means that the vector may be a syntax table. 
     However, according to this test, any vector of length 256 is
     considered to be a syntax table, no matter what its contents.

* Menu:

* Syntax Classes::           How characters are classified.
* Syntax Table Functions::   How to create, examine and alter syntax tables.
* Standard Syntax Tables::   Syntax tables used by various major modes.
* Syntax Table Internals::   How syntax table information is stored.

 

File: lispref,  Node: Syntax Classes,  Next: Syntax Table Functions,  Prev: Syntax Tables,  Up: Syntax Tables

Syntax Classes
==============

  A character belongs to one of twelve "syntax classes".  Often,
different tables put characters into different classes; there is no
necessary relationship between the class of a character in one table
and its class in any other.

  Most of the functions that operate on syntax tables use characters to
represent the classes; the character that represents each class is
chosen as a mnemonic.

  Here is a summary of the classes, the characters that stand for them,
their meanings, and examples of their use:

 * Syntax class: whitespace characters

     "Whitespace characters" (designated with ` ' or `-') divide
     symbols and words from each other.  Typically, whitespace
     characters have no other syntactic use and multiple whitespace
     characters are considered as one.  Space, tab, newline, formfeed
     are almost always considered whitespace.

 * Syntax class: word constituents

     "Word constituents" (designated with `w') are parts of normal
     English words and are typically used in variable and command
     names in programs.  All upper and lower case letters and the
     digits are typically word constituents.

 * Syntax class: symbol constituents

     "Symbol constituents" (designated with `_') are the extra
     characters that, along with word constituents, are used in
     variable and command names.  The symbol constituents class may
     be used, for example, to allow Lisp symbols to include extra
     characters without changing the notion that a word is an element
     of the English language.  In Lisp, symbol constituents are
     `$&*+-_<>'.  In standard C, the only non-word-constituent
     character that is valid in symbols is underscore (`_').

 * Syntax class: punctuation characters

     "Punctuation characters" (`.') are those characters that are
     used as punctuation in English, or are used in some way in a
     programming languages to separate symbols from one another. 
     Most programming language modes, including Emacs Lisp mode, do
     not have any characters in this class since the few characters
     that are not symbol or word constituents all have other uses.

 * Syntax class: open-parenthesis characters

 * Syntax class: close-parenthesis characters

     Open and close "parenthesis characters" come in pairs of
     matching characters that allow one to surround sentences or
     expressions.  The class of open-parentheses is designated with
     `(', and that of close-parentheses with `)'.

     In English text, and in C code, these are `()', `[]', and `{}'. 
     In Emacs Lisp, the list and vector delimiting characters (`()'
     and `[]') are parenthesis characters.

     Normally, Emacs shows a matching open parenthesis when you type
     a closing parenthesis.  *Note Blinking::.

 * Syntax class: string quote

     "String quote characters" (`"') come in pairs to delimit string
     constants in many languages, including Lisp and C.

     The Lisp modes have two string quote characters: double quote
     (`"') and vertical bar (`|').  `|' is not used in Emacs Lisp,
     but it is used in Common Lisp, and this is the right syntax for
     it.  C also has two string quote characters: double quote for
     strings, and single quote (`'') for character constants.

     The parsing facilities of Emacs consider a string as a single
     token.  The usual syntactic meanings of the characters in the
     string are suppressed.

     English text has no string quote characters because it is not a
     programming language.  Although quotation marks are used in
     English, we do not want them to turn off the usual syntactic
     properties of other characters in the quotation.

 * Syntax class: escape

     An "escape character" (`\') starts an escape sequence such as is
     used in C string and character constants.  The character `\'
     belongs to this class in both C and Lisp.  (In C, it is used
     thus only inside strings, but it turns out to cause no trouble
     to treat it this way throughout C code.)

 * Syntax class: character quote

     A "character quote character" (`/') quotes the following
     character such that it loses its normal syntax meaning.  This
     differs from an escape character in that only one following
     character is ever affected.

     Currently, this class is equivalent in practice to the class of
     escape characters, and is not used.

 * Syntax class: paired delimiter

     Paired "delimiter characters" (`$') serve a similar purpose to
     string quote characters, but differ in that the same character
     is used at the beginning and end.  Only TeX mode uses paired
     delimiters presently--the `$' that begins and ends math mode.

 * Syntax class: expression prefix

     An "expression prefix operator" (`'') is used in Lisp for things
     that go next to an expression but aren't part of a symbol if
     they are next to it, such as the apostrophe, `'', used for
     quoting and the comma, `,' used in macros.

 * Syntax class: comment starter

 * Syntax class: comment ender

     The "comment starter" and "comment ender" characters are used in
     different languages to delimit comments.  These classes are
     designated with `<' and `>', respectively.

     English text has no comment characters.  In Lisp, the semi-colon
     (`;') starts a comment and a newline or formfeed ends one.

In addition to these classes, entries for characters in a syntax
table can include flags.  At present, there are four possible flags,
all of which are intended to deal with multi-character comment
delimiters.  The four flags (represented by the characters `1', `2',
`3', and `4') indicate that the character for which the entry is
being made can *also* be part of a comment sequence.  Thus an
asterisk (used for multiplication in C) is a punctuation character,
*and* the second character of a start-of-comment sequence (`/*'),
*and* the first character of an end-of-comment sequence (`*/').

The flags for a character C are:

`1'
     means C is the start of a two-character comment start sequence.

`2'
     means C is the second character of such a sequence.

`3'
     means C is the start of a two-character comment end sequence.

`4'
     means C is the second character of such a sequence.

  Thus, the entry for the character ``*'' in the C syntax table is:
`.23' (i.e., punctuation, second character of a comment-starter,
first character of an comment--ender), and the entry for `/' is `.14'
(i.e., punctuation, first character of a comment-starter, second
character of a comment-ender).



File: lispref,  Node: Syntax Table Functions,  Next: Standard Syntax Tables,  Prev: Syntax Classes,  Up: Syntax Tables

Syntax Table Functions
======================

  The syntax table functions all work with strings of characters that
represent a syntax class.  The representative characters are chosen
to be mnemonic.

 * Function: make-syntax-table &optional TABLE

       This function constructs a copy of TABLE and returns it.  If
     TABLE is not supplied (or is `nil'), it returns a copy of the
     current syntax table.  Otherwise, an error is signaled if TABLE
     is not a syntax table.

 * Function: copy-syntax-table &optional TABLE

       This function is identical to `make-syntax-table'.

 * Command: modify-syntax-entry CHAR SYNTAX-STRING &optional TABLE

       This function sets the syntax entry for CHAR according to
     SYNTAX-STRING.  The syntax is changed only for TABLE, which
     defaults to the current buffer's syntax table.  The syntax
     string defines the new syntax for the character according to the
     definitions for the representation characters (*note Syntax
     Classes::.).

       The old syntax information in the table for this character is
     completely forgotten.

       This function always returns `nil'.  An error is signaled if the
     first character of the syntax string is not one of the twelve
     syntax class characters.  An error is also signaled if CHAR is
     not a character.

     Examples:

          ;; Put the space character in class whitespace.
          (modify-syntax-entry ?\  " ")
               => nil
          
          ;; Make `$' an open parenthesis character,
          ;; with `^' as its matching close.
          (modify-syntax-entry ?$ "(^")
               => nil
          ;; Make `^' a close parenthesis character,
          ;; with `$' as its matching open.
          (modify-syntax-entry ?^ ")$")
               => nil
          
          ;; Make `/' a punctuation character,
          ;; the first character of a start-comment sequence,
          ;; and the second character of an end-comment sequence.
          ;; This is used in C mode.
          (modify-syntax-entry ?/ ".13")
               => nil

 * Function: char-syntax CHARACTER

       This function returns the syntax class of CHARACTER, represented
     by its mnemonic character.  This *only* returns the class, not
     any matching parentheses, or flags.

       An error is signaled if CHAR is not a character.

       The first example shows that the syntax class of space is
     whitespace (represented by a space).  The second example shows
     that the syntax of ``/'' is punctuation in C-mode.  This does
     not show the fact that it is also a comment sequence character. 
     The third example shows that open parenthesis is in the class of
     open parentheses.  This does not show the fact that it has a
     matching character, ``)''.

          (char-to-string (char-syntax ? ))
               => " "
          
          (char-to-string (char-syntax ?/))
               => "."
          
          (char-to-string (char-syntax ?( ))
               => "("

 * Function: set-syntax-table TABLE

       This function makes TABLE the syntax table for the current buffer.
     It returns TABLE.

 * Function: syntax-table

       This function returns the current syntax table.  This is the
     table for the current buffer.

 * Function: backward-prefix-chars

       This function moves point backward over any number of chars with
     syntax PREFIX.  *Note Syntax Tables::, to find out about prefix
     characters.

 * command: describe-syntax

       This function describes the syntax specifications of the current
     syntax table.  It makes a listing in the `*Help*' buffer, and
     then pops up a window to view this in.

       It returns `nil'.

     A portion of a description is shown below.

          (describe-syntax)
               => nil
          
          --------- Buffer: *Help* ---------
          C-q             \       which means: escape
          C-r .. C-_              which means: whitespace
          !               .       which means: punctuation
          (               ()      which means: open, matches )
          )               )(      which means: close, matches (
          * .. +          _       which means: symbol
          ,               .       which means: punctuation
          -               _       which means: symbol
          .               .       which means: punctuation
          /               . 13    which means: punctuation,
                    is the first character of a comment-start sequence,
                    is the first character of a comment-end sequence
          0 .. 9          w       which means: word
          --------- Buffer: *Help* ---------



File: lispref,  Node: Standard Syntax Tables,  Next: Syntax Table Internals,  Prev: Syntax Table Functions,  Up: Syntax Tables

Some Standard Syntax Tables
===========================

  Each of the major modes in Emacs has its own syntax table.  Here are
several of them:

 * Function: standard-syntax-table

       This function returns the standard syntax table.  This is the
     syntax table used in Fundamental mode.

 * Variable: text-mode-syntax-table

       The value of this variable is the syntax table used in text mode.

 * Variable: c-mode-syntax-table

       The value of this variable is the syntax table in use in C-mode
     buffers.

 * Variable: emacs-lisp-mode-syntax-table

       The value of this variable is the syntax table used in Emacs
     Lisp mode by editing commands.  (It has no effect on the Lisp
     `read' function.)



File: lispref,  Node: Syntax Table Internals,  Prev: Standard Syntax Tables,  Up: Syntax Tables

Syntax Table Internals
======================

  Each element of a syntax table is an integer which translates into
the full meaning of the entry: class, possible matching character,
and flags.  However, it is not common for a programmer to work with
the entries directly in this form since the syntax table functions
all expect a string of representative characters.  In such a string,
the first character of the string will always be the class of the
character; the second character will be the matching parenthesis (if
it is a parenthesis character); and the subsequent characters will be
the flags, if any.

    The low 8 bits of each element of a syntax table indicates the syntax
class.

`Integer'
     Class

`0'
     whitespace

`1'
     punctuation

`2'
     word

`3'
     symbol

`4'
     open paren

`5'
     close paren

`6'
     expression prefix

`7'
     string quote

`8'
     paired delimiter

`9'
     escape

`10'
     character quote

`11'
     comment-start

`12'
     comment-end

  The next 8 bits are the matching opposite parenthesis (if the
character has parenthesis syntax); otherwise, they are not meaningful.
The next 4 bits are the flags.



File: lispref,  Node: Lisp Expressions,  Next: Abbreviations,  Prev: Syntax Tables,  Up: Top

Lisp Expressions
****************

  Here are several functions for parsing and scanning Lisp expressions.

 * Function: parse-partial-sexp START LIMIT &optional TARGET-DEPTH
STOP-BEFORE STATE

       This function parses Lisp syntax in the current buffer starting
     at START and not reading past LIMIT.  It returns the status of
     the parse at LIMIT.  Parsing stops at LIMIT or when certain
     criteria are met described below; point is set to where parsing
     stops.

       Normally, START is assumed to be the top level of a form to be
     parsed, such as the beginning of a function definition.  If you
     wish to continue a previous parse, you must provide a STATE
     argument, which describes the initial status of parsing.  If
     STATE is omitted (or `nil'), parsing assumes that START is the
     beginning of a new parse at level 0.

       If the third argument TARGET-DEPTH is non-`nil', parsing stops
     if the depth in parentheses becomes equal to TARGET-DEPTH.  The
     depth starts at 0, or at whatever is given in STATE.

       If the fourth argument STOP-BEFORE is non-`nil', parsing stops
     when it comes to any character that starts a sexp.

       The fifth argument STATE is a seven-element list in the same
     form as this function returns, described below.  the return
     value of one call may be used to initialize the state of the
     parse on another call to `parse-partial-sexp'.

       The result is a list of seven elements describing the final
     state of the parse:

       1. Depth in parens, starting at 0.

       2. Character position of the start of the innermost containing
          list; `nil' if none.

       3. Character position of the start of the last complete sexp
          terminated; `nil' if none.

       4. Non-`nil' if inside a string.  (It is the character that
          will terminate the string.)

       5. `t' if inside a comment.

       6. `t' if point is just after a quote character.

       7. The minimum paren-depth encountered during this scan.

       Elements 1, 4, 5, and 6 are significant in the argument STATE.

     This function is used to determine how to indent lines of
     programs that have nested lists.

 * Function: scan-lists FROM COUNT DEPTH

       This function scals from character number FROM by COUNT lists. 
     It returns the character number of the position thus found.

       If DEPTH is nonzero, parenthesis depth counting begins from that
     value.  Only places where the depth in parentheses becomes zero
     are candidates for stopping; COUNT such places are counted. 
     Thus, a positive value for DEPTH means go out levels of
     parenthesis.

       Comments are ignored if `parse-sexp-ignore-comments' is non-`nil'.

       If the beginning or end of (the accessiblepart of) the buffer is
     reached and the depth is not zero, an `end-of-file' error is
     signaled.  If the depth is zerobut the count is not used up,
     `nil' is returned.

 * Function: scan-sexps FROM COUNT

       Scan from character number FROM by COUNT balanced expressions. 
     Returns the character number of the position thus found.

       Comments are ignored if `parse-sexp-ignore-comments' is non-`nil'.

       If the beginning or end of (the accessible part of) the buffer
     is reached in the middle of a parenthetical grouping, an
     `end-of-file' error is signaled.  If the beginning or end is
     reached between groupings but before count is used up, `nil' is
     returned.

 * Variable: parse-sexp-ignore-comments

       Non-`nil' means `forward-sexp', etc., should treat comments as
     whitespace.  Non-`nil' works only when the comment terminator is
     something like `*/', and appears only when it ends a comment. 
     If comments are terminated by newlines, you must make this
     variable `nil', since not every newline is the end of a comment.
     (In version 19, this limitation is removed.)



File: lispref,  Node: Abbreviations,  Next: Processes,  Prev: Lisp Expressions,  Up: Top

Abbreviations
*************

  An abbreviation or "abbrev" is a string of characters that may be
expanded to a longer string.  If you type a part of an abbreviation,
Emacs replaces the abbreviation with the full string.  This saves
typing and makes life easier.

  The set of abbrevs currently in effect is recorded in an "abbrev
table".  Each buffer can have its own abbrev table, but normally all
buffers in the same major mode share one abbrev table.

  An abbrev table is represented as an obarray containing non-canonical
symbols, one for each abbreviation.  The symbol's name is the
abbreviation.  Its value is the expression; its function definition
is the hook; its property-list slot contains the number of times the
abbreviation has been expanded.

  For use of all the abbreviation-related commands, see *Note :
(emacs)Abbrevs.

* Menu:

* Abbrev Mode::			Setting up Emacs for abbreviation.
* Tables: Abbrev Tables.	Creating and working with abbrev tables.
* Defining Abbrevs::		Specifying abbreviations and their expansions.
* Files: Abbrev Files.		Saving abbrevs in files.
* Expansion: Abbrev Expansion.	Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::	Abbrev tables used by various major modes.

 

File: lispref,  Node: Abbrev Mode,  Next: Abbrev Tables,  Prev: Abbreviations,  Up: Abbreviations

Setting Up Abbrev Mode
======================

Abbrev mode is a minor mode controlled by the value of the variable
`abbrev-mode'.

 * Variable: abbrev-mode

     A non-`nil' value of this variable turns on the automatic
     expansion of abbrevs when their abbreviations are inserted into
     a buffer.  If the value is `nil', abbrevs may be defined, but
     they are not expanded automatically.

     Automatically becomes local when set in any fashion.

 * Variable: default-abbrev-mode

     This is the value `abbrev-mode' for buffers that do not override
     it.  This is the same as `(default-value 'abbrev-mode)'.



File: lispref,  Node: Abbrev Tables,  Next: Defining Abbrevs,  Prev: Abbrev Mode,  Up: Abbreviations

Abbrev Tables
=============

 * Function: make-abbrev-table

     This function creates a new, empty abbrev table--an obarray with
     no symbols.  It is a vector filled with `nil's.

 * Function: clear-abbrev-table TABLE

     This function undefines all the abbrevs in abbrev table TABLE,
     leaving it empty.

 * Function: define-abbrev-table TABNAME DEFINITIONS

     This function defines TABNAME (a symbol) as an abbrev table
     name, i.e., as a variable whose value is an abbrev table. 
     Define abbrevs in the table according to DEFINITIONS, a list of
     elements of the form `(ABBREVNAME EXPANSION HOOK USECOUNT)'.

 * Variable: abbrev-table-name-list

     This is a list of symbols whose values are abbrev tables. 
     `define-abbrev-table' adds the new abbrev table name to this list.

 * Function: insert-abbrev-table-description NAME HUMAN

     This function inserts before point a description of the abbrev
     table named NAME.  NAME is a symbol whose value is an abbrev
     table.

     If HUMAN is non-`nil', a human-oriented description is inserted.
     Otherwise the description is a Lisp expression--a call to
     `define-abbrev-table' which would define NAME exactly as it is
     currently defined.



File: lispref,  Node: Defining Abbrevs,  Next: Abbrev Files,  Prev: Abbrev Tables,  Up: Abbreviations

Defining Abbrevs
================

 * Function: add-abbrev TABLE TYPE ARG

     This function adds an abbreviation to abbrev table TABLE.  TYPE
     is a string saying what kind of abbrev this is (global or
     mode-specific, or whatever).  ARG is the number of words in the
     expansion.

 * Function: define-abbrev TABLE NAME EXPANSION HOOK

     This function defines an abbrev in TABLE named NAME, to expand
     to EXPANSION, and call HOOK.  NAME and EXPANSION are strings.

     HOOK is a function or `nil'.  If HOOK is non-`nil', then it is
     called with no arguments after the abbrev is replaced with
     EXPANSION; point is located at the end of EXPANSION.

     The use-count of the abbrev is initialized to zero.

     To undefine an abbrev, define it with EXPANSION = `nil'

 * Option: only-global-abbrevs

     If the the value of this variable is `t', it means that the user
     plans to use global abbrevs only.  This makes the commands that
     define mode-specific abbrevs define global ones instead.

 * Variable: edit-abbrevs-map

     This is the keymap used in `edit-abbrevs'.



File: lispref,  Node: Abbrev Files,  Next: Abbrev Expansion,  Prev: Defining Abbrevs,  Up: Abbreviations

Saving Abbrevs in Files
=======================

 * Option: abbrev-file-name

     This is the default name of the file to read abbrevs from and to
     save them in.

 * Function: quietly-read-abbrev-file FILE

     This function reads abbrev definitions from a file named FILE,
     previously written with `write-abbrev-file'.  If FILE is `nil',
     the file specified in `abbrev-file-name' is used. 
     `save-abbrevs' is set to `t' so that changes will be saved.

     This function does not print anything.

 * Option: save-abbrevs

     A non-`nil' value for `save-abbrev' means that Emacs should save
     word abbrevs when files are saved.  `abbrev-file-name' specifies
     the file to save in.

 * Variable: abbrevs-changed

     This variable is set non-`nil' by defining or altering any word
     abbrevs.  This serves as a flag for various Emacs commands to
     offer to save your abbrevs.

 * Command: write-abbrev-file FILE

     Save all abbrev definitions, in all abbrev tables, in file FILE
     as a Lisp program which will redefine the abbrevs when it is run.



File: lispref,  Node: Abbrev Expansion,  Next: Standard Abbrev Tables,  Prev: Abbrev Files,  Up: Abbreviations

Looking Up and Expanding Abbreviations
======================================

  Abbrevs are usually expanded by commands for interactive use, or 
automatically by `self-insert'.  This section describes the 
subroutines used in writing such functions, and the variables they
use for communication.

 * Function: abbrev-symbol ABBREV TABLE

     This function returns the symbol representing the abbrev named
     ABBREV.  The value returned is `nil' if that abbrev is not
     defined.  The optional second argument TABLE is the abbrev table
     to look it up in.  By default, this function tries the buffer's
     mode-specific abbrev table, and then the global table.

 * Option: abbrev-all-caps

     When this is set non-`nil', Emacs expands multi-word abbrevs
     using all upper case letters if the abbrev was all in upper case.

 * Function: abbrev-expansion ABBREV &optional TABLE

     This function returns the string that ABBREV expands into in the
     current buffer.  Optionally specify an abbrev TABLE; then ABBREV
     is looked up in that table only.

 * Variable: abbrev-start-location

     This is the buffer position for `expand-abbrev' to use as the
     start of the abbrev to expand.  `nil' means use the word before
     point as the abbrev.  `abbrev-start-location' is set to `nil'
     each time `expand-abbrev' is called.  This variable is set by
     `abbrev-prefix-mark'.

 * Variable: abbrev-start-location-buffer

     The value of this variable is the buffer that
     `abbrev-start-location' has been set for.  Trying to expand an
     abbrev in any other buffer clears `abbrev-start-location'.  This
     variable is set by `abbrev-prefix-mark'.

 * Variable: last-abbrev

     This is the `abbrev-symbol' of the last abbrev expanded.  This
     contains information left by `expand-abbrev' for the sake of the
     `unexpand-abbrev' command.

 * Variable: last-abbrev-location

     This is the location of the last abbrev expanded.  This contains
     information left by `expand-abbrev' for the sake of the
     `unexpand-abbrev' command.

 * Variable: last-abbrev-text

     This is the exact expansion  text of the last abbrev expanded,
     as results from case conversion.  Its value is `nil' if the
     abbrev has already been unexpanded.  This contains information
     left by `expand-abbrev' for the sake of the `unexpand-abbrev'
     command.



File: lispref,  Node: Standard Abbrev Tables,  Prev: Abbrev Expansion,  Up: Abbreviations

Standard Abbrev Tables
======================

 * Variable: global-abbrev-table

     This is the abbrev table whose abbrevs affect all buffers.  Each
     buffer may also have a local abbrev table.  If it does, the
     local table overrides the global one for any particular abbrev
     defined in both.

 * Variable: local-abbrev-table

     The value of this buffer-local variable is the (mode-specific)
     abbreviation table of the current buffer.

 * Variable: fundamental-mode-abbrev-table

     This is the fundamental abbrev table of mode-specific abbrevs
     for Fundamental mode.

 * Variable: text-mode-abbrev-table

     This s the local abbrev table used in Text mode.

 * Variable: c-mode-abbrev-table

     This is the local abbrev table used in C mode.

 * Variable: lisp-mode-abbrev-table

     This is the local abbrev table used in Lisp mode and Emacs Lisp
     mode.



File: lispref,  Node: Processes,  Next: System Interface,  Prev: Abbreviations,  Up: Top

Processes
*********

  In the terminology of the operating system, a "process" is a space in
which a program can execute.  Emacs runs in a process.  Emacs Lisp
programs can also invoke other programs in processes of their own. 
These are called "subprocesses" or "child processes" of the Emacs
process, which is their "parent process".

  A subprocess of Emacs may be "synchronous" or "asynchronous",
depending on how you create it.  When you create a synchronous
subprocess, the Lisp program waits for the subprocess to terminate
before continuing execution.  When you create an asynchronous
subprocess, it can run in parallel with the Lisp program.  This kind
of subprocess is represented within Emacs by a Lisp object which is
also called a ``process''.  Lisp programs can use this object to
communicate with the subprocess, or to control it.  For example, you
can send signals, obtain status information, receive output from the
process, or send input to it.

 * Function: processp OBJECT

      This function returns `t' if OBJECT is a process, `nil' otherwise.

* Menu:

* Subprocess Creation::	     Functions that start subprocesses.
* Synchronous Processes::    Details of using synchronous subprocesses.
* Asynchronous Processes::   Starting up an asynchronous subprocess.
* Deleting Processes::       Eliminating an asynchronous subprocess.
* Process Information::      Accessing run-status and other attributes.
* Input to Processes::       Sending input to an asynchronous subprocess.
* Signals to Processes::     Stopping, continuing or interrupting
                               an asynchronous subprocess.
* Output from Processes::    Collecting output from an asynchronous subprocess.
* Sentinels::                Sentinels run when process run-status changes.
* VMS Subprocesses::         VMS has completely different subprocess features.
* TCP::                      Opening network connections.

 

File: lispref,  Node: Subprocess Creation,  Next: Synchronous Processes,  Prev: Processes,  Up: Processes

Functions that Create Subprocesses
==================================

  There are three functions that create a new Unix subprocess in which
to run a program.  One of them, `start-process', creates an
asynchronous process and returns a process object (*note Asynchronous
Processes::.).  The other two, `call-process' and
`call-process-region', create a synchronous process and do not return
a process object (*note Synchronous Processes::.).

  Synchronous and asychonous processes are explained in following
sections.  Since the three functions are all called in a similar
fashion, their common arguments are described here.

  In all cases, the program to be run, named by the function's PROGRAM
argument, is found by following the normal rules for Unix: if an
absolute file name is given for the program, then the program must be
found in the specified place.  If a relative file name is given, then
the program is searched for in each of the directories in
`exec-path', which is set to the user's `PATH' variable on entering
Emacs.  The standard symbols, `~', `.', and `..', are interpreted the
same as by Unix shells.  Environment variables (`HOME', etc.) are not
substituted for.  See `expand-file-name' in *Note Relative File
Names::.  An error is signaled if the program is not found.

  Each of the subprocess-creating functions has a BUFFER-OR-NAME
argument.  This argument specifies where the standard output from the
program will go.  If BUFFER-OR-NAME is `nil', then the output will be
discarded (by directing it to `/dev/null') unless a filter function
is specified to handle it.  (*Note Filter Functions::, and *Note
Streams::.)  Normally, you do not want more than one process to send
output to the same buffer because the outputs will be intermixed
randomly.

  All three of the subprocess creating functions have a `&rest'
argument, ARGS.  The ARGS must all be strings, and they are supplied
to PROGRAM as separate command line arguments.  *Note* that the
argument PROGRAM is only the name of the program; it may not contain
any arguments for the PROGRAM.

  Subprocesses also inherit an environment from Emacs; but you can
specify overrides for it with `process-environment'.

 * Variable: process-environment

       This global variable is a list of strings to append to the
     environment of processes that are started.  Each string assigns
     a value to a shell environment variable.  (This applies both to
     asynchronous and synchronous processes.)

          process-environment
          => ("l=/usr/stanford/lib/gnuemacs/lisp"
              "PATH=.:/user/lewis/bin:/usr/class:/nfsusr/local/bin"
              "USER=lewis" 
              "TERM=ibmapa16" 
              "SHELL=/bin/csh"
              "HOME=/user/lewis")

 * Variable: exec-directory

       The value of this variable is the name of a directory (a string)
     that contains programs that come with GNU Emacs, which are
     intended for Emacs to invoke.  The program `loadst' is an
     example of such a program; it is used by the `display time'
     command and prints a string of the current time one per minute. 
     We sometimes refer to the default value of the `exec-directory'
     as `emacs/etc'.

 * Option: exec-path

       The value of this variable is a list of directories to search
     for programs to run in subprocesses.  Each element is either the
     name of a directory (i.e., a string), or `nil', which stands for
     the default directory (which is the value of `default-directory').

       `exec-path' is used by `call-process' or `start-process' when
     the PROGRAM argument does not contain an absolute file name.



File: lispref,  Node: Synchronous Processes,  Next: Asynchronous Processes,  Prev: Subprocess Creation,  Up: Processes

Creating a Synchronous Process
==============================

  After a "synchronous process" is created, Emacs waits for the process
to terminate before continuing.  Starting `dired' is an example of
this: it runs `ls' in a synchronous process, then modifies the output
slightly.  You are not able to type a command until this is finished.

 * Function: call-process PROGRAM &optional INFILE BUFFER DISPLAY
&rest ARGS

       This function calls PROGRAM in a separate process and waits for
     it to finish.  It returns `nil'.  (In version 19, it will return
     an indication of how process terminated.)

       The standard input for the process comes from file INFILE if
     INFILE is not `nil' and from `/dev/null' otherwise.  The process
     output gets inserted in buffer BUFFER-OR-NAME before point, if
     that argument names a buffer.  If BUFFER-OR-NAME is `t', output
     is sent to the current buffer; and if BUFFER-OR-NAME is `nil',
     output is discarded.

       If BUFFER-OR-NAME is the integer 0, the output is discarded and
     `call-process' returns immediately.  In this case, the process
     is not truly synchronous, since it can run in parallel with
     Emacs; but since Emacs gets no output from it, you can think of
     it as that.  Emacs is essentially finished with the subprocess
     when this function returns.

       If DISPLAY is non-`nil', then `call-process' redisplays the
     buffer as output is inserted.  Otherwise the function does no
     redisplay; you will see the results (put in a buffer) only if
     and when Emacs redisplays that buffer.

       The remaining arguments, ARGS, are strings that will be supplied
     as the command line arguments for the program.

       While the `call-process' function waits for PROGRAM to
     terminate; if you quit by typing `C-g', the process is killed by
     sending it a SIGKILL signal.

       The examples below are both run with the buffer `foo' current.

          (call-process "pwd" nil t)
               => nil
          
          --------- Buffer: foo ---------
          /usr/user/lewis/manual
          --------- Buffer: foo ---------
          
          (call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
               => nil
          
          --------- Buffer: bar ---------
          lewis:5LTsHm66CSWKg:398:21:Bil Lewis:/user/lewis:/bin/csh
          
          --------- Buffer: bar ---------

     The `dired-readin' function contains a good example of the use
     of `call-process':

          (call-process "ls" nil buffer nil dired-listing-switches dirname)

 * Function: call-process-region START END PROGRAM &optional DELETE
BUFFER-OR-NAME DISPLAY &rest ARGS

       This function sends the text between START to END as standard
     input to a process running PROGRAM.  It deletes the text sent if
     DELETE is non-`nil'.  You might want to do this if you are going
     to insert the output back in the current buffer.

       If BUFFER-OR-NAME names a buffer, the output is inserted in that
     buffer at point.  If BUFFER-OR-NAME is `t', then the output is
     sent to the current buffer.  If BUFFER-OR-NAME is `nil', the
     output is discarded.  If BUFFER-OR-NAME is the integer 0, the
     output is discarded and `call-process' returns immediately, as
     in `call-process'.

       If DISPLAY is non-`nil', then `call-process-region' redisplays
     the buffer as output is inserted.  Otherwise the function does
     no redisplay; you will see the results (put in a buffer) only if
     and when Emacs redisplays that buffer.

       The remaining arguments, ARGS, are strings that are supplied as
     the command line arguments for the program.

       The `call-process-region' function normally waits for the
     process to terminate; but if you quit (for example, by typing
     `C-g'), the process is killed.

       This function always returns `nil'.  In version 19, it will
     return an indication of how the process terminated.

       In the following example, we use `call-process-region' to run
     the `cat' utility, with standard input being the first five
     characters in buffer `foo' (the word `input').  `cat' copies its
     standard input into its standard output.  Since the 5th argument
     is `t', which stands for the current buffer, this output is
     inserted in the buffer.

          --------- Buffer: foo ---------
          input
          --------- Buffer: foo ---------
          
          (call-process-region 1 6 "cat" nil t)
               => nil
          
          --------- Buffer: foo ---------
          inputinput
          --------- Buffer: foo ---------

       The `shell-command-on-region' command uses `call-process-region'
     like this:

          (call-process-region start end 
                               shell-file-name    ; Name of program.
                               nil                ; Do not delete region.
                               buffer             ; Send output to BUFFER.
                               nil                ; No redisplay during output.
                               "-c" command)      ; Arguments for the shell.

 

File: lispref,  Node: Asynchronous Processes,  Next: Deleting Processes,  Prev: Synchronous Processes,  Up: Processes

Creating an Asynchronous Process
================================

  After an "asynchronous process" is created by `start-process',
control returns to Emacs.  The process may thereafter run at the same
time as Emacs; and it and Emacs may communicate with each other using
the functions described in following sections.

 * Function: start-process NAME BUFFER-OR-NAME PROGRAM &rest ARGS

       This function creates a new process and starts a program in that
     process.  The process will be named NAME (modified as necessary
     to be unique).  The buffer BUFFER-OR-NAME is the buffer to
     associate with the process.  PROGRAM is the program to run.

       The remaining arguments, ARGS, are strings that will be supplied
     as the command line arguments for the program.

       `start-process' returns the process object created.

     The name given to the process is guaranteed to be unique among
     processes.  It will be the name supplied by the user, or the
     name modified (by appending `<1>', `<2>', etc.) if necessary to
     make it unique.

       In the example below, the first process is started and runs
     (well, sleeps) for 100 seconds.  Meanwhile, the second process
     is started and runs to completion, inserting the directory
     listing at the end of the buffer `foo' before the first process
     finishes.  After the first process finishes, Emacs inserts
     `Process my-process finished' at the end of the buffer.

          (start-process "my-process" "foo" "sleep" "100")
               => #<process my-process>
          
          (start-process "my-process" "foo" "ls" "-l" "/user/lewis/bin")
               => #<process my-process<1>>
          
          --------- Buffer: foo ---------
          total 2
          lrwxrwxrwx  1 lewis          14 Jul 22 10:12 gnuemacs --> /emacs
          -rwxrwxrwx  1 lewis          19 Jul 30 21:02 lemon
          
          Process my-process<1> finished
          
          Process my-process finished
          --------- Buffer: foo ---------

 * Variable: process-connection-type

       This global variable controls the type of device used to
     communicate with asynchronous subprocesses.  If it is `nil',
     then pipes are used.  If it is `t', then PTYS are used (or pipes
     if PTYS not supported--this is determined by the C constant
     `HAVE_PTYS', which must be defined when Emacs is compiled.). 
     PTYS are usually preferable because they allow job control
     (`C-c, C-z, etc.') to work between the process and its children
     whereas pipes do not; the `shell' command uses PTYS by default.

       The value `process-connection-type' is used when `start-process'
     is called, so to change it for just one call of `start-process',
     temporarily rebind it with `let'.

          (let ((process-connection-type nil))  ; use a pipe
            (start-process ...))



File: lispref,  Node: Deleting Processes,  Next: Process Information,  Prev: Asynchronous Processes,  Up: Processes

Deleting Processes
==================

 * Variable: delete-exited-processes

       This global variable determines when exited processes will be
     deleted.  If it is `nil', then they will not be deleted until
     `list-processes' is run; otherwise, they will be deleted
     immediately after they exit.

 * Function: delete-process NAME

       This function deletes the process associated with NAME.  NAME
     may be a process, the name of a process, a buffer, or the name
     of a buffer.  The subprocess is killed with a `SIGHUP' signal.

          (delete-process "*shell*")
               => nil

 * Function: process-kill-without-query PROCESS

       This function declares that Emacs need not query the user if
     PROCESS is still running when Emacs is exited.  It returns `t'.

          (process-kill-without-query (get-process "shell"))
               => t



File: lispref,  Node: Process Information,  Next: Input to Processes,  Prev: Deleting Processes,  Up: Processes

Process Information
===================

Several functions return information about processes. 
`list-processes' is provided for interactive use.

 * Command: list-processes

       This command displays a listing of all living processes.  (Any
     processes listed as Exited or Signaled are actually eliminated
     after the listing is made.)  This function returns `nil'.

 * Function: process-list

       This function returns a list of all processes that are still
     alive.

          (process-list)
               => (#<process display-time> #<process shell>)

 * Function: get-process NAME

       This function returns the process named NAME, or `nil' if there
     is none.  An error is signaled if NAME is not a string.

          (get-process "shell")
               => #<process shell>

 * Variable: mode-line-process

       This buffer-local variable contains the mode line information on
     process status.  It is displayed immediately following the major
     mode name, with no intervening space.  For example, its value in
     the `*shell*' buffer is `(": %s")', which allows the shell to
     display its status along with the major mode as: `(Shell: run)'.
     Normally this variable is `nil'.  *Note Mode Line Format::.

 * Function: process-command PROCESS

       This function returns the command that was executed to start
     PROCESS.  This is a list of strings, the first string being the
     program executed and the rest of the strings being the arguments
     given to it.

          (process-command (get-process "shell"))
               => ("/bin/csh" "-i")

 * Function: process-exit-status PROCESS

       This function returns the exit status of PROCESS or the signal
     number that killed it.  If PROCESS has not yet exited or died,
     the value is 0.

 * Function: process-id PROCESS

       This function returns the process id of PROCESS.  This is the
     PID of the Unix process which PROCESS refers to.

 * Function: process-name PROCESS

       This function returns the name of PROCESS.

 * Function: process-status PROCESS-NAME

       This function returns the status of PROCESS-NAME as a symbol. 
     PROCESS-NAME must be either a process or a string.  If it is a
     string, it need not name an actual process.

     The possible values for an actual subprocess are:

    `run'
           for a process that is running.

    `stop'
           for a process that is stopped but continuable.

    `exit'
           for a process that has exited.

    `signal'
           for a process that has received a fatal signal.

    `nil'
           if PROCESS-NAME does not exist.

          (process-status "shell")
               => run
          (process-status "never-existed")
               => nil
          x
               => #<process xx<1>>
          (process-status x)
               => exit

     For a network stream, `process-status' returns one of the
     symbols `open' or `closed'.  The latter means that the other
     side closed the connection, or Emacs did `delete-process'.



File: lispref,  Node: Input to Processes,  Next: Signals to Processes,  Prev: Process Information,  Up: Processes

Sending Input to Processes
==========================

  Asynchronous subprocesses receive input when it is sent to them by
Emacs.  This is done by calling one of the functions in this section.
You must specify the process to send input to, and the input.  The
data you send appears on the ``standard input'' of the subprocess.

  Some operating systems have limited space for buffered input in a
PTY.  On these systems, the subprocess will cease to read input
correctly if you send an input line longer than the buffer can hold. 
You cannot avoid the problem by breaking the input into pieces and
sending them separately, for the operating system will still have to
put all the pieces together in the input buffer before it lets the
subprocess read the line.  The only solution is to put the input in a
temporary file, and send as input just a brief command to read that
file.

 * Function: process-send-string PROCESS-NAME STRING

       This function sends PROCESS-NAME the contents of STRING as
     standard input.   PROCESS-NAME must be a process or the name of
     one.

       The function returns `nil'.

          (process-send-string "shell<1>" "ls\n")
               => nil
          
          --------- Buffer: *shell* ---------
          ...
          introduction.texinfo            syntax-tables.texinfo~
          introduction.texinfo~           text.texinfo
          introduction.txt                text.texinfo~
          ...
          --------- Buffer: *shell* ---------

 * Command: process-send-region PROCESS-NAME START END

       This function sends the text in the region defined by START and
     END as standard input to PROCESS-NAME, which is a process or a
     process name.

       An error is signaled unless both START and END are integers or
     markers that indicate positions in the current buffer.  It is
     unimportant which number is larger.

 * Function: process-send-eof &optional PROCESS-NAME

       This function makes PROCESS-NAME see an end-of-file in its
     input.  The EOF comes after any text already sent to it.

       If PROCESS-NAME is not supplied, or if it is `nil', then this
     function sends the EOF to the current buffer's process.  An
     error is signaled if the current buffer has no process.

       The function returns PROCESS-NAME.

          (process-send-eof "shell")
               => "shell"



File: lispref,  Node: Signals to Processes,  Next: Output from Processes,  Prev: Input to Processes,  Up: Processes

Sending Signals to Processes
============================

  "Sending a signal" to a subprocess is a way of interrupting its
activities.  There are several different signals, each with its own
meaning.  For example, the signal `SIGINT' means that the user has
typed `C-c', or that some analogous thing has happened.

  Each signal has a standard effect on the subprocess.  Most signals
kill the subprocess, but some stop execution or resume execution
instead.  Most signals can also be handled by certain programs; if
so, it is up to the program what the signal does.

  The set of signals and their names is defined by the operating
system; Emacs has facilities for sending only a few of the signals
that are defined.

  Emacs can send signals only to its own subprocesses.  This is done
with the functions below, or automatically: killing a buffer sends a
`SIGHUP' signal to all its associated processes; killing Emacs sends
a `SIGHUP' signal to all remaining processes.  (`SIGHUP' is a signal
that usually indicates that the user hung up the phone.)

  Each of the signal-sending functions takes two optional arguments:
PROCESS-NAME and CURRENT-GROUP.

  The argument PROCESS-NAME must be either a process, the name of one,
or `nil'.  If it is `nil', the process defaults to the process
associated with the current buffer.  An error is signaled if
PROCESS-NAME does not identify a process.

  The argument CURRENT-GROUP is a flag which makes a difference when
you are running a job-control shell as an Emacs subprocess.  If it is
non-`nil', then the signal is sent to the current process-group of
the terminal which Emacs uses to communicate with the subprocess.  If
the process is a job-control shell, this means the shell's current
subjob.  If it is `nil', the signal is sent to the process group of
the immediate subprocess of Emacs.  If the subprocess is a
job-control shell, this is the shell itself.

  The flag CURRENT-GROUP has no effect when a pipe is used to
communicate with the subprocess, because the operating system does
not support the distinction in the case of pipes.  For the same
reason, job-control shells won't work when a pipe is used.  See
`process-connection-type' in *Note Asynchronous Processes::.

 * Function: interrupt-process &optional PROCESS-NAME CURRENT-GROUP

       This function interrupts the process PROCESS-NAME by sending the
     Unix signal `SIGINT'.  When you are not in Emacs, typing the
     ``interrupt character'' (usually `C-c' on Berkeley Unix) sends
     this signal.

     When the argument CURRENT-GROUP is non-`nil', you can think of
     this function as ``typing `C-c''' on the terminal by which Emacs
     talks to the subprocess.

 * Function: kill-process &optional PROCESS-NAME CURRENT-GROUP

       This function kills the process PROCESS-NAME by sending the Unix
     signal `SIGKILL'.  This signal kills the subprocess immediately;
     it cannot be handled by the subprocess.

 * Function: quit-process &optional PROCESS-NAME CURRENT-GROUP

       This function sends the Unix signal `SIGQUIT' to the process
     PROCESS-NAME.  This signal is the one sent by the ``quit
     character'' (usually `C-b' or `C-\') when you are not inside
     Emacs.

 * Function: stop-process &optional PROCESS-NAME CURRENT-GROUP

       This function stops the process PROCESS-NAME by sending the Unix
     signal `SIGTSTP'.  Use `continue-process' to resume its execution.

       On systems with job control, the ``stop character'' (usually
     `C-z') sends this signal (when you are not inside Emacs).  When
     CURRENT-GROUP is non-`nil', you can think of this function as
     ``typing `C-z''' on the terminal Emacs uses to communicate with
     the subprocess.

 * Function: continue-process &optional PROCESS-NAME CURRENT-GROUP

       This function resumes execution of the process PROCESS by
     sending it the Unix signal `SIGCONT'.  This presumes that
     PROCESS-NAME was stopped previously.



File: lispref,  Node: Output from Processes,  Next: Sentinels,  Prev: Signals to Processes,  Up: Processes

Receiving Output from Processes
===============================

  There are two ways to receive output that a subprocess outputs to its
standard output stream.  You can have the output inserted in a
buffer, called the associated buffer of the process, or you can
specify a filter function to act on the output.

* Menu:

* Process Buffers::       If no filter, output is put in a buffer.
* Filter Functions::      Filter functions accept output from the process.
* Waiting for Output::    How to wait until process output arrives.

 

File: lispref,  Node: Process Buffers,  Next: Filter Functions,  Prev: Output from Processes,  Up: Output from Processes

Process Buffers
---------------

  The buffer that a process is associated with is where the standard
output from that process will be inserted (if the process does not
have a filter function).  Output is always inserted at the
`process-mark' (*note Process Information::.), which is then updated
to point to the end of the text just inserted.  Often the
`process-mark' is at the end of the buffer.

 * Function: process-buffer PROCESS

     This function returns the buffer PROCESS is associated with.

          (process-buffer (get-process "shell"))
               => #<buffer *shell*>

 * Function: process-mark PROCESS

     This function returns the marker which indicates the end of the
     last output from PROCESS into its buffer (*note Process
     Buffers::.).  This marker controls where additional output from
     the process will be inserted.  In simple use of subprocesses,
     this marker causes input and output to work properly with no
     explicit attention from the Lisp program.

     If PROCESS does not insert its output into a buffer, then
     `process-mark' returns a marker that points nowhere.

     A good example of a filter function that uses `process-mark' is
     found at the end of the following section.

 * Function: set-process-buffer PROCESS BUFFER

     This function sets the buffer associated with PROCESS to BUFFER.
     If BUFFER is `nil', then the process will not be associated with
     any buffer at all.

 * Function: get-buffer-process BUFFER-OR-NAME

     This function returns the process associated with
     BUFFER-OR-NAME.  If there are several processes associated with
     it, then one is chosen.  (Presently, the one chosen is the one
     most recently created.)  Normally, you should avoid having more
     than one process with the same buffer.

          (get-buffer-process "*shell*")
               => #<process shell>

     If the process's buffer is killed, the actual child process is
     killed with a `SIGHUP' signal (*note Signals to Processes::.).



File: lispref,  Node: Filter Functions,  Next: Waiting for Output,  Prev: Process Buffers,  Up: Output from Processes

Process Filter Functions
------------------------

  A process "filter function" is a function that receives the standard
output from the associated process.  If a process has a filter, then
*all* standard output from that process will be sent to the filter
rather than be inserted into a buffer or discarded.  The process
buffer is used for output from the process only when there is no
filter.

  A filter function runs only while Emacs is waiting (for terminal
input, or for time to elapse, or for process output).  This avoids
the timing errors that could result from running filters at random
places in the middle of other Lisp programs.

  You may explicitly cause Emacs to wait, so that filter functions will
run, by calling `sit-for', `sleep-for' or `accept-process-output'
(*note Waiting for Output::.).  Emacs also waits in the command loop
for the next keystroke.

  All filter functions that do regexp searching or matching should save
and restore the match data.  Otherwise, a filter function that runs
during a call to `sit-for' might clobber the match data of the
program that called `sit-for'.  *Note Match Data::.

  A filter function must accept two arguments: the associated process
and a string, which is the output.  The function is then free to do
whatever it chooses to with the output.

  The output to the function may come in any sized chunks.  A program
that produces the same output twice in a row may send it as one
string of 200 characters one time, and five strings of 40 characters
the next.

 * Function: set-process-filter PROCESS FILTER

     This function gives PROCESS the filter function FILTER.  If
     FILTER is `nil', then the process will have no filter.

 * Function: process-filter PROCESS

     This function returns the filter function of PROCESS, or `nil'
     if has none.

  Here is an example of use of a filter function:

     (defun keep-output (process output)
        (setq kept (cons output kept)))
          => keep-output
     (setq kept nil)
          => nil
     (set-process-filter (get-process "shell") 'keep-output)
          => keep-output
     (process-send-string "shell" "ls ~/other\n")
          => nil
     kept
          => ("lewis@slug[8] % "
     "FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
     address.txt             backup.psf              kolstad.psf
     backup.bib~             david.mss               resume-Dec-86.mss~
     backup.err              david.psf               resume-Dec.psf
     backup.mss              dland                   syllabus.mss
     "
     "#backups.mss#          backup.mss~             kolstad.mss
     ")
     
     ;; Insert input in the buffer specified by `my-shell-buffer'
     ;; and make sure that buffer is shown in some window.
     (defun my-process-filter (proc str)
         (let ((cur (selected-window))
               (pop-up-windows t))
           (pop-to-buffer my-shell-buffer)
           (goto-char (point-max))
           (insert str)
           (set-marker (process-mark proc) (point-max))
           (select-window cur)))



File: lispref,  Node: Waiting for Output,  Prev: Filter Functions,  Up: Output from Processes

Waiting for Output from Processes
---------------------------------

 * Function: accept-process-output &optional PROCESS

       This function allows pending output from any processes to be
     read by Emacs.  It is read into the process buffers or given to
     their filter functions.  If PROCESS is non-`nil' then this
     function does not return until some output has been received
     from that process.

 * Function: waiting-for-user-input-p

       This function returns non-`nil' if Emacs is waiting for keyboard
     input from the user, `nil' if it is not.  This is intended for
     use by asynchronous process output filters and sentinels.



File: lispref,  Node: Sentinels,  Next: VMS Subprocesses,  Prev: Output from Processes,  Up: Processes

Sentinels: Detecting Process Status Changes
-------------------------------------------

  A "process sentinel" is a function that is called whenever the
associated process changes status for any reason.  This includes
anything that terminates, stops, or continues the process.  The
process sentinel is also called if the process exits on its own.  The
sentinel is called with two arguments: the process for which the
event occurred, and a string describing the type of event.

  A sentinel runs only while Emacs is waiting (for terminal input, or
for time to elapse, or for process output).  This avoids the timing
errors that could result from running them at random places in the
middle of other Lisp programs.

  You may explicitly cause Emacs to wait, so that sentinels will run,
by calling `sit-for', `sleep-for' or `accept-process-output' (*note
Waiting for Output::.).  Emacs also waits in the command loop for the
next keystroke.

  All sentinels that do regexp searching or matching should save and
restore the match data.  Otherwise, a sentinel that runs during a
call to `sit-for' might clobber the match data of the program that
called `sit-for'.  *Note Match Data::.

The string describing the event looks like one of the following:

   * `"finished\n"'.

   * `"exited abnormally with code EXITCODE\n"'.

   * `"NAME-OF-SIGNAL\n"'.

   * `"NAME-OF-SIGNAL (core dumped)\n"'.

A sentinel is called for any signal that terminates, stops or
continue the process.  This can include signals explicitly sent by
Emacs.  The sentinel is not called for signals that are handled or
ignored by the process.

 * Function: set-process-sentinel PROCESS SENTINEL

       This function associates SENTINEL with PROCESS.  If SENTINEL is
     `nil', then the process will have no sentinel.  The default
     behavior when there is no sentinel is to insert a message in the
     process's buffer.

          (defun msg-me (process event)
             (princ
               (format "Process: %s had the event `%s'" process event)))
          (set-process-sentinel (get-process "shell") 'msg-me)
               => msg-me
          (kill-process (get-process "shell"))
               => Process: #<process shell> had the event `killed'
               => #<process shell>

 * Function: process-sentinel PROCESS

       This function returns the sentinel of PROCESS, or `nil' if it
     has none.



File: lispref,  Node: VMS Subprocesses,  Next: TCP,  Prev: Sentinels,  Up: Processes

Subprocess Functions for VMS
============================

The ordinary subprocess functions do not work on VMS in version 18. 
Instead, these are available.

 * Function: default-subprocess-input-handler

       This function is the default input handler for input from
     spawned subprocesses.

 * Function: spawn-subprocess INTEGER &optional FILTER SENTINEL

     This function spawns an asynchronous VMS subprocess for command
     processing.  The arguments are INTEGER, an integer which will
     identify the subprocess in future operations; FILTER, a function
     which will be called when output arrives from the subprocess;
     and SENTINEL, a function which will be called when the
     subprocess terminates.

     If FILTER is `nil', output is inserted in the current buffer. 
     If SENTINEL is `nil', nothing special is done when the
     subprocess terminates.

     When the filter is called, it receives two argument: INTEGER, to
     identify the process, and a string containing the output.

     When the sentinel is called, it receives just one argument:
     INTEGER.

 * Function: send-command-to-subprocess INTEGER COMMAND

     This function sends the string COMMAND to a VMS subprocess
     numbered INTEGER.

 * Function: stop-subprocess INTEGER

     This function terminates the VMS subprocess numbered INTEGER.

  In version 19, these functions have been eliminated, and the ordinary
VMS subprocess functions are implemented.



File: lispref,  Node: TCP,  Prev: VMS Subprocesses,  Up: Processes

TCP
===

  This is how you can open a network connection to any program or
server that might be listening.  This connection works much like the
connection with a subprocess, and is represented in Emacs Lisp by a
process object.  However, the process you are communicating with is
not a child of the Emacs process, and you can't kill it or send it
signals.  All you can do is send and receive data.  `delete-process'
closes the connection, but does not kill the process at the other end
of it.

  You can distinguish process objects representing network connections
from those representing subprocesses with the `process-status'
function.

 * Function: open-network-stream NAME BUFFER HOST SERVICE

     This function opens a TCP connection for a service to a host. 
     It returns a process object to represent the connection.

     The NAME argument is the name for the ``process''.  It is
     modified if necessary to make it unique.

     The BUFFER-OR-NAME argument is the buffer to associate with the
     connection.  Output from the connection goes at the end of the
     buffer, unless you specify an output stream or filter function
     to handle the output.  BUFFER-OR-NAME may be also `nil', which
     means that the connection is not associated with any buffer.

     SERVICE is the name of the service desired, or an integer
     specifying a port number to connect to.



File: lispref,  Node: System Interface,  Next: Emacs Display,  Prev: Processes,  Up: Top

Operating System Interface
**************************

  This chapter is about starting and getting out of Emacs, access to
values in the operating system environment, and terminal input,
output and flow control.

  *Note Building Emacs::, for related information.  See also *Note
Emacs Display::, for additional forms of operating system status
information.

* Menu:

* Starting Up::         Customizing Emacs start-up processing.
* Getting Out::         How exiting works (permanent or temporary).
* System Environment::  Distinguish the name and kind of system.
* Terminal Input::      Recording terminal input for debugging.
* Terminal Output::     Recording terminal output for debugging.
* Flow Control::        How to turn output flow control on or off.
* Batch Mode::          Running Emacs without terminal interaction.

 

File: lispref,  Node: Starting Up,  Next: Getting Out,  Prev: System Interface,  Up: System Interface

Starting Up Emacs
=================

  This section describes what Emacs does when it is started, and you
can customize these actions.

* Menu:

* Start-up Summary::        Sequence of actions Emacs performs at start-up.
* Init File::               Details on reading the init file (`.emacs').
* Terminal-specific::       How the terminal-specific Lisp file is read.
* Command Line Arguments::  How command line arguments are processed,
                              and how you can customize them.

 

File: lispref,  Node: Start-up Summary,  Next: Init File,  Prev: Starting Up,  Up: Starting Up

Summary: Sequence of Actions at Start Up
----------------------------------------

   The order of operations performed (in `startup.el') by Emacs when it
is started up is as follows:

  1. Read command line switches.

  2. Load `.emacs' unless `-q' specified on command line.

  3. Load `default.el' unless `inhibit-default-init' is  non-`nil'.

  4. Load terminal specific file.

  5. Run `term-setup-hook'.

  6. Run `window-setup-hook'.

  7. Display copyleft and non-warranty, plus basic use information,
     unless `inhibit-startup-message' is non-`nil'.

  8. Process remaining command line arguments.

 * Option: inhibit-startup-message

       This global variable inhibits the initial startup messages (the
     non-warranty, etc.).  If it is non-`nil', then the messages are
     not printed.  This is for use in your personal init file, once
     you are familiar with the contents of the startup message.



File: lispref,  Node: Init File,  Next: Terminal-specific,  Prev: Start-Up Summary,  Up: Starting Up

The Init File: `.emacs'
-----------------------

  When you start Emacs, it normally attempts to load the `.emacs' file
from your home directory.  This file, if it exists, must contain Lisp
code.  It is called your "init file".  The command line switches `-q'
and `-u' can be used to tell Emacs whether to load an init file. 
(The `-q' switch tells Emacs not to load your init file; and the `-u'
switch tell Emacs to load a named user's init file instead of yours.)
*Note : (emacs)Entering Emacs.

  Emacs may also have a "default init file", which is the library named
`default.el'.  Emacs finds the `default.el' file through the standard
search path for libraries (*note How Programs Do Loading::.).  The
Emacs distribution does not have any such file; you may create one at
your site for local customizations.  If the default init file exists,
it is loaded whenever you start Emacs.  But your own personal init
file, if any, is loaded first; if it sets `inhibit-default-init' to a
non-`nil' value, then Emacs will not load the `default.el' file.

  If you have a large amount of code in your `.emacs' file, you should
move it into another file named `SOMETHING.el', byte-compile it
(*note Byte Compilation::.), and make your `.emacs' file load the
other file using `load' (*note Loading::.).

  *Note : (emacs)Init File Examples, for examples of how to make
various commonly desired customizations in your `.emacs' file.

 * Option: inhibit-default-init

       This global variable prevents Emacs from loading the default
     initialization library file for your session of Emacs.  If its
     value is non-`nil', then the default library is not loaded.  The
     default value is `nil'.



File: lispref,  Node: Terminal-specific,  Next: Command Line Arguments,  Prev: Init File,  Up: Starting Up

Terminal-specific Initialization
--------------------------------

  Each terminal type can have its own Lisp library that Emacs will load
when run on that type of terminal.  For a terminal type named
TERMTYPE, the library is called `term/TERMTYPE'.  Emacs finds the
file by searching the `load-path' directories as it does for other
files, and trying the `.elc' and `.el' suffixes.  Normally,
terminal-specific Lisp library is located in `emacs/lisp/term', a
subdirectory of the `emacs/lisp' directory in which most Emacs Lisp
libraries are kept.

  The library's name is constructed by concatenating the value of the
variable `term-file-prefix' and the terminal type.  Normally,
`term-file-prefix' has the value `"term/"'; changing this is not
recommended.

  The usual purpose of a terminal-specific library is to define the
escape sequences used by a terminal's function keys.

  Function keys are handled by a two-level process.  The first level is
dependent on the specific type of terminal and maps Emacs's input
sequences to the function keys that they represent.  The second level
is independent of terminal type and is customized by users; function
keys are mapped into meanings at this level.  The terminal-specific
library handles the first level of the process and the library
`keypad.el' handles the second level of mapping.

  See the file `term/vt100.el' for an example of of a terminal-specific
library.

  When the name of the terminal type contains a hyphen, only the part
of the name before the first hyphen is significant in choosing the
library name.  Thus, terminal types `aaa-48' and `aaa-30-rv' both use
the `term/aaa' library.  If necessary, the library can evaluate
`(getenv "TERM")' to find the full name of the terminal type.

  Your `.emacs' file can prevent the loading of the terminal-specific
library by setting `term-file-prefix' to `nil'.  This feature is very
useful for when you experimenting with your own peculiar
customizations; but a more elegant long-term mechanism for handling
your own customizations is to include a value for `term-setup-hook'
in your `.emacs'.

  If it is not `nil', Emacs calls the value of the variable
`term-setup-hook' as a function of no arguments at the end of Emacs
initialization, after Emacs has already loaded both your `.emacs'
file and any terminal-specific libraries.  You can set the value of
the `term-setup-hook' variable in your `.emacs' file to override part
of any of the terminal-specific libraries and to define
initializations for terminals that do not have a library.

 * Variable: term-file-prefix

       If the `term-file-prefix' global variable is non-`nil', Emacs
     loads your `.emacs' file and the default initialization file and
     then evaluates the following expression:

          (load (concat term-file-prefix (getenv"TERM")))

     You may set the `term-file-prefix' variable to `nil' in your
     `.emacs' file if you do not wish to load the
     terminal-initialization file.  (To do this, put the following in
     your `.emacs' file: `(setq term-file-prefix nil)'.)

 * Variable: term-setup-hook

       The value of this variable is either `nil' or that of a function
     that Emacs calls after loading your `.emacs' file, the default
     initialization file (if any) and after loading terminal-specific
     lisp code.  The value of `term-setup-hook' is called with no
     arguments.

       The expression in `startup.el' is this:

          (and term-setup-hook (funcall term-setup-hook))

       To prevent the hook from being run twice, `term-setup-hook' is
     set to `nil' after it is used.

       You can use `term-setup-hook' to override the definitions made
     by a terminal-specific file.

 * Variable: window-setup-hook

       The value of the `window-setup-hook' variable is either `nil',
     or that of a function for Emacs to call, after loading any
     initialization file and any terminal-specific lisp code, and
     after calling `term-setup-hook'.  `window-setup-hook' is called
     with no arguments.

       This hook is not for user use.  It is used for creating the
     initial window.



File: lispref,  Node: Command Line Arguments,  Prev: Terminal-specific,  Up: Starting Up

Command Line Arguments
----------------------

  You can use command line arguments to request various actions when
you start Emacs.  Since you do not need to start Emacs more than once
per day, and will often leave your Emacs session running longer than
that, command line arguments are hardly ever used.  As a practical
matter, it is best to avoid making the habit of using them, since
this habit would encourage you to kill and restart Emacs
unnecessarily often.  They exist to permit several sophisticated
actions and for compatibility with other editors.

 * Function: command-line

       This function parses the command line which Emacs was called
     with, processes it, loads the user's `.emacs' file and displays
     the initial warranty information, etc.

 * Variable: command-line-processed

       The value of this variable is `t' once the command line has been
     processed.

     If you redump Emacs by calling `dump-emacs', you must set this
     variable to `nil' first in order to cause the new dumped Emacs
     to process its new command line arguments.

 * Variable: command-switch-alist

     The value of this variable is an alist of user-defined
     command-line options and associated handler functions.  This
     variable exists so you can add elements to it.

     A "command line option" is an argument on the command line of
     the form:

          -OPTION-STRING

     The elements of the `command-switch-alist' look like this:

          (OPTION-STRING . HANDLER-FUNCTION)

     For each element, the HANDLER-FUNCTION receives the switch name
     as its sole argument.

     In some cases, the command line switch is followed by an
     argument.  In these cases, the command-line arguments are in the
     variable `command-line-args'.

     The command line arguments are parsed by the `command-line-1'
     function in the `startup.el' file.  See also *Note :
     (emacs)Command Switches.

 * Variable: command-line-args

     The value of this variable is the arguments passed by the shell
     to Emacs, as a list of strings.



File: lispref,  Node: Getting Out,  Next: System Environment,  Prev: Starting Up,  Up: System Interface

Getting out of Emacs
====================

  As a practical matter, in everyday use, you seldom quit Emacs--only
when you are about to log out.  The rest of the time, you will work
in Emacs or in a shell inside of Emacs.  If you do have to leave
Emacs temporarily, it is best to suspend Emacs rather than quit it. 
(*Note Suspending Emacs::.)

* Menu:

* Killing Emacs::        Exiting Emacs irreversibly.
* Suspending Emacs::     Exiting Emacs reversibly.

 

File: lispref,  Node: Killing Emacs,  Next: Suspending Emacs,  Prev: Getting Out,  Up: Getting Out

Killing Emacs
-------------

  Killing Emacs means ending the execution of the Emacs job.  It will
return to its superior process.

  All the information in the Emacs, aside from files that are saved, is
lost when the Emacs is killed.  Because killing Emacs inadvertently
can lose a lot of work, Emacs will query for confirmation before
actually terminating, if you have files that need saving or
subprocesses that are running.

 * Function: kill-emacs &optional NO-QUERY

       This function exits the Emacs job and kills it.  If NO-QUERY is
     supplied and non-`nil', then Emacs will exit directly.

       Normally, if there are modified files or if there are running
     processes, Emacs will ask the user whether it should *really*
     exit.

       If Emacs is running noninteractively and NO-QUERY is an integer,
     then it returns NO-QUERY as the Unix program's exit code.

          (kill-emacs)
               => nil
          
          --------- Buffer: Minibuffer ---------
          1 modified buffer exists, do you really want to exit? (yes or no) yes
          Subprocesses are executing;  kill them and exit? (yes or no) no
          --------- Buffer: Minibuffer ---------

 * Variable: kill-emacs-hook

       The value of the `kill-emacs-hook' variable is either `nil' or
     is that of a function that Emacs calls whenever `kill-emacs' is
     called.  The hook is called before anything else is done by
     `kill-emacs'.



File: lispref,  Node: Suspending Emacs,  Prev: Killing Emacs,  Up: Getting Out

Suspending Emacs
----------------

``Suspending Emacs'' means stopping Emacs temporarily and returning
control to its superior, which is usually the shell.  This allows you
to resume editing later in the same Emacs job, with the same files,
the same kill ring, the same undo history, and so on.  This is very
convenient.  As a practical matter, you seldom need to suspend Emacs;
you can do almost all your work inside Emacs or inside a shell inside
of Emacs.

 * Function: suspend-emacs STRING

       This function stops Emacs and returns to the superior process. 
     After suspending Emacs, you may still resume Emacs.  (This is in
     contrast to your situation after killing Emacs.)  This function
     does nothing if Emacs is running under X windows, since you can
     switch to another job by moving the mouse to another window.

       If STRING is non-`nil', its characters are sent to be read as
     terminal input by Emacs's superior shell.  The characters in
     STRING will not be echoed by the superior shell; just the
     results will appear.

       Before suspending, Emacs examines the symbol `suspend-hook'.  If
     it is bound, and its value is non-`nil', then the value will be
     called as a function of no arguments.  Emacs won't be suspended
     unless this called function returns `nil'.

       After Emacs resumes, the symbol `suspend-resume-hook' will be
     examined.  If it is bound and non-`nil', then the value will be
     called as a function of no arguments.

       The next redisplay after resumption will redraw the entire
     screen, unless `no-redraw-on-reenter' is set (*note Screen
     Attributes::.).

       `suspend-emacs' returns `nil'.

       In the example, note that `pwd' is not echoed by the shell after
     Emacs is suspended.

          (suspend-emacs)
               => nil
          
          (setq suspend-hook
              (function (lambda ()
                        (not (y-or-n-p "Really suspend? ")))))
               => (lambda nil (not (y-or-n-p "Really suspend? ")))
          (setq suspend-resume-hook
              (function (lambda () (message "Resumed!"))))
               => (lambda nil (message "Resumed!"))
          (suspend-emacs "pwd")
               => nil
          --------- Buffer: Minibuffer ---------
          Really suspend? y
          
          --------- Parent Shell ---------
          lewis@slug[23] % /user/lewis/manual
          lewis@slug[24] % fg
          
          --------- Echo Area ---------
          Resumed!

  * Variable: suspend-hook

       The value of the `suspend-hook' variable is either `nil', or a
     function to be called (with no arguments) by `suspend-emacs'
     before Emacs is actually suspended.  Emacs won't be suspended
     unless the called function returns `nil'.

 * Variable: suspend-resume-hook

       The value of the `suspend-resume-hook' variable is either `nil'
     or is called as a function (with no arguments) after resumption
     of an Emacs session that was suspended with `suspend-emacs'.



File: lispref,  Node: System Environment,  Next: Terminal Input,  Prev: Getting Out,  Up: System Interface

Operating System Environment
============================

  Emacs provides access to variables in the operating system
environment through various functions.  These variables include the
name of the system, the user's UID, and so on.

 * Variable: system-type

       The value of this global variable is a symbol indicating the
     type of operating system Emacs is operating on.  Here is a table
     of the symbols for the operating systems that Emacs can run on
     up to version 18.51.

          system-type
               => berkeley-unix

    `berkeley-unix'
          Berkeley BSD 4.1, 4.2, or 4.3

    `hpux'
          Hewlett-Packard release 5 or 6

    `silicon-graphics-unix'
          Silicon Graphics Iris 3.5 or 3.6

    `rtu'
          RTU 3.0, ucb universe

    `unisoft-unix'
          UniSoft's UniPlus 5.0 or 5.2

    `usg-unix-v'
          AT&T's System V.0, System V Release 2.0, 2.2, or 3

    `vax-vms'
          VMS VMS 4.0, 4.2, 4.4

    `xenix'
          SCO Xenix 386 Release 2.2

     We do not wish to add new symbols to make finer distinctions
     unless it is absolutely necessary!

 * Function: getenv VAR

       This function returns the value of the environment variable VAR,
     as a string.

          (getenv "USER")
               => "lewis"
          
          lewis@slug[10] % printenv
          PATH=.:/user/lewis/bin:/usr/bin:/usr/local/bin
          USER=lewis
          TERM=ibmapa16
          SHELL=/bin/csh
          HOME=/user/lewis

 * Function: user-login-name

       This function returns the name under which the user is logged in.
     This is based on the effective UID, not the real UID.

          (user-login-name)
               => "lewis"

 * Function: user-real-login-name

       This function returns the name under which the user logged in. 
     This is based on the real UID, not the effective UID.  This
     differs from `user-login-name' only when running with the setuid
     bit.

 * Function: user-full-name

     This function returns the full name of the user.

          (user-full-name)
               => "Bil Lewis"

 * Function: user-real-uid

       This function returns the real UID of the user.

          (user-real-uid)
               => 19

 * Function: user-uid

        This function returns the effective UID of the user.

 * Function: system-name

        This function returns the name of the machine you are running on.

          (system-name)
               => "wheaties.ai.mit.edu"

 * Function: current-time-string

        This function returns the current time, as a humanly readable
     string.  The format of the string is unvarying; the number of
     characters used for each part is always the same, so you can
     reliably use `substring' to extract pieces of it.

          (current-time-string)
               => "Wed Oct 14 22:21:05 1987"

 * Function: load-average

        This function returns the current 1 minute, 5 minute and 15
     minute load averages in a list.  The values are intergers that
     are 100 times the system load averages.  (The load averages
     indicate the number of processes trying to run.)

          (load-average)
               => (68 48 35)
          
          lewis@rocky[5] % uptime
           11:55am  up 1 day, 19:37,  3 users,  load average: 0.69, 0.48, 0.36

 * Function: setprv PRIVILEGE-NAME &optional SETP GETPRV

       This function sets or resets a VMS privilege.  The first arg is
     the privilege name.  The second argument, SETP, is `t' or `nil',
     indicating whether the privilege is to be set or reset.  Its
     default is `nil'.  The funtion returns `t' if success, `nil' if
     not.

       If the third argument, GETPRV, is non-`nil', `setprv' does not
     change the privilege, but returns `t' or `nil', depending upon
     whether the privilege is already enabled.



File: lispref,  Node: Terminal Input,  Next: Terminal Output,  Prev: System Environment,  Up: System Interface

Terminal Input
==============

  The terminal input functions and variables keep track of or
manipulate terminal input.

  See *Note Emacs Display::, for related functions.

 * Function: recent-keys

       This function returns a string comprising the last 100
     characters read from terminal.  These are the last 100
     characters read by Emacs, no exceptions.

          (recent-keys)
          => "erminal.  These are the last 100 characters read by Emacs, no
          exceptions.
          
          @example
          (recent-keys)^U^X^E"

 * Variable: last-input-char

       This global variable is set to the last terminal input character
     that was typed (as part of a command or not).

       In the example below, a character is read (the character `1',
     ASCII code 49).  It becomes the value of `last-input-char',
     while `C-e' (from the `C-x C-e' command used to evaluate this
     expression) remains the value of `last-command-char'.

          (progn (print (read-char))
                 (print last-command-char)
                 last-input-char)
               -| 49
               -| 5
               => 49

 * Command: open-dribble-file FILENAME

       This function opens a "dribble file" named FILENAME.  When a
     dribble file is open, Emacs copies all keyboard input characters
     to that file.  (The contents of keyboard macros are not typed on
     the keyboard so they are not copied to the dribble file.)

       The function is normally used to debug Emacs input.  You close
     the dribble file by calling this function with an argument of
     `nil'.  The function always returns `nil'.

          (open-dribble-file "$j/dribble")
               => nil

  See also the `open-termscript' function (*note Terminal Output::.).

 * Function: set-input-mode INTERRUPT FLOW

       This function sets the mode for reading keyboard input.  If
     INTERRUPT is non-null, then Emacs uses input interrupts.  If it
     is `nil', then it uses CBREAK mode.

       If FLOW is non-`nil', then Emacs uses XON/XOFF (`C-q', `C-s')
     flow control for output to terminal.  This has no effect except
     in CBREAK mode.

       The normal setting is system dependent.

       *Note Flow Control::.

 * Variable: meta-flag

       This global variable tells Emacs if it should treat the 0200 bit
     in keyboard input as the Meta bit.

 * Variable: keyboard-translate-table

       This global variable defines the translate table for keyboard
     input.  This allows the user to redefine the keys on the
     keyboard without changing any command bindings.

       If `keyboard-translate-table' is a string, then each character
     read from the keyboard is looked up in this string and the
     character in the string is used instead.  If the string is of
     length N, character codes N and up are untranslated.

       In the example, `keyboard-translate-table' is set to a string of
     128 characters.  Then the characters `C-s' and `C-\' are swapped
     and the characters `C-q' and `C-^' are swapped.  After executing
     this function, typing `C-\' behaves exactly like typing `C-s'
     and vice versa.  (*Note Flow Control:: for more information on
     this subject.)

          (defun evade-flow-control ()
            "Replace C-s with C-\ and C-q with C-^."
            (interactive)
            (let ((the-table (make-string 128 0)))
              (let ((i 0))
                (while (< i 128)
                  (aset the-table i i)
                  (setq i (1+ i))))
          
              ;; Swap C-s and C-\
              (aset the-table ?\034 ?\^s)
              (aset the-table ?\^s ?\034)
              ;; Swap C-q and C-^
              (aset the-table ?\036 ?\^q)
              (aset the-table ?\^q ?\036)
          
              (setq keyboard-translate-table the-table)))



File: lispref,  Node: Terminal Output,  Next: Flow Control,  Prev: Terminal Input,  Up: System Interface

Terminal Output
===============

  The terminal output functions send or keep track of output sent from
the computer to the terminal.  The `baud-rate' variable tells you
what Emacs think is the output baud rate of the terminal.

 * Function: baud-rate

       This function returns the output baud rate of the terminal.

          (baud-rate)
               => 9600

       If you are running across a network, and different parts of the
     network work at different baud rates, the value returned by
     Emacs may be different from the value used by your local
     terminal.  This can indicate a deficiency in the communication
     software.  You can overcome the problem by using the `stty'
     program to set the speed on the machine where Emacs is running.

          (note: In version 19, `baud-rate' is a variable.)

 * Function: send-string-to-terminal STRING

       This function sends STRING to the terminal without alteration. 
     Control characters in STRING will have terminal-dependent effects.

       Typically, this function is used to define function keys on
     terminals that have down-loadable function key definitions.

       This example works on some terminals to define function key 4 to
     move forward four characters (by transmitting the characters
     `C-u C-f' to the computer):

          (send-string-to-terminal "\eF4\^U\^F")
               => nil

 * Command: open-termscript FILENAME

       After this function is called, Emacs copies all terminal output
     characters to FILENAME as well to the terminal.  It returns
     `nil'.  This function is normally used to debug Emacs redisplay.

       See also `open-dribble-file' in *Note Terminal Input::.

          (open-termscript "../junk/termscript")
               => nil



File: lispref,  Node: Flow Control,  Next: Batch Mode,  Prev: Terminal Output,  Up: System Interface

Flow Control
============

  This section attempts to answer the question ``Why does Emacs choose
to use flow-control characters in its command character set?''  For a
second view on this issue, please read the comments on flow control
in the `emacs/INSTALL' file from the distribution; for help with
termcaps and DEC terminal concentrators, see `emacs/etc/TERMS'.

  At one time, most terminals did not need flow control.  This meant
that the choice of `C-s' and `C-q' as command characters was
reasonable.  Emacs, for economy of keystrokes and portability, chose
to use the control characters in the ASCII character set, and tried
to make the assignments mnemonic (thus, `S' for search and `Q' for
quote).

  (There are other (albeit less common in practice) ways to do flow
control, not using `C-s' and `C-q', that preserve transparency of the
character stream; these ways are not discussed here.)

  After Emacs's precedent was established, it was too hard to undo:
Emacs' use of `C-s' and `C-q' predates their use by terminals and
front-ends for flow control.  Note also that their use for flow
control is not an official standard.  Interestingly, on the model 33
teletype with a paper tape punch (which is very old), `C-s' and `C-q'
were used for the host to turn the punch on and off!

  So which usage is `right', Emacs's or that of some terminal and
front-end manufacturers?  This is a rhetorical (or religious)
question; it has no simple answer.

  GNU Emacs (version 18.48 and later) provides several options for
coping with terminals or front-ends that insist on using flow control
characters.  Listed in estimated order of preference, these options
are as follows:

  1. Have Emacs run in CBREAK mode with the kernel handling flow
     control.  Issue `(set-input-mode nil t)' from `.emacs'.  After
     doing this, it will be necessary to find other keys to bind to
     the commands `isearch-forward' and `quoted-insert'.  The
     traditional nominees are `C-^' and `C-\'.  There are two ways to
     get this effect:

       1. Use the `keyboard-translate-table' to cause `C-^' and `C-\'
          to be received by Emacs as though `C-s' and `C-q' were
          typed.  Emacs (except at its very lowest level) never knows
          that the characters typed were anything but `C-s' and
          `C-q', so the use of these keys inside `isearch-forward'
          still works--typing `C-^' while incremental searching will
          move the cursor to the next match, etc.  Here's some code
          for this:

               (setq keyboard-translate-table (make-string 128 0))
               (let ((i 0))
                 (while (< i 128)
                   (aset keyboard-translate-table i i)
                   (setq i (1+ i))))
               
                 (aset keyboard-translate-table ?\^\\ ?\^s)
                 (aset keyboard-translate-table ?\^^ ?\^q)
                 ))

       2. Simply rebind the keys `C-^' and `C-\' to `isearch-forward'
          and `quoted-insert'.  To get continued searches inside
          isearch it is also necessary to set `search-repeat-char' to
          `C-^', as well.

  2. Don't use CBREAK mode, but cause `C-s' and `C-q' to be bound to
     a null command.  The problem with this solution is that the flow
     control characters were probably sent because whatever sent them
     is falling behind on the characters being sent to it.  The
     characters that find their way to the terminal screen will not
     in general be those that are intended.  Also, it will be be
     necessary to find other keys to bind to `isearch-forward' and
     `quoted-insert'; see the two previous alternatives.

     Here is a suitable null command:

          (defun noop ()
            "Do nothing; return nil."
            (interactive))

  3. Don't use CBREAK mode, and unset the `C-s' and `C-Q' keys with
     the `global-unset-key' function.  This is similar to the
     previous alternative, except that the flow control characters
     will probably cause beeps or visible bells.

     Note that if the terminal is the source of the flow control
     characters and kernel flow control handling is enabled, you
     probably will not have to to send padding characters as
     specified in a termcap or terminfo entry.  In this case, it may
     be possible to customize a termcap entry to provide better Emacs
     performance on the assumption that flow control is in use.  This
     effect can also be simulated by announcing (with `stty' or its
     equivalent) that the terminal is running at a very slow speed,
     provided the terminal is not directly wired to the host.



File: lispref,  Node: Batch Mode,  Prev: Flow Control,  Up: System Interface

Batch Mode
==========

  The command line option `-batch' causes Emacs to run
noninteractively.  In this mode, Emacs does not read commands from
the terminal, it does not alter the terminal modes, and it does not
expect to be outputting to an erasable screen.  The idea is that you
will specify (with the command line options `-l' and `-f') some Lisp
programs to run; when they are finished, Emacs should exit.

  Any Lisp program output that would normally go to the echo area,
either using `message' or using `prin1', etc., with `t' as the
stream, will actually go to Emacs's standard output descriptor when
in batch mode.  Thus, Emacs behaves much like a noninteractive
application program.  (The echo-area output that Emacs itself
normally generates is suppressed entirely.)

 * Variable: noninteractive

     This variable is non-`nil' when Emacs is running in batch mode.



File: lispref,  Node: Emacs Display,  Next: Tips and Standards,  Prev: System Interface,  Up: Top

Emacs Display
*************

This chapter describes a number of features related to the display
that Emacs presents to the user.

* Menu:

* Window Systems::      Which window system is being used.
* Screen Attributes::   How big is the Emacs screen.
* Truncation::          Folding or wrapping long text lines.
* The Echo Area::	Where messages are displayed.
* Selective Display::   Hiding part of the buffer text.
* Overlay Arrow::       Display of an arrow to indicate position.
* Temporary Displays::  Displays that go away automatically.
* Waiting::             Forcing display update and waiting for user.
* Blinking::            How Emacs shows the matching open-paren.
* Control Char Display::  How control characters are displayed.
* Beeping::             Audible signal to the user.

  * Command: redraw-display

       This function clears the screen and redraws what is supposed to
     appear on it.



File: lispref,  Node: Window Systems,  Next: Screen Attributes,  Prev: Emacs Display,  Up: Emacs Display

Window Systems
==============

  Emacs works with several window systems, most notably, X.

 * Variable: window-system

       This global variable tells Emacs what window system it is
     running under.  Its value should be a symbol such as `x' (if
     Emacs is running under X) or `nil' (if Emacs is running on an
     ordinary terminal).

 * Variable: window-system-version

       This variable will be either 10 or 11 when using the X window
     system.

 * Variable: window-setup-hook

       The value of the `window-setup-hook' variable is either `nil' or
     that of a function that Emacs calls after loading your `.emacs'
     file, the default initialization file (if any),  after loading
     terminal-specific lisp code, and after calling `term-setup-hook'.
     `window-setup-hook' is called with no arguments.

       This hook is used for internal purposes: setting up
     communication with the window system, and creating the initial
     window.  Users should not mess with it.



File: lispref,  Node: Screen Attributes,  Next: Truncation,  Prev: Window Systems,  Up: Emacs Display

Screen Attributes
=================

  The screen attribute functions describe and define the
characteristics of your terminal.

 * Function: screen-height

       This function returns the number of lines on the screen that are
     available for display.

          (screen-height)
               => 50

 * Function: set-screen-height LINES &optional NOT-ACTUAL-SIZE

       This function declares that the terminal can display LINES lines.
     The sizes of existing windows will be altered proportionally to
     fit.

       If NOT-ACTUAL-SIZE is non-`nil', then Emacs should use LINES for
     display, but it will still know about the actual size of the
     screen.  Knowing the correct actual size may be necessary for
     correct cursor positioning.

       If LINES is different from what it was previously, Emacs will
     redisplay the screen using the new size.

       This function returns `nil'.

 * Function: screen-width

       This function returns the number of columns on the screen that
     are available for display.

          (screen-width)
               => 80

 * Function: set-screen-width COLUMNS &optional NOT-ACTUAL-SIZE

       This function declares that the terminal can display COLUMNS
     columns.

       NOT-ACTUAL-SIZE is the same as in `set-screen-height'.

       If COLUMNS is different from what it was previously, Emacs will
     redisplay the screen using the new size.

       This function returns `nil'.

 * Variable: no-redraw-on-reenter

       This global variable determines whether Emacs should redraw the
     entire screen after it has been suspended and resumed.  `t'
     means do, `nil' means don't.  This is useful if the terminal can
     remember and restore the Emacs screen.

 * Variable: inverse-video

       This global variable determines whether Emacs will use inverse
     video for all text on the screen.  `t' means do, `nil' means
     don't.

 * Option: mode-line-inverse-video

       This variable determines how the mode line will be displayed. 
     If it is non-`nil', then the mode line will use inverse video
     (or another suitable display mode).  Otherwise the mode line
     will be in normal display, just like the rest of the screen.



File: lispref,  Node: Truncation,  Next: The Echo Area,  Prev: Screen Attributes,  Up: Emacs Display

Truncation
==========

  When a line of text extends beyond the right edge of a window, the
line can either be truncated or continued on the next line.  When a
line is trucated, this is shown with a `$' in the right most column
of the window.  When a line is continued or `wrapped' onto the next
line, this is shown with a `\' on the right most column of the window.
Lines that continue onto the next line are called "continuation"
lines.  (Note that wrapped lines are not filled.  Filling has nothing
to do with truncation and continuation.  *Note Auto Filling::.)

 * Option: truncate-lines

        This per-buffer-local variable controls how Emacs displays lines
     that extend beyond the right edge of the window.  If it is
     non-`nil', then Emacs will not display continuation lines; but
     rather each line of text will take exactly one screen line and a
     dollar sign will be shown at the edge of any line that extends
     to or beyond the edge of the window.

      This variable is overridden by the variable
     `truncate-partial-width-windows' if that variable is non-`nil'
     and the window in question is not the full width of the screen.

 * Variable: default-truncate-lines

       This variable is the default value for `truncate-lines' in
     buffers that do not override it.

 * Option: truncate-partial-width-windows

       This variable determines how lines that are too wide to fit on
     the screen are displayed in side-by-side windows (*note
     Splitting Windows::.).  If it is non-`nil', then wide lines will
     be truncated (with a `$' at the end of the line), otherwise they
     will be wrapped (with a `\' at the end of the line).



File: lispref,  Node: The Echo Area,  Next: Selective Display,  Prev: Truncation,  Up: Emacs Display

The Echo Area
=============

  The minibuffer is *not* the "echo area", despite the fact that they
occupy the same physical space on the screen.  The echo area is where
messages from Emacs are displayed, using the `message' primitive or
something similar.  The ``GNU Emacs Manual'' specifies the rules for
how conflicts between use of the echo area and the minibuffer are
resolved (*note : (emacs)Minibuffer.).

 * Function: message STRING &rest ARGUMENTS

       This function prints a one-line message in the echo area. 
     STRING is similar to a C language `printf' control string.  See
     `format' in *Note String Conversion::, for the details on the
     conversion specifications.  `message' returns the constructed
     string.

          (message "Minibuffer depth is %d." (minibuffer-depth))
          -| "Minibuffer depth is 0."
          
          --------- Echo Area ---------
          Minibuffer depth is 0.
          --------- Echo Area ---------

 * Variable: cursor-in-echo-area

       This global variable controls where the cursor will be placed
     when a message is displayed in the echo area.  If it is
     non-`nil', then do put the cursor there.



File: lispref,  Node: Selective Display,  Next: Overlay Arrow,  Prev: The Echo Area,  Up: Emacs Display

Selective Display
=================

  "Selective display" is a class of minor modes in which specially
marked lines do not appear on the screen, or in which highly indented
lines do not appear.

  The first variant, explicit selective display, is designed for use in
a Lisp program.  The program controls which lines are hidden by
altering the text.  Outline mode uses this variant.  In the second
variant, the choice of lines to hide is made automatically based on
indentation.  This variant is designed as a user-level feature.

  The way you control explicit selective display is by replacing a
newline (`^j') with a m.  The text which was formerly a line
following that newline is now invisible.  Strictly speaking, it is no
longer a separate line, since only newlines can separate lines.  It
is now part of the previous line.

  On its own, selective display does not affect editing commands; for
example, `C-f' (`forward-char' will move point into invisible space. 
However, the replacement of newline characters with carriage return
characters affects some editing commands.  For example, `next-line'
will skip invisible lines, since it searches only for newlines. 
Also, modes which use selective display can also define commands
which take account of the newlines, or which make parts of the text
visible or invisible.

  When you write a selectively displayed buffer into a file, all the
m's are replaced by their original newlines.  This means that when
you next read in the file, it looks OK, with nothing invisible. 
Selective display is an effect that is only seen in Emacs.

 * Variable: selective-display

       This buffer-local variable enables selective display.  This
     means that lines, or portions of lines, may be made invisible.

        * If the value of `selective-display' is `t', then any
          portion of a line that follows a m will not be displayed.

        * If the value of `selective-display' is a positive integer,
          then lines that start with whitespace in more than
          `selective-display' columns will not be displayed.

       When some portion of a buffer is invisible, the vertical
     movement commands operate as if that portion did not exist,
     allowing a single `next-line' command to skip a hundred lines. 
     Character movement commands (such as `forward-char') will not
     skip the invisible portion however, and it is possible, if
     tricky, to insert or delete parts of an invisible portion.

       In the examples below, what is shown is the *display* of the
     buffer `foo', which changes with the value of
     `selective-display'.  The *contents* of the buffer does not
     change.

          (setq selective-display nil)
               => nil
          
          --------- Buffer: foo ---------
          1 on this column
           2on this column
            3n this column
            3n this column
           2on this column
          1 on this column
          --------- Buffer: foo ---------
          
          (setq selective-display-ellipses t)
               => t
          (setq selective-display 2)
               => 2
          
          --------- Buffer: foo ---------
          1 on this column
           2on this column ...
           2on this column
          1 on this column
          --------- Buffer: foo ---------
          
          (setq selective-display-ellipses nil)
               => nil
          
          --------- Buffer: foo ---------
          1 on this column
           2on this column
           2on this column
          1 on this column
          --------- Buffer: foo ---------

 * Variable: selective-display-ellipses

     If this buffer-local variable is non-`nil', then display `...'
     at the end of a line that is followed by invisible text.



File: lispref,  Node: Overlay Arrow,  Next: Temporary Displays,  Prev: Selective Display,  Up: Emacs Display

Overlay Arrow
=============

  The "overlay arrow" is useful for directing the user's attention to a
particular line in a buffer.  For example, in a debugger mode, the
overlay arrow might point to the current line of code about to be
executed.

 * Variable: overlay-arrow-string

     The string to display as an arrow.

 * Variable: overlay-arrow-position

     Marker for where to display `overlay-arrow-string' on top of the
     buffer text.  This must be a marker at the beginning of some
     line.  The overlay string will only display over text on that
     line up to the end of line.

     The overlay string will only be displayed in the buffer which
     this marker points into.



File: lispref,  Node: Temporary Displays,  Next: Waiting,  Prev: Overlay Arrow,  Up: Emacs Display

Temporary Displays
==================

  Temporary displays are used by help commands.

 * Variable: temp-buffer-show-hook

       The value of the `temp-buffer-show-hook' variable is either
     `nil' or is called as a function to display a help buffer.  This
     variable is used by `with-output-to-temp-buffer'.

 * Special form: with-output-to-temp-buffer BUFFER-NAME FORMS...

       This function arranges foroutput generated by evaluating FORMS
     to be inserted into the buffer named BUFFER-NAME.  The buffer is
     then shown in some window for viewing.  The buffer is displayed
     but not selected.

       The buffer is named by the string BUFFER-NAME, and it need not
     exist.  BUFFER-NAME must be a string, not a buffer.  The buffer
     is erased initially (with no questions asked), and it is marked
     as unmodified after `with-output-to-temp-buffer' exits.

       `with-output-to-temp-buffer' first binds `standard-output' to
     the buffer, then it evaluates the forms in FORMS.  With
     `standard-output' rebound, any output directed there will
     naturally be inserted into the buffer.

       The value of the last form in FORMS is returned.

          --------- Buffer: foo ---------
           This is the contents of foo.
          --------- Buffer: foo ---------
          
          (with-output-to-temp-buffer "foo"
              (print 20)
              (print standard-output))
          => #<buffer foo>
          
          --------- Buffer: foo ---------
          20
          
          #<buffer foo>
          
          --------- Buffer: foo ---------

 * Function: momentary-string-display STRING POSITION &optional CHAR
MESSAGE

       This function momentarily displays STRING in the current buffer
     at POSITION (which is a character offset from the beginning of
     the buffer).  The display remains until the next character is
     typed.

       If the next character the user types is CHAR, then Emacs ignores
     it.  Otherwise it is then the first character in the next input.
     Thus, typing CHAR will simply remove the string from the
     display, while typing say, `C-f' will remove the string from the
     display and move point forward.  CHAR is a space by default.

       Note that the result of `momentary-string-display' is the
     character typed rather than `t' if that character is not CHAR.

       If MESSAGE is non-`nil', it is displayed in the echo area.  If
     it is `nil', then instructions to type CHAR are displayed there,
     e.g., `Type RET to continue editing'.

       In the example, point in `foo' is located at the beginning of
     the second line.

          --------- Buffer: foo ---------
          This is the contents of foo.
          -!-This is the contents of foo.
          --------- Buffer: foo ---------
          
          (momentary-string-display
             "******* Important Message! *******" (point) ?\r
             "Type RET when done reading")
          
               => t
          
          --------- Buffer: foo ---------
          This is the contents of foo.
          ******* Important Message! *******This is the contents of foo.
          --------- Buffer: foo ---------
          
          --------- Echo Area ---------
          Type RET when done reading

       This function works by actually changing the text in the buffer;
     as a result, if you later undo in this buffer, you will see the
     message come and go.



File: lispref,  Node: Waiting,  Next: Blinking,  Prev: Temporary Displays,  Up: Emacs Display

Waiting for Elapsed Time or Input
=================================

  The waiting commands are designed to make Emacs wait for a certain
amount of time to pass or until there is input.  For example, you may
wish to pause in the middle of a computation to allow the user time
to view the display.  `sit-for' performs a pause with an update of
screen, while `sleep-for' performs a pause without updating the screen.

 * Function: sit-for SECONDS

       This function performs redisplay (if there is no pending input
     from the user), then waits SECONDS seconds, or until input is
     available.  The result is `t' if `sit-for' waited the full time
     with no input arriving (see `input-pending-p' in *Note Keyboard
     Input::).  Otherwise, `nil' is returned.

     Redisplay is always preempted if input arrives, and does not
     happen at all if input is available before it starts.  Thus
     there is no way to force an update if there is pending input. 
     But if there is no input pending, you can force an update with
     no delay by using `(sit-for 0)'.

       You use `sit-for' to give the user time to read messages that
     you display.

 * Function: sleep-for SECONDS

       This function simply pauses, without updating the display, for
     SECONDS seconds.  It pays no attention to available input.  It
     returns `nil'.

       You use `sleep-for' to guarantee a delay.



File: lispref,  Node: Blinking,  Next: Control Char Display,  Prev: Waiting,  Up: Emacs Display

Blinking
========

  These are the internals of the mechanism by which Emacs shows a
matching open parenthesis.

 * Variable: blink-paren-hook

       The value of this variable should be a function (of no
     arguments) to be called whenever a char with close parenthesis
     syntax is inserted.  The value of `blink-paren-hook' may be
     `nil', in which case nothing is done.

          Note: In version 18, this function is named
          `blink-paren-hook'; but since `blink-paren-hook' is not
          called with the standard convention for hooks, it is being
          re-named `blink-paren-function' in version 19.

 * Variable: blink-matching-paren

     Non-`nil' means show matching open-paren when close-paren is
     inserted.

 * Function: blink-matching-open

     Move cursor momentarily to the beginning of the sexp before point.

          (defun interactive-blink-matching-open ()
            "Move cursor momentarily to start of sexp before point."
            (interactive)
            (let ((blink-matching-paren t))
              (blink-matching-open)))



File: lispref,  Node: Control Char Display,  Next: Beeping,  Prev: Blinking,  Up: Emacs Display

Display of Control Characters
=============================

 * Option: ctl-arrow

       This buffer-local variable controls how control characters are
     displayed.  If it is non-`nil', then they are displayed as an
     uparrow followed by the character: `^A'.  If it is `nil', then
     they are displayed as a backslash followed by three octal
     digits, `\001'.

 * Variable: default-ctl-arrow

       The value of this variable is the default value for `ctl-arrow'
     in buffers that do not override it.  This is the same as
     `(default-value 'ctl-arrow)'.



File: lispref,  Node: Beeping,  Prev: Control Char Display,  Up: Emacs Display

Beeping
=======

  You can make Emacs ring a bell (or, perhaps, blink the screen) to
attract the user's attention.  If used too frequently, this becomes
irritating.  Be careful not to use beeping when an error message is
appropriate.  (*Note Errors::.)

 * Function: ding &optional DONT-TERMINATE

       This function beeps, or flashes the screen (see `visible-bell'
     below).  It also terminates any keyboard macro currently
     executing unless DONT-TERMINATE is non-`nil'.

 * Function: beep &optional DONT-TERMINATE

     This is a synonym for `ding'.

 * Variable: visible-bell

       This global variable determines whether Emacs will try to flash
     the screen to represent a bell.  `t' means do, `nil' means don't.
     This is only effective if the termcap entry for the terminal in
     use has the visible bell flag (vb) set.



File: lispref,  Node: Tips and Standards,  Next: GNU Emacs Internals,  Prev: Emacs Display,  Up: Top

Tips and Standards for Emacs Lisp programs
******************************************

Here are some tips for avoiding common errors in writing Lisp code
for other people to use:

   * Since all global names are in the same name space, you should
     take care to prefix the names of all global variables,
     constants, and functions with the major mode name (or with an
     abbreviation of it if the name is long).  This helps avoid name
     conflicts.

     This recommendation applies even to names for traditional Lisp
     primitives that are not primitives in Emacs Lisp--even to `cadr'!
     Believe it or not, there is more than one plausible way to
     define `cadr'.  Play it safe; append your name prefix to produce
     a name like `foo-cadr' or `mylib-cadr' instead.

     If one prefix is insufficient, your package may use two or three
     alternative common words, so long as they make sense.

   * It is often useful to put a call to `provide' in each separate
     library program, at least if there is more than one entry point
     to the program.

   * If one file FOO uses a macro defined in another file BAR, FOO
     should contain `(require 'BAR)' before the first use of the
     macro.  (And BAR should contain `(provide 'BAR)', to make the
     `require' work.)  This will cause BAR to be loaded when you
     byte-compile FOO.

     Otherwise, you risk compiling FOO without the necessary macro
     loaded.  If that happens, the compiled code won't work right.

   * If you define a major mode, make sure to run a hook variable
     using `run-hooks', just as the existing major modes do.

   * Please do not define `C-c LETTER' as a key.  These sequences are
     reserved for users; they are the *only* sequences reserved for
     users, so we cannot do without them.

     Everything in Emacs that used to define such sequences has been
     changed, which was a lot of work.  Abandoning this convention
     would waste that work, and hurt the users.

   * It is a bad idea to define aliases for the Emacs primitives. 
     Use the standard names instead.

   * Every command, function or variable intended for users to know
     about should have a documention string.

   * The first line of the documentation string should consist of one
     or two complete sentences which stand on their own as a summary.
     In particular, start with a capital letter and end with a period.

     A doc string can have additional lines which expand on the
     details of how to use the function or variable.  The additional
     lines should be made up of complete sentences also, but they may
     be filled if that looks good.

   * *Do not* indent subsequent lines of doc string so that their
     text is lined up with the text of the first line.  This looks
     nice in the source code, but looks bad when users view the
     documentation.  Remember that the indentation before the
     starting doublequote is not part of the string!

   * A variable's doc string should start with `*' if the variable is
     one that users would want to set interactively often.  If the
     value is a long list, or a function, or the variable would only
     be set in init files, then don't start the doc string with `*'.

   * In documentation strings, don't write key sequences directly. 
     Instead, use the `\\[...]' construct to stand for them.  For
     example, instead of writing `C-f', write `\\[forward-char]'. 
     When the doc string is printed, Emacs will replace it with
     whatever key runs `forward-char'.  This will usually be `C-f',
     but if the user has moved key bindings, it will be the correct
     key for that user.

     In doc strings for a major mode, do the same thing.  However,
     you will want to refer to the key bindings of that mode's local
     map, rather than global ones.  Therefore, use the construct
     `\\<...>' once in the doc string to specify which key map to
     use.  Do this before the first use of `\\[...]'.  The text
     inside the `\\<...>' should be the name of the variable
     containing the local keymap for that major mode.

   * Don't use `next-line' or `previous-line' in programs; nearly
     always, `forward-line' is more convenient as well as more
     predictable and robust.

   * Don't use functions that set the mark in your Lisp code (unless
     you are writing a command to set the mark).  The mark is for the
     user to use, and messing it up is incorrect.

     In particular, don't use these functions:

        * `beginning-of-buffer', `end-of-buffer'

        * `replace-string', `replace-regexp'

     If you just want to move point, or just replace a certain
     string, without any of the other features intended for
     interactive users, you can replace these with one or two lines
     of simple Lisp code.

   * The recommended way to print a message in the echo area is with
     the `message' function, not `princ'.

   * When you encounter an error condition, call the function `error'.
     This function does not return.

     Do not use `message', `throw', `sleep-for', or `beep' to report
     errors.

   * Indent each function with `C-M-q' (`indent-sexp') using the
     default indentation parameters.  Or `M-C-\' (`indent-region').

   * Avoid using recursive edits.  Instead, do what the Rmail `w'
     command does: use a new local keymap which contains one command
     defined to switch back to the old local keymap.  Or do what the
     `edit-options' command does: switch to another buffer and let
     the user switch back at will.

   * If a file replaces any of the functions or library programs of
     standard Emacs, prominent comments at the beginning of the file
     should say which functions are replaced, and how the behavior of
     the replacements differs from the originals.

     If a file requires certain standard library programs to be
     loaded first, then the comments at the beginning of the file
     should say so.

   * Please put a copyright notice on the file if you give copies to
     anyone.  Use the same lines that appear at the top of the Lisp
     files in Emacs itself.  If you have not signed papers to assign
     the copyright to the Foundation, then place your name in the
     copyright notice in place of the Foundation's name.



File: lispref,  Node: GNU Emacs Internals,  Next: Standard Errors,  Prev: Tips and Standards,  Up: Top

GNU Emacs Internals
*******************

This chapter describes many internal aspects of GNU Emacs that may
only be of interest to C programmers.

* Menu:

* Building Emacs::      How to preload Lisp libraries into Emacs.
* Pure Storage::        A kludge to make preloaded Lisp functions sharable.
* Garbage Collection::  Reclaiming space for Lisp objects no longer used.
* Object Internals::    Data formats of buffers, windows, processes.
* Writing Emacs Primitives::   Writing C code for Emacs.

 

File: lispref,  Node: Building Emacs,  Next: Pure Storage,  Prev: GNU Emacs Internals,  Up: GNU Emacs Internals

Building Emacs
==============

  To build Emacs, you first compile the C sources.  This produces a
program called `temacs', also called a "bare impure Emacs".  This
version of Emacs contains the Emacs Lisp interpreter and I/O
routines, but not the editing commands.

  To create a working Emacs editor, you issue the command `temacs -l
loadup'.  This directs `temacs' to evaluate the Lisp files named in
the `loadup.el' file.  These files define the normal Emacs editing
environment.

  It takes long time to load the standard Lisp files.  Luckily, you
don't have to do this each time you run Emacs: `temacs' can dump out
an executable file called `xemacs' which has these files preloaded. 
`xemacs' starts more quickly because it does not need to load the
files.  It is `xemacs' that is normally installed under the name
`emacs' for users to run.

  To create `xemacs', use the command `temacs -batch -l loadup dump'. 
The purpose of `-batch' here is to prevent `temacs' from trying to
initialize any of its data on the terminal.  This ensures that the
tables of terminal information are empty in the dumped Emacs.

  When the `xemacs' executable is started, it will automatically load
the user's `.emacs' file, or the default initialization file
`default.el' if the user has none.  With the `.emacs' file, you can
produce a version of Emacs that suits you and is not the same as the
version other people use.  With `default.el', you can customize Emacs
for all the users at your site who don't choose to customize it for
themselves.  (For further reflection: why is this different from the
case of the barber who shaves every man who doesn't shave himself?)

  On some systems, dumping does not work.  Then, you can start Emacs
with the `temacs -l loadup' command.  This takes a long time, but
since you need to start Emacs once a day at most--and once a week or
less frequently if you never log out--the extra time is not too
severe a problem.

 * Function: dump-emacs TO-FILE FROM-FILE

       This function dumps the current state of Emacs into an
     executable file TO-FILE.  It takes symbols from FROM-FILE (this
     is normally the executable file `temacs').  See also
     `Snarf-documentation' in *Note Accessing Documentation::.

     If you use this function in an Emacs that was already dumped,
     you must set `command-line-processed' to `nil' first for good
     results.  *Note Command Line Arguments::.

 * Function: emacs-version

       This function returns a string describing the version of Emacs
     that is running.  It is useful to include this string in bug
     reports.

          (emacs-version)
            => "GNU Emacs 18.36.1 of Fri Feb 27 1987 on slug (berkeley-unix)"

 * Variable: emacs-build-time

       The value of this global variable is the time at which Emacs was
     built at the local site.

          emacs-build-time
               => "Fri Feb 27 14:55:57 1987"

 * Variable: emacs-version

       The value of this variable is the version of Emacs being run. 
     It is a string, e.g. `"18.36.1"'.



File: lispref,  Node: Pure Storage,  Next: Garbage Collection,  Prev: Building Emacs,  Up: GNU Emacs Internals

Pure Storage
============

  There are two types of storage in GNU Emacs Lisp for user-created
Lisp objects: "normal storage" and "pure storage".  Normal storage is
where all the new data which is created during an Emacs session is
kept.  Pure storage is used for certain data in the preloaded
standard Lisp files: data that should never change during actual use
of Emacs.

  When a program creates a list or the user defines a new function
(such as by loading a library), then that data is placed in normal
storage.  If normal storage runs low, then Emacs asks the operating
system to allocate more memory in blocks of 1k bytes.  Each block is
used for one type of Lisp object, so symbols, cons cells, markers,
etc. are segregated in distinct blocks in memory.  (Vectors, buffers
and certain other editing types, which are fairly large, are
allocated in individual blocks, one per object, while strings are
packed into blocks of 8k bytes.)

  After a certain amount of storage has been allocated (determined by
the variable `gc-cons-threshold'), the garbage collector is called to
collect all storage which has been used and abandoned.

  Pure storage is allocated only while `temacs' is loading the standard
preloaded Lisp libraries.  In the file `xemacs', it is marked as
read-only (on operating systems which permit this), so that the
memory space can be shared by all the Emacs jobs running on the
machine at once.  Pure storage is not expandable; a fixed amount is
allocated when Emacs is compiled, and if that is not sufficient for
the preloaded libraries, `temacs' crashes.  If that happens, you will
have to increase the compilation parameter `PURESIZE' in the file
`config.h'.  This normally won't happen unless you try to preload
additional libraries or add features to the standard ones.

 * Function: purecopy OBJECT

       This function makes a copy of OBJECT in pure storage and returns
     it.  It copies strings by simply making a new string with the
     same characters in pure storage.  It recursively copies the
     contents of vectors and cons cells.

       It does not make copies of symbols, or any other objects, but
     just returns them unchanged.  It signals an error if asked to
     copy markers.

     This function is used only while Emacs is being built and
     dumped, and appears only in the `emacs/lisp/loaddefs.el' file,
     among the Lisp sources.

 * Variable: pure-bytes-used

       The value of this variable is the number of bytes of pure
     storage allocated so far.  Typically, in a dumped Emacs, this
     number is very close to the total amount of pure storage
     available--if it were not, we would preallocate less of it.

 * Variable: purify-flag

       This variable determines whether `defun' should make a copy of
     the function definition in pure storage.  If it is non-`nil',
     then the function definition is copied into pure storage.

       This flag is `t' while loading all of the basic functions for
     building Emacs initially (allowing those functions to be
     sharable and non-collectible).  It is set to `nil' when Emacs is
     saved out as `xemacs'.  The flag is set and reset in the C
     sources.

      You should not change this flag in a running Emacs.



File: lispref,  Node: Garbage Collection,  Next: Writing Emacs Primitives,  Prev: Pure Storage,  Up: GNU Emacs Internals

Garbage Collection
==================

  All functions which build new Lisp objects (be they lists, strings,
buffers, or whatever) require storage for them.  It is quite common
to use some storage for a while, and then release it, for example, by
killing a buffer or by deleting the last pointer to an object.  Emacs
provides a "garbage collector" to reclaim this abandoned storage. 
(This name is traditional, but ``garbage recycler'' might be a more
intuitive metaphor for this facility.)

  The garbage collector operates by scanning all the objects which have
been allocated and marking those that are accessible to the user.  To
begin with, all the symbols, their values and associated function
definitions, and any data presently on the stack, are accessible. 
Any objects which can be reached indirectly through other accessible
objects are also marked as being accessible.

  When this is finished, all inaccessible objects are garbage.  No
matter what the Lisp program or the user does, it is impossible to
refer to them, since there is no longer a way to get ahold of them. 
Their space might as well be reused, since no one will notice.  That
is what the garbage collector arranges to do.

  Unused cons cells are simply chained together onto a "free list" for
future allocation.  The accessible strings are compacted so they are
contiguous in memory; then the rest of the space formerly occupied by
strings is made available to the string creation functions.

     Common Lisp Note: Unlike other Lisps, the garbage collector is
     not called when storage is exhausted.  Instead, GNU Emacs Lisp
     simply requests the operating system to allocate more storage,
     and processing continues until `gc-cons-threshold' bytes have
     been used.

     This means that you can run the garbage collector and then be
     sure that you won't need another garbage collection until
     another `gc-cons-threshold' bytes have been used.

 * Command: garbage-collect

       This function reclaims storage used by Lisp objects that are no
     longer needed.  It returns information on the amount of space in
     use.  Garbage collection happens automatically if you use more
     than `gc-cons-threshold' bytes of Lisp data since the previous
     garbage collection.  You can also request it explicitly by
     calling this function.

       `garbage-collect' returns a list containing the following
     information:

          ((USED-CONSES . FREE-CONSES)
           (USED-SYMS . FREE-SYMS)
           (USED-MARKERS . FREE-MARKERS)
           USED-STRING-CHARS 
           USED-VECTOR-SLOTS)
          
          (garbage-collect)
               => ((3435 . 2332) (1688 . 0) (57 . 417) 24510 3839)

     Here is a table explaining each element:

    USED-CONSES
          The number of cons cells in use.

    FREE-CONSES
          The number of cons cells for which space has been obtained
          from the operating system, but that are not currently being
          used.

    USED-SYMS
          The number of symbols in use.

    FREE-SYMS
          The number of symbols for which space has been obtained
          from the operating system, but that are not currently being
          used.

    USED-MARKERS
          The number of markers in use.

    FREE-MARKERS
          The number of markers for which space has been obtained
          from the operating system, but that are not currently being
          used.

    USED-STRING-CHARS
          The total size of all strings, in characters.

    USED-VECTOR-SLOTS
          The total number of elements of existing vectors.

 * Option: gc-cons-threshold

       The value of this variable is the number of bytes of storage
     that may be allocated for Lisp objects after one garbage
     collection before another one is automatically called.  A cons
     cell counts as eight, a string as one byte per character plus a
     few bytes of overhead, and so on.  Space allocated to the
     contents of buffers does not count.

       The initial value is 100,000.  If you set it to a larger value,
     garbage collection will happen less often.  This reduces the
     amount of time spent garbage collecting, but increases total
     memory use.  You may want to do this when running a program
     which creates lots of Lisp data.

       You can make collections more frequent by storing a smaller
     value, down to 10,000.  Setting it to a value less than 10,000
     will only have effect until the subsequent garbage collection,
     at which time `garbage-collect' will set it back to 10,000.



File: lispref,  Node: Writing Emacs Primitives,  Next: Object Internals,  Prev: Garbage Collection,  Up: GNU Emacs Internals

Writing Emacs Primitives
========================

  Lisp primitives are Lisp functions implemented in C.  The details of
interfacing the C function so that Lisp can call it are handled by a
few C macros.  The only way to really understand how to write new C
code is to read the source; however, we can explain some things here.

  An example of a special form (an ordinary function would have the
same general appearance) is the definition of `or', from `eval.c'.

     DEFUN ("or", For, Sor, 0, UNEVALLED, 0,
       "Eval args until one of them yields non-NIL, then return that value.\n\
     The remaining args are not evalled at all.\n\
     If all args return NIL, return NIL.")
       (args)
          Lisp_Object args;
     {
       register Lisp_Object val;
       Lisp_Object args_left;
       struct gcpro gcpro1;
     
       if (NULL(args))
         return Qnil;
     
       args_left = args;
       GCPRO1 (args_left);
     
       do
         {
           val = Feval (Fcar (args_left));
           if (!NULL (val))
             break;
           args_left = Fcdr (args_left);
         }
       while (!NULL(args_left));
     
       UNGCPRO;
       return val;
     }

  Let's start with a precise explanation of the arguments to the
`DEFUN' macro:

  1. The first argument is the name of the function in Lisp; it will
     be named `or'.

  2. The second argument is the C function name for this function. 
     This is the name that is used in C code for calling the
     function.  The name is, by convention, `F' prepended to the Lisp
     name, with all dashes (`-') in the Lisp name changed to
     underscores.  Thus, if your C code wishes to call this function,
     it will call `For'.  Remember that the arguments must be of type
     `Lisp_Object'; various macros and functions for creating values
     of type `Lisp_Object' are provided in the file `lisp.h'.

  3. The third argument is the name of the C variable representing
     the Lisp primitive that this function codes.  This name is by
     convention `S' prepended to the name, in the same manner that
     the function name is created.

  4. The fourth argument is the minimum number of arguments that must
     be provided; i.e., the number of required arguments.  In this
     case, no arguments are required.

  5. The fifth argument is the maximum number of arguments that can
     be provided.  Alternatively, it can be `UNEVALLED', indicating a
     special form that receives unevaluated arguments.  A function
     with the equivalent of an `&rest' argument would have `MANY' in
     this position.  Both `UNEVALLED' and `MANY' are macros.  This
     argument must be one of these macros or a number at least as
     large as the fourth argument.

  6. The sixth argument is an interactive specification exactly like
     the one provided in Lisp.  In this case it is 0 (a null
     pointer), indicating that this function cannot be called
     interactively.  A value of `""' indicates an interactive
     function not taking arguments.

  7. The last argument is the documentation string.  It is written
     just like a documentation string for a function defined in Lisp,
     except you must write `\n\' at the end of each line.  In
     particular, the first line should be a single sentence.

  After the call to the `DEFUN' macro, you must write the list of
argument names that every C function must have, followed by ordinary
C declarations for them.  Normally, all the arguments must be
declared as `Lisp_Object'.  If the function has no upper limit on the
number of arguments in Lisp, then in C it receives two arguments: the
number of Lisp arguments, and the address of a block containing their
values.  These have types `int' and `Lisp_Object *'.

  Within the function `For' itself, note the use of the macros `GCPRO1'
and `UNGCPRO'.  `GCPRO1' is used to ``protect'' a variable from
garbage collection: to inform the garbage collector that it must look
in that variable and regard its contents as an accessible object. 
This is necessary whenever you call `Feval' or anything that can
directly or indirectly call `Feval'.  At such a time, any Lisp object
that you intend to refer to again must be protected somehow. 
`UNGCPRO' cancels the protection of the variables that are protected
in the current function.  It is necessary to do this explicitly.

  For most data types, it suffices to know that one pointer to the
object is protected; as long as the object is not recycled, all
pointers to it remain valid.  For strings, this is not so, because
the garbage collector can move them.  When a string is moved, any
pointers to it that the garbage collector does not know about will
not be properly relocated.  Therefore, all pointers to strings must
be protected across any point where garbage collection may be possible.

  The macro `GCPRO1' protects just one local variable.  If you want to
protect two, use `GCPRO2' instead; repeating `GCPRO1' will not work.

  In addition to using these macros, you must declare the local
variables such as `gcpro1' which they implicitly use.  Alas, we can't
explain all the tricky details here.

  Defining the C function is not enough; you must also create the Lisp
symbol for the primitive and store a suitable subr object in its
function cell.  This is done by adding code to an initialization
routine.  The code looks like this:

     defsubr (&C-VARIABLE-NAME);

C-VARIABLE-NAME is the name you used as the third argument to `DEFUN'.

  If you are adding a primitive to a file that already has Lisp
primitives defined in it, find the function (near the end of the
file) named `syms_of_SOMETHING', and add that function call to it. 
If the file doesn't have this function, or if you create a new file,
add to it a `syms_of_FILENAME' (e.g., `syms_of_eval').  Then find the
spot in `emacs.c' where all of these functions are called, and add a
call to `syms_of_FILENAME' there.

  This function `syms_of_FILENAME' is also the place to define any C
variables which are to be visible as Lisp variables.  `DEFVAR_LISP'
is used to make a C variable of type `Lisp_Object' visible in Lisp. 
`DEFVAR_INT' is used to make a C variable of type `int' visible in
Lisp with a value that is an integer.

  Here is another function, with more complicated arguments.  This
comes from the code for the X window system, and it demonstrates the
use of macros and functions to manipulate Lisp objects.

     DEFUN ("coordinates-in-window-p", Fcoordinates_in_window_p,
       Scoordinates_in_window_p, 2, 2,
       "xSpecify coordinate pair: \nXExpression which evals to window: ",
       "Return non-nil if POSITIONS (a list, (SCREEN-X SCREEN-Y)) is in WINDOW.\n\  
       Returned value is list of positions expressed\n\
       relative to window upper left corner.")
       (coordinate, window)
          register Lisp_Object coordinate, window;
     {
       register Lisp_Object xcoord, ycoord;
     
       if (!CONSP (coordinate)) wrong_type_argument (Qlistp, coordinate);
       CHECK_WINDOW (window, 2);
       xcoord = Fcar (coordinate);
       ycoord = Fcar (Fcdr (coordinate));
       CHECK_NUMBER (xcoord, 0);
       CHECK_NUMBER (ycoord, 1);
       if ((XINT (xcoord) < XINT (XWINDOW (window)->left))
           || (XINT (xcoord) >= (XINT (XWINDOW (window)->left)
                                 + XINT (XWINDOW (window)->width))))
         {
           return Qnil;
         }
       XFASTINT (xcoord) -= XFASTINT (XWINDOW (window)->left);
       if (XINT (ycoord) == (screen_height - 1))
         return Qnil;
       if ((XINT (ycoord) < XINT (XWINDOW (window)->top))
           || (XINT (ycoord) >= (XINT (XWINDOW (window)->top)
                                 + XINT (XWINDOW (window)->height)) - 1))
         {
           return Qnil;
         }
       XFASTINT (ycoord) -= XFASTINT (XWINDOW (window)->top);
       return (Fcons (xcoord, Fcons (ycoord, Qnil)));
     }

  Note that you cannot directly call functions defined in Lisp as, for
example, the primitive function `Fcons' is called above.  You must
create the appropriate Lisp form, protect everything from garbage
collection, and `Feval' the form, as was done in `For' above.

  `eval.c' is a very good file to look through for examples; `lisp.h'
contains the definitions for some important macros and functions.



File: lispref,  Node: Object Internals,  Prev: Writing Emacs Primitives,  Up: GNU Emacs Internals

Object Internals
================

  GNU Emacs Lisp manipulates many different types of data.  The actual
data is stored in a heap and the only access that programs have to
the data is through pointers.  Pointers are thirty-two bits wide in
most implementations.  Depending on the operating system and type of
machine for which you compile Emacs, twenty-four to twenty-six bits
are used to indicate the object, and the remaining six to eight bits
are used for a tag that identifies the object's type.

  Because all access to data is through tagged pointers, it is always
possible to determine the type of any object.  This allows variables
to be untyped, and the values assigned to them to be changed without
regard to type.  Function arguments also can be of any type; if you
want a function to accept only a certain type of argument, you must
check the type explicitly using a suitable predicate (*note Type
Predicates::.).

* Menu:

* Buffer Internals::    Components of a buffer structure.
* Window Internals::    Components of a window structure.
* Process Internals::   Components of a process structure.

   Emacs has more than twenty types of tags; here is the list, from
`emacs/src/lisp.h': integer, symbol, marker, string, vector of Lisp
objects, cons, byte-compiled function, editor buffer, built-in
function, internal value return by subroutines of read, forwarding
pointer to an int variable, boolean forwarding pointer to an int
variable, object describing a connection to a subprocess, forwarding
pointer to a Lisp_Object variable, Pointer to a vector-like object
describing a display screen, Lisp_Internal_Stream,
Lisp_Buffer_Local_Value, Lisp_Some_Buffer_Local_Value,
Lisp_Buffer_Objfwd, Lisp_Void, Window used for Emacs display,
Lisp_Window_Configuration.



File: lispref,  Node: Buffer Internals,  Next: Window Internals,  Prev: Object Internals,  Up: Object Internals

Buffer Internals
----------------

  Buffers contain fields which are not directly accessible by the Lisp
programmer.  We describe them here, naming them by the names used in
the C code.  Often they are accessible indirectly in Lisp programs
via one or more Lisp primitives.

`name'
     The buffer name is a string which names the buffer.  It is
     guaranteed to be unique.  *Note Buffer Names::.

`save_modified'
     This field contains the time when the buffer was last saved, as
     an integer.  *Note Buffer Modification::.

`modtime'
     This field contains the modification time of the visited file. 
     It is set when the file is written or read.  Every time the
     buffer is written to the file, this field is compared to the
     modification of the file.  *Note Buffer Modification::.

`auto_save_modified'
     This field contains the time when the buffer was last auto-saved.

`last_window_start'
     This field contains the position in the buffer at which the
     display started the last time the buffer was displayed in a
     window.

`undodata'
     This field contains records which tell Emacs how it can undo the
     last set of changes to the buffer.  *Note Undo::.

`syntax_table_v'
     This field contains the syntax table for the buffer.  *Note
     Syntax Tables::.

`markers'
     This field contains the chain of all markers that point into the
     buffer.  At each deletion or motion of the buffer gap, all of
     these markers must be checked and perhaps updated.  *Note
     Markers::.

`backed_up'
     This field is a flag which tells whether a backup file has been
     made for the visited file of this buffer.

`mark'
     This field contains the mark for the buffer.  The mark is a
     marker, hence it is also included on the list `markers'.

`local_var_alist'
     This field contains the association list containing all of the
     local fields and their associated values.  A copy of this list
     is returned by the function `buffer-local-variables'.

`mode_line_format'
     This field contains a Lisp object which controls how to display
     the mode line for this buffer.  *Note Mode Line Format::.



File: lispref,  Node: Window Internals,  Next: Process Internals,  Prev: Buffer Internals,  Up: Object Internals

Window Internals
----------------

  Windows have the following accessible fields:

`height'
       The height of the window, measured in lines.  All windows
     (except for the minibuffer window) have a minimum height of two
     lines, one of which is the mode line.

`width'
       The width of the window, measured in columns.

`buffer'
       The buffer which the window is displaying.  This may change
     often during the life of the window.

`start'
      The position in the buffer which is the first character to be
     displayed in the buffer.  This is always located in the upper
     left corner (location `(0,0)').  There is no restriction on
     which character in a buffer this is, although it is common for
     it to be the first character on a line.

`pointm'
       This is the value of point in the current buffer when this
     window is selected; when it is not selected, it retains its
     previous value.  When reselected, this once again becomes point
     for the current buffer (assuming that the buffer associated with
     the window has not changed).

       This allows Emacs to maintain different points in different
     windows, even when they display the same buffer.  (This variable
     is only useful when there are multiple windows displaying the
     same buffer.)

`left'
       This is the left-hand edge of the window, measured in columns. 
     (The leftmost column on the screen is column 0.)

`top'
       This is the top edge of the window, measured in lines.  (The top
     line on the screen is line 0.)

`next'
       This is the window that is the next in the chain of siblings.

`prev'
       This is the window that is the previous in the chain of siblings.

`force-start'
       This says that the window has been scrolled explicitly by the
     Lisp program.  At the next redisplay, if point is off the
     screen, instead of scrolling the window to show the text around
     point, point will be moved to a location that is on the screen.

`hscroll'
       This is the number of columns that the display in the window is
     scrolled horizontally to the left.  Normally, this is 0.

`use-time'
       This is the last time that the window was selected.  This field
     is used by `get-lru-window'.



File: lispref,  Node: Process Internals,  Prev: Window Internals,  Up: Object Internals

Process Internals
-----------------

  The fields of a process are:

`name'
     A string: the name used when creating the process, or a variant
     of it.  The name is normally created from the name of the
     program which it is running.

`command'
     A list: the command arguments that were used to start this
     process.

`filter'
     A function (or a symbol which names it): used to accept output
     from the process instead of a buffer.

`sentinel'
     A function: called whenever the process receives a signal.

`buffer'
     A buffer: where process output is directed, if no filter is
     specified.

`pid'
     An integer: the Unix process ID.

`command_channel_p'
     A flag: non-`nil' if this is really a command channel instead of
     a process.  (This is not really used.)

`childp'
     A flag: non-`nil' if this is really a child process.  It is
     `nil' for a network connection.

`flags'
     A symbol: the state of the process.  Possible values include
     `run', `stop', `closed', etc.

`reason'
     A integer: the Unix signal that the process received that caused
     the process to stop (The process is not necessarily dead).  If
     the process has died, and was not killed by a signal, then this
     is the code the process exited with.

`mark'
     A marker: set to end of last output from this process inserted
     into the buffer.  Normally, this will be the end of the buffer.

`kill_without_query'
     A flag: non-`nil' means kill this process silently if Emacs is
     exited.



File: lispref,  Node: Standard Errors,  Next: Standard Buffer Local Variables,  Prev: GNU Emacs Internals,  Up: Top

Standard Errors
***************

  Here is the complete list of the error symbols in standard Emacs,
grouped by concept.  The list includes each symbol's message (on the
`error-message' property of the symbol), and a cross reference to a
description of how the error can occur.

  Each error symbol has an `error-conditions' property which is a list
of symbols.  Normally, this list includes the error symbol itself,
and the symbol `error'.  Occasionally it includes additional symbols,
which are intermediate classifications, narrower than `error' but
broader than a single error symbol.  For example, all the errors in
accessing files have the condition `file-error'.

  As a special exception, the error symbol `quit' does not have the
condition `error', because quitting is not considered a true error.

  *Note Errors::, for an explanation of how errors are generated and
handled.

`SYMBOL'
     STRING; REFERENCE.

`error'
     `"error"'; see `error' in *Note Errors::.

`quit'
     `"Quit"'; see *Note Quitting::.

`args-out-of-range'
     `"Args out of range"'; see *Note Sequences Arrays Vectors::.

`arith-error'
     `"Arithmetic error"'; see `/' and `%' in *Note Numbers::.

`beginning-of-buffer'
     `"Beginning of buffer"'; see *Note Buffer Contents::.

`buffer-read-only'
     `"Buffer is read-only"'; see *Note Read Only Buffers::.

`end-of-buffer'
     `"End of buffer"'; see *Note Buffer Contents::.

`end-of-file'
     `"End of file during parsing"'; see *Note Input Functions::. 
     This is not a `file-error'.

`file-error'
     *Note Files::.  This error, and its subcategories, do not have
     error-strings, because the error message is constructed from the
     data items alone when the error condition `file-error' is present.

`file-locked'
     *Note File Locks::.  This is a `file-error'.

`file-already-exists'
     *Note Writing to Files::.  This is a `file-error'.

`file-supersession'
     *Note Buffer Modification::.  This is a `file-error'.

`invalid-function'
     `"Invalid function"'; see *Note Nonempty List Forms::.

`invalid-read-syntax'
     `"Invalid read syntax"'; see *Note Input Functions::.

`invalid-regexp'
     `"Invalid regexp"'; see *Note Regular Expressions::.

`no-catch'
     `"No catch for tag"'; see *Note Catch and Throw::.

`search-failed'
     `"Search failed"'; see *Note Searching and Matching::.

`setting-constant'
     `"Attempt to set a constant symbol"'; the values of the symbols
     `nil' and `t' may not be changed.

`void-function'
     `"Symbol's function definition is void"'; see *Note Function
     Cells::.

`void-variable'
     `"Symbol's value as variable is void"'; see *Note Accessing
     Variables::.

`wrong-number-of-arguments'
     `"Wrong number of arguments"'; see *Note Nonempty List Forms::.

`wrong-type-argument'
     `"Wrong type argument"'; see *Note Type Predicates::.



File: lispref,  Node: Standard Buffer Local Variables,  Next: Standard Keymaps,  Prev: Standard Errors,  Up: Top

Standard Buffer Local Variables
*******************************

  The table below shows all of the variables that are automatically
local (when set) in each buffer in Emacs Version 18 with the common
packages loaded.

`fill-column'
     *Note Auto Filling::.

`truncate-lines'
     *Note Truncation::.

`ctl-arrow'
     *Note Control Char Display::.

`selective-display'
     *Note Selective Display::.

`selective-display-ellipses'
     *Note Selective Display::.

`minor-modes'
     *Note Minor Modes::.

`overwrite-mode'
     *Note Insertion::.

`abbrev-mode'
     *Note Abbreviations::.

`tab-width'
     *Note Indent Tabs::.

`auto-fill-hook'
     *Note Auto Filling::; (in version 19, `auto-fill-hook' has been
     renamed `auto-fill-function').

`case-fold-search'
     *Note Searching and Case::.

`left-margin'
     *Note Indentation::.

`local-abbrev-table'
     *Note Abbreviations::.

`mode-name'
     *Note Mode Line Variables::.

`major-mode'
     *Note Mode Help::.

`buffer-read-only'
     *Note Read Only Buffers::.

`buffer-auto-save-file-name'
     *Note Auto Saving::.

`buffer-saved-size'
     *Note Buffer Contents::.

`buffer-backed-up'
     *Note Backup Files::.

`default-directory'
     *Note System Environment::.

`buffer-file-name'
     *Note Buffer File Name::.

`mark-ring'
     *Note The Mark::.

`paragraph-start'
     *Note Standard Regexps::.

`paragraph-separate'
     *Note Standard Regexps::.

`require-final-newline'
     *Note Insertion::.



File: lispref,  Node: Standard Keymaps,  Next: Standard Hooks,  Prev: Standard Buffer Local Variables,  Up: Top

Standard Keymaps
****************

The following symbols are used as the names for various keymaps. 
Some of these exist when Emacs is first started, others are only
loaded when their respective mode is used.  This is not an exhaustive
list.

Almost all of these maps are used as local maps.  Indeed, of the
modes that presently exist, only Vip mode and Terminal mode ever
change the global keymap.

`Helper-help-map'
     A full keymap used by the help utility package.
       It has the same keymap in its value cell and in its function
     cell.

`Buffer-menu-mode-map'
     A full keymap used by Buffer mode.

`Info-edit-map'
     A sparse keymap used by the `e' command of Info.

`Info-mode-map'
     A sparse keymap containing Info commands.

`c-mode-map'
     A sparse keymap used in C mode as a local map.

`ctl-x-4-map'
     A sparse keymap for subcommands of the prefix `C-x 4'.

`ctl-x-map'
     A full keymap for `C-x' commands.

`dired-mode-map'
     A full keymap for `dired-mode' buffers.

`edit-abbrevs-map'
     A sparse keymap used in `edit-abbrevs'.

`edit-tab-stops-map'
     A sparse keymap used in `edit-tab-stops'.

`emacs-lisp-mode-map'
     A sparse keymap used in Emacs Lisp mode.

`lisp-mode-map'
     A sparse keymap used in Lisp mode.

`lisp-interaction-mode-map'
     A sparse keymap used in Lisp mode.

`function-keymap'
     The keymap for the definitions of keypad and function keys.
       If there are none, then it contains an empty sparse keymap.

`mouse-map'
     A sparse keymap for mouse commands from the X window system.

`occur-mode-map'
     A local keymap used in Occur mode.

`text-mode-map'
     A sparse keymap used by Text mode.

`view-mode-map'
     A full keymap used by View mode.

`debugger-mode-map'
     A full keymap used by Debugger mode.

`command-history-map'
     A full keymap used by Command History mode.

`doctor-mode-map'
     A sparse keymap used by Doctor mode.

`electric-buffer-menu-mode-map'
     A full keymap used by Electric Buffer Menu mode.

`electric-history-map'
     A full keymap used by Electric Command History mode.

`fundamental-mode-map'
     The local keymap for Fundamental mode.
       It is empty unless changed by the user.

`mode-specific-map'
     The keymap for characters following `C-c'.  Note, this is in the
     global map.  This map is not actually mode specific: its name
     was chosen to be informative for the user in `C-h b'
     (`display-bindings'), where it describes the main use of the
     `C-c' prefix key.



File: lispref,  Node: Standard Hooks,  Next: Index,  Prev: Standard Keymaps,  Up: Top

Standard Hooks
**************

The following is a list of hooks available with the distributed 18.52
version of GNU Emacs.  Some of these hooks are called with
`run-hooks' and can be a list of functions.  Others are not called
with `run-hooks' and may or may not allow a list of functions.  For
example, the `suspend-hook' can only reference a single function. 
*Note Hooks::, for more info on using hooks.

     Note: In version 19, `blink-paren-hook' and `auto-fill-hook' are
     renamed to `blink-paren-function' and `auto-fill-function'
     respectively, since they are not called by the `run-hooks'
     function.

`auto-fill-hook'
`blink-paren-hook'
`c-mode-hook'
`command-history-hook'
`comment-indent-hook'
`define-hooked-global-abbrev'
`define-hooked-local-abbrev'
`dired-mode-hook'
`disabled-command-hook'
`edit-picture-hook'
`edit-picture-hook'
`electric-buffer-menu-mode-hook'
`electric-command-history-hook'
`electric-help-mode-hook'
`emacs-lisp-mode-hook'
`find-file-hooks'
`find-file-not-found-hooks'
`fortran-comment-hook'
`fortran-mode-hook'
`ftp-setup-write-file-hooks'
`ftp-write-file-hook'
`indent-mim-hook'
`LaTeX-mode-hook'
`ledit-mode-hook'
`lisp-indent-hook'
`lisp-interaction-mode-hook'
`lisp-mode-hook'
`m2-mode-hook'
`mail-mode-hook'
`mail-setup-hook'
`medit-mode-hook'
`mh-compose-letter-hook'
`mh-folder-mode-hook'
`mh-letter-mode-hook'
`mim-mode-hook'
`news-mode-hook'
`news-reply-mode-hook'
`news-setup-hook'
`nroff-mode-hook'
`outline-mode-hook'
`plain-TeX-mode-hook'
`prolog-mode-hook'
`protect-innocence-hook'
`rmail-edit-mode-hook'
`rmail-mode-hook'
`rmail-summary-mode-hook'
`scheme-indent-hook'
`scheme-mode-hook'
`scribe-mode-hook'
`shell-mode-hook'
`shell-set-directory-error-hook'
`suspend-hook'
`suspend-resume-hook'
`temp-buffer-show-hook'
`term-setup-hook'
`terminal-mode-hook'
`terminal-mode-break-hook'
`TeX-mode-hook'
`text-mode-hook'
`vi-mode-hook'
`view-hook'
`write-file-hooks'
`x-process-mouse-hook'


File: lispref,  Node: Index,  Prev: Standard Hooks,  Up: Top

Index
*****

* Menu:

* %: Arithmetic Operations.
* &optional: Argument List.
* &rest: Argument List.
* *: Arithmetic Operations.
* *scratch*: Auto Major Mode.
* *scratch*: The Buffer List.
* +: Arithmetic Operations.
* ,: Backquote.
* -: Arithmetic Operations.
* .emacs: Start-up Summary.
* .emacs: Disabling Commands.
* .emacs key bindings: Changing Key Bindings.
* .emacs load-path: How Programs Do Loading.
* /: Arithmetic Operations.
* /=: Comparison of Numbers.
* 1+: Arithmetic Operations.
* 1-: Arithmetic Operations.
* <: Comparison of Numbers.
* <=: Comparison of Numbers.
* =: Comparison of Numbers.
* >: Comparison of Numbers.
* >=: Comparison of Numbers.
* `args-out-of-range' error: Text.
* `commandp' example: High-level Completion.
* `define-key' in sparse keymaps: Creating Keymaps.
* `ignore' in keymap: Key Lookup.
* `interactive', examples of using: Interactive Examples.
* `invalid-regexp' error: Syntax of Regexps.
* `isearch-forward' quitting: Quitting.
* `lambda' in keymap: Key Lookup.
* `mode-class' property: Major Mode Conventions.
* `nil' input stream: Input Streams.
* `nil' output stream: Output Streams.
* `quote-insert' suppression: Changing Key Bindings.
* `search-failed' error: Regexp Search.
* `self-insert-command' override: Changing Key Bindings.
* `self-insert-command', and minor modes: Limits of Minor Modes.
* `special': Major Mode Conventions.
* `suspend-emacs', related to `no-redraw-on-reenter': Screen Attributes.
* `throw' example: Recursive Editing.
* `t' input stream: Input Streams.
* `t' output stream: Output Streams.
* `undefined' in keymap: Key Lookup.
* `user-variable-p' example: High-level Completion.
* `.emacs': Init File.
* `emacs/etc/DOC-VERSION': Documentation Basics.
* `etc/DOC-VERSION': Documentation Basics.
* `?' in minibuffer: Text from Minibuffer.
* `C-c': Prefix Keys.
* `C-g': Quitting.
* `C-h': Prefix Keys.
* `C-q': Flow Control.
* `C-s': Flow Control.
* `C-x 4': Prefix Keys.
* `C-x': Prefix Keys.
* `M-x': Interactive Call.
* ESC: Key Lookup.
* ESC: Prefix Keys.
* SPC in minibuffer: Text from Minibuffer.
* TAB in minibuffer: Text from Minibuffer.
* `"' in print: Output Functions.
* `"' in strings: String Type.
* `$' in display: Truncation.
* `$' in regexp: Syntax of Regexps.
* `%' in format: Formatting Strings.
* `&' in replacement: Match Data.
* `'' in regexp: Syntax of Regexps.
* `(...)' in lists: List Type.
* `(' in regexp: Syntax of Regexps.
* `)' in regexp: Syntax of Regexps.
* `*' in interactive: Using Interactive.
* `*' in regexp: Syntax of Regexps.
* `+' in regexp: Syntax of Regexps.
* `.emacs' customization: Major Mode Conventions.
* `.' in lists: Dotted Pair Notation.
* `.' in regexp: Syntax of Regexps.
* `;' comment: Comments.
* `?' in characters: Character Type.
* `?' in regexp: Syntax of Regexps.
* `[' in regexp: Syntax of Regexps.
* `\<' in regexp: Syntax of Regexps.
* `\>' in regexp: Syntax of Regexps.
* `\N' in replacement: Match Data.
* `\B' in regexp: Syntax of Regexps.
* `\S' in regexp: Syntax of Regexps.
* `\W' in regexp: Syntax of Regexps.
* `\b': Character Type.
* `\b' in regexp: Syntax of Regexps.
* `\e': Character Type.
* `\f': Character Type.
* `\n': Character Type.
* `\n' in print: Output Functions.
* `\r': Character Type.
* `\s' in regexp: Syntax of Regexps.
* `\t': Character Type.
* `\v': Character Type.
* `\w' in regexp: Syntax of Regexps.
* `\' in characters: Character Type.
* `\' in display: Truncation.
* `\' in print: Output Functions.
* `\' in regexp: Syntax of Regexps.
* `\' in replacement: Match Data.
* `\' in strings: String Type.
* `\' in symbols: Symbol Type.
* `]' in regexp: Syntax of Regexps.
* `^' in regexp: Syntax of Regexps.
* `^' in regexp: Syntax of Regexps.
* ``' in regexp: Syntax of Regexps.
* `|' in regexp: Syntax of Regexps.
* character quote: Syntax Classes.
* close-parenthesis characters: Syntax Classes.
* comment ender: Syntax Classes.
* comment starter: Syntax Classes.
* escape: Syntax Classes.
* expression prefix: Syntax Classes.
* open-parenthesis characters: Syntax Classes.
* paired delimiter: Syntax Classes.
* punctuation characters: Syntax Classes.
* string quote: Syntax Classes.
* symbol constituents: Syntax Classes.
* whitespace characters: Syntax Classes.
* word constituents: Syntax Classes.
* ASCII character: Character Type.
* Auto Fill mode: Auto Filling.
* Buffer-menu-mode-map: Standard Keymaps.
* CBREAK: Flow Control.
* Common Lisp: Lisp History.
* Control-X-prefix: Prefix Keys.
* EMACSLOADPATH: How Programs Do Loading.
* ESC-prefix: Prefix Keys.
* Emacs character standard notation: Accessing Documentation.
* Fundamental mode: Major Modes.
* HOME: Subprocess Creation.
* Helper-describe-bindings: Help Functions.
* Helper-help: Help Functions.
* Helper-help-map: Standard Keymaps.
* Info-edit-map: Standard Keymaps.
* Info-mode-map: Standard Keymaps.
* Lisp debugger: Debugger.
* Lisp expressions: List Motion.
* Lisp history: Lisp History.
* Lisp interpreter: Evaluation.
* Lisp library: Loading Libraries.
* Lisp nesting error: Eval.
* Lisp object: Types of Lisp Object.
* Lisp printer: Output Functions.
* Lisp printer: Printed Representation.
* Lisp reader: Streams Intro.
* Lisp reader: Printed Representation.
* Lisp reader: Loading.
* Lisp symbol completion: Lisp Symbol Completion.
* MacLisp: Lisp History.
* New File message: Subroutines of Visiting.
* No Match error: Interactive Codes.
* Outline mode: Replacement.
* PATH: Subprocess Creation.
* Shell mode `mode-line-format': Mode Line Data.
* Snarf-documentation: Accessing Documentation.
* TERM: Terminal-specific.
* Unix: System Environment.
* VMS: System Environment.
* X Window System: Basic Windows.
* X window system: Window Systems.
* `: Backquote.
* abbrev: Abbreviations.
* abbrev table: Abbreviations.
* abbrev-all-caps: Abbrev Expansion.
* abbrev-expansion: Abbrev Expansion.
* abbrev-file-name: Abbrev Files.
* abbrev-mode: Abbrev Mode.
* abbrev-start-location: Abbrev Expansion.
* abbrev-start-location-buffer: Abbrev Expansion.
* abbrev-symbol: Abbrev Expansion.
* abbrev-table-name-list: Abbrev Tables.
* abbrevs-changed: Abbrev Files.
* abort-recursive-edit: Recursive Editing.
* aborting: Recursive Editing.
* absolute file name: Relative File Names.
* accept-process-output: Waiting for Output.
* accessible-keymaps: Global and Local Keymaps.
* add-abbrev: Defining Abbrevs.
* add-name-to-file: Changing File Attributes.
* address register: List Type.
* after-find-file: Subroutines of Visiting.
* alist: Association Lists.
* all-completions: Basic Completion.
* and: Combining Conditions.
* anonymous function: Anonymous Functions.
* apostrophe for quote: Quoting.
* append: Building Lists.
* append-to-file: Writing to Files.
* append-to-register: Registers.
* apply: Calling Functions.
* apply, and debugging: Invoking the Debugger.
* apropos: Help Functions.
* aref: Array Functions.
* args-out-of-range error: Creating Strings.
* args-out-of-range error: Buffer Contents.
* argument descriptors: Using Interactive.
* argument evaluation form: Using Interactive.
* argument prompt: Using Interactive.
* argument prompt: Interactive Codes.
* arguments, reading: Minibuffers.
* arith-error example: Handling Errors.
* arith-error in division: Arithmetic Operations.
* arithmetic shift: Bitwise Operations.
* array: Arrays.
* array elements: Array Functions.
* arrayp: Array Functions.
* aset: Array Functions.
* ash: Bitwise Operations.
* ask-user-about-lock: File Locks.
* ask-user-about-supersession-threat: Modification Time.
* assoc: Association Lists.
* association list: Association Lists.
* assq: Association Lists.
* asynchronous subprocess: Asynchronous Processes.
* atom: List Type.
* atom: List-related Predicates.
* atoms: List-related Predicates.
* auto saving: Auto Saving.
* auto-fill-hook: Auto Filling.
* auto-mode-alist: Auto Major Mode.
* auto-save error: Reverting.
* auto-save-default: Auto Saving.
* auto-save-file-name-p: Auto Saving.
* auto-save-interval: Auto Saving.
* auto-save-mode: Auto Saving.
* auto-save-visited-file-name: Auto Saving.
* autoload: Autoload.
* autoload: Autoload.
* autoload errors: Autoload.
* automatically buffer local: Buffer Local Variables.
* back-to-indentation: Indentation.
* backquote (list substitution): Backquote.
* backslash in characters: Character Type.
* backslash in strings: String Type.
* backslash in symbols: Symbol Type.
* backspace: Character Type.
* backtrace: Invoking the Debugger.
* backtrace-debug: Invoking the Debugger.
* backup file: Backup Files.
* backup files, how to make them: Rename or Copy.
* backup-buffer: Making Backups.
* backup-by-copying: Rename or Copy.
* backup-by-copying-when-linked: Rename or Copy.
* backup-by-copying-when-mismatch: Rename or Copy.
* backup-file-name-p: Backup Names.
* backward-char: Character Motion.
* backward-delete-char-untabify: Deletion.
* backward-list: List Motion.
* backward-prefix-chars: Syntax Table Functions.
* backward-sexp: List Motion.
* backward-to-indentation: Indentation.
* backward-word: Character Motion.
* balancing: Blinking.
* barf-if-buffer-read-only: Read Only Buffers.
* batch mode: Batch Mode.
* batch-byte-compile: Compilation Functions.
* baud-rate: Terminal Output.
* beep: Beeping.
* beeping: Beeping.
* beginning of line: Lines.
* beginning of line: Syntax of Regexps.
* beginning-of-buffer: Character Motion.
* beginning-of-buffer error: Character Motion.
* beginning-of-line: Lines.
* bell: Beeping.
* binding arguments: Local Variables.
* binding arguments: Argument List.
* binding local variables: Local Variables.
* binding of a key: Keymap Terms.
* bitwise and: Bitwise Operations.
* bitwise exclusive or: Bitwise Operations.
* bitwise not: Bitwise Operations.
* bitwise operations: Bitwise Operations.
* bitwise or: Bitwise Operations.
* blink-matching-open: Blinking.
* blink-matching-paren: Blinking.
* blink-paren-function: Blinking.
* blink-paren-hook: Blinking.
* blinking: Blinking.
* bobp: Point.
* body of function: Lambda Components.
* bolp: Point.
* boolean: nil and t.
* boundp: Void Variables.
* box diagrams, for lists: List Type.
* box representation for lists: Lists as Boxes.
* break: Debugger.
* bucket (in obarray): Creating Symbols.
* buffer: Buffers.
* buffer contents: Buffer Contents.
* buffer contents: Text.
* buffer disable undo: Undo.
* buffer file name: Buffer File Name.
* buffer input stream: Input Streams.
* buffer internals: Buffer Internals.
* buffer list: The Buffer List.
* buffer modification: Buffer Modification.
* buffer name error: Buffer Names.
* buffer names: Buffer Names.
* buffer output stream: Output Streams.
* buffer text notation: Buffer Text Notation.
* buffer, read-only: Read Only Buffers.
* buffer-auto-save-file-name: Auto Saving.
* buffer-backed-up: Making Backups.
* buffer-enable-undo: Undo.
* buffer-end: Buffer Contents.
* buffer-file-name: Buffer File Name.
* buffer-file-name: Buffer File Name.
* buffer-flush-undo: Undo.
* buffer-list: The Buffer List.
* buffer-local variables: Buffer Local Variables.
* buffer-local variables in modes: Major Mode Conventions.
* buffer-local-variables: Buffer Local Variables.
* buffer-modified-p: Buffer Modification.
* buffer-name: Buffer Names.
* buffer-offer-save: Saving Buffers.
* buffer-read-only: Read Only Buffers.
* buffer-read-only error: Read Only Buffers.
* buffer-read-only error: Deletion.
* buffer-read-only error: Using Interactive.
* buffer-saved-size: Buffer Contents.
* buffer-size: Buffer Contents.
* buffer-string: Buffer Contents.
* buffer-substring: Buffer Contents.
* bufferp: Buffer Basics.
* buffers, controlled in windows: Buffers and Windows.
* buffers, creating: Creating Buffers.
* buffers, killing: Killing Buffers.
* building Emacs: Building Emacs.
* building lists: Building Lists.
* built-in: Function Cells.
* built-in function: What Is a Function.
* bury-buffer: The Buffer List.
* byte code: Byte Compilation.
* byte compiling require: Features.
* byte-code: Compilation Functions.
* byte-code interpreter: Compilation Functions.
* byte-compile: Compilation Functions.
* byte-compile-file: Compilation Functions.
* byte-compiling macros: Compiling Macros.
* byte-recompile-directory: Compilation Functions.
* bytes: Strings and Characters.
* c-mode-abbrev-table: Standard Abbrev Tables.
* c-mode-map: Standard Keymaps.
* c-mode-syntax-table: Standard Syntax Tables.
* call stack: Invoking the Debugger.
* call-interactively: Interactive Call.
* call-process: Synchronous Processes.
* call-process-region: Synchronous Processes.
* calling a function: Calling Functions.
* cancel-debug-on-entry: Function Debugging.
* capitalization: Character Case.
* capitalize: Character Case.
* capitalize-region: Case Changes.
* capitalize-word: Case Changes.
* car: List Elements.
* car-safe: List Elements.
* case changes: Case Changes.
* case in replacements: Match Data.
* case-fold-search: Searching and Case.
* case-replace: Searching and Case.
* catch: Catch and Throw.
* cdr: List Elements.
* cdr-safe: List Elements.
* centering point: Vertical Scrolling.
* changing key bindings: Changing Key Bindings.
* changing to another buffer: Changing Buffers.
* char-after: Point.
* char-equal: Text Comparison.
* char-or-string-p: Predicates for Strings.
* char-syntax: Syntax Table Functions.
* char-to-string: String Conversion.
* character: Character Type.
* character arrays: Strings and Characters.
* character case: Character Case.
* character insertion: Insertion.
* character printing: Accessing Documentation.
* character set (in regexp): Syntax of Regexps.
* character to string: Formatting Strings.
* character to string: String Conversion.
* character width: Columns.
* characters: Strings and Characters.
* characters for interactive codes: Interactive Codes.
* child process: Processes.
* cleanup forms: Cleanups.
* clear-abbrev-table: Abbrev Tables.
* clear-visited-file-modtime: Modification Time.
* clipping restriction: Clipping Restrictions.
* close parenthesis: Blinking.
* code character description: Interactive Codes.
* codes, interactive description: Interactive Codes.
* command: What Is a Function.
* command descriptions: A Sample Function Description.
* command history: Command History.
* command line arguments: Command Line Arguments.
* command line options: Command Line Arguments.
* command loop: Command Loop.
* command loop, recursive: Recursive Editing.
* command-execute: Interactive Call.
* command-history: Command History.
* command-history-map: Standard Keymaps.
* command-line: Command Line Arguments.
* command-line-args: Command Line Arguments.
* command-line-processed: Command Line Arguments.
* command-switch-alist: Command Line Arguments.
* commandp: Interactive Call.
* commands, defining: Defining Commands.
* comment syntax: Syntax Classes.
* comments: Comments.
* comparison of modification time: Modification Time.
* compilation: Byte Compilation.
* compilation functions: Compilation Functions.
* complete key: Keymap Terms.
* complete sexp: Lisp Expressions.
* completing-read: Completion Reading.
* completion: Completion.
* completion, filename: Filename Completion.
* completion, lisp symbol: Lisp Symbol Completion.
* completion-auto-help: Help Functions.
* completion-ignore-case: Completion Reading.
* completion-ignored-extensions: Filename Completion.
* complex arguments: Minibuffers.
* complex command: Command History.
* concat: Creating Strings.
* concatenating lists: Rearrangement.
* concatenation: Creating Strings.
* cond: Conditionals.
* condition name: Error Names.
* condition-case: Handling Errors.
* conditional evaluation: Conditionals.
* cons: Building Lists.
* cons cell: List-related Predicates.
* cons cell: Lists.
* cons cell as box: Lists as Boxes.
* cons cells: Building Lists.
* consp: List-related Predicates.
* continuation lines: Truncation.
* continue-process: Signals to Processes.
* control character keys: Changing Key Bindings.
* control character printing: Accessing Documentation.
* control characters: Global and Local Keymaps.
* control characters: Character Type.
* control characters in display: Control Char Display.
* control characters, reading: Keyboard Input.
* control structures: Control Structures.
* conventions for writing minor mode: Minor Mode Conventions.
* conversion: String Conversion.
* copy-alist: Association Lists.
* copy-file: Changing File Attributes.
* copy-keymap: Creating Keymaps.
* copy-marker: Creating Markers.
* copy-rectangle-to-register: Registers.
* copy-region-as-kill: Kill Functions.
* copy-sequence: Sequence Functions.
* copy-syntax-table: Syntax Table Functions.
* copy-to-buffer: Insertion.
* copy-to-register: Registers.
* copying files in file system: Changing File Attributes.
* copying lists: Association Lists.
* copying lists: Building Lists.
* copying sequences: Vectors.
* copying sequences: Sequence Functions.
* copying sequences: Creating Strings.
* copying sequences: Building Lists.
* copying strings: Creating Strings.
* copying vectors: Vectors.
* count-lines: Lines.
* cp: Changing File Attributes.
* create-file-buffer: Subroutines of Visiting.
* creating buffers: Creating Buffers.
* creating keymaps: Creating Keymaps.
* ctl-arrow: Control Char Display.
* ctl-arrow: Columns.
* ctl-x-4-map: Standard Keymaps.
* ctl-x-4-map: Prefix Keys.
* ctl-x-map: Prefix Keys.
* ctl-x-map: Standard Keymaps.
* current binding: Local Variables.
* current buffer: Buffers.
* current buffer excursion: Excursions.
* current buffer mark: The Mark.
* current buffer position: Point.
* current command: Command Loop Info.
* current stack frame: Using Debugger.
* current-buffer: Buffer Basics.
* current-column: Columns.
* current-global-map: Global and Local Keymaps.
* current-indentation: Indentation.
* current-local-map: Global and Local Keymaps.
* current-prefix-arg: Prefix Command Arguments.
* current-time-string: System Environment.
* current-window-configuration: Window Configurations.
* cursor-in-echo-area: The Echo Area.
* cyclic ordering of windows: Cyclic Window Ordering.
* data type: Types of Lisp Object.
* debug: Invoking the Debugger.
* debug-on-entry: Function Debugging.
* debug-on-error: Error Debugging.
* debug-on-error use: Processing of Errors.
* debug-on-next-call: Invoking the Debugger.
* debug-on-quit: Error Debugging.
* debugger: Processing of Errors.
* debugger: Invoking the Debugger.
* debugger: Debugger.
* debugger-mode-map: Standard Keymaps.
* decrement register: List Type.
* default argument string: Interactive Codes.
* default init file: Init File.
* default value: Default Value.
* default-abbrev-mode: Abbrev Mode.
* default-case-fold-search: Searching and Case.
* default-ctl-arrow: Control Char Display.
* default-directory: File Name Expansion.
* default-directory: Subprocess Creation.
* default-fill-column: Auto Filling.
* default-major-mode: Auto Major Mode.
* default-mode-line-format: %-constructs.
* default-subprocess-input-handler: VMS Subprocesses.
* default-truncate-lines: Truncation.
* default-value: Default Value.
* default.el: Start-up Summary.
* defconst: Defining Variables.
* define-abbrev: Defining Abbrevs.
* define-abbrev-table: Abbrev Tables.
* define-key: Changing Key Bindings.
* define-prefix-command: Prefix Keys.
* defining a function: Defining Functions.
* defining commands: Defining Commands.
* defining-kbd-macro: Keyboard Macros.
* definition of a symbol: Definitions.
* defmacro: Defining Macros.
* defun: Defining Functions.
* defvar: Defining Variables.
* delete previous char: Deletion.
* delete whitespace: Deletion.
* delete whitespace: Deletion.
* delete-auto-save-file-if-necessary: Auto Saving.
* delete-auto-save-files: Auto Saving.
* delete-backward-char: Deletion.
* delete-blank-lines: Deletion.
* delete-char: Deletion.
* delete-exited-processes: Deleting Processes.
* delete-file: Changing File Attributes.
* delete-horizontal-space: Deletion.
* delete-indentation: Deletion.
* delete-other-windows: Deleting Windows.
* delete-process: Deleting Processes.
* delete-region: Deletion.
* delete-window: Deleting Windows.
* delete-windows-on: Deleting Windows.
* deleting files in file system: Changing File Attributes.
* deleting windows: Deleting Windows.
* deletion of elements: Lists as Sets.
* deletion vs killing: Deletion.
* delq: Lists as Sets.
* dereferencing indirection: Classifying Lists.
* describe-bindings: Global and Local Keymaps.
* describe-mode: Mode Help.
* describe-syntax: Syntax Table Functions.
* description for interactive codes: Interactive Codes.
* descriptions: Format of Descriptions.
* diagrams, boxed, for lists: List Type.
* digit-argument: Prefix Command Arguments.
* ding: Beeping.
* dinging: Beeping.
* directory name: Directory Names.
* directory part (of file name): File Name Components.
* directory-file-name: Directory Names.
* directory-files: Contents of Directories.
* directory-oriented functions: Contents of Directories.
* dired-mode-map: Standard Keymaps.
* disable-command: Disabling Commands.
* disabled command: Disabling Commands.
* disabled property: Disabling Commands.
* disabled-command-hook: Disabling Commands.
* disassemble: Disassembly.
* discard input: Keyboard Input.
* discard-input: Keyboard Input.
* display columns: Screen Attributes.
* display lines: Screen Attributes.
* display-buffer: Changing Buffers.
* display-completion-list: Completion Reading.
* dissassembled byte code: Disassembly.
* do-auto-save: Auto Saving.
* doctor-mode-map: Standard Keymaps.
* documentation: Accessing Documentation.
* documentation conventions: Documentation Basics.
* documentation for major mode: Mode Help.
* documentation notation: Evaluation Notation.
* documentation of function: Function Documentation.
* documentation string, writing one: Documentation Basics.
* documentation strings: Documentation.
* documentation-property: Accessing Documentation.
* dotted pair notation: Dotted Pair Notation.
* double-quote in strings: String Type.
* down-list: List Motion.
* downcase: Character Case.
* downcase-region: Case Changes.
* downcase-word: Case Changes.
* downcasing in `lookup-key': Keyboard Input.
* dribble file: Terminal Input.
* dump-emacs: Building Emacs.
* dynamic scoping: Variable Resolution.
* echo area: The Echo Area.
* echo-keystrokes: Command Loop Info.
* edit-abbrevs-map: Defining Abbrevs.
* edit-abbrevs-map: Standard Keymaps.
* edit-and-eval-command: Object from Minibuffer.
* edit-tab-stops-map: Standard Keymaps.
* editing command loop: Command Loop.
* editing types: Editing Types.
* electric-buffer-menu-mode-map: Standard Keymaps.
* electric-future-map: A Sample Variable Description.
* electric-history-map: Standard Keymaps.
* element (of list): Lists.
* elements of sequences: Sequence Functions.
* elt: Sequence Functions.
* emacs-build-time: Building Emacs.
* emacs-lisp-mode-map: Standard Keymaps.
* emacs-lisp-mode-syntax-table: Standard Syntax Tables.
* emacs-version: Building Emacs.
* emacs-version: Building Emacs.
* empty list: List Type.
* enable-command: Disabling Commands.
* enable-recursive-minibuffers: Minibuffer Misc.
* end of buffer marker: Creating Markers.
* end-of-buffer: Character Motion.
* end-of-buffer error: Character Motion.
* end-of-file error: Input Functions.
* end-of-file error: Lisp Expressions.
* end-of-file error: Lisp Expressions.
* end-of-line: Lines.
* enlarge-window: Size of Window.
* enlarge-window-horizontally: Size of Window.
* environment: Intro Eval.
* environment variables: System Environment.
* eobp: Point.
* eolp: Point.
* eq: Equality Predicates.
* equal: Equality Predicates.
* equality: Equality Predicates.
* erase-buffer: Deletion.
* error: Signalling Errors.
* error cleanup: Cleanups.
* error debugging: How Debugger Works.
* error debugging: Error Debugging.
* error display: The Echo Area.
* error handler: Handling Errors.
* error in debug: Invoking the Debugger.
* error message notation: Error Messages.
* error name: Error Names.
* error symbol: Error Names.
* error-conditions: Error Names.
* error-conditions property: Signalling Errors.
* error-conditions property: Standard Errors.
* errors: Errors.
* esc-map: Prefix Keys.
* escape: Character Type.
* escape characters: Output Functions.
* escape characters: Output Functions.
* escape sequence: Character Type.
* eval: Eval.
* eval, and debugging: Invoking the Debugger.
* eval-current-buffer: Eval.
* eval-minibuffer: Object from Minibuffer.
* eval-region: Eval.
* evaluation: Evaluation.
* evaluation error: Eval.
* evaluation notation: Evaluation Notation.
* evaluation of buffer contents: Eval.
* examining windows: Buffers and Windows.
* examples of using `interactive': Interactive Examples.
* excursion: Excursions.
* exec-directory: Subprocess Creation.
* exec-path: Subprocess Creation.
* execute program: Subprocess Creation.
* execute with prefix argument: Interactive Call.
* execute-extended-command: Interactive Call.
* execute-kbd-macro: Keyboard Macros.
* executing-macro: Keyboard Macros.
* executing-macro-index: Keyboard Macros.
* exit: Recursive Editing.
* exit recursive editing: Recursive Editing.
* exit-minibuffer: Minibuffer Misc.
* exit-recursive-edit: Recursive Editing.
* exiting Emacs: Getting Out.
* expand-file-name: File Name Expansion.
* expansion of file names: File Name Expansion.
* expansion of macros: Expansion.
* expression: Intro Eval.
* extent: Variable Resolution.
* false: nil and t.
* fboundp: Function Cells.
* featurep: Features.
* features: Features.
* features: Features.
* field width: Formatting Strings.
* file age: Testing Accessibility.
* file attributes: File Attributes.
* file hard link: Changing File Attributes.
* file hard links: File Attributes.
* file locks: File Locks.
* file mode specification error: Auto Major Mode.
* file modification time: Testing Accessibility.
* file name of buffer: Buffer File Name.
* file name of directory: Directory Names.
* file names: File Names.
* file names in directory: Contents of Directories.
* file open error: Subroutines of Visiting.
* file symbolic links: Kinds of Files.
* file-already-exists error: Changing File Attributes.
* file-already-exists error: Changing File Attributes.
* file-attributes: File Attributes.
* file-directory-p: Kinds of Files.
* file-error: How Programs Do Loading.
* file-exists-p: Testing Accessibility.
* file-locked error: File Locks.
* file-locked-p: File Locks.
* file-modes: File Attributes.
* file-name-absolute-p: Relative File Names.
* file-name-all-completions: Filename Completion.
* file-name-all-versions: Contents of Directories.
* file-name-as-directory: Directory Names.
* file-name-completion: Filename Completion.
* file-name-directory: File Name Components.
* file-name-nondirectory: File Name Components.
* file-name-sans-versions: File Name Components.
* file-newer-than-file-p: Testing Accessibility.
* file-nlinks: File Attributes.
* file-precious-flag: Saving Buffers.
* file-readable-p: Testing Accessibility.
* file-supersession error: Modification Time.
* file-symlink-p: Kinds of Files.
* file-writable-p: Testing Accessibility.
* filename completion subroutines: Filename Completion.
* fill-column: Auto Filling.
* fill-individual-paragraphs: Filling.
* fill-paragraph: Filling.
* fill-region: Filling.
* fill-region-as-paragraph: Filling.
* fillarray: Array Functions.
* filling a paragraph: Filling.
* filling, automatic: Auto Filling.
* filling, explicit: Filling.
* filter function: Filter Functions.
* find-alternate-file: Visiting Functions.
* find-backup-file-name: Backup Names.
* find-file: Visiting Functions.
* find-file-hooks: Visiting Functions.
* find-file-noselect: Visiting Functions.
* find-file-not-found-hooks: Visiting Functions.
* find-file-other-window: Visiting Functions.
* find-file-read-only: Visiting Functions.
* finding files: Visiting Files.
* finding windows: Selecting Windows.
* fixup-whitespace: Deletion.
* floating point: Number Type.
* floatp: Predicates on Numbers.
* flow control characters: Flow Control.
* flow control example: Terminal Input.
* flush input: Keyboard Input.
* fmakunbound: Function Cells.
* following-char: Point.
* fonts: Some Terms.
* foo: A Sample Function Description.
* for: Problems with Macros.
* forcing redisplay: Waiting.
* format: Formatting Strings.
* formatting: Formatting Strings.
* formatting strings: Formatting Strings.
* formfeed: Character Type.
* forms: Intro Eval.
* forward-char: Character Motion.
* forward-line: Lines.
* forward-list: List Motion.
* forward-sexp: List Motion.
* forward-to-indentation: Indentation.
* forward-word: Character Motion.
* free list: Garbage Collection.
* fset: Function Cells.
* ftp-login: Cleanups.
* full keymap: Creating Keymaps.
* funcall: Calling Functions.
* funcall, and debugging: Invoking the Debugger.
* function: What Is a Function.
* function: Anonymous Functions.
* function call: Function Forms.
* function call: Calling Functions.
* function call debugging: Function Debugging.
* function cell: Symbol Components.
* function cell: Compilation Functions.
* function cell in autoload: Autoload.
* function definition: Symbol Components.
* function definition: Function Names.
* function descriptions: A Sample Function Description.
* function evaluation: Argument List.
* function evaluation: Function Forms.
* function in keymap: Key Lookup.
* function input stream: Input Streams.
* function invocation: Calling Functions.
* function keys: Terminal-specific.
* function name: Function Names.
* function output stream: Output Streams.
* function quoting: Anonymous Functions.
* function-keymap: Standard Keymaps.
* functions in modes: Major Mode Conventions.
* functions, making them interactive: Defining Commands.
* fundamental-mode: Auto Major Mode.
* fundamental-mode-abbrev-table: Standard Abbrev Tables.
* fundamental-mode-map: Standard Keymaps.
* garbage collection protection: Writing Emacs Primitives.
* garbage collector: Garbage Collection.
* garbage-collect: Garbage Collection.
* gc-cons-threshold: Garbage Collection.
* generate-new-buffer: Creating Buffers.
* get: Property Lists.
* get-buffer: Buffer Names.
* get-buffer-create: Creating Buffers.
* get-buffer-process: Process Buffers.
* get-buffer-window: Buffers and Windows.
* get-file-buffer: Buffer File Name.
* get-file-char: Input Streams.
* get-largest-window: Selecting Windows.
* get-lru-window: Selecting Windows.
* get-process: Process Information.
* get-register: Registers.
* getenv: System Environment.
* global binding: Local Variables.
* global keymap: Global and Local Keymaps.
* global keymap: Global and Local Keymaps.
* global variable: Global Variables.
* global-abbrev-table: Standard Abbrev Tables.
* global-key-binding: Global and Local Keymaps.
* global-map: Global and Local Keymaps.
* global-mode-string: Mode Line Variables.
* global-set-key: Changing Key Bindings.
* global-unset-key: Changing Key Bindings.
* goal column: Goal Column.
* goal-column: Goal Column.
* goto-char: Character Motion.
* goto-line: Lines.
* hack-local-variables: Auto Major Mode.
* handling errors: Handling Errors.
* hash notation: Primitive Function Type.
* hash notation: Printed Representation.
* hashing: Creating Symbols.
* help for major mode: Mode Help.
* help-char: Help Functions.
* help-command: Help Functions.
* help-form: Help Functions.
* help-map: Prefix Keys.
* help-map: Help Functions.
* highlighting: Screen Attributes.
* history of commands: Command History.
* hook: Hooks.
* horizontal scrolling: Horizontal Scrolling.
* horizontal split lines: Truncation.
* if: Conditionals.
* ignore: Key Lookup.
* implicit `progn': Sequencing.
* inc: Simple Macro.
* indent-according-to-mode: Indentation.
* indent-for-tab-command: Indentation.
* indent-line-function: Indentation.
* indent-region: Indentation.
* indent-region-function: Indentation.
* indent-relative: Indentation.
* indent-relative-maybe: Indentation.
* indent-rigidly: Indentation.
* indent-tabs-mode: Indentation.
* indent-to: Indentation.
* indent-to-left-margin: Indentation.
* indenting: Indentation.
* indenting lists: Lisp Expressions.
* indirection: Classifying Lists.
* indirection for symbols: Classifying Lists.
* infinite recursion: Eval.
* inhibit-default-init: Init File.
* inhibit-local-variables: Auto Major Mode.
* inhibit-quit: Quitting.
* inhibit-startup-message: Start-up Summary.
* init file: Init File.
* initial-major-mode: Auto Major Mode.
* initializtion: Start-up Summary.
* innermost list: Lisp Expressions.
* input stream: Input Streams.
* input-pending-p: Keyboard Input.
* insert: Insertion.
* insert killed text: Yank Commands.
* insert-abbrev-table-description: Abbrev Tables.
* insert-before-markers: Insertion.
* insert-buffer: Insertion.
* insert-buffer-substring: Insertion.
* insert-char: Insertion.
* insert-default-directory: High-level Completion.
* insert-file: Reading from Files.
* insert-file-contents: Reading from Files.
* insert-register: Registers.
* inside comment: Lisp Expressions.
* inside string: Lisp Expressions.
* int-to-string: String Conversion.
* integer to decimal: Building Lists.
* integer to decimal: Creating Strings.
* integer to decimal: Formatting Strings.
* integer to decimal: String Conversion.
* integer to decimal: Vectors.
* integer to hexadecimal: Formatting Strings.
* integer to octal: Formatting Strings.
* integer to string: String Conversion.
* integer-or-marker-p: Predicates on Markers.
* integerp: Predicates on Numbers.
* integers: Number Type.
* integers: Numbers.
* interactive: Using Interactive.
* interactive call: Interactive Call.
* interactive code description: Interactive Codes.
* interactive completion: Interactive Codes.
* interactive function: Defining Commands.
* interactive-p: Interactive Call.
* intern: Creating Symbols.
* intern-soft: Creating Symbols.
* internals, of buffer: Buffer Internals.
* internals, of process: Process Internals.
* internals, of window: Window Internals.
* interning: Creating Symbols.
* interpreter: Evaluation.
* interrupt-process: Signals to Processes.
* invalid format error: Formatting Strings.
* invalid function: Classifying Lists.
* invalid prefix characters error: Changing Key Bindings.
* invalid-function: Classifying Lists.
* invalid-function error: Key Lookup.
* invalid-read-syntax error: Printed Representation.
* inverse-video: Screen Attributes.
* iteration: Iteration.
* joining lists: Rearrangement.
* just-one-space: Deletion.
* justify-current-line: Filling.
* kept-new-versions: Backup Names.
* kept-old-versions: Backup Names.
* key: Keymap Terms.
* key binding: Keymap Terms.
* key lookup: Key Lookup.
* key lookup: Keymaps.
* key sequence: Keyboard Input.
* key sequence error: Changing Key Bindings.
* key-binding: Global and Local Keymaps.
* key-description: Accessing Documentation.
* keyboard macro execution: Interactive Call.
* keyboard macro in keymap: Key Lookup.
* keyboard macro termination: Beeping.
* keyboard macros: Keyboard Macros.
* keyboard-quit: Quitting.
* keyboard-translate-table: Terminal Input.
* keymap: Keymaps.
* keymap entry: Key Lookup.
* keymap in keymap: Key Lookup.
* keymap in keymap: Key Lookup.
* keymapp: Creating Keymaps.
* keymaps in modes: Major Mode Conventions.
* keystroke: Keymap Terms.
* keystroke command: What Is a Function.
* kill command repetition: Command Loop Info.
* kill ring: The Kill Ring.
* kill to character: Kill Functions.
* kill-all-local-variables: Buffer Local Variables.
* kill-buffer: Killing Buffers.
* kill-emacs: Killing Emacs.
* kill-emacs-hook: Killing Emacs.
* kill-line: Kill Functions.
* kill-local-variable: Buffer Local Variables.
* kill-process: Signals to Processes.
* kill-region: Kill Functions.
* kill-ring: Kill Ring Internals.
* kill-ring-max: Kill Ring Internals.
* kill-ring-yank-pointer: Kill Ring Internals.
* killing Emacs: Killing Emacs.
* killing buffers: Killing Buffers.
* lambda expression: Lambda Expressions.
* lambda in debug: Invoking the Debugger.
* lambda in hooks: Hooks.
* lambda list: Lambda Components.
* last-abbrev: Abbrev Expansion.
* last-abbrev-location: Abbrev Expansion.
* last-abbrev-text: Abbrev Expansion.
* last-command: Command Loop Info.
* last-command-char: Command Loop Info.
* last-input-char: Terminal Input.
* last-kbd-macro: Keyboard Macros.
* left-margin: Indentation.
* length: Sequence Functions.
* let: Local Variables.
* let*: Local Variables.
* lexical comparison: Text Comparison.
* libraries: Compilation Functions.
* library: Loading Libraries.
* library evaluation: Loading.
* line wrapping: Truncation.
* lines: Lines.
* lines in region: Lines.
* linking files in file system: Changing File Attributes.
* lisp interpreter: Compilation Functions.
* lisp-complete-symbol: Lisp Symbol Completion.
* lisp-interaction-mode-map: Standard Keymaps.
* lisp-mode-abbrev-table: Standard Abbrev Tables.
* lisp-mode-map: Standard Keymaps.
* lisp-mode.el: Example Major Modes.
* list: Building Lists.
* list: Lists.
* list elements: List Elements.
* list form evaluation: Nonempty List Forms.
* list in keymap: Key Lookup.
* list length: Sequence Functions.
* list moving: List Motion.
* list-buffers: The Buffer List.
* list-directory: Contents of Directories.
* list-directory-brief-switches: Contents of Directories.
* list-directory-verbose-switches: Contents of Directories.
* list-processes: Process Information.
* listp: List-related Predicates.
* lists as sets: Lists as Sets.
* lists represented as boxes: Lists as Boxes.
* literal evaluation: Self-Evaluating Forms.
* ln: Changing File Attributes.
* load: How Programs Do Loading.
* load error with provide: Features.
* load errors: Loading Libraries.
* load-average: System Environment.
* load-in-progress: How Programs Do Loading.
* load-path: How Programs Do Loading.
* load-path: How Programs Do Loading.
* loading: Loading.
* loadst: Subprocess Creation.
* loadup.el: Building Emacs.
* local binding: Local Variables.
* local keymap: Global and Local Keymaps.
* local keymap: Global and Local Keymaps.
* local variables: Local Variables.
* local-abbrev-table: Standard Abbrev Tables.
* local-key-binding: Global and Local Keymaps.
* local-set-key: Changing Key Bindings.
* local-unset-key: Changing Key Bindings.
* lock-buffer: File Locks.
* logand: Bitwise Operations.
* logical and: Bitwise Operations.
* logical exclusive or: Bitwise Operations.
* logical inclusive or: Bitwise Operations.
* logical not: Bitwise Operations.
* logical shift: Bitwise Operations.
* logior: Bitwise Operations.
* lognot: Bitwise Operations.
* logxor: Bitwise Operations.
* looking-at: Regexp Search.
* lookup-key: Key Lookup.
* lower case: Character Case.
* ls: Contents of Directories.
* lsh: Bitwise Operations.
* macro call: Expansion.
* macro compilation: Compilation Functions.
* macro descriptions: A Sample Function Description.
* macro evaluation: Problems with Macros.
* macro evaluation: Macro Forms.
* macro expansion: Expansion.
* macroexpand: Expansion.
* macros: Macros.
* major mode: Major Modes.
* major mode keymap: Global and Local Keymaps.
* major-mode: Mode Help.
* make-abbrev-table: Abbrev Tables.
* make-auto-save-file-name: Auto Saving.
* make-backup-file-name: Backup Names.
* make-backup-files: Making Backups.
* make-keymap: Creating Keymaps.
* make-list: Building Lists.
* make-local-variable: Buffer Local Variables.
* make-marker: Creating Markers.
* make-sparse-keymap: Creating Keymaps.
* make-string: Creating Strings.
* make-symbol: Creating Symbols.
* make-symbolic-link: Changing File Attributes.
* make-syntax-table: Syntax Table Functions.
* make-temp-name: Unique File Names.
* make-variable-buffer-local: Buffer Local Variables.
* make-vector: Vectors.
* makunbound: Void Variables.
* mapatoms: Creating Symbols.
* mapcar: Mapping Functions.
* mapconcat: Mapping Functions.
* mapping functions: Mapping Functions.
* mark: The Mark.
* mark excursion: Excursions.
* mark ring: The Mark.
* mark, the: The Mark.
* mark-marker: The Mark.
* mark-ring: The Mark.
* mark-ring-max: The Mark.
* marker argument: Interactive Codes.
* marker garbage collection: Markers.
* marker input stream: Input Streams.
* marker output stream: Output Streams.
* marker updating: Markers.
* marker-buffer: Information from Markers.
* marker-position: Information from Markers.
* markerp: Predicates on Markers.
* markers: Markers.
* markers: Number Basics.
* markers as numbers: Markers.
* match-beginning: Match Data.
* match-data: Match Data.
* match-end: Match Data.
* matching: Searching and Matching.
* max: Comparison of Numbers.
* max-lisp-eval-depth: Eval.
* max-specpdl-size: Local Variables.
* max-specpdl-size: Eval.
* membership in a list: Lists as Sets.
* memory allocation: Pure Storage.
* memq: Lists as Sets.
* message: The Echo Area.
* meta character: Character Type.
* meta character keys: Changing Key Bindings.
* meta character printing: Accessing Documentation.
* meta characters: Global and Local Keymaps.
* meta characters: Creating Keymaps.
* meta-flag: Terminal Input.
* meta-prefix-char: Key Lookup.
* min: Comparison of Numbers.
* minibuffer: Minibuffers.
* minibuffer input: Recursive Editing.
* minibuffer window: Cyclic Window Ordering.
* minibuffer-complete: Completion Reading.
* minibuffer-complete-and-exit: Completion Reading.
* minibuffer-complete-word: Completion Reading.
* minibuffer-completion-confirm: Completion Reading.
* minibuffer-completion-help: Completion Reading.
* minibuffer-completion-predicate: Completion Reading.
* minibuffer-completion-table: Completion Reading.
* minibuffer-depth: Minibuffer Misc.
* minibuffer-help-form: Minibuffer Misc.
* minibuffer-local-completion-map: Completion Reading.
* minibuffer-local-map: Text from Minibuffer.
* minibuffer-local-must-match-map: Completion Reading.
* minibuffer-local-ns-map: Text from Minibuffer.
* minibuffer-scroll-window: Minibuffer Misc.
* minibuffer-window: Minibuffer Misc.
* minimum window size: Size of Window.
* minor mode: Minor Modes.
* minor mode conventions: Minor Mode Conventions.
* minor-mode-alist: Mode Line Variables.
* mode: Modes.
* mode help: Mode Help.
* mode line construct: Mode Line Data.
* mode line format: Mode Line Format.
* mode loading: Major Mode Conventions.
* mode-line-buffer-identification: Mode Line Variables.
* mode-line-format: Mode Line Data.
* mode-line-inverse-video: Screen Attributes.
* mode-line-modified: Mode Line Variables.
* mode-line-process: Process Information.
* mode-name: Mode Line Variables.
* mode-specific-map: Prefix Keys.
* mode-specific-map: Standard Keymaps.
* modification flag (of buffer): Buffer Modification.
* modification of lists: Rearrangement.
* modification time, comparison of: Modification Time.
* modify-syntax-entry: Syntax Table Functions.
* modulus: Arithmetic Operations.
* momentary-string-display: Temporary Displays.
* mouse-map: Standard Keymaps.
* move-marker: Changing Markers.
* move-to-column: Columns.
* move-to-window-line: Lines.
* multiple windows: Basic Windows.
* mv: Changing File Attributes.
* named function: Function Names.
* narrow-to-page: Clipping Restrictions.
* narrow-to-region: Clipping Restrictions.
* narrowing: Clipping Restrictions.
* natnump: Predicates on Numbers.
* natural numbers: Predicates on Numbers.
* nconc: Rearrangement.
* negative-argument: Prefix Command Arguments.
* newline: Insertion.
* newline: Character Type.
* newline in Auto Fill mode: Insertion.
* newline in print: Output Functions.
* newline in strings: String Type.
* newline-and-indent: Indentation.
* next command: Prefix Command Arguments.
* next input: Keyboard Input.
* next-screen-context-lines: Vertical Scrolling.
* next-window: Cyclic Window Ordering.
* nil: nil and t.
* nil: Constant Variables.
* nil in keymap: Key Lookup.
* nil in lists: List Type.
* nlistp: List-related Predicates.
* no-catch: Catch and Throw.
* no-redraw-on-reenter: Screen Attributes.
* nondirectory part (of file name): File Name Components.
* noninteractive: Batch Mode.
* noninteractive use: Batch Mode.
* nonlocal exits: Nonlocal Exits.
* nonprinting characters, reading: Keyboard Input.
* normal-mode: Auto Major Mode.
* not: Combining Conditions.
* not-modified: Buffer Modification.
* nreverse: Rearrangement.
* nth: List Elements.
* nthcdr: List Elements.
* null: List-related Predicates.
* number equality: Comparison of Numbers.
* numbers: Number Type.
* numeric prefix: Formatting Strings.
* numeric prefix argument: Prefix Command Arguments.
* obarray: Creating Symbols.
* obarray: Creating Symbols.
* obarray in completion: Basic Completion.
* object: Types of Lisp Object.
* object internals: Object Internals.
* object to string: Formatting Strings.
* object to string: Output Functions.
* object type tags: Object Internals.
* obsolete buffer: Modification Time.
* occur-mode-map: Standard Keymaps.
* octal character: Character Type.
* octal characters: Keyboard Input.
* octal to character: Insertion.
* one-window-p: Splitting Windows.
* only-global-abbrevs: Defining Abbrevs.
* open-dribble-file: Terminal Input.
* open-line: Insertion.
* open-network-stream: TCP.
* open-termscript: Terminal Output.
* operating system environment: System Environment.
* option descriptions: A Sample Variable Description.
* optional arguments: Argument List.
* or: Combining Conditions.
* ordering of windows, cyclic: Cyclic Window Ordering.
* other-buffer: The Buffer List.
* other-window: Cyclic Window Ordering.
* output from processes: Output from Processes.
* output stream: Output Streams.
* overflow: Number Basics.
* overlay arrow: Overlay Arrow.
* overlay-arrow-position: Overlay Arrow.
* overlay-arrow-string: Overlay Arrow.
* overwrite-mode: Insertion.
* padding: Formatting Strings.
* page-delimiter: Standard Regexps.
* paragraph-separate: Standard Regexps.
* paragraph-start: Standard Regexps.
* parent process: Processes.
* parenthesis: List Type.
* parenthesis depth: Lisp Expressions.
* parenthesis depth: Lisp Expressions.
* parenthesis depth: List Motion.
* parenthesis matching: Blinking.
* parenthesis syntax: Syntax Classes.
* parse state: Lisp Expressions.
* parse-partial-sexp: Lisp Expressions.
* parse-sexp-ignore-comments: Lisp Expressions.
* parsing: Syntax Tables.
* pausing: Waiting.
* peculiar error: Signalling Errors.
* peculiar error: Error Names.
* peeking at input: Keyboard Input.
* percent symbol in mode-line: Mode Line Data.
* permission: File Attributes.
* pipes: Asynchronous Processes.
* plist: Property Lists.
* point: Point.
* point: Point.
* point excursion: Excursions.
* point in restriction: Point.
* point in window: Window Point.
* point-marker: Creating Markers.
* point-max: Buffer Contents.
* point-max-marker: Creating Markers.
* point-min: Buffer Contents.
* point-min-marker: Creating Markers.
* point-to-register: Registers.
* pop-mark: The Mark.
* pop-to-buffer: Changing Buffers.
* pop-up-windows: Changing Buffers.
* pos-visible-in-window-p: Window Point.
* position (in buffer): Positions.
* position argument: Interactive Codes.
* position in window: Window Point.
* preceding-char: Point.
* predicates: Type Predicates.
* prefix argument: Prefix Command Arguments.
* prefix argument unreading: Keyboard Input.
* prefix command: Prefix Keys.
* prefix key: Prefix Keys.
* prefix-arg: Prefix Command Arguments.
* prefix-numeric-value: Prefix Command Arguments.
* prepend-to-register: Registers.
* preventing prefix key: Key Lookup.
* previous-window: Cyclic Window Ordering.
* primitive: What Is a Function.
* primitive: Function Cells.
* primitive function internals: Writing Emacs Primitives.
* primitive type: Types of Lisp Object.
* prin1: Output Functions.
* prin1-to-string: Output Functions.
* princ: Output Functions.
* print: Output Functions.
* print example: Output Streams.
* print name: Creating Symbols.
* print name cell: Symbol Components.
* print representation: Formatting Strings.
* print syntax for characters: Character Type.
* print-escape-newlines: Output Functions.
* print-help-return-message: Help Functions.
* print-length: Output Functions.
* printed representation: Printed Representation.
* printing: Streams Intro.
* printing limits: Output Functions.
* printing notation: Printing Notation.
* process: Processes.
* process filter: Filter Functions.
* process input: Input to Processes.
* process internals: Process Internals.
* process output: Output from Processes.
* process sentinel: Sentinels.
* process signals: Signals to Processes.
* process-buffer: Process Buffers.
* process-command: Process Information.
* process-connection-type: Asynchronous Processes.
* process-environment: Subprocess Creation.
* process-exit-status: Process Information.
* process-filter: Filter Functions.
* process-id: Process Information.
* process-kill-without-query: Deleting Processes.
* process-list: Process Information.
* process-mark: Process Buffers.
* process-name: Process Information.
* process-send-eof: Input to Processes.
* process-send-region: Input to Processes.
* process-send-string: Input to Processes.
* process-sentinel: Sentinels.
* process-status: Process Information.
* processed prefix argument: Interactive Codes.
* processp: Processes.
* prog1: Sequencing.
* prog2: Sequencing.
* progn: Sequencing.
* program arguments: Subprocess Creation.
* program directories: Subprocess Creation.
* programming types: Programming Types.
* property list: Property Lists.
* property list cell: Symbol Components.
* property lists vs association lists: Property Lists.
* protected forms: Cleanups.
* provide: Features.
* providing features: Features.
* ptys: Asynchronous Processes.
* pure storage: Pure Storage.
* pure-bytes-used: Pure Storage.
* purecopy: Pure Storage.
* purify-flag: Pure Storage.
* push-mark: The Mark.
* put: Property Lists.
* question mark in characters: Character Type.
* quietly-read-abbrev-file: Abbrev Files.
* quit: Error Debugging.
* quit error: Recursive Editing.
* quit signal: How Debugger Works.
* quit signal: Error Debugging.
* quit-flag: Quitting.
* quit-process: Signals to Processes.
* quiting Emacs: Getting Out.
* quitting: Quitting.
* quote: Quoting.
* quote character: Lisp Expressions.
* quote using apostrophe: Quoting.
* quoted-insert: Insertion.
* quoting: Quoting.
* quoting characters: Output Functions.
* random: Random Numbers.
* random numbers: Random Numbers.
* rassq: Association Lists.
* raw prefix argument: Prefix Command Arguments.
* re-search-backward: Regexp Search.
* re-search-forward: Regexp Search.
* read: Input Functions.
* read buffer name: Interactive Codes.
* read character: Interactive Codes.
* read command name: Interactive Codes.
* read command name: Interactive Call.
* read directory name: Interactive Codes.
* read file name: Interactive Codes.
* read function name: Interactive Codes.
* read key sequence: Interactive Codes.
* read number: Interactive Codes.
* read sexp: Interactive Codes.
* read string: Interactive Codes.
* read symbol: Interactive Codes.
* read syntax: Printed Representation.
* read syntax for characters: Character Type.
* read user option: Interactive Codes.
* read variable: Interactive Codes.
* read-buffer: High-level Completion.
* read-char: Keyboard Input.
* read-command: High-level Completion.
* read-file-name: High-level Completion.
* read-from-minibuffer: Text from Minibuffer.
* read-from-string: Input Functions.
* read-key-sequence: Keyboard Input.
* read-minibuffer: Object from Minibuffer.
* read-no-blanks-input: Text from Minibuffer.
* read-only buffer: Read Only Buffers.
* read-quoted-char: Keyboard Input.
* read-string: Text from Minibuffer.
* read-variable: High-level Completion.
* reading: Streams Intro.
* reading symbols: Creating Symbols.
* reals: Number Type.
* rearrangement of lists: Rearrangement.
* rebinding: Changing Key Bindings.
* recent-auto-save-p: Auto Saving.
* recent-keys: Terminal Input.
* recenter: Vertical Scrolling.
* record command history: Interactive Call.
* recover-file: Reverting.
* recursion: Iteration.
* recursion-depth: Recursive Editing.
* recursive command loop: Recursive Editing.
* recursive editing level: Recursive Editing.
* recursive evaluation: Intro Eval.
* recursive-edit: Recursive Editing.
* redo: Undo.
* redraw-display: Emacs Display.
* regexp: Regular Expressions.
* regexp alternative: Syntax of Regexps.
* regexp grouping: Syntax of Regexps.
* regexp searching: Regexp Search.
* regexp-quote: Syntax of Regexps.
* region argument: Interactive Codes.
* region error: Text.
* region, the: The Region.
* region-beginning: The Region.
* region-end: The Region.
* register-alist: Registers.
* register-to-point: Registers.
* registers: Registers.
* regular expression: Regular Expressions.
* regular expression searching: Regexp Search.
* regular expressions used standardly in editing: Standard Regexps.
* reindent-then-newline-and-indent: Indentation.
* relative file name: Relative File Names.
* removing clipping restriction: Clipping Restrictions.
* rename-auto-save-file: Auto Saving.
* rename-buffer: Buffer Names.
* rename-file: Changing File Attributes.
* renaming files in file system: Changing File Attributes.
* repeat-complex-command-map: Command History.
* replace bindings: Changing Key Bindings.
* replace characters: Replacement.
* replace-buffer-in-windows: Buffers and Windows.
* replace-match: Match Data.
* replacement: Replacement.
* require: Features.
* require-final-newline: Saving Buffers.
* requiring features: Features.
* resize redisplay: Screen Attributes.
* rest arguments: Argument List.
* restriction (in a buffer): Clipping Restrictions.
* resume, related to `no-redraw-on-reenter': Screen Attributes.
* return: Character Type.
* reverse: Building Lists.
* reversing a list: Rearrangement.
* revert-buffer: Reverting.
* revert-buffer-function: Reverting.
* rm: Changing File Attributes.
* rotate-yank-pointer: Kill Ring Internals.
* rplaca: Modifying Lists.
* rplacd: Modifying Lists.
* run-hooks: Hooks.
* runtime stack: Invoking the Debugger.
* runtime stack: Handling Errors.
* save-abbrevs: Abbrev Files.
* save-buffer: Saving Buffers.
* save-buffers-kill-emacs: Saving Buffers.
* save-excursion: Excursions.
* save-restriction: Clipping Restrictions.
* save-some-buffers: Saving Buffers.
* save-window-excursion: Window Configurations.
* saving window information: Window Configurations.
* scan-lists: Lisp Expressions.
* scan-sexps: Lisp Expressions.
* scope: Variable Resolution.
* screen attributes: Screen Attributes.
* screen layout: Window Configuration Type.
* screen of terminal: Basic Windows.
* screen size: Screen Attributes.
* screen-height: Screen Attributes.
* screen-width: Screen Attributes.
* scroll-down: Vertical Scrolling.
* scroll-left: Horizontal Scrolling.
* scroll-other-window: Vertical Scrolling.
* scroll-right: Horizontal Scrolling.
* scroll-step: Vertical Scrolling.
* scroll-up: Vertical Scrolling.
* scrolling vertically: Vertical Scrolling.
* search-backward: String Search.
* search-failed error: String Search.
* search-forward: String Search.
* searching: Searching and Matching.
* searching and case: Searching and Case.
* searching for regexp: Regexp Search.
* select-window: Selecting Windows.
* selected window: Basic Windows.
* selected-window: Selecting Windows.
* selecting a buffer: Changing Buffers.
* selecting windows: Selecting Windows.
* selective display: Selective Display.
* selective-display: Selective Display.
* selective-display-ellipses: Selective Display.
* self-evaluating form: Self-Evaluating Forms.
* self-insert at point: Point.
* self-insert-and-exit: Minibuffer Misc.
* self-insert-command: Insertion.
* send-command-to-subprocess: VMS Subprocesses.
* send-string-to-terminal: Terminal Output.
* sending signals: Signals to Processes.
* sentence-end: Standard Regexps.
* sentinel: Sentinels.
* sequence: Sequences Arrays Vectors.
* sequence length: Sequence Functions.
* sequencep: Sequence Functions.
* set: Setting Variables.
* set-auto-mode: Auto Major Mode.
* set-buffer: Changing Buffers.
* set-buffer-auto-saved: Auto Saving.
* set-buffer-modified-p: Buffer Modification.
* set-default: Default Value.
* set-file-modes: Changing File Attributes.
* set-goal-column: Goal Column.
* set-input-mode: Terminal Input.
* set-mark: The Mark.
* set-mark-command: The Mark.
* set-marker: Changing Markers.
* set-process-buffer: Process Buffers.
* set-process-filter: Filter Functions.
* set-process-sentinel: Sentinels.
* set-register: Registers.
* set-screen-height: Screen Attributes.
* set-screen-width: Screen Attributes.
* set-syntax-table: Syntax Table Functions.
* set-visited-file-name: Buffer File Name.
* set-window-buffer: Buffers and Windows.
* set-window-configuration: Window Configurations.
* set-window-hscroll: Horizontal Scrolling.
* set-window-point: Window Point.
* set-window-start: Window Point.
* setcar: Setcar.
* setcdr: Setcdr.
* setplist: Property Lists.
* setprv: System Environment.
* setq: Setting Variables.
* setq-default: Default Value.
* sets: Lists as Sets.
* setting modes of files: Changing File Attributes.
* setting-constant error: Constant Variables.
* sexp argument evaluation: Interactive Codes.
* sexp start: Lisp Expressions.
* sexps: List Motion.
* shadowing of variables: Local Variables.
* shell environment variables: Subprocess Creation.
* shrink-window: Size of Window.
* shrink-window-horizontally: Size of Window.
* side effect: Intro Eval.
* signal: Signalling Errors.
* signal: Signals to Processes.
* signaling errors: Signalling Errors.
* single-key-description: Accessing Documentation.
* sit-for: Waiting.
* skip-chars-backward: Skipping Characters.
* skip-chars-forward: Skipping Characters.
* skipping characters: Skipping Characters.
* skipping comments: Lisp Expressions.
* sleep-for: Waiting.
* sort: Rearrangement.
* sort-columns: Sorting.
* sort-fields: Sorting.
* sort-lines: Sorting.
* sort-numeric-fields: Sorting.
* sort-pages: Sorting.
* sort-paragraphs: Sorting.
* sort-regexp-fields: Sorting.
* sort-subr: Sorting.
* sorting lists: Rearrangement.
* sorting text: Sorting.
* sparse keymap: Creating Keymaps.
* spawn-subprocess: VMS Subprocesses.
* special form descriptions: A Sample Function Description.
* special form evaluation: Special Forms.
* special form evaluation: Control Structures.
* split-height-threshold: Changing Buffers.
* split-line: Insertion.
* split-window: Splitting Windows.
* split-window-horizontally: Splitting Windows.
* split-window-vertically: Splitting Windows.
* splitting windows: Changing Buffers.
* splitting windows: Splitting Windows.
* stable sort: Rearrangement.
* stack trace: Invoking the Debugger.
* stack-trace-on-error: Invoking the Debugger.
* standard regular expressions used in editing: Standard Regexps.
* standard-input: Input Functions.
* standard-output: Output Functions.
* standard-syntax-table: Standard Syntax Tables.
* start up: Start-up Summary.
* start-process: Asynchronous Processes.
* startup.el: Start-up Summary.
* stop-process: Signals to Processes.
* stop-subprocess: VMS Subprocesses.
* store-match-data: Match Data.
* stream (for printing): Output Streams.
* stream (for reading): Input Streams.
* string equality: Text Comparison.
* string in keymap: Key Lookup.
* string in keymap: Key Lookup.
* string input stream: Input Streams.
* string length: Sequence Functions.
* string search: String Search.
* string to character: String Conversion.
* string to integer: String Conversion.
* string to object: Input Functions.
* string, writing a documentation string: Documentation Basics.
* string-equal: Text Comparison.
* string-lessp: Text Comparison.
* string-match: Regexp Search.
* string-to-char: String Conversion.
* string-to-int: String Conversion.
* string<: Text Comparison.
* string=: Text Comparison.
* stringp: Predicates for Strings.
* strings: Strings and Characters.
* strings, formatting them: Formatting Strings.
* subprocess: Processes.
* subr: What Is a Function.
* subroutine: Function Cells.
* subrp: Function Cells.
* subst-char-in-region: Replacement.
* substitute-command-keys: Accessing Documentation.
* substitute-in-file-name: File Name Expansion.
* substitute-key-definition: Changing Key Bindings.
* substring: Creating Strings.
* subtype: Types of Lisp Object.
* supertype: Types of Lisp Object.
* suppress-keymap: Changing Key Bindings.
* suspend X Windows: Suspending Emacs.
* suspend evaluation: Recursive Editing.
* suspend-emacs: Suspending Emacs.
* suspend-hook: Suspending Emacs.
* suspend-resume-hook: Suspending Emacs.
* suspending Emacs: Suspending Emacs.
* switch-to-buffer: Changing Buffers.
* switch-to-buffer-other-window: Changing Buffers.
* switches: Command Line Arguments.
* switching to a buffer: Changing Buffers.
* symbol: Symbols.
* symbol cells: Symbol Components.
* symbol completion, lisp: Lisp Symbol Completion.
* symbol components: Symbol Components.
* symbol equality: Creating Symbols.
* symbol evaluation: Symbol Forms.
* symbol function indirection: Classifying Lists.
* symbol in keymap: Key Lookup.
* symbol indirection: Classifying Lists.
* symbol name hashing: Creating Symbols.
* symbol-function: Function Cells.
* symbol-name: Creating Symbols.
* symbol-plist: Property Lists.
* symbol-value: Accessing Variables.
* symbolp: Symbols.
* synchronous subprocess: Synchronous Processes.
* syntax classes: Syntax Classes.
* syntax flags: Syntax Classes.
* syntax table: Syntax Tables.
* syntax table example: Example Major Modes.
* syntax table internals: Syntax Table Internals.
* syntax tables in modes: Major Mode Conventions.
* syntax, print, for characters: Character Type.
* syntax, read, for characters: Character Type.
* syntax-table: Syntax Table Functions.
* syntax-table-p: Syntax Tables.
* system-name: System Environment.
* system-type: System Environment.
* t: nil and t.
* t: Constant Variables.
* tab: Character Type.
* tab character width: Columns.
* tab deletion: Deletion.
* tab-stop-list: Indent Tabs.
* tab-to-tab-stop: Indent Tabs.
* tabs stops for indentation: Indent Tabs.
* tag on runtime stack: Catch and Throw.
* temacs: Building Emacs.
* temp-buffer-show-hook: Temporary Displays.
* temporary-goal-column: Goal Column.
* term-file-prefix: Terminal-specific.
* term-setup-hook: Terminal-specific.
* termcap: Terminal-specific.
* terminal input: Terminal Input.
* terminal output: Terminal Output.
* terminal screen: Basic Windows.
* terminal-specific initialization: Terminal-specific.
* terminate keyboard macro: Keyboard Input.
* terpri: Output Functions.
* testing types: Type Predicates.
* text: Text.
* text insertion: Insertion.
* text parsing: Syntax Tables.
* text-char-description: Accessing Documentation.
* text-mode-abbrev-table: Standard Abbrev Tables.
* text-mode-map: Standard Keymaps.
* text-mode-syntax-table: Standard Syntax Tables.
* this-command: Command Loop Info.
* this-command-keys: Command Loop Info.
* throw: Catch and Throw.
* tiled windows: Basic Windows.
* toggle-read-only: Read Only Buffers.
* top-level: Recursive Editing.
* top-level form: Loading.
* top-level form: Lisp Expressions.
* track-eol: Goal Column.
* true: nil and t.
* truncate-lines: Truncation.
* truncate-partial-width-windows: Truncation.
* truth value: nil and t.
* try-completion: Basic Completion.
* two's complement: Number Basics.
* type: Types of Lisp Object.
* type checking: Type Predicates.
* type checking internals: Object Internals.
* type predicate: Type Predicates.
* type testing: Type Predicates.
* unbinding keys: Changing Key Bindings.
* undefined: Key Lookup.
* undefined key: Keymap Terms.
* underline-region: Underlining.
* underlining: Underlining.
* undo: Undo.
* undo avoidance: Replacement.
* undo-boundary: Undo.
* undo-more: Undo.
* undo-start: Undo.
* unexec: Building Emacs.
* uninterned symbol: Creating Symbols.
* uninterned symbol: Creating Symbols.
* universal-argument: Prefix Command Arguments.
* unlock-buffer: File Locks.
* unprocessed prefix argument: Interactive Codes.
* unread-command-char: Keyboard Input.
* ununderline-region: Underlining.
* unwind-protect: Cleanups.
* unwind-protect error: Eval.
* unwinding: Cleanups.
* up-list: List Motion.
* upcase: Character Case.
* upcase-region: Case Changes.
* upcase-word: Case Changes.
* upper case: Character Case.
* uppercase key sequence: Keyboard Input.
* use-global-map: Global and Local Keymaps.
* use-local-map: Global and Local Keymaps.
* user option: Defining Variables.
* user-defined error: Error Names.
* user-full-name: System Environment.
* user-login-name: System Environment.
* user-real-login-name: System Environment.
* user-real-uid: System Environment.
* user-uid: System Environment.
* user-variable-p: Defining Variables.
* value cell: Symbol Components.
* value of expression: Evaluation.
* values: Eval.
* variable: Variables.
* variable descriptions: A Sample Variable Description.
* variable limit error: Eval.
* variable resolution: Variable Resolution.
* variable-documentation: Defining Variables.
* variable-documentation: Documentation Basics.
* variables, buffer-local: Buffer Local Variables.
* vconcat: Vectors.
* vector: Vectors.
* vector: Vectors.
* vector evaluation: Vectors.
* vector evaluation: Self-Evaluating Forms.
* vector length: Sequence Functions.
* vectorp: Vectors.
* verify-visited-file-modtime: Modification Time.
* version number (in file name): File Name Components.
* vertical motion column: Goal Column.
* vertical scrolling: Vertical Scrolling.
* vertical tab: Character Type.
* vertical-motion: Lines.
* view-file: Visiting Functions.
* view-mode-map: Standard Keymaps.
* view-register: Registers.
* visible-bell: Beeping.
* visited file: Buffer File Name.
* visited file mode: Auto Major Mode.
* visiting files: Visiting Files.
* void function: Classifying Lists.
* void function cell: Function Cells.
* void variable: Void Variables.
* void-function: Classifying Lists.
* void-function error: Function Cells.
* void-variable: Void Variables.
* waiting: Waiting.
* waiting for Elapsed Time or Input: Waiting.
* waiting for command key input: Keyboard Input.
* waiting-for-user-input-p: Waiting for Output.
* where-is-internal: Global and Local Keymaps.
* while: Iteration.
* whitespace: Character Type.
* widen: Clipping Restrictions.
* widening: Clipping Restrictions.
* window: Basic Windows.
* window configurations: Window Configurations.
* window excursions: Excursions.
* window internals: Window Internals.
* window ordering, cyclic: Cyclic Window Ordering.
* window point: Window Point.
* window point internals: Window Internals.
* window position: Window Point.
* window resizing: Size of Window.
* window splitting: Splitting Windows.
* window top line: Window Point.
* window-buffer: Buffers and Windows.
* window-edges: Size of Window.
* window-height: Size of Window.
* window-hscroll: Horizontal Scrolling.
* window-min-height: Size of Window.
* window-min-width: Size of Window.
* window-point: Window Point.
* window-setup-hook: Window Systems.
* window-setup-hook: Terminal-specific.
* window-start: Window Point.
* window-system: Window Systems.
* window-system-version: Window Systems.
* window-width: Size of Window.
* windowp: Basic Windows.
* windows, controlling precisely: Buffers and Windows.
* with-output-to-temp-buffer: Temporary Displays.
* word search: String Search.
* word-search-backward: String Search.
* word-search-forward: String Search.
* write-abbrev-file: Abbrev Files.
* write-char: Output Functions.
* write-file: Saving Buffers.
* write-file-hooks: Saving Buffers.
* write-region: Writing to Files.
* writing a documentation string: Documentation Basics.
* wrong-number-of-arguments: Argument List.
* wrong-type-argument error: Type Predicates.
* xemacs: Building Emacs.
* y-or-n-p: Yes or No Queries.
* yank: Yank Commands.
* yank suppression: Changing Key Bindings.
* yank-pop: Yank Commands.
* yanking: Data in Kill Ring.
* yes-or-no-p: Yes or No Queries.
* zap-to-char: Kill Functions.
* zerop: Predicates on Numbers.


 
Tag Table:
Node: Top1103
Node: License2034
Node: Introduction15374
Node: Caveats16581
Node: Lisp History18019
Node: Conventions19272
Node: Some Terms20055
Node: nil and t20762
Node: Evaluation Notation22085
Node: Printing Notation22957
Node: Error Messages23905
Node: Buffer Text Notation24346
Node: Format of Descriptions25209
Node: A Sample Function Description25831
Node: A Sample Variable Description28576
Node: Types of Lisp Object29485
Node: Printed Representation31882
Node: Comments33691
Node: Programming Types36236
Node: Number Type37625
Node: Character Type38599
Node: Sequence Type43436
Node: List Type44679
Node: Dotted Pair Notation48882
Node: Association List Type52059
Node: Array Type53105
Node: String Type54564
Node: Vector Type56320
Node: Symbol Type57099
Node: Lisp Function Type62141
Node: Lisp Macro Type64724
Node: Primitive Function Type65385
Node: Autoload Type66883
Node: Editing Types67672
Node: Buffer Type68512
Node: Window Type70371
Node: Window Configuration Type71680
Node: Marker Type72232
Node: Process Type73064
Node: Stream Type73928
Node: Keymap Type74965
Node: Syntax Table Type75471
Node: Type Predicates76421
Node: Equality Predicates78680
Node: Numbers81153
Node: Number Basics82214
Node: Predicates on Numbers84838
Node: Comparison of Numbers86294
Node: Arithmetic Operations88632
Node: Bitwise Operations91540
Node: Random Numbers100568
Node: Strings and Characters102664
Node: Predicates for Strings104588
Node: Creating Strings105170
Node: Text Comparison109867
Node: String Conversion112330
Node: Formatting Strings115349
Node: Character Case120846
Node: Lists123708
Node: Lists as Boxes124815
Node: List-related Predicates127832
Node: Building Lists129377
Node: List Elements134484
Node: Modifying Lists137519
Node: Setcar138319
Node: Setcdr140682
Node: Rearrangement142818
Node: Lists as Sets147844
Node: Association Lists150130
Node: Sequences Arrays Vectors156255
Node: Sequence Functions158352
Node: Arrays161357
Node: Array Functions163340
Node: Vectors165537
Node: Symbols168939
Node: Symbol Components170398
Node: Definitions173000
Node: Creating Symbols175331
Node: Property Lists180502
Node: Lisp Symbol Completion184493
Node: Variables186260
Node: Global Variables188079
Node: Constant Variables189189
Node: Local Variables189694
Node: Void Variables194016
Node: Defining Variables197531
Node: Accessing Variables203241
Node: Setting Variables204682
Node: Variable Resolution207619
Node: Impl of Scope208985
Node: Scope211175
Node: Extent212817
Node: Buffer Local Variables214081
Node: Default Value220650
Node: Functions223232
Node: What Is a Function224248
Node: Lambda Expressions227527
Node: Lambda Components228176
Node: Simple Lambda229936
Node: Argument List231354
Node: Function Documentation234963
Node: Function Names236895
Node: Defining Functions239195
Node: Calling Functions241214
Node: Mapping Functions244380
Node: Anonymous Functions246713
Node: Function Cells249735
Node: Related Topics254364
Node: Macros255206
Node: Simple Macro256308
Node: Expansion257016
Node: Compiling Macros259830
Node: Defining Macros261267
Node: Backquote262584
Node: Problems with Macros264591
Node: Control Structures269496
Node: Sequencing270988
Node: Conditionals273853
Node: Combining Conditions277165
Node: Iteration280464
Node: Nonlocal Exits281656
Node: Catch and Throw282254
Node: Examples of Catch286001
Node: Errors288024
Node: Signalling Errors289541
Node: Processing of Errors292446
Node: Handling Errors293790
Node: Error Names300198
Node: Cleanups303620
Node: Evaluation306669
Node: Intro Eval307317
Node: Eval310218
Node: Forms314730
Node: Self-Evaluating Forms315394
Node: Symbol Forms316895
Node: Nonempty List Forms317755
Node: Classifying Lists318596
Node: Function Forms321300
Node: Macro Forms322218
Node: Special Forms323605
Node: Autoloading325933
Node: Quoting326411
Node: Loading327506
Node: Loading Libraries328851
Node: How Programs Do Loading331461
Node: Autoload335434
Node: Features339303
Node: Byte Compilation343723
Node: Compilation Functions344702
Node: Disassembly350216
Node: Debugging357762
Node: Debugger358773
Node: Error Debugging360195
Node: Function Debugging361962
Node: Explicit Debug364206
Node: Using Debugger364956
Node: Debugger Commands366615
Node: How Debugger Works369498
Node: Invoking the Debugger370540
Node: Syntax Errors377862
Node: Compilation Errors381095
Node: Streams382205
Node: Streams Intro383092
Node: Input Streams384873
Node: Input Functions389024
Node: Output Streams390964
Node: Output Functions394270
Node: Minibuffers398885
Node: Reading Text or Objects401402
Node: Text from Minibuffer401832
Node: Object from Minibuffer405821
Node: Completion408949
Node: Basic Completion410973
Node: Completion Reading414529
Node: High-level Completion420950
Node: Yes or No Queries426359
Node: Minibuffer Misc429626
Node: Command Loop431631
Node: Command Overview432867
Node: Defining Commands434832
Node: Using Interactive435565
Node: Interactive Codes437936
Node: Interactive Examples441974
Node: Interactive Call443351
Node: Command Loop Info448326
Node: Keyboard Input450991
Node: Quitting455996
Node: Prefix Command Arguments459985
Node: Recursive Editing463835
Node: Disabling Commands468600
Node: Command History470482
Node: Keyboard Macros472077
Node: Keymaps474210
Node: Keymap Terms475151
Node: Creating Keymaps476661
Node: Key Lookup479777
Node: Prefix Keys486532
Node: Global and Local Keymaps489543
Node: Changing Key Bindings497214
Node: Modes506881
Node: Major Modes507758
Node: Major Mode Conventions510126
Node: Example Major Modes514574
Node: Auto Major Mode522849
Node: Mode Help527531
Node: Minor Modes528600
Node: Minor Mode Conventions529955
Node: Limits of Minor Modes531885
Node: Mode Line Format533485
Node: Mode Line Data534735
Node: Mode Line Variables538914
Node: %-constructs542190
Node: Hooks544163
Node: Documentation548713
Node: Documentation Basics549573
Node: Accessing Documentation552050
Node: Help Functions561350
Node: Files567904
Node: Visiting Files569029
Node: Visiting Functions570510
Node: Subroutines of Visiting575651
Node: Saving Buffers577501
Node: Reading from Files584032
Node: Writing to Files585181
Node: File Locks586828
Node: Information about Files589370
Node: Testing Accessibility590404
Node: Kinds of Files592807
Node: File Attributes594121
Node: Contents of Directories598241
Node: Changing File Attributes600591
Node: File Names605377
Node: File Name Components606808
Node: Directory Names609386
Node: Relative File Names611385
Node: File Name Expansion612532
Node: Unique File Names615553
Node: Filename Completion616732
Node: Backups and Auto Saving619199
Node: Backup Files619869
Node: Making Backups621139
Node: Rename or Copy622516
Node: Backup Names625531
Node: Auto Saving629025
Node: Reverting634677
Node: Buffers637155
Node: Buffer Basics638505
Node: Buffer Names640485
Node: Buffer File Name642758
Node: Buffer Contents645826
Node: Buffer Modification648748
Node: Modification Time650472
Node: Read Only Buffers652830
Node: The Buffer List654627
Node: Creating Buffers658989
Node: Killing Buffers660620
Node: Changing Buffers662355
Node: Windows670357
Node: Basic Windows671410
Node: Splitting Windows674535
Node: Deleting Windows679486
Node: Selecting Windows681330
Node: Cyclic Window Ordering683149
Node: Buffers and Windows685955
Node: Window Point687689
Node: Vertical Scrolling693239
Node: Horizontal Scrolling698895
Node: Size of Window701560
Node: Window Configurations707721
Node: Positions710322
Node: Point711266
Node: Motion715126
Node: Character Motion715755
Node: Lines719659
Node: Goal Column724968
Node: List Motion726924
Node: Skipping Characters728043
Node: Excursions730028
Node: Clipping Restrictions732287
Node: Markers736623
Node: Predicates on Markers740245
Node: Creating Markers740986
Node: Information from Markers744335
Node: Changing Markers745464
Node: The Mark746653
Node: The Region751666
Node: Text752825
Node: Insertion755048
Node: Deletion761357
Node: The Kill Ring767594
Node: Data in Kill Ring769020
Node: Kill Functions772946
Node: Yank Commands775293
Node: Kill Ring Internals777054
Node: Undo778177
Node: Auto Filling781147
Node: Filling783334
Node: Sorting785885
Node: Indentation794501
Node: Indent Tabs803371
Node: Columns804361
Node: Case Changes806371
Node: Underlining809439
Node: Registers810470
Node: Searching and Matching813981
Node: String Search814990
Node: Regular Expressions819150
Node: Syntax of Regexps819728
Node: Regexp Example830798
Node: Regexp Search833306
Node: Replacement837853
Node: Match Data839522
Node: Standard Regexps847715
Node: Searching and Case849134
Node: Syntax Tables850589
Node: Syntax Classes852482
Node: Syntax Table Functions859204
Node: Standard Syntax Tables864027
Node: Syntax Table Internals864887
Node: Lisp Expressions866158
Node: Abbreviations870206
Node: Abbrev Mode871533
Node: Abbrev Tables872261
Node: Defining Abbrevs873605
Node: Abbrev Files874819
Node: Abbrev Expansion876013
Node: Standard Abbrev Tables878522
Node: Processes879508
Node: Subprocess Creation881517
Node: Synchronous Processes885277
Node: Asynchronous Processes890572
Node: Deleting Processes893584
Node: Process Information894583
Node: Input to Processes897752
Node: Signals to Processes900245
Node: Output from Processes904325
Node: Process Buffers904969
Node: Filter Functions907121
Node: Waiting for Output910312
Node: Sentinels911068
Node: VMS Subprocesses913563
Node: TCP915115
Node: System Interface916574
Node: Starting Up917497
Node: Start-up Summary918104
Node: Init File919124
Node: Terminal-specific920923
Node: Command Line Arguments925166
Node: Getting Out927334
Node: Killing Emacs927900
Node: Suspending Emacs929456
Node: System Environment932587
Node: Terminal Input936547
Node: Terminal Output940512
Node: Flow Control942397
Node: Batch Mode947147
Node: Emacs Display948107
Node: Window Systems949123
Node: Screen Attributes950235
Node: Truncation952568
Node: The Echo Area954356
Node: Selective Display955640
Node: Overlay Arrow959539
Node: Temporary Displays960345
Node: Waiting963914
Node: Blinking965415
Node: Control Char Display966599
Node: Beeping967273
Node: Tips and Standards968202
Node: GNU Emacs Internals974626
Node: Building Emacs975232
Node: Pure Storage978404
Node: Garbage Collection981769
Node: Writing Emacs Primitives986474
Node: Object Internals994930
Node: Buffer Internals996808
Node: Window Internals999086
Node: Process Internals1001467
Node: Standard Errors1003088
Node: Standard Buffer Local Variables1006079
Node: Standard Keymaps1007679
Node: Standard Hooks1010315
Node: Index1012357

End Tag Table
