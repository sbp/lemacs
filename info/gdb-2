Info file ../info/gdb, produced by Makeinfo, -*- Text -*- from input
file gdb.tex.

   This file documents the GNU debugger GDB.

   Copyright (C) 1988, 1989 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.


File: gdb,  Node: Conditions,  Next: Break Commands,  Prev: Disabling,  Up: Breakpoints

Break Conditions
----------------

   The simplest sort of breakpoint breaks every time the program
reaches a specified place.  You can also specify a "condition" for a
breakpoint.  A condition is just a boolean expression in your
programming language.  (*Note Expressions::).  A breakpoint with a
condition evaluates the expression each time the program reaches it,
and the program stops only if the condition is true.

   Break conditions may have side effects, and may even call functions
in your program.  These may sound like strange things to do, but their
effects are completely predictable unless there is another enabled
breakpoint at the same address.  (In that case, GDB might see the
other breakpoint first and stop the program without checking the
condition of this one.)  Note that breakpoint commands are usually
more convenient and flexible for the purpose of performing side
effects when a breakpoint is reached (*note Break Commands::.).

   Break conditions can be specified when a breakpoint is set, by using
`if' in the arguments to the `break' command.  *Note Set Breaks::. 
They can also be changed at any time with the `condition' command:

`condition BNUM EXPRESSION'
     Specify EXPRESSION as the break condition for breakpoint number
     BNUM.  From now on, this breakpoint will stop the program only if
     the value of EXPRESSION is true (nonzero, in C).  EXPRESSION is
     not evaluated at the time the `condition' command is given. 
     *Note Expressions::.

`condition BNUM'
     Remove the condition from breakpoint number BNUM.  It becomes an
     ordinary unconditional breakpoint.

   A special case of a breakpoint condition is to stop only when the
breakpoint has been reached a certain number of times.  This is so
useful that there is a special way to do it, using the "ignore count"
of the breakpoint.  Every breakpoint has an ignore count, which is an
integer.  Most of the time, the ignore count is zero, and therefore
has no effect.  But if the program reaches a breakpoint whose ignore
count is positive, then instead of stopping, it just decrements the
ignore count by one and continues.  As a result, if the ignore count
value is N, the breakpoint will not stop the next N times it is
reached.

`ignore BNUM COUNT'
     Set the ignore count of breakpoint number BNUM to COUNT.  The
     next COUNT times the breakpoint is reached, it will not stop.

     To make the breakpoint stop the next time it is reached, specify
     a count of zero.

`cont COUNT'
     Continue execution of the program, setting the ignore count of the
     breakpoint that the program stopped at to COUNT minus one.  Thus,
     the program will not stop at this breakpoint until the COUNT'th
     time it is reached.

     This command is allowed only when the program stopped due to a
     breakpoint.  At other times, the argument to `cont' is ignored.

   If a breakpoint has a positive ignore count and a condition, the
condition is not checked.  Once the ignore count reaches zero, the
condition will start to be checked.

   Note that you could achieve the effect of the ignore count with a
condition such as `$foo-- <= 0' using a debugger convenience variable
that is decremented each time.  *Note Convenience Vars::.


File: gdb,  Node: Break Commands,  Next: Error in Breakpoints,  Prev: Conditions,  Up: Breakpoints

Commands Executed on Breaking
-----------------------------

   You can give any breakpoint a series of commands to execute when the
program stops due to that breakpoint.  For example, you might want to
print the values of certain expressions, or enable other breakpoints.

`commands BNUM'
     Specify commands for breakpoint number BNUM.  The commands
     themselves appear on the following lines.  Type a line containing
     just `end' to terminate the commands.

     \hfuzz = 10pt To remove all commands from a breakpoint, use the
     command `commands' and follow it immediately by `end'; that is,
     give no commands.

     With no arguments, `commands' refers to the last breakpoint set.

   It is possible for breakpoint commands to start the program up
again.  Simply use the `cont' command, or `step', or any other command
to resume execution.  However, any remaining breakpoint commands are
ignored.  When the program stops again, GDB will act according to the
cause of that stop.

   If the first command specified is `silent', the usual message about
stopping at a breakpoint is not printed.  This may be desirable for
breakpoints that are to print a specific message and then continue. 
If the remaining commands too print nothing, you will see no sign that
the breakpoint was reached at all.  `silent' is not really a command;
it is meaningful only at the beginning of the commands for a
breakpoint.

   The commands `echo' and `output' that allow you to print precisely
controlled output are often useful in silent breakpoints.  *Note
Output::.

   For example, here is how you could use breakpoint commands to print
the value of `x' at entry to `foo' whenever it is positive.

     break foo if x>0
     commands
     silent
     echo x is\040
     output x
     echo \n
     cont
     end

   One application for breakpoint commands is to correct one bug so
you can test another.  Put a breakpoint just after the erroneous line
of code, give it a condition to detect the case in which something
erroneous has been done, and give it commands to assign correct values
to any variables that need them.  End with the `cont' command so that
the program does not stop, and start with the `silent' command so that
no output is produced.  Here is an example:

     break 403
     commands
     silent
     set x = y + 4
     cont
     end

   One deficiency in the operation of automatically continuing
breakpoints under Unix appears when your program uses raw mode for the
terminal.  GDB switches back to its own terminal modes (not raw)
before executing commands, and then must switch back to raw mode when
your program is continued.  This causes any pending terminal input to
be lost.

   In the GNU system, this will be fixed by changing the behavior of
terminal modes.

   Under Unix, when you have this problem, you might be able to get
around it by putting your actions into the breakpoint condition
instead of commands.  For example

     condition 5  (x = y + 4), 0

specifies a condition expression (*Note Expressions::) that will change
`x' as needed, then always have the value 0 so the program will not
stop.  Loss of input is avoided here because break conditions are
evaluated without changing the terminal modes.  When you want to have
nontrivial conditions for performing the side effects, the operators
`&&', `||' and `?...:' may be useful.


File: gdb,  Node: Error in Breakpoints,  Prev: Break Commands,  Up: Breakpoints

"Cannot Insert Breakpoints" Error
---------------------------------

   Under some operating systems, breakpoints cannot be used in a
program if any other process is running that program.  Attempting to
run or continue the program with a breakpoint in this case will cause
GDB to stop it.

   When this happens, you have three ways to proceed:

  1. Remove or disable the breakpoints, then continue.

  2. Suspend GDB, and copy the file containing the program to a new
     name.  Resume GDB and use the `exec-file' command to specify that
     GDB should run the program under that name.  Then start the
     program again.

  3. Relink the program so that the text segment is nonsharable, using
     the linker option `-N'.  The operating system limitation may not
     apply to nonsharable executables.


File: gdb,  Node: Continuing,  Next: Stepping,  Prev: Breakpoints,  Up: Stopping

Continuing
==========

   After your program stops, most likely you will want it to run some
more if the bug you are looking for has not happened yet.

`cont'
     Continue running the program at the place where it stopped.

   If the program stopped at a breakpoint, the place to continue
running is the address of the breakpoint.  You might expect that
continuing would just stop at the same breakpoint immediately.  In
fact, `cont' takes special care to prevent that from happening.  You
do not need to delete the breakpoint to proceed through it after
stopping at it.

   You can, however, specify an ignore-count for the breakpoint that
the program stopped at, by means of an argument to the `cont' command. 
*Note Conditions::.

   If the program stopped because of a signal other than `SIGINT' or
`SIGTRAP', continuing will cause the program to see that signal.  You
may not want this to happen.  For example, if the program stopped due
to some sort of memory reference error, you might store correct values
into the erroneous variables and continue, hoping to see more
execution; but the program would probably terminate immediately as a
result of the fatal signal once it sees the signal.  To prevent this,
you can continue with `signal 0'.  *Note Signaling::.  You can also
act in advance to prevent the program from seeing certain kinds of
signals, using the `handle' command (*note Signals::.).


File: gdb,  Node: Stepping,  Prev: Continuing,  Up: Stopping

Stepping
========

   "Stepping" means setting your program in motion for a limited time,
so that control will return automatically to the debugger after one
line of code or one machine instruction.  Breakpoints are active
during stepping and the program will stop for them even if it has not
gone as far as the stepping command specifies.

`step'
     Continue running the program until control reaches a different
     line, then stop it and return control to the debugger.  This
     command is abbreviated `s'.

     This command may be given when control is within a function for
     which there is no debugging information.  In that case, execution
     will proceed until control reaches a different function, or is
     about to return from this function.  An argument repeats this
     action.

`step COUNT'
     Continue running as in `step', but do so COUNT times.  If a
     breakpoint is reached or a signal not related to stepping occurs
     before COUNT steps, stepping stops right away.

`next'
     Similar to `step', but any function calls appearing within the
     line of code are executed without stopping.  Execution stops when
     control reaches a different line of code at the stack level which
     was executing when the `next' command was given.  This command is
     abbreviated `n'.

     An argument is a repeat count, as in `step'.

     `next' within a function without debugging information acts as
     does `step', but any function calls appearing within the code of
     the function are executed without stopping.

`finish'
     Continue running until just after the selected stack frame
     returns (or until there is some other reason to stop, such as a
     fatal signal or a breakpoint).  Print value returned by the
     selected stack frame (if any).

     Contrast this with the `return' command (*note Returning::.).

`until'
     This command is used to avoid single stepping through a loop more
     than once.  It is like the `next' command, except that when
     `until' encounters a jump, it automatically continues execution
     until the program counter is greater than the address of the jump.

     This means that when you reach the end of a loop after single
     stepping though it, `until' will cause the program to continue
     execution until the loop is exited.  In contrast, a `next'
     command at the end of a loop will simply step back to the
     beginning of the loop, which would force you to step through the
     next iteration.

     `until' always stops the program if it attempts to exit the
     current stack frame.

     `until' may produce somewhat counterintuitive results if the order
     of the source lines does not match the actual order of execution.
      For example, in a typical C `for'-loop, the third expression in
     the `for'-statement (the loop-step expression) is executed after
     the statements in the body of the loop, but is written before
     them.  Therefore, the `until' command would appear to step back
     to the beginning of the loop when it advances to this expression.
      However, it has not really done so, not in terms of the actual
     machine code.

     Note that `until' with no argument works by means of single
     instruction stepping, and hence is slower than `until' with an
     argument.

`until LOCATION'
     Continue running the program until either the specified location
     is reached, or the current (innermost) stack frame returns.  This
     form of the command uses breakpoints, and hence is quicker than
     `until' without an argument.

`stepi'
`si'
     Execute one machine instruction, then stop and return to the
     debugger.

     It is often useful to do `display/i $pc' when stepping by machine
     instructions.  This will cause the next instruction to be
     executed to be displayed automatically at each stop.  *Note Auto
     Display::.

     An argument is a repeat count, as in `step'.

`nexti'
`ni'
     Execute one machine instruction, but if it is a subroutine call,
     proceed until the subroutine returns.

     An argument is a repeat count, as in `next'.

   A typical technique for using stepping is to put a breakpoint
(*note Breakpoints::.) at the beginning of the function or the section
of the program in which a problem is believed to lie, and then step
through the suspect area, examining the variables that are
interesting, until the problem happens.

   The `cont' command can be used after stepping to resume execution
until the next breakpoint or signal.


File: gdb,  Node: Stack,  Next: Source,  Prev: Stopping,  Up: Top

Examining the Stack
*******************

   When your program has stopped, the first thing you need to know is
where it stopped and how it got there.

   Each time your program performs a function call, the information
about where in the program the call was made from is saved in a block
of data called a "stack frame".  The frame also contains the arguments
of the call and the local variables of the function that was called. 
All the stack frames are allocated in a region of memory called the
"call stack".

   When your program stops, the GDB commands for examining the stack
allow you to see all of this information.

   One of the stack frames is "selected" by GDB and many GDB commands
refer implicitly to the selected frame.  In particular, whenever you
ask GDB for the value of a variable in the program, the value is found
in the selected frame.  There are special GDB commands to select
whichever frame you are interested in.

   When the program stops, GDB automatically selects the currently
executing frame and describes it briefly as the `frame' command does
(*note Info: Frame Info.).

* Menu:

* Frames::          Explanation of stack frames and terminology.
* Backtrace::       Summarizing many frames at once.
* Selection::       How to select a stack frame.
* Info: Frame Info, Commands to print information on stack frames.


File: gdb,  Node: Frames,  Next: Backtrace,  Prev: Stack,  Up: Stack

Stack Frames
============

   The call stack is divided up into contiguous pieces called "stack
frames", or "frames" for short; each frame is the data associated with
one call to one function.  The frame contains the arguments given to
the function, the function's local variables, and the address at which
the function is executing.

   When your program is started, the stack has only one frame, that of
the function `main'.  This is called the "initial" frame or the
"outermost" frame.  Each time a function is called, a new frame is
made.  Each time a function returns, the frame for that function
invocation is eliminated.  If a function is recursive, there can be
many frames for the same function.  The frame for the function in
which execution is actually occurring is called the "innermost" frame.
 This is the most recently created of all the stack frames that still
exist.

   Inside your program, stack frames are identified by their
addresses.  A stack frame consists of many bytes, each of which has
its own address; each kind of computer has a convention for choosing
one of those bytes whose address serves as the address of the frame. 
Usually this address is kept in a register called the "frame pointer
register" while execution is going on in that frame.

   GDB assigns numbers to all existing stack frames, starting with
zero for the innermost frame, one for the frame that called it, and so
on upward.  These numbers do not really exist in your program; they
are to give you a way of talking about stack frames in GDB commands.

   Many GDB commands refer implicitly to one stack frame.  GDB records
a stack frame that is called the "selected" stack frame; you can
select any frame using one set of GDB commands, and then other
commands will operate on that frame.  When your program stops, GDB
automatically selects the innermost frame.

   Some functions can be compiled to run without a frame reserved for
them on the stack.  This is occasionally done with heavily used library
functions to save the frame setup time.  GDB has limited facilities for
dealing with these function invocations; if the innermost function
invocation has no stack frame, GDB will give it a virtual stack frame
of 0 and correctly allow tracing of the function call chain.  Results
are undefined if a function invocation besides the innermost one is
frameless.


File: gdb,  Node: Backtrace,  Next: Selection,  Prev: Frames,  Up: Stack

Backtraces
==========

   A backtrace is a summary of how the program got where it is.  It
shows one line per frame, for many frames, starting with the currently
executing frame (frame zero), followed by its caller (frame one), and
on up the stack.

`backtrace'
`bt'
     Print a backtrace of the entire stack: one line per frame for all
     frames in the stack.

     You can stop the backtrace at any time by typing the system
     interrupt character, normally `Control-C'.

`backtrace N'
`bt N'
     Similar, but print only the innermost N frames.

`backtrace -N'
`bt -N'
     Similar, but print only the outermost N frames.

   The names `where' and `info stack' are additional aliases for
`backtrace'.

   Every line in the backtrace shows the frame number, the function
name and the program counter value.

   If the function is in a source file whose symbol table data has been
fully read, the backtrace shows the source file name and line number,
as well as the arguments to the function.  (The program counter value
is omitted if it is at the beginning of the code for that line number.)

   If the source file's symbol data has not been fully read, just
scanned, this extra information is replaced with an ellipsis.  You can
force the symbol data for that frame's source file to be read by
selecting the frame.  (*Note Selection::).

   Here is an example of a backtrace.  It was made with the command
`bt 3', so it shows the innermost three frames.

     #0  rtx_equal_p (x=(rtx) 0x8e58c, y=(rtx) 0x1086c4)
     (/gp/rms/cc/rtlanal.c line 337)
     #1  0x246b0 in expand_call (...) (...)
     #2  0x21cfc in expand_expr (...) (...)
     (More stack frames follow...)

The functions `expand_call' and `expand_expr' are in a file whose
symbol details have not been fully read.  Full detail is available for
the function `rtx_equal_p', which is in the file `rtlanal.c'.  Its
arguments, named `x' and `y', are shown with their typed values.


File: gdb,  Node: Selection,  Next: Frame Info,  Prev: Backtrace,  Up: Stack

Selecting a Frame
=================

   Most commands for examining the stack and other data in the program
work on whichever stack frame is selected at the moment.  Here are the
commands for selecting a stack frame; all of them finish by printing a
brief description of the stack frame just selected.

`frame N'
     Select frame number N.  Recall that frame zero is the innermost
     (currently executing) frame, frame one is the frame that called
     the innermost one, and so on.  The highest-numbered frame is
     `main''s frame.

`frame ADDR'
     Select the frame at address ADDR.  This is useful mainly if the
     chaining of stack frames has been damaged by a bug, making it
     impossible for GDB to assign numbers properly to all frames.  In
     addition, this can be useful when the program has multiple stacks
     and switches between them.

`up N'
     Select the frame N frames up from the frame previously selected. 
     For positive numbers N, this advances toward the outermost frame,
     to higher frame numbers, to frames that have existed longer.  N
     defaults to one.

`down N'
     Select the frame N frames down from the frame previously
     selected.  For positive numbers N, this advances toward the
     innermost frame, to lower frame numbers, to frames that were
     created more recently.  N defaults to one.

   All of these commands end by printing some information on the frame
that has been selected: the frame number, the function name, the
arguments, the source file and line number of execution in that frame,
and the text of that source line.  For example:

     #3  main (argc=3, argv=??, env=??) at main.c, line 67
     67        read_input_file (argv[i]);

   After such a printout, the `list' command with no arguments will
print ten lines centered on the point of execution in the frame. 
*Note List::.


File: gdb,  Node: Frame Info,  Prev: Selection,  Up: Stack

Information on a Frame
======================

   There are several other commands to print information about the
selected stack frame.

`frame'
     This command prints a brief description of the selected stack
     frame.  It can be abbreviated `f'.  With an argument, this
     command is used to select a stack frame; with no argument, it
     does not change which frame is selected, but still prints the
     same information.

`info frame'
     This command prints a verbose description of the selected stack
     frame, including the address of the frame, the addresses of the
     next frame in (called by this frame) and the next frame out
     (caller of this frame), the address of the frame's arguments, the
     program counter saved in it (the address of execution in the
     caller frame), and which registers were saved in the frame.  The
     verbose description is useful when something has gone wrong that
     has made the stack format fail to fit the usual conventions.

`info frame ADDR'
     Print a verbose description of the frame at address ADDR, without
     selecting that frame.  The selected frame remains unchanged by
     this command.

`info args'
     Print the arguments of the selected frame, each on a separate
     line.

`info locals'
     Print the local variables of the selected frame, each on a
     separate line.  These are all variables declared static or
     automatic within all program blocks that execution in this frame
     is currently inside of.


File: gdb,  Node: Source,  Next: Data,  Prev: Stack,  Up: Top

Examining Source Files
**********************

   GDB knows which source files your program was compiled from, and
can print parts of their text.  When your program stops, GDB
spontaneously prints the line it stopped in.  Likewise, when you
select a stack frame (*note Selection::.), GDB prints the line which
execution in that frame has stopped in.  You can also print parts of
source files by explicit command.

* Menu:

* List::        Using the `list' command to print source files.
* Search::      Commands for searching source files.
* Source Path:: Specifying the directories to search for source files.


File: gdb,  Node: List,  Next: Search,  Prev: Source,  Up: Source

Printing Source Lines
=====================

   To print lines from a source file, use the `list' command
(abbreviated `l').  There are several ways to specify what part of the
file you want to print.

   Here are the forms of the `list' command most commonly used:

`list LINENUM'
     Print ten lines centered around line number LINENUM in the
     current source file.

`list FUNCTION'
     Print ten lines centered around the beginning of function
     FUNCTION.

`list'
     Print ten more lines.  If the last lines printed were printed
     with a `list' command, this prints ten lines following the last
     lines printed; however, if the last line printed was a solitary
     line printed as part of displaying a stack frame (*note
     Stack::.), this prints ten lines centered around that line.

`list -'
     Print ten lines just before the lines last printed.

   Repeating a `list' command with RET discards the argument, so it is
equivalent to typing just `list'.  This is more useful than listing
the same lines again.  An exception is made for an argument of `-';
that argument is preserved in repetition so that each repetition moves
up in the file.

   In general, the `list' command expects you to supply zero, one or
two "linespecs".  Linespecs specify source lines; there are several
ways of writing them but the effect is always to specify some source
line.  Here is a complete description of the possible arguments for
`list':

`list LINESPEC'
     Print ten lines centered around the line specified by LINESPEC.

`list FIRST,LAST'
     Print lines from FIRST to LAST.  Both arguments are linespecs.

`list ,LAST'
     Print ten lines ending with LAST.

`list FIRST,'
     Print ten lines starting with FIRST.

`list +'
     Print ten lines just after the lines last printed.

`list -'
     Print ten lines just before the lines last printed.

`list'
     As described in the preceding table.

   Here are the ways of specifying a single source line--all the kinds
of linespec.

`LINENUM'
     Specifies line LINENUM of the current source file.  When a `list'
     command has two linespecs, this refers to the same source file as
     the first linespec.

`+OFFSET'
     Specifies the line OFFSET lines after the last line printed. 
     When used as the second linespec in a `list' command that has
     two, this specifies the line OFFSET lines down from the first
     linespec.

`-OFFSET'
     Specifies the line OFFSET lines before the last line printed.

`FILENAME:LINENUM'
     Specifies line LINENUM in the source file FILENAME.

`FUNCTION'
     Specifies the line of the open-brace that begins the body of the
     function FUNCTION.

`FILENAME:FUNCTION'
     Specifies the line of the open-brace that begins the body of the
     function FUNCTION in the file FILENAME.  The file name is needed
     with a function name only for disambiguation of identically named
     functions in different source files.

`*ADDRESS'
     Specifies the line containing the program address ADDRESS. 
     ADDRESS may be any expression.

   One other command is used to map source lines to program addresses.

`info line LINENUM'
     Print the starting and ending addresses of the compiled code for
     source line LINENUM.

     The default examine address for the `x' command is changed to the
     starting address of the line, so that `x/i' is sufficient to
     begin examining the machine code (*note Memory::.).  Also, this
     address is saved as the value of the convenience variable `$_'
     (*note Convenience Vars::.).


File: gdb,  Node: Search,  Next: Source Path,  Prev: List,  Up: Source

Searching Source Files
======================

   There are two commands for searching through the current source
file for a regular expression.

   The command `forward-search REGEXP' checks each line, starting with
the one following the last line listed, for a match for REGEXP.  It
lists the line that is found.  You can abbreviate the command name as
`fo'.

   The command `reverse-search REGEXP' checks each line, starting with
the one before the last line listed and going backward, for a match
for REGEXP.  It lists the line that is found.  You can abbreviate this
command with as little as `rev'.


File: gdb,  Node: Source Path,  Prev: Search,  Up: Source

Specifying Source Directories
=============================

   Executable programs do not record the directories of the source
files from which they were compiled, just the names.  GDB remembers a
list of directories to search for source files; this is called the
"source path".  Each time GDB wants a source file, it tries all the
directories in the list, in the order they are present in the list,
until it finds a file with the desired name.  Note that the executable
search path is not used for this purpose.  Neither is the current
working directory, unless it happens to be in the source path.

   When you start GDB, its source path contains just the current
working directory.  To add other directories, use the `directory'
command.

`directory DIRNAMES...'
     Add directory DIRNAME to the end of the source path.  Several
     directory names may be given to this command, separated by
     whitespace or `:'.

`directory'
     Reset the source path to just the current working directory of
     GDB.  This requires confirmation.

     Since this command deletes directories from the search path, it
     may change the directory in which a previously read source file
     will be discovered.  To make this work correctly, this command
     also clears out the tables GDB maintains about the source files
     it has already found.

`info directories'
     Print the source path: show which directories it contains.

   Because the `directory' command adds to the end of the source path,
it does not affect any file that GDB has already found.  If the source
path contains directories that you do not want, and these directories
contain misleading files with names matching your source files, the
way to correct the situation is as follows:

  1. Choose the directory you want at the beginning of the source path. 
     Use the `cd' command to make that the current working directory.

  2. Use `directory' with no argument to reset the source path to just
     that directory.

  3. Use `directory' with suitable arguments to add any other
     directories you want in the source path.


File: gdb,  Node: Data,  Next: Symbols,  Prev: Source,  Up: Top

Examining Data
**************

   The usual way to examine data in your program is with the `print'
command (abbreviated `p').  It evaluates and prints the value of any
valid expression of the language the program is written in (for now,
C).  You type

     print EXP

where EXP is any valid expression, and the value of EXP is printed in
a format appropriate to its data type.

   A more low-level way of examining data is with the `x' command.  It
examines data in memory at a specified address and prints it in a
specified format.

* Menu:

* Expressions::      Expressions that can be computed and printed.
* Variables::        Using your program's variables in expressions.
* Assignment::       Setting your program's variables.
* Arrays::           Examining part of memory as an array.
* Format Options::   Controlling how structures and arrays are printed.
* Output formats::   Specifying formats for printing values.
* Memory::           Examining memory explicitly.
* Auto Display::     Printing certain expressions whenever program stops.
* Value History::    Referring to values previously printed.
* Convenience Vars:: Giving names to values for future reference.
* Registers::        Referring to and storing in machine registers.


File: gdb,  Node: Expressions,  Next: Variables,  Prev: Data,  Up: Data

Expressions
===========

   Many different GDB commands accept an expression and compute its
value.  Any kind of constant, variable or operator defined by the
programming language you are using is legal in an expression in GDB. 
This includes conditional expressions, function calls, casts and
string constants.  It unfortunately does not include symbols defined
by preprocessor `#define' commands.

   Casts are supported in all languages, not just in C, because it is
so useful to cast a number into a pointer so as to examine a structure
at that address in memory.

   GDB supports three kinds of operator in addition to those of
programming languages:

`@'
     `@' is a binary operator for treating parts of memory as arrays. 
     *Note Arrays::, for more information.

`::'
     `::' allows you to specify a variable in terms of the file or
     function it is defined in.  *Note Variables::.

`{TYPE} ADDR'
     Refers to an object of type TYPE stored at address ADDR in
     memory.  ADDR may be any expression whose value is an integer or
     pointer (but parentheses are required around nonunary operators,
     just as in a cast).  This construct is allowed regardless of what
     kind of data is officially supposed to reside at ADDR.


File: gdb,  Node: Variables,  Next: Arrays,  Prev: Expressions,  Up: Data

Program Variables
=================

   The most common kind of expression to use is the name of a variable
in your program.

   Variables in expressions are understood in the selected stack frame
(*note Selection::.); they must either be global (or static) or be
visible according to the scope rules of the programming language from
the point of execution in that frame.  This means that in the function

     foo (a)
          int a;
     {
       bar (a);
       {
         int b = test ();
         bar (b);
       }
     }

the variable `a' is usable whenever the program is executing within
the function `foo', but the variable `b' is visible only while the
program is executing inside the block in which `b' is declared.

   As a special exception, you can refer to a variable or function
whose scope is a single source file even if the current execution
point is not in this file.  But it is possible to have more than one
such variable or function with the same name (if they are in different
source files).  In such a case, it is not defined which one you will
get.  If you wish, you can specify any one of them using the
colon-colon construct:

     BLOCK::VARIABLE

Here BLOCK is the name of the source file whose variable you want.


File: gdb,  Node: Arrays,  Next: Format options,  Prev: Variables,  Up: Data

Artificial Arrays
=================

   It is often useful to print out several successive objects of the
same type in memory; a section of an array, or an array of dynamically
determined size for which only a pointer exists in the program.

   This can be done by constructing an "artificial array" with the
binary operator `@'.  The left operand of `@' should be the first
element of the desired array, as an individual object.  The right
operand should be the length of the array.  The result is an array
value whose elements are all of the type of the left argument.  The
first element is actually the left argument; the second element comes
from bytes of memory immediately following those that hold the first
element, and so on.  Here is an example.  If a program says

     int *array = (int *) malloc (len * sizeof (int));

you can print the contents of `array' with

     p *array@len

   The left operand of `@' must reside in memory.  Array values made
with `@' in this way behave just like other arrays in terms of
subscripting, and are coerced to pointers when used in expressions. 
(It would probably appear in an expression via the value history,
after you had printed it out.)


File: gdb,  Node: Format options,  Next: Output formats,  Prev: Arrays,  Up: Data

Format options
==============

   GDB provides a few ways to control how arrays and structures are
printed.

`info format'
     Display the current settings for the format options.

`set array-max NUMBER-OF-ELEMENTS'
     If GDB is printing a large array, it will stop printing after it
     has printed the number of elements set by the `set array-max'
     command.  This limit also applies to the display of strings.

`set prettyprint on'
     Cause GDB to print structures in an indented format with one
     member per line, like this:

          $1 = {
            next = 0x0,
            flags = {
              sweet = 1,
              sour = 1
            },
            meat = 0x54 "Pork"
          }

`set prettyprint off'
     Cause GDB to print structures in a compact format, like this:

          $1 = {next = 0x0, flags = {sweet = 1, sour = 1},
          meat = 0x54 "Pork"}

          This is the default format.

`set unionprint on'
     Tell GDB to print unions which are contained in structures.  This
     is the default setting.

`set unionprint off'
     Tell GDB not to print unions which are contained in structures.

     For example, given the declarations

          typedef enum {Tree, Bug} Species;
          typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
          typedef enum {Caterpiller, Cocoon, Butterfly} Bug_forms;
          
          struct thing {
            Species it;
            union {
              Tree_forms tree;
              Bug_forms bug;
            } form;
          };
          
          struct thing foo = {Tree, {Acorn}};

          with `set unionprint on' in effect `p foo' would print

          $1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}

          and with `set unionprint off' in effect it would print

          $1 = {it = Tree, form = {...}}


File: gdb,  Node: Output formats,  Next: Memory,  Prev: Format options,  Up: Data

Output formats
==============

   GDB normally prints all values according to their data types. 
Sometimes this is not what you want.  For example, you might want to
print a number in hex, or a pointer in decimal.  Or you might want to
view data in memory at a certain address as a character string or an
instruction.  These things can be done with "output formats".

   The simplest use of output formats is to say how to print a value
already computed.  This is done by starting the arguments of the
`print' command with a slash and a format letter.  The format letters
supported are:

`x'
     Regard the bits of the value as an integer, and print the integer
     in hexadecimal.

`d'
     Print as integer in signed decimal.

`u'
     Print as integer in unsigned decimal.

`o'
     Print as integer in octal.

`a'
     Print as an address, both absolute in hex and then relative to a
     symbol defined as an address below it.

`c'
     Regard as an integer and print it as a character constant.

`f'
     Regard the bits of the value as a floating point number and print
     using typical floating point syntax.

   For example, to print the program counter in hex (*note
Registers::.), type

     p/x $pc

Note that no space is required before the slash; this is because
command names in GDB cannot contain a slash.

   To reprint the last value in the value history with a different
format, you can use the `print' command with just a format and no
expression.  For example, `p/x' reprints the last value in hex.


File: gdb,  Node: Memory,  Next: Auto Display,  Prev: Output formats,  Up: Data

Examining Memory
----------------

   The command `x' (for `examine') can be used to examine memory
without reference to the program's data types.  The format in which you
wish to examine memory is instead explicitly specified.  The allowable
formats are a superset of the formats described in the previous
section.

   `x' is followed by a slash and an output format specification,
followed by an expression for an address.  The expression need not have
a pointer value (though it may); it is used as an integer, as the
address of a byte of memory.  *Note Expressions:: for more information
on expressions.  For example, `x/4xw $sp' prints the four words of
memory above the stack pointer in hexadecimal.

   The output format in this case specifies both how big a unit of
memory to examine and how to print the contents of that unit.  It is
done with one or two of the following letters:

   These letters specify just the size of unit to examine:

`b'
     Examine individual bytes.

`h'
     Examine halfwords (two bytes each).

`w'
     Examine words (four bytes each).

     Many assemblers and cpu designers still use `word' for a 16-bit
     quantity, as a holdover from specific predecessor machines of the
     1970's that really did use two-byte words.  But more generally
     the term `word' has always referred to the size of quantity that
     a machine normally operates on and stores in its registers.  This
     is 32 bits for all the machines that GDB runs on.

`g'
     Examine giant words (8 bytes).

   These letters specify just the way to print the contents:

`x'
     Print as integers in unsigned hexadecimal.

`d'
     Print as integers in signed decimal.

`u'
     Print as integers in unsigned decimal.

`o'
     Print as integers in unsigned octal.

`a'
     Print as an address, both absolute in hex and then relative to a
     symbol defined as an address below it.

`c'
     Print as character constants.

`f'
     Print as floating point.  This works only with sizes `w' and `g'.

`s'
     Print a null-terminated string of characters.  The specified unit
     size is ignored; instead, the unit is however many bytes it takes
     to reach a null character (including the null character).

`i'
     Print a machine instruction in assembler syntax (or nearly).  The
     specified unit size is ignored; the number of bytes in an
     instruction varies depending on the type of machine, the opcode
     and the addressing modes used.

   If either the manner of printing or the size of unit fails to be
specified, the default is to use the same one that was used last.  If
you don't want to use any letters after the slash, you can omit the
slash as well.

   You can also omit the address to examine.  Then the address used is
just after the last unit examined.  This is why string and instruction
formats actually compute a unit-size based on the data: so that the
next string or instruction examined will start in the right place. 
The `print' command sometimes sets the default address for the `x'
command; when the value printed resides in memory, the default is set
to examine the same location.  `info line' also sets the default for
`x', to the address of the start of the machine code for the specified
line and `info breakpoints' sets it to the address of the last
breakpoint listed.

   When you use RET to repeat an `x' command, it does not repeat
exactly the same: the address specified previously (if any) is
ignored, so that the repeated command examines the successive
locations in memory rather than the same ones.

   You can examine several consecutive units of memory with one
command by writing a repeat-count after the slash (before the format
letters, if any).  The repeat count must be a decimal integer.  It has
the same effect as repeating the `x' command that many times except
that the output may be more compact with several units per line.  For
example,

     x/10i $pc

prints ten instructions starting with the one to be executed next in
the selected frame.  After doing this, you could print another ten
following instructions with

     x/10

in which the format and address are allowed to default.

   The addresses and contents printed by the `x' command are not put in
the value history because there is often too much of them and they
would get in the way.  Instead, GDB makes these values available for
subsequent use in expressions as values of the convenience variables
`$_' and `$__'.

   After an `x' command, the last address examined is available for use
in expressions in the convenience variable `$_'.  The contents of that
address, as examined, are available in the convenience variable `$__'.

   If the `x' command has a repeat count, the address and contents
saved are from the last memory unit printed; this is not the same as
the last address printed if several units were printed on the last
line of output.

   The specialized command `disassemble' is also provided to dump a
range of memory as machine instructions.  The default memory range is
the function surrounding the program counter of the selected frame.  A
single argument to this command is a program counter value; the
function surrounding this value will be dumped.  Two arguments specify
a range of addresss (first inclusive, second exclusive) to be dumped.


File: gdb,  Node: Auto Display,  Next: Value History,  Prev: Memory,  Up: Data

Automatic Display
=================

   If you find that you want to print the value of an expression
frequently (to see how it changes), you might want to add it to the
"automatic display list" so that GDB will print its value each time
the program stops.  Each expression added to the list is given a
number to identify it; to remove an expression from the list, you
specify that number.  The automatic display looks like this:

     2: foo = 38
     3: bar[5] = (struct hack *) 0x3804

showing item numbers, expressions and their current values.

   If the expression refers to local variables, then it does not make
sense outside the lexical context for which it was set up.  Such an
expression is printed only when execution is inside that lexical
context.  For example, if you give the command `display name' while
inside a function with an argument `name', then this argument will be
displayed whenever the program stops inside that function, but not when
it stops elsewhere (since this argument doesn't exist elsewhere).

`display EXP'
     Add the expression EXP to the list of expressions to display each
     time the program stops.  *Note Expressions::.

`display/FMT EXP'
     For FMT specifying only a display format and not a size or count,
     add the expression EXP to the auto-display list but arranges to
     display it each time in the specified format FMT.

`display/FMT ADDR'
     For FMT `i' or `s', or including a unit-size or a number of
     units, add the expression ADDR as a memory address to be examined
     each time the program stops.  Examining means in effect doing
     `x/FMT ADDR'.  *Note Memory::.

`undisplay DNUMS...'
`delete display DNUMS...'
     Remove item numbers DNUMS from the list of expressions to display.

`disable display DNUMS...'
     Disable the display of item numbers DNUMS.  A disabled display
     item is not printed automatically, but is not forgotten.  It may
     be reenabled later.

`enable display DNUMS...'
     Enable display of item numbers DNUMS.  It becomes effective once
     again in auto display of its expression, until you specify
     otherwise.

`display'
     Display the current values of the expressions on the list, just
     as is done when the program stops.

`info display'
     Print the list of expressions previously set up to display
     automatically, each one with its item number, but without showing
     the values.  This includes disabled expressions, which are marked
     as such.  It also includes expressions which would not be
     displayed right now because they refer to automatic variables not
     currently available.


File: gdb,  Node: Value History,  Next: Convenience Vars,  Prev: Auto Display,  Up: Data

Value History
=============

   Every value printed by the `print' command is saved for the entire
session in GDB's "value history" so that you can refer to it in other
expressions.

   The values printed are given "history numbers" for you to refer to
them by.  These are successive integers starting with 1.  `print'
shows you the history number assigned to a value by printing `$NUM = '
before the value; here NUM is the history number.

   To refer to any previous value, use `$' followed by the value's
history number.  The output printed by `print' is designed to remind
you of this.  Just `$' refers to the most recent value in the history,
and `$$' refers to the value before that.

   For example, suppose you have just printed a pointer to a structure
and want to see the contents of the structure.  It suffices to type

     p *$

   If you have a chain of structures where the component `next' points
to the next one, you can print the contents of the next one with this:

     p *$.next

It might be useful to repeat this command many times by typing RET.

   Note that the history records values, not expressions.  If the
value of `x' is 4 and you type this command:

     print x
     set x=5

then the value recorded in the value history by the `print' command
remains 4 even though the value of `x' has changed.

`info values'
     Print the last ten values in the value history, with their item
     numbers.  This is like `p $$9' repeated ten times, except that
     `info values' does not change the history.

`info values N'
     Print ten history values centered on history item number N.

`info values +'
     Print ten history values just after the values last printed.

