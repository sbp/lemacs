Info file ../info/emacs, produced by Makeinfo, -*- Text -*- from input
file lemacs.tex.

   This file documents the GNU Emacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992 Lucid, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: emacs,  Node: Representing Keystrokes,  Next: Key Sequences,  Prev: Keystrokes,  Up: Top

Representing Keystrokes
-----------------------

   Lucid GNU Emacs represents keystrokes as lists. Each list consists
of an arbitrary combination of modifiers followed by a single keysym
at the end of the list.  If the keysym corresponds to an ASCII
character, you can use its character code.  A keystroke may also be
represented by an event object, as returned by the
`next-command-event' and `read-key-sequence' functions.    The
following table gives some examples of how to list representations for
keystrokes.  Each list consists of sets of modifiers followed by
keysyms:

`(control a)'
     Pressing CTRL and `a' simultaneously.

`(control ?a)'
     Another way of writing the keystroke `C-a'.

`(control 65)'
     Yet another way of writing the keystroke `C-a'.

`(break)'
     Pressing the BREAK key.

`(control meta button2up)'
     Release the middle mouse button, while pressing CTRL and META.

   Note: As you define keystrokes, you can use the `Shift' key only as
a modifier with characters that do not have a second keysym on the
same key, such as `Backspace' and `tab'.  It is an error to define a
keystroke using the shift modifier with keysyms such as `a' and `='. 
The correct forms are `A' and `+'.


File: emacs,  Node: Key Sequences,  Next: String Key Sequences,  Prev: Representing Keystrokes,  Up: Keystrokes

Representing Key Sequences
--------------------------

   A "complete key sequence" is a sequence of keystrokes that Emacs
understands as a unit.  Key sequences are significant because you can
bind them to commands.  Note that not all sequences of keystrokes are
possible key sequences.  In particular, the initial keystrokes in a key
sequence must make up a "prefix key sequence".

   Emacs represents a key sequence as a vector of keystrokes.  Thus,
the schematic representation of a complete key sequence is as follows:

       [(modifier .. modifer keysym) ... (modifier .. modifier keysym)]

   Here are some examples of complete key sequences:

`[(control c) (control a)]'
     Hitting `C-c' followed by `C-a'

`[(control c) (control 65)]'
     Hitting `C-c' followed by `C-a'. (Using the ASCII code for the
     character `a')

`[(control c)(break)]'
     Hitting `C-c' followed by the `Break' character.

   A "prefix key sequence" is the beginning of a series of longer
sequences that are valid key sequences; adding any single keystroke to
the end of a prefix results in a valid key sequence.  For example,
`(Control-x)' is standardly defined as a prefix.  Thus, there is a
two-character key sequence starting with `C-x' for each valid
keystroke, giving numerous possibilities.  Here are some samples:

   * `[(control x)(c)]'

   * `[(control x)(control c)]'

   Adding one character to a prefix key does not have to form a
complete key.  It could make another, longer prefix.  For example,
`[(control x) (\4)]' is itself a prefix that leads to any number of
different three-character keys, including `[(control x) (\4) (f)]',
`[(control x) (\4)(b)]' and so on.  It would be possible to define one
of those three-character sequences as a prefix, creating a series of
four-character keys, but we did not define any of them this way.

   By contrast, the two-character sequence `[(control f) (control k)]'
is not a key, because the `(control f)' is a complete key in itself. 
It's impossible to give `[(control f (control k)]' an independent
meaning as a command as long as `(control f)' retains its meaning,
because what we have is really two commands.

   The predefined prefix key sequences in Emacs are `(control c)',
`(control x)', `(control h)', `[(control x) (\4)]', and `Escape'.  You
can customize Emacs, and could make new prefix keys, or eliminate the
default key sequences.  *Note Key Bindings::.

   Whether a particular key sequence is valid can be changed by
customization.  For example, if you redefine `(control f)' as a
prefix, `[(control f)(control k)]' automatically becomes a valid key
sequence (complete, unless you define it as a prefix as well). 
Conversely, if you remove the prefix definition of `[(control x)
(\4)]', `[(control x)(\4) (f)]' (or `[(control x)(\4) ANYTHING]') is
no longer a valid key sequence.

   Note that, the above paragraphs uses \4 instead of simply 4,
because \4 is the symbol whose name is "4", and plain 4 is the integer
4, which would have been interpreted as the ASCII value.  Another way
of representing the symbol whose name is "4" is to write ?4, which
would be interpreted as the number 52, which is the ASCII code for the
character "4".  We could therefore actually have written 52 directly
but that is far less clear.


File: emacs,  Node: String Key Sequences,  Next: Meta Key,  Prev: Key Sequences,  Up: Keystrokes

String Key Sequences
--------------------

   For backward compatibility, you may also represent a key sequence
using strings.  For example, we have the following equivalent
representations:

`"\C-c\C-c"'
     `[(control c)(control c)]'

`"\e\C-c"'
     `[(meta control c)]'

* Menu:

* Meta Key:: Assignment of the META Key
* Super and Hyper Keys:: Assignment of the SUPER and HYPER Keys


File: emacs,  Node: Meta Key,  Next: Super and Hyper Keys,  Prev: String Key Sequences,  Up: Keystrokes

Assignment of the META Key
--------------------------

   Not all terminals have the complete set of modifiers.  For example,
terminals that have a Meta key allow you to type Meta characters by
just holding that key down.  To type `Meta-a', hold down META and
press `a'.  On those terminals, the META key works like the SHIFT key.
 Such a key is not always labeled META, however, as this function is
often a special option for a key with some other primary purpose.

   If there is no META key, you can still type Meta characters using
two-character sequences starting with ESC.  To enter `Meta-a', you
could type `ESC a'.  To enter `C-M-a', you would type `C-Esc-a'.  ESC
is allowed on terminals with Meta keys, too, in case you have formed a
habit of using it.

   Emacs believes the terminal has a META key if the variable
`meta-flag' is non-`nil'.  Normally this is set automatically
according to the termcap entry for your terminal type.  However,
sometimes the termcap entry is wrong, and then it is useful to set
this variable yourself.  *Note Variables::, for how to do this.

   Note: If you are running under the X window system, the setting of
the `meta-flag' variable is irrelevant.


File: emacs,  Node: Super and Hyper Keys,  Next: Character Representation,  Prev: Meta Key,  Up: Keystrokes

Assignment of the SUPER and HYPER Keys
--------------------------------------

   Most keyboards do not, by default, have SUPER or HYPER modifier
keys.  Under X, you can simulate the SUPER or HYPER key if you want to
bind keys to sequences using `Super' and `Hyper'.  You can use the
`xmodmap' program to do this.

   For example, to turn your CAPS-LOCK key into a SUPER key, do the
following:

   Create a file called `~/.xmodmap'.  In this file, place the lines

     	keysym Caps_Lock = Super_L
     	add Mod2 = Super_L

   The first line says that the key that is currently called
`Caps_Lock' should now be called `Super_L' instead.  The second line
says that the key called `Super_L' should be a modifier key, which
produces the `Mod2' modifier.  Emacs recognizes `Mod1' as META, `Mod2'
as SUPER and `Mod3' as HYPER.

   Just after you start up X, execute the command `xmodmap
~/.xmodmap'.  You can add this command to the appropriate
initialization file to have the command executed automatically.


File: emacs,  Node: Key Bindings,  Next: Syntax,  Prev: Keyboard Macros,  Up: Customization

Customizing Key Bindings
========================

   This section deals with the "keymaps" which define the bindings
between keys and functions, and shows how you can customize these
bindings.

   A command is a Lisp function whose definition provides for
interactive use.  Like every Lisp function, a command has a function
name, a Lisp symbol whose name usually consists of lower case letters
and hyphens.

* Menu:

* Keymaps::    Definition of the keymap data structure.
               Names of Emacs's standard keymaps.
* Rebinding::  How to redefine one key's meaning conveniently.
* Disabling::  Disabling a command means confirmation is required
                before it can be executed.  This is done to protect
                beginners from surprises.


File: emacs,  Node: Keymaps,  Next: Disabling,  Up: Key Bindings

Keymaps
-------

   The bindings between characters and command functions are recorded
in data structures called "keymaps".  Emacs has many of these.  One,
the "global" keymap, defines the meanings of the single-character keys
that are defined regardless of major mode.  It is the value of the
variable `global-map'.

   Each major mode has another keymap, its "local keymap", which
contains overriding definitions for the single-character keys that are
redefined in that mode.  Each buffer records which local keymap is
installed for it at any time, and the current buffer's local keymap is
the only one that directly affects command execution.  The local
keymaps for Lisp mode, C mode, and many other major modes always exist
even when not in use.  They are the values of the variables
`lisp-mode-map', `c-mode-map', and so on.  For less frequently used
major modes, the local keymap is sometimes constructed only when the
mode is used for the first time in a session, to save space.

   There are local keymaps for the minibuffer too; they contain various
completion and exit commands.

   * `minibuffer-local-map' is used for ordinary input (no completion).

   * `minibuffer-local-ns-map' is similar, except that SPC exits just
     like RET.  This is used mainly for Mocklisp compatibility.

   * `minibuffer-local-completion-map' is for permissive completion.

   * `minibuffer-local-must-match-map' is for strict completion and
     for cautious completion.

   * `repeat-complex-command-map' is for use in `C-x ESC'.

   Finally, each prefix key has a keymap which defines the key
sequences that start with it.  For example, `ctl-x-map' is the keymap
used for characters following a `C-x'.

   * `ctl-x-map' is the variable name for the map used for characters
     that follow `C-x'.

   * `help-map' is used for characters that follow `C-h'.

   * `esc-map' is for characters that follow ESC.  All Meta characters
     are actually defined by this map.

   * `ctl-x-4-map' is for characters that follow `C-x 4'.

   * `mode-specific-map' is for characters that follow `C-c'.

   The definition of a prefix key is the keymap to use for looking up
the following character.  Sometimes, the definition is actually a Lisp
symbol whose function definition is the following character keymap. 
The effect is the same, but it provides a command name for the prefix
key that you can use as a description of what the prefix key is for. 
Thus, the binding of `C-x' is the symbol `Ctl-X-Prefix', whose function
definition is the keymap for `C-x' commands, the value of `ctl-x-map'.

   Prefix key definitions can appear in either the global map or a
local map.  The definitions of `C-c', `C-x', `C-h' and ESC as prefix
keys appear in the global map, so these prefix keys are always
available.  Major modes can locally redefine a key as a prefix by
putting a prefix key definition for it in the local map.

   A mode can also put a prefix definition of a global prefix
character such as `C-x' into its local map.  This is how major modes
override the definitions of certain keys that start with `C-x'.  This
case is special, because the local definition does not entirely
replace the global one.  When both the global and local definitions of
a key are other keymaps, the next character is looked up in both
keymaps, with the local definition overriding the global one.  So, the
character after the `C-x' is looked up in both the major mode's own
keymap for redefined `C-x' commands and in `ctl-x-map'.  If the major
mode's own keymap for `C-x' commands contains `nil', the definition
from the global keymap for `C-x' commands is used.

* Menu:

* Rebinding::                 Changing Key Bindings Interactively
* Programmatic Rebinding::    Changing Key Bindings Programmatically
* Key Bindings Using Strings::Using Strings for Changings Key Bindings


File: emacs,  Node: Rebinding,  Next: Programmatic Rebinding,  Prev: Keymaps,  Up: Keymaps

Changing Key Bindings Interactively
-----------------------------------

   You can redefine an Emacs key by changing its entry in a keymap. 
You can change the global keymap, in which case the change is
effective in all major modes except those that have their own
overriding local definitions for the same key.  Or you can change the
current buffer's local map, which affects all buffers using the same
major mode.

`M-x global-set-key RET KEY CMD RET'
     Defines KEY globally to run CMD.

`M-x local-set-key RET KEY CMD RET'
     Defines KEY locally (in the major mode now in effect) to run CMD.

   For example,

     M-x global-set-key RET C-f next-line RET

redefines `C-f' to move down a line.  The fact that CMD is read second
makes it serve as a kind of confirmation for KEY.

   These functions offer no way to specify a particular prefix keymap
as the one to redefine in, but that is not necessary, as you can
include prefixes in KEY.  KEY is read by reading characters one by one
until they amount to a complete key (that is, not a prefix key). 
Thus, if you type `C-f' for KEY, Emacs enters the minibuffer
immediately to read CMD.  But if you type `C-x', another character is
read; if that character is `4', another character is read, and so on. 
For example,

     M-x global-set-key RET C-x 4 $ spell-other-window RET

redefines `C-x 4 $' to run the (fictitious) command
`spell-other-window'.

   The most general way to modify a keymap is the function
`define-key', used in Lisp code (such as your `.emacs' file). 
`define-key' takes three arguments: the keymap, the key to modify in
it, and the new definition.  *Note Init File::, for an example. 
`substitute-key-definition' is used similarly; it takes three
arguments, an old definition, a new definition and a keymap, and
redefines in that keymap all keys that were previously defined with the
old definition to have the new definition instead.


File: emacs,  Node: Programmatic Rebinding,  Next: Key Bindings Using Strings,  Prev: Rebinding,  Up: Keymaps

Changing Key Bindings Programmatically
--------------------------------------

   You can use the functions `global-set-key' and `define-key' to
rebind keys under program control.

``(global-set-key KEY-SEQUENCE CMD)''
     Defines KEY-SEQUENCE globally to run CMD.

``(define-key KEYMAP KEY-SEQUENCE DEF)''
     Defines KEY-SEQUENCE to run CMD in the keymap KEYMAP.

   For backward compatibility, Lucid GNU Emacs allows you to specify
key sequences as strings.  However, the preferred method is to use the
representations of key sequences as vectors of keystrokes.  *Note
Keystrokes::, for more information about the rules for constructing
key sequences.

   Emacs allows you to abbreviate representations for key sequences in
most places where there is no ambiguity.  Here are some rules for
abbreviation:

   * The keysym by itself is equivalent to a list of just that keysym,
     i.e.  `f1' is equivalent to `(f1)'.

   * A keystroke by itself is equivalent to a vector containing just
     that keystroke, i.e.  `(control a)' is equivalent to `[(control
     a)]'

   * You can use ASCII codes for keysyms that have them. i.e.  `65' is
     equivalent to `A'. (This is not so much an abbreviation as an
     alternate representation.)

   Here are some examples of programmatically binding keys:


     ;;;  Bind `my-command' to f1
     
     (global-set-key 'f1 'my-command)
     
     ;;;  Bind `my-command' to `Shift-f1'
     (global-set-key '(shift f1) 'my-command)
     
     ;;; Bind `my-command' to `C-c Shift-f1'
     (global-set-key '[(control c) (shift f1)] 'my-command)
     
     ;;; Bind `my-command' to the middle mouse button.
     (global-set-key 'button2 'my-command)
     
     ;;; Bind `my-command' to `META CTL Right Mouse Button'
     ;;; in the KEYMAP that is in force when you are running `dired'.
     (define-key dired-mode-map '(meta control button3) 'my-command)


File: emacs,  Node: Key Bindings Using Strings,  Prev: Programmatic Rebinding,  Up: Keymaps

   For backward compatibility, you can still use strings to represent
key sequences.  Thus you can use comands like the following:

     ;;; Bind `end-of-line' to `C-f'
     (global-set-key "\C-f" 'end-of-line)

   Note, however, that in some cases you may be binding more than one
key sequence by using a single command.  This situation can arise
because in ASCII,  i' and TAB have the same representation. 
Therefore, when Emacs sees:

     (global-set-key "\C-i" 'end-of-line)

   it is unclear whether the user intended to bind `C-i' or TAB.  The
solution Lucid GNU Emacs adopts is to bind both of these key sequences.

   Here is a table of pairs of key sequences that behave in a similar
fashion:

     	control h   backspace
             control l   clear
     	control i   tab
             control m   return
     	control j   linefeed
             control [   escape


File: emacs,  Node: Disabling,  Prev: Keymaps,  Up: Key Bindings

Disabling Commands
------------------

   Disabling a command marks it as requiring confirmation before it
can be executed.  The purpose of disabling a command is to prevent
beginning users from executing it by accident and being confused.

   The direct mechanism for disabling a command is to have a non-`nil'
`disabled' property on the Lisp symbol for the command.  These
properties are normally set by the user's `.emacs' file with Lisp
expressions such as

     (put 'delete-region 'disabled t)

   If the value of the `disabled' property is a string, that string is
included in the message printed when the command is used:

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

   You can disable a command either by editing the `.emacs' file
directly or with the command `M-x disable-command', which edits the
`.emacs' file for you.  *Note Init File::.

   When you attempt to invoke a disabled command interactively in
Emacs, a window is displayed containing the command's name, its
documentation, and some instructions on what to do next; then Emacs
asks for input saying whether to execute the command as requested,
enable it and execute, or cancel it.  If you decide to enable the
command, you are asked whether to do this permanently or just for the
current session.  Enabling permanently works by automatically editing
your `.emacs' file.  You can use `M-x enable-command' at any time to
enable any command permanently.

   Whether a command is disabled is independent of what key is used to
invoke it; it also applies if the command is invoked using `M-x'. 
Disabling a command has no effect on calling it as a function from Lisp
programs.


File: emacs,  Node: Syntax,  Next: Init File,  Prev: Key Bindings,  Up: Customization

The Syntax Table
================

   All the Emacs commands which parse words or balance parentheses are
controlled by the "syntax table".  The syntax table specifies which
characters are opening delimiters, which are parts of words, which are
string quotes, and so on.  Actually, each major mode has its own syntax
table (though sometimes related major modes use the same one) which it
installs in each buffer that uses that major mode.  The syntax table
installed in the current buffer is the one that all commands use, so we
call it "the" syntax table.  A syntax table is a Lisp object, a vector
of length 256 whose elements are numbers.

* Menu:

* Entry: Syntax Entry.    What the syntax table records for each character.
* Change: Syntax Change.  How to change the information.


File: emacs,  Node: Syntax Entry,  Next: Syntax Change,  Prev: Syntax,  Up: Syntax

Information about Each Character
--------------------------------

   The syntax table entry for a character is a number that encodes six
pieces of information:

   * The syntactic class of the character, represented as a small
     integer.

   * The matching delimiter, for delimiter characters only.  The
     matching delimiter of `(' is `)', and vice versa.

   * A flag saying whether the character is the first character of a
     two-character comment starting sequence.

   * A flag saying whether the character is the second character of a
     two-character comment starting sequence.

   * A flag saying whether the character is the first character of a
     two-character comment ending sequence.

   * A flag saying whether the character is the second character of a
     two-character comment ending sequence.

   The syntactic classes are stored internally as small integers, but
are usually described to or by the user with characters.  For example,
`(' is used to specify the syntactic class of opening delimiters. 
Here is a table of syntactic classes, with the characters that specify
them.

` '
     The class of whitespace characters.

`w'
     The class of word-constituent characters.

`_'
     The class of characters that are part of symbol names but not
     words.  This class is represented by `_' because the character `_'
     has this class in both C and Lisp.

`.'
     The class of punctuation characters that do not fit into any other
     special class.

`('
     The class of opening delimiters.

`)'
     The class of closing delimiters.

`''
     The class of expression-adhering characters.  These characters are
     part of a symbol if found within or adjacent to one, and are part
     of a following expression if immediately preceding one, but are
     like whitespace if surrounded by whitespace.

`"'
     The class of string-quote characters.  They match each other in
     pairs, and the characters within the pair all lose their syntactic
     significance except for the `\' and `/' classes of escape
     characters, which can be used to include a string-quote inside the
     string.

`$'
     The class of self-matching delimiters.  This is intended for TeX's
     `$', which is used both to enter and leave math mode.  Thus, a
     pair of matching `$' characters surround each piece of math mode
     TeX input.  A pair of adjacent `$' characters act like a single
     one for purposes of matching

`/'
     The class of escape characters that always just deny the following
     character its special syntactic significance.  The character
     after one of these escapes is always treated as alphabetic.

`\'
     The class of C-style escape characters.  In practice, these are
     treated just like `/'-class characters, because the extra
     possibilities for C escapes (such as being followed by digits)
     have no effect on where the containing expression ends.

`<'
     The class of comment-starting characters.  Only single-character
     comment starters (such as `;' in Lisp mode) are represented this
     way.

`>'
     The class of comment-ending characters.  Newline has this syntax
     in Lisp mode.

   The characters flagged as part of two-character comment delimiters
can have other syntactic functions most of the time.  For example, `/'
and `*' in C code, when found separately, have nothing to do with
comments.  The comment-delimiter significance overrides when the pair
of characters occur together in the proper order.  Only the list and
sexp commands use the syntax table to find comments; the commands
specifically for comments have other variables that tell them where to
find comments.  And the list and sexp commands notice comments only if
`parse-sexp-ignore-comments' is non-`nil'.  This variable is set to
`nil' in modes where comment-terminator sequences are liable to appear
where there is no comment; for example, in Lisp mode where the comment
terminator is a newline but not every newline ends a comment.


File: emacs,  Node: Syntax Change,  Next: Menu Customization,  Prev: Syntax Entry,  Up: Syntax

Altering Syntax Information
---------------------------

   It is possible to alter a character's syntax table entry by storing
a new number in the appropriate element of the syntax table, but it
would be hard to determine what number to use.  Emacs therefore
provides a command that allows you to specify the syntactic properties
of a character in a convenient way.

   `M-x modify-syntax-entry' is the command to change a character's
syntax.  It can be used interactively, and is also used by major modes
to initialize their own syntax tables.  Its first argument is the
character to change.  The second argument is a string that specifies
the new syntax.  When called from Lisp code, there is a third, optional
argument, which specifies the syntax table in which to make the
change.  If not supplied, or if this command is called interactively,
the third argument defaults to the current buffer's syntax table.

  1. The first character in the string specifies the syntactic class. 
     It is one of the characters in the previous table (*note Syntax
     Entry::.).

  2. The second character is the matching delimiter.  For a character
     that is not an opening or closing delimiter, this should be a
     space, and may be omitted if no following characters are needed.

  3. The remaining characters are flags.  The flag characters allowed
     are

    `1'
          Flag this character as the first of a two-character comment
          starting sequence.

    `2'
          Flag this character as the second of a two-character comment
          starting sequence.

    `3'
          Flag this character as the first of a two-character comment
          ending sequence.

    `4'
          Flag this character as the second of a two-character comment
          ending sequence.

   Use `C-h s' (`describe-syntax') to display a description of the
contents of the current syntax table.  The description of each
character includes both the string you have to pass to
`modify-syntax-entry' to set up that character's current syntax, and
some English to explain that string if necessary.


File: emacs,  Node: Menu Customization,  Prev: Syntax Change,  Up: Pull-down Menus

Customizing Lucid GNU Emacs Menus
=================================

   You can customize any of the pull-down menus by adding or removing
menu items and disabling or enabling existing menu items.

   The following functions are available:

``add-menu-item: (menu-path item-name function enabled-p)''
     Add a menu item to a menu, creating the menu first if necessary.

``delete-menu-item: (path)''
     Remove the menu item defined by PATH from the menu hierarchy.

``relabel-menu-item: (path new-name)''
     Change the string of the menu item specified by PATH to NEW-NAME.

``disable-menu-item: (path)''
     Disable the specified menu item.

``enable-menu-item: (path)''
     Enable the specified previously disabled menu item.

   The function `add-menu-item' adds a menu item to the specified
menu, creating the menu first if necessary.  If the named item already
exists, the menu remains unchanged.

   MENU-PATH identifies the menu into which the new menu item should
be inserted.  It is a list of strings; for example, `("File")' names
the top-level File menu.  `("File" "Foo")' names a hypothetical
submenu of File.

   ITEM-NAME is the string naming the menu item to add.

   FUNCTION is the command to invoke when this menu item is selected. 
If it is a symbol, it is invoked with `call-interactively', in the
same way that functions bound to keys are invoked.  If it is a list,
the list is simply evaluated.

   ENABLED-P controls whether the item is selectable or not.

   For example, to make the `rename-file' command available from the
File menu, use the following code:

     (add-menu-item '("File") "Rename File"
             'rename-file t)

   To add a submenu of file management commands using a File Management
item, use the following code:

     (add-menu-item '("File" "File Management")
             "Copy File" 'copy-file t)
     (add-menu-item '("File" "File Management")
             "Delete File" 'delete-file t)
     (add-menu-item '("File" "File Management")
             "Rename File" 'rename-file t)

   To remove a specified menu item from the menu hierarchy, use
`delete-menu-item'.

   To change the string of the specified menu item, use
`relabel-menu-item'.  NEW-NAME is the string to which the menu item
will be changed.

   To disable a menu item, use `disable-menu-item'.  The disabled menu
item is grayed and can no longer be selected.  To make the item
selectable again, use `enable-menu-item'.


File: emacs,  Node: Init File,  Next: Audible Bell,  Prev: Syntax,  Up: Customization

The Init File, .emacs
=====================

   When you start Emacs, it normally loads the file `.emacs' in your
home directory.  This file, if it exists, should contain Lisp code.  It
is called your initialization file or "init file".  Use the command
line switches `-q' and `-u' to tell Emacs whether to load an init file
(*note Entering Emacs::.).

   At some sites, there is a "default init file", which is the library
named `default.el', found via the standard search path for libraries. 
The Emacs distribution contains no such library; your site may create
one for local customizations.  If this library exists, it is loaded
whenever you start Emacs.  But your init file, if any, is loaded
first; if it sets `inhibit-default-init' non-`nil', then `default' is
not loaded.

   If you have a large amount of code in your `.emacs' file, you
should move it into another file named `SOMETHING.el', byte-compile it
(*note Lisp Libraries::.), and load that file from your `.emacs' file
using `load'.

* Menu:

* Init Syntax::     Syntax of constants in Emacs Lisp.
* Init Examples::   How to do some things with an init file.
* Terminal Init::   Each terminal type can have an init file.


File: emacs,  Node: Init Syntax,  Next: Init Examples,  Prev: Init File,  Up: Init File

Init File Syntax
----------------

   The `.emacs' file contains one or more Lisp function call
expressions.  Each consists of a function name followed by arguments,
all surrounded by parentheses.  For example, `(setq fill-column 60)'
represents a call to the function `setq' which is used to set the
variable `fill-column' (*note Filling::.) to 60.

   The second argument to `setq' is an expression for the new value of
the variable.  This can be a constant, a variable, or a function call
expression.  In `.emacs', constants are used most of the time.  They
can be:

Numbers:
     Numbers are written in decimal, with an optional initial minus
     sign.

Strings:
     Lisp string syntax is the same as C string syntax with a few extra
     features.  Use a double-quote character to begin and end a string
     constant.

     Newlines and special characters may be present literally in
     strings.  They can also be represented as backslash sequences:
     `\n' for newline, `\b' for backspace, `\r' for return, `\t' for
     tab, `\f' for formfeed (control-l), `\e' for escape, `\\' for a
     backslash, `\"' for a double-quote, or `\OOO' for the character
     whose octal code is OOO.  Backslash and double-quote are the only
     characters for which backslash sequences are mandatory.

     You can use `\C-' as a prefix for a control character, as in
     `\C-s' for ASCII Control-S, and `\M-' as a prefix for a meta
     character, as in `\M-a' for Meta-A or `\M-\C-a' for
     Control-Meta-A.

Characters:
     Lisp character constant syntax consists of a `?' followed by
     either a character or an escape sequence starting with `\'. 
     Examples: `?x', `?\n', `?\"', `?\)'.  Note that strings and
     characters are not interchangeable in Lisp; some contexts require
     one and some contexts require the other.

True:
     `t' stands for `true'.

False:
     `nil' stands for `false'.

Other Lisp objects:
     Write a single-quote (') followed by the Lisp object you want.


File: emacs,  Node: Init Examples,  Next: Terminal Init,  Prev: Init Syntax,  Up: Init File

Init File Examples
------------------

   Here are some examples of doing certain commonly desired things with
Lisp expressions:

   * Make TAB in C mode just insert a tab if point is in the middle of
     a line.

          (setq c-tab-always-indent nil)

          Here we have a variable whose value is normally `t' for `true'
     and the alternative is `nil' for `false'.

   * Make searches case sensitive by default (in all buffers that do
     not override this).

          (setq-default case-fold-search nil)

          This sets the default value, which is effective in all buffers
     that do not have local values for the variable.  Setting
     `case-fold-search' with `setq' affects only the current buffer's
     local value, which is probably not what you want to do in an init
     file.

   * Make Text mode the default mode for new buffers.

          (setq default-major-mode 'text-mode)

          Note that `text-mode' is used because it is the command for
     entering the mode we want.  A single-quote is written before it
     to make a symbol constant; otherwise, `text-mode' would be
     treated as a variable name.

   * Turn on Auto Fill mode automatically in Text mode and related
     modes.

          (setq text-mode-hook
            '(lambda () (auto-fill-mode 1)))

          Here we have a variable whose value should be a Lisp function. 
     The function we supply is a list starting with `lambda', and a
     single quote is written in front of it to make it (for the
     purpose of this `setq') a list constant rather than an
     expression.  Lisp functions are not explained here; for mode
     hooks it is enough to know that `(auto-fill-mode 1)' is an
     expression that will be executed when Text mode is entered.  You
     could replace it with any other expression that you like, or with
     several expressions in a row.

          (setq text-mode-hook 'turn-on-auto-fill)

          This is another way to accomplish the same result. 
     `turn-on-auto-fill' is a symbol whose function definition is
     `(lambda () (auto-fill-mode 1))'.

   * Load the installed Lisp library named `foo' (actually a file
     `foo.elc' or `foo.el' in a standard Emacs directory).

          (load "foo")

          When the argument to `load' is a relative pathname, not starting
     with `/' or `~', `load' searches the directories in `load-path'
     (*note Loading::.).

   * Load the compiled Lisp file `foo.elc' from your home directory.

          (load "~/foo.elc")

          Here an absolute file name is used, so no searching is done.

   * Rebind the key `C-x l' to run the function `make-symbolic-link'.

          (global-set-key "\C-xl" 'make-symbolic-link)

          or

          (define-key global-map "\C-xl" 'make-symbolic-link)

          Note once again the single-quote used to refer to the symbol
     `make-symbolic-link' instead of its value as a variable.

   * Do the same thing for C mode only.

          (define-key c-mode-map "\C-xl" 'make-symbolic-link)

   * Redefine all keys which now run `next-line' in Fundamental mode
     to run `forward-line' instead.

          (substitute-key-definition 'next-line 'forward-line
                                     global-map)

   * Make `C-x C-v' undefined.

          (global-unset-key "\C-x\C-v")

          One reason to undefine a key is so that you can make it a prefix. 
     Simply defining `C-x C-v ANYTHING' would make `C-x C-v' a prefix,
     but `C-x C-v' must be freed of any non-prefix definition first.

   * Make `$' have the syntax of punctuation in Text mode.  Note the
     use of a character constant for `$'.

          (modify-syntax-entry ?\$ "." text-mode-syntax-table)

   * Enable the use of the command `eval-expression' without
     confirmation.

          (put 'eval-expression 'disabled nil)


File: emacs,  Node: Terminal Init,  Prev: Init Examples,  Up: Init File

Terminal-specific Initialization
--------------------------------

   Each terminal type can have a Lisp library to be loaded into Emacs
when it is run on that type of terminal.  For a terminal type named
TERMTYPE, the library is called `term/TERMTYPE' and it is found by
searching the directories `load-path' as usual and trying the suffixes
`.elc' and `.el'.  Normally it appears in the subdirectory `term' of
the directory where most Emacs libraries are kept.

   The usual purpose of the terminal-specific library is to define the
escape sequences used by the terminal's function keys using the library
`keypad.el'.  See the file `term/vt100.el' for an example of how this
is done.

   When the terminal type contains a hyphen, only the part of the name
before the first hyphen is significant in choosing the library name. 
Thus, terminal types `aaa-48' and `aaa-30-rv' both use the library
`term/aaa'.  The code in the library can use `(getenv "TERM")' to find
the full terminal type name.

   The library's name is constructed by concatenating the value of the
variable `term-file-prefix' and the terminal type.  Your `.emacs' file
can prevent the loading of the terminal-specific library by setting
`term-file-prefix' to `nil'.

   The value of the variable `term-setup-hook', if not `nil', is
called as a function of no arguments at the end of Emacs
initialization, after both your `.emacs' file and any
terminal-specific library have been read.  You can set the value in
the `.emacs' file to override part of any of the terminal-specific
libraries and to define initializations for terminals that do not have
a library.


File: emacs,  Node: Audible Bell,  Prev: Init File,  Up: Customization

Changing the Bell Sound
-----------------------

   You can now change how the audible bell, sounds using the variable
`sound-alist'.

   `sound-alist''s value is an alist associating symbols with strings
of audio-data.  When `beep' or `ding' is called with one of the
symbols, the associated sound data is played instead of the standard
beep.  This only works if you are logged in on the console of a
SPARCstation.

   Elements of the list should be of one of the following forms:

        ( symbol . string-or-symbol )
        ( symbol integer string-or-symbol )

   If `string-or-symbol' is a string, it should contain raw sound
data, the contents of a `.au' file.  If it is a symbol, the symbol is
considered an alias for some other element, and the sound-player looks
for that next.  If the integer is provided, it is the volume at which
the sound should be played, from 0 to 100.

   If an element of this alist begins with the symbol `default', that
sound is used when no other sound is appropriate.

   If the symbol `t' is in place of a sound-string, Emacs uses the
default X beep.  This allows you to define beep-types of different
volumes even when not running on the console of a SPARCstation.

   You should probably add things to this list by calling the function
`load-sound-file'.

   `load-sound-file (filename sound-name &optional volume)'

   Read in an audio-file and add its data to the sound-alist.

   The following beep-types are used by Emacs itself. Other Lisp
packages may use other beep types, but these are the ones that the C
kernel of Emacs uses.

`auto-save-error'
     An auto-save does not succeed

`command-error'
     The Emacs command loop catches an error

`undefined-key'
     You type a key that is undefined

`undefined-click'
     You use an undefined mouse-click combination

`no-completion'
     Completion was not possible

`y-or-n-p'
     You type something other than the required `y' or `n'

`yes-or-no-p'
     When you type something other than `yes' or `no'


File: emacs,  Node: Quitting,  Next: Lossage,  Prev: Customization,  Up: Top

Quitting and Aborting
=====================

`C-g'
     Quit.  Cancel running or partially typed command.

`C-]'
     Abort innermost recursive editing level and cancel the command
     which invoked it (`abort-recursive-edit').

`M-x top-level'
     Abort all recursive editing levels that are currently executing.

`C-x u'
     Cancel an already-executed command, usually (`undo').

   There are two ways of cancelling commands which are not finished
executing: "quitting" with `C-g', and "aborting" with `C-]' or `M-x
top-level'.  Quitting is cancelling a partially typed command or one
which is already running.  Aborting is getting out of a recursive
editing level and cancelling the command that invoked the recursive
edit.

   Quitting with `C-g' is used for getting rid of a partially typed
command, or a numeric argument that you don't want.  It also stops a
running command in the middle in a relatively safe way, so you can use
it if you accidentally start executing a command that takes a long
time.  In particular, it is safe to quit out of killing; either your
text will ALL still be there, or it will ALL be in the kill ring (or
maybe both).  Quitting an incremental search does special things
documented under searching; in general, it may take two successive
`C-g' characters to get out of a search.  `C-g' works by setting the
variable `quit-flag' to `t' the instant `C-g' is typed; Emacs Lisp
checks this variable frequently and quits if it is non-`nil'.  `C-g'
is only actually executed as a command if it is typed while Emacs is
waiting for input.

   If you quit twice in a row before the first `C-g' is recognized, you
activate the "emergency escape" feature and return to the shell. 
*Note Emergency Escape::.

   You can use `C-]' (`abort-recursive-edit') to get out of a
recursive editing level and cancel the command which invoked it. 
Quitting with `C-g' does not do this, and could not do this, because it
is used to cancel a partially typed command within the recursive
editing level.  Both operations are useful.  For example, if you are
in the Emacs debugger (*note Lisp Debug::.) and have typed `C-u 8' to
enter a numeric argument, you can cancel that argument with `C-g' and
remain in the debugger.

   The command `M-x top-level' is equivalent to "enough" `C-]'
commands to get you out of all the levels of recursive edits that you
are in.  `C-]' only gets you out one level at a time, but `M-x
top-level' goes out all levels at once.  Both `C-]' and `M-x
top-level' are like all other commands, and unlike `C-g', in that they
are effective only when Emacs is ready for a command.  `C-]' is an
ordinary key and has its meaning only because of its binding in the
keymap.  *Note Recursive Edit::.

   `C-x u' (`undo') is not strictly speaking a way of cancelling a
command, but you can think of it as cancelling a command already
finished executing.  *Note Undo::.


File: emacs,  Node: Lossage,  Next: Bugs,  Prev: Quitting,  Up: Top

Dealing with Emacs Trouble
==========================

   This section describes various conditions in which Emacs fails to
work, and how to recognize them and correct them.

* Menu:

* Stuck Recursive::    `[...]' in mode line around the parentheses
* Screen Garbled::     Garbage on the screen
* Text Garbled::       Garbage in the text
* Unasked-for Search:: Spontaneous entry to incremental search
* Emergency Escape::   Emergency escape--
                        What to do if Emacs stops responding
* Total Frustration::  When you are at your wits' end.


File: emacs,  Node: Stuck Recursive,  Next: Screen Garbled,  Prev: Lossage,  Up: Lossage

Recursive Editing Levels
------------------------

   Recursive editing levels are important and useful features of
Emacs, but they can seem like malfunctions to the user who does not
understand them.

   If the mode line has square brackets `[...]' around the parentheses
that contain the names of the major and minor modes, you have entered a
recursive editing level.  If you did not do this on purpose, or if you
don't understand what that means, you should just get out of the
recursive editing level.  To do so, type `M-x top-level'.  This is
called getting back to top level.  *Note Recursive Edit::.


File: emacs,  Node: Screen Garbled,  Next: Text Garbled,  Prev: Stuck Recursive,  Up: Lossage

Garbage on the Screen
---------------------

   If the data on the screen looks wrong, the first thing to do is see
whether the text is actually wrong.  Type `C-l', to redisplay the
entire screen.  If the text appears correct after this, the problem was
entirely in the previous screen update.

   Display updating problems often result from an incorrect termcap
entry for the terminal you are using.  The file `etc/TERMS' in the
Emacs distribution gives the fixes for known problems of this sort. 
`INSTALL' contains general advice for these problems in one of its
sections.  Very likely there is simply insufficient padding for certain
display operations.  To investigate the possibility that you have this
sort of problem, try Emacs on another terminal made by a different
manufacturer.  If problems happen frequently on one kind of terminal
but not another kind, the real problem is likely to be a bad termcap
entry, though it could also be due to a bug in Emacs that appears for
terminals that have or that lack specific features.


File: emacs,  Node: Text Garbled,  Next: Unasked-for Search,  Prev: Screen Garbled,  Up: Lossage

Garbage in the Text
-------------------

   If `C-l' shows that the text is wrong, try undoing the changes to it
using `C-x u' until it gets back to a state you consider correct.  Also
try `C-h l' to find out what command you typed to produce the observed
results.

   If a large portion of text appears to be missing at the beginning or
end of the buffer, check for the word `Narrow' in the mode line.  If
it appears, the text is still present, but marked off-limits.  To make
it visible again, type `C-x w'.  *Note Narrowing::.


File: emacs,  Node: Unasked-for Search,  Next: Emergency Escape,  Prev: Text Garbled,  Up: Lossage

Spontaneous Entry to Incremental Search
---------------------------------------

   If Emacs spontaneously displays `I-search:' at the bottom of the
screen, it means that the terminal is sending `C-s' and `C-q'
according to the poorly designed xon/xoff "flow control" protocol.  You
should try to prevent this by putting the terminal in a mode where it
will not use flow control or by giving it enough padding that it will
never send a `C-s'.  If that cannot be done, you must tell Emacs to
expect flow control to be used, until you can get a properly designed
terminal.

   Information on how to do these things can be found in the file
`INSTALL' in the Emacs distribution.


File: emacs,  Node: Emergency Escape,  Next: Total Frustration,  Prev: Unasked-for Search,  Up: Lossage

Emergency Escape
----------------

   Because at times there have been bugs causing Emacs to loop without
checking `quit-flag', a special feature causes Emacs to be suspended
immediately if you type a second `C-g' while the flag is already set,
so you can always get out of GNU Emacs.  Normally Emacs recognizes and
clears `quit-flag' (and quits!) quickly enough to prevent this from
happening.

   When you resume Emacs after a suspension caused by multiple `C-g',
it asks two questions before going back to what it had been doing:

     Auto-save? (y or n)
     Abort (and dump core)? (y or n)

Answer each one with `y' or `n' followed by RET.

   Saying `y' to `Auto-save?' causes immediate auto-saving of all
modified buffers in which auto-saving is enabled.

   Saying `y' to `Abort (and dump core)?' causes an illegal
instruction to be executed, dumping core.  This is to enable a wizard
to figure out why Emacs was failing to quit in the first place. 
Execution does not continue after a core dump.  If you answer `n',
execution does continue.  With luck, Emacs will ultimately check
`quit-flag' and quit normally.  If not, and you type another `C-g', it
is suspended again.

   If Emacs is not really hung, just slow, you may invoke the double
`C-g' feature without really meaning to.  Then just resume and answer
`n' to both questions, and you will arrive at your former state. 
Presumably the quit you requested will happen soon.

   The double-`C-g' feature may be turned off when Emacs is running
under a window system, since the window system always enables you to
kill Emacs or to create another window and run another program.


File: emacs,  Node: Total Frustration,  Prev: Emergency Escape,  Up: Lossage

Help for Total Frustration
--------------------------

   If using Emacs (or something else) becomes terribly frustrating and
none of the techniques described above solve the problem, Emacs can
still help you.

   First, if the Emacs you are using is not responding to commands,
type `C-g C-g' to get out of it and then start a new one.

   Second, type `M-x doctor RET'.

   The doctor will make you feel better.  Each time you say something
to the doctor, you must end it by typing RET RET.  This lets the
doctor know you are finished.

