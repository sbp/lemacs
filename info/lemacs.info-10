This is Info file ../info/lemacs.info, produced by Makeinfo-1.55 from
the input file lemacs.texinfo.

   This file documents the GNU Emacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992, 1993, 1994 Lucid, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: lemacs.info,  Node: Loading,  Next: Compiling Libraries,  Prev: Lisp Libraries,  Up: Lisp Libraries

Loading Libraries
-----------------

`M-x load-file FILE'
     Load the file FILE of Lisp code.

`M-x load-library LIBRARY'
     Load the library named LIBRARY.

`M-x locate-library LIBRARY &optional NOSUFFIX'
     Show the full path name of Emacs library `library'.

   To execute a file of Emacs Lisp, use `M-x load-file'.  This command
reads the file name you provide in the minibuffer, then executes the
contents of that file as Lisp code.  It is not necessary to visit the
file first; in fact, this command reads the file as found on disk, not
the text in an Emacs buffer.

   Once a file of Lisp code is installed in the Emacs Lisp library
directories, users can load it using `M-x load-library'.  Programs can
load it by calling `load-library', or with `load', a more primitive
function that is similar but accepts some additional arguments.

   `M-x load-library' differs from `M-x load-file' in that it searches
a sequence of directories and tries three file names in each directory.
The three names are: first, the specified name with `.elc' appended;
second, the name with `.el' appended; third, the specified name alone.
A `.elc' file would be the result of compiling the Lisp file into byte
code;  if possible, it is loaded in preference to the Lisp file itself
because the compiled file loads and runs faster.

   Because the argument to `load-library' is usually not in itself a
valid file name, file name completion is not available.  In fact, when
using this command, you usually do not know exactly what file name will
be used.

   The sequence of directories searched by `M-x load-library' is
specified by the variable `load-path', a list of strings that are
directory names.  The elements of this list may not begin with "`~'",
so you must call `expand-file-name' on them before adding them to the
list.  The default value of the list contains the directory where the
Lisp code for Emacs itself is stored.  If you have libraries of your
own, put them in a single directory and add that directory to
`load-path'.  `nil' in this list stands for the current default
directory, but it is probably not a good idea to put `nil' in the list.
If you start wishing that `nil' were in the list, you should probably
use `M-x load-file' for this case.

   The variable is initialized by the EMACSLOADPATH environment
variable. If no value is specified, the variable takes the default value
specified in the file `paths.h' when Emacs was built. If a path isn't
specified in `paths.h', a default value is obtained from the file
system, near the directory in which the Emacs executable resides.

   `M-x locate-library' searches the directories in `load-path' like
`M-x load-library' to find the file that `M-x load-library' would load.
If the optional second argument NOSUFFIX is non-`nil', the suffixes
`.elc' or `.el' are not added to the specified name LIBRARY (a la
calling load instead of load-library).

   You often do not have to give any command to load a library, because
the commands defined in the library are set up to "autoload" that
library.  Running any of those commands causes `load' to be called to
load the library; this replaces the autoload definitions with the real
ones from the library.

   If autoloading a file does not finish, either because of an error or
because of a `C-g' quit, all function definitions made by the file are
undone automatically.  So are any calls to `provide'.  As a
consequence, the entire file is loaded a second time if you use one of
the autoloadable commands again.  This prevents problems when the
command is no longer autoloading but works incorrectly because the file
was only partially loaded.  Function definitions are undone only for
autoloading; explicit calls to `load' do not undo anything if loading
is not completed.

   The variable `after-load-alist' takes an alist of expressions to be
evalled when particular files are loaded.  Each element looks like
`(FILENAME forms...)'.  When load is run and the filename argument is
FILENAME, the forms in the corresponding element are executed at the
end of loading.

   FILENAME must match exactly.  Normally FILENAME is the name of a
library, with no directory specified, since that is how load is
normally called.  An error in `forms' does not undo the load, but does
prevent execution of the rest of the `forms'.


File: lemacs.info,  Node: Compiling Libraries,  Next: Mocklisp,  Prev: Loading,  Up: Lisp Libraries

Compiling Libraries
-------------------

   Emacs Lisp code can be compiled into byte-code which loads faster,
takes up less space when loaded, and executes faster.

`M-x batch-byte-compile'
     Run byte-compile-file on the files remaining on the command line.

`M-x byte-compile-buffer &optional BUFFER'
     Byte-compile and evaluate contents of BUFFER (default is current
     buffer).

`M-x byte-compile-file'
     Compile a file of Lisp code named FILENAME into a file of byte
     code.

`M-x byte-compile-and-load-file FILENAME'
     Compile a file of Lisp code named FILENAME into a file of byte
     code and load it.

`M-x byte-recompile-directory DIRECTORY'
     Recompile every `.el' file in DIRECTORY that needs recompilation.

`M-x disassemble'
     Print disassembled code for OBJECT on (optional) STREAM.

`M-x make-obsolete FUNCTION NEW'
     Make the byte-compiler warn that FUNCTION is obsolete and NEW
     should be used instead.

   `byte-compile-file' creates a byte-code compiled file from an
Emacs-Lisp source file.  The default argument for this function is the
file visited in the current buffer.  The function reads the specified
file, compiles it into byte code, and writes an output file whose name
is made by appending `c' to the input file name.  Thus, the file
`rmail.el' would be compiled into `rmail.elc'. To compile a file of
Lisp code named FILENAME into a file of byte code and then load it, use
`byte-compile-and-load-file'. To compile and evaluate Lisp code in a
given buffer, use `byte-compile-buffer'.

   To recompile all changed Lisp files in a directory, use `M-x
byte-recompile-directory'.  Specify just the directory name as an
argument.  Each `.el' file that has been byte-compiled before is
byte-compiled again if it has changed since the previous compilation.
A numeric argument to this command tells it to offer to compile each
`.el' file that has not been compiled yet.  You must answer `y' or `n'
to each offer.

   You can use the function `batch-byte-compile' to invoke Emacs
non-interactively from the shell to do byte compilation.  When you use
this function, the files to be compiled are specified with command-line
arguments.  Use a shell command of the form

     emacs -batch -f batch-byte-compile FILES...

   Directory names may also be given as arguments; in that case,
`byte-recompile-directory' is invoked on each such directory.
`batch-byte-compile' uses all remaining command-line arguments as file
or directory names, then kills the Emacs process.

   `M-x disassemble' explains the result of byte compilation.  Its
argument is a function name.  It displays the byte-compiled code in a
help window in symbolic form, one instruction per line.  If the
instruction refers to a variable or constant, that is shown too.


File: lemacs.info,  Node: Mocklisp,  Prev: Compiling Libraries,  Up: Lisp Libraries

Converting Mocklisp to Lisp
---------------------------

   GNU Emacs can run Mocklisp files by converting them to Emacs Lisp
first.  To convert a Mocklisp file, visit it and then type `M-x
convert-mocklisp-buffer'.  Then save the resulting buffer of Lisp file
in a file whose name ends in `.el' and use the new file as a Lisp
library.

   You cannot currently byte-compile converted Mocklisp code.  The
reason is that converted Mocklisp code uses some special Lisp features
to deal with Mocklisp's incompatible ideas of how arguments are
evaluated and which values signify "true" or "false".


File: lemacs.info,  Node: Lisp Eval,  Next: Lisp Debug,  Prev: Lisp Libraries,  Up: Running

Evaluating Emacs-Lisp Expressions
=================================

   Lisp programs intended to be run in Emacs should be edited in
Emacs-Lisp mode; this will happen automatically for file names ending in
`.el'.  By contrast, Lisp mode itself should be used for editing Lisp
programs intended for other Lisp systems.  Emacs-Lisp mode can be
selected with the command `M-x emacs-lisp-mode'.

   For testing of Lisp programs to run in Emacs, it is useful to be able
to evaluate part of the program as it is found in the Emacs buffer.  For
example, if you change the text of a Lisp function definition, and then
evaluate the definition, Emacs installs the change for future calls to
the function.  Evaluation of Lisp expressions is also useful in any
kind of editing task for invoking non-interactive functions (functions
that are not commands).

`M-ESC'
     Read a Lisp expression in the minibuffer, evaluate it, and print
     the value in the minibuffer (`eval-expression').

`C-x C-e'
     Evaluate the Lisp expression before point, and print the value in
     the minibuffer (`eval-last-sexp').

`C-M-x'
     Evaluate the defun containing point or after point, and print the
     value in the minibuffer (`eval-defun').

`M-x eval-region'
     Evaluate all the Lisp expressions in the region.

`M-x eval-current-buffer'
     Evaluate all the Lisp expressions in the buffer.

   `M-ESC' (`eval-expression') is the most basic command for evaluating
a Lisp expression interactively.  It reads the expression using the
minibuffer, so you can execute any expression on a buffer regardless of
what the buffer contains.  When evaluation is complete, the current
buffer is once again the buffer that was current when `M-ESC' was typed.

   `M-ESC' can easily confuse users, especially on keyboards with
autorepeat where it can result from holding down the ESC key for too
long.  Therefore, `eval-expression' is normally a disabled command.
Attempting to use this command asks for confirmation and gives you the
option of enabling it; once you enable the command, you are no longer
required to confirm.  *Note Disabling::.

   In Emacs-Lisp mode, the key `C-M-x' is bound to the function
`eval-defun', which parses the defun containing point or following point
as a Lisp expression and evaluates it.  The value is printed in the echo
area.  This command is convenient for installing in the Lisp environment
changes that you have just made in the text of a function definition.

   The command `C-x C-e' (`eval-last-sexp') performs a similar job but
is available in all major modes, not just Emacs-Lisp mode.  It finds
the sexp before point, reads it as a Lisp expression, evaluates it, and
prints the value in the echo area.  It is sometimes useful to type in an
expression and then, with point still after it, type `C-x C-e'.

   If `C-M-x' or `C-x C-e' are given a numeric argument, they print the
value by inserting it into the current buffer at point, rather than in
the echo area.  The argument value does not matter.

   The most general command for evaluating Lisp expressions from a
buffer is `eval-region'.  `M-x eval-region' parses the text of the
region as one or more Lisp expressions, evaluating them one by one.
`M-x eval-current-buffer' is similar but evaluates the entire buffer.
This is a reasonable way to install the contents of a file of Lisp code
that you are just ready to test.  After finding and fixing a bug, use
`C-M-x' on each function that you change, to keep the Lisp world in
step with the source file.


File: lemacs.info,  Node: Lisp Debug,  Next: Lisp Interaction,  Prev: Lisp Eval,  Up: Running

The Emacs-Lisp Debugger
=======================

   GNU Emacs contains a debugger for Lisp programs executing inside it.
This debugger is normally not used; many commands frequently get Lisp
errors when invoked in inappropriate contexts (such as `C-f' at the end
of the buffer) and it would be unpleasant to enter a special debugging
mode in this case.  When you want to make Lisp errors invoke the
debugger, you must set the variable `debug-on-error' to non-`nil'.
Quitting with `C-g' is not considered an error, and `debug-on-error'
has no effect on the handling of `C-g'.  However, if you set
`debug-on-quit' non-`nil', `C-g' will invoke the debugger.  This can be
useful for debugging an infinite loop; type `C-g' once the loop has had
time to reach its steady state.  `debug-on-quit' has no effect on
errors.

   You can make Emacs enter the debugger when a specified function is
called, or at a particular place in Lisp code.  Use `M-x
debug-on-entry' with argument FUN-NAME to have Emacs enter the debugger
as soon as FUN-NAME is called.Use `M-x cancel-debug-on-entry' to make
the function stop entering the debugger when called.  (Redefining the
function also does this.)  To enter the debugger from some other place
in Lisp code, you must insert the expression `(debug)' there and
install the changed code with `C-M-x'.  *Note Lisp Eval::.

   When the debugger is entered, it displays the previously selected
buffer in one window and a buffer named `*Backtrace*' in another
window.  The backtrace buffer contains one line for each level of Lisp
function execution currently going on.  At the beginning of the buffer
is a message describing the reason that the debugger was invoked, for
example, an error message if it was invoked due to an error.

   The backtrace buffer is read-only, and is in Backtrace mode, a
special major mode in which letters are defined as debugger commands.
The usual Emacs editing commands are available; you can switch windows
to examine the buffer that was being edited at the time of the error,
and you can switch buffers, visit files, and perform any other editing
operations.  However, the debugger is a recursive editing level (*note
Recursive Edit::.); it is a good idea to return to the backtrace buffer
and explictly exit the debugger when you don't want to use it any more.
Exiting the debugger kills the backtrace buffer.

   The contents of the backtrace buffer show you the functions that are
executing and the arguments that were given to them.  It also allows you
to specify a stack frame by moving point to the line describing that
frame.  The frame whose line point is on is considered the "current
frame".  Some of the debugger commands operate on the current frame.
Debugger commands are mainly used for stepping through code one
expression at a time.  Here is a list of them:

`c'
     Exit the debugger and continue execution.  In most cases,
     execution of the program continues as if the debugger had never
     been entered (aside from the effect of any variables or data
     structures you may have changed while inside the debugger).  This
     includes entry to the debugger due to function entry or exit,
     explicit invocation, and quitting or certain errors.  Most errors
     cannot be continued; trying to continue an error usually causes
     the same error to occur again.

`d'
     Continue execution, but enter the debugger the next time a Lisp
     function is called.  This allows you to step through the
     subexpressions of an expression, and see what the subexpressions
     do and what values they compute.

     When you enter the debugger this way, Emacs flags the stack frame
     for the function call from which you entered.  The same function
     is then called when you exit the frame.  To cancel this flag, use
     `u'.

`b'
     Set up to enter the debugger when the current frame is exited.
     Frames that invoke the debugger on exit are flagged with stars.

`u'
     Don't enter the debugger when the current frame is exited.  This
     cancels a `b' command on a frame.

`e'
     Read a Lisp expression in the minibuffer, evaluate it, and print
     the value in the echo area.  This is equivalent to the command
     `M-ESC', except that `e' is not normally disabled like `M-ESC'.

`q'
     Terminate the program being debugged; return to top-level Emacs
     command execution.

     If the debugger was entered due to a `C-g' but you really want to
     quit, not to debug, use the `q' command.

`r'
     Return a value from the debugger.  The value is computed by
     reading an expression with the minibuffer and evaluating it.

     The value returned by the debugger makes a difference when the
     debugger was invoked due to exit from a Lisp call frame (as
     requested with `b'); then the value specified in the `r' command
     is used as the value of that frame.

     The debugger's return value also matters with many errors.  For
     example, `wrong-type-argument' errors will use the debugger's
     return value instead of the invalid argument; `no-catch' errors
     will use the debugger value as a throw tag instead of the tag that
     was not found.  If an error was signaled by calling the Lisp
     function `signal', the debugger's return value is returned as the
     value of `signal'.


File: lemacs.info,  Node: Lisp Interaction,  Next: External Lisp,  Prev: Lisp Debug,  Up: Running

Lisp Interaction Buffers
========================

   The buffer `*scratch*', which is selected when Emacs starts up, is
provided for evaluating Lisp expressions interactively inside Emacs.
Both the expressions you evaluate and their output goes in the buffer.

   The `*scratch*' buffer's major mode is Lisp Interaction mode, which
is the same as Emacs-Lisp mode except for one command, LFD.  In
Emacs-Lisp mode, LFD is an indentation command.  In Lisp Interaction
mode, LFD is bound to `eval-print-last-sexp'.  This function reads the
Lisp expression before point, evaluates it, and inserts the value in
printed representation before point.

   The way to use the `*scratch*' buffer is to insert Lisp expressions
at the end, ending each one with LFD so that it will be evaluated.  The
result is a complete typescript of the expressions you have evaluated
and their values.

   The rationale for this feature is that Emacs must have a buffer when
it starts up, but that buffer is not useful for editing files since a
new buffer is made for every file that you visit.  The Lisp interpreter
typescript is the most useful thing I can think of for the initial
buffer to do.  `M-x lisp-interaction-mode' will put any buffer in Lisp
Interaction mode.


File: lemacs.info,  Node: External Lisp,  Prev: Lisp Interaction,  Up: Running

Running an External Lisp
========================

   Emacs has facilities for running programs in other Lisp systems.
You can run a Lisp process as an inferior of Emacs, and pass
expressions to it to be evaluated.  You can also pass changed function
definitions directly from the Emacs buffers in which you edit the Lisp
programs to the inferior Lisp process.

   To run an inferior Lisp process, type `M-x run-lisp'.  This runs the
program named `lisp', the same program you would run by typing `lisp'
as a shell command, with both input and output going through an Emacs
buffer named `*lisp*'.  In other words, any "terminal output" from Lisp
will go into the buffer, advancing point, and any "terminal input" for
Lisp comes from text in the buffer.  To give input to Lisp, go to the
end of the buffer and type the input, terminated by RET.  The `*lisp*'
buffer is in Inferior Lisp mode, which has all the special
characteristics of Lisp mode and Shell mode (*note Shell Mode::.).

   Use Lisp mode to run the source files of programs in external Lisps.
You can select this mode with `M-x lisp-mode'.  It is used automatically
for files whose names end in `.l' or `.lisp', as most Lisp systems
usually expect.

   When you edit a function in a Lisp program you are running, the
easiest way to send the changed definition to the inferior Lisp process
is the key `C-M-x'.  In Lisp mode, this key runs the function
`lisp-send-defun', which finds the defun around or following point and
sends it as input to the Lisp process.  (Emacs can send input to any
inferior process regardless of what buffer is current.)

   Contrast the meanings of `C-M-x' in Lisp mode (for editing programs
to be run in another Lisp system) and Emacs-Lisp mode (for editing Lisp
programs to be run in Emacs): in both modes it has the effect of
installing the function definition that point is in, but the way of
doing so is different according to where the relevant Lisp environment
is found.  *Note Lisp Modes::.


File: lemacs.info,  Node: Abbrevs,  Next: Picture,  Prev: Running,  Up: Top

Abbrevs
*******

   An "abbrev" is a word which "expands", if you insert it, into some
different text.  Abbrevs are defined by the user to expand in specific
ways.  For example, you might define `foo' as an abbrev expanding to
`find outer otter'.  With this abbrev defined, you would be able to get
`find outer otter ' into the buffer by typing `f o o SPC'.

   Abbrevs expand only when Abbrev mode (a minor mode) is enabled.
Disabling Abbrev mode does not cause abbrev definitions to be discarded,
but they do not expand until Abbrev mode is enabled again.  The command
`M-x abbrev-mode' toggles Abbrev mode; with a numeric argument, it
turns Abbrev mode on if the argument is positive, off otherwise.  *Note
Minor Modes::.  `abbrev-mode' is also a variable; Abbrev mode is on
when the variable is non-`nil'.  The variable `abbrev-mode'
automatically becomes local to the current buffer when it is set.

   Abbrev definitions can be "mode-specific"--active only in one major
mode.  Abbrevs can also have "global" definitions that are active in
all major modes.  The same abbrev can have a global definition and
various mode-specific definitions for different major modes.  A mode
specific definition for the current major mode overrides a global
definition.

   You can define Abbrevs interactively during an editing session.  You
can also save lists of abbrev definitions in files and reload them in
later sessions.  Some users keep extensive lists of abbrevs that they
load in every session.

   A second kind of abbreviation facility is called the "dynamic
expansion".  Dynamic abbrev expansion happens only when you give an
explicit command and the result of the expansion depends only on the
current contents of the buffer.  *Note Dynamic Abbrevs::.

* Menu:

* Defining Abbrevs::  Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs:: Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::   Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::    Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::   Abbreviations for words already in the buffer.


File: lemacs.info,  Node: Defining Abbrevs,  Next: Expanding Abbrevs,  Prev: Abbrevs,  Up: Abbrevs

Defining Abbrevs
================

`C-x +'
     Define an abbrev to expand into some text before point
     (`add-global-abbrev').

`C-x C-a'
     Similar, but define an abbrev available only in the current major
     mode (`add-mode-abbrev').

`C-x -'
     Define a word in the buffer as an abbrev
     (`inverse-add-global-abbrev').

`C-x C-h'
     Define a word in the buffer as a mode-specific abbrev
     (`inverse-add-mode-abbrev').

`M-x kill-all-abbrevs'
     After this command, no abbrev definitions remain in effect.

   The usual way to define an abbrev is to enter the text you want the
abbrev to expand to, position point after it, and type `C-x +'
(`add-global-abbrev').  This reads the abbrev itself using the
minibuffer, and then defines it as an abbrev for one or more words
before point.  Use a numeric argument to say how many words before point
should be taken as the expansion.  For example, to define the abbrev
`foo' as in the example above, insert the text `find outer otter', then
type
`C-u 3 C-x + f o o RET'.

   An argument of zero to `C-x +' means to use the contents of the
region as the expansion of the abbrev being defined.

   The command `C-x C-a' (`add-mode-abbrev') is similar, but defines a
mode-specific abbrev.  Mode specific abbrevs are active only in a
particular major mode.  `C-x C-a' defines an abbrev for the major mode
in effect at the time `C-x C-a' is typed.  The arguments work the same
way they do for `C-x +'.

   If the text of an abbrev you want is already in the buffer instead of
the expansion, use command `C-x -' (`inverse-add-global-abbrev')
instead of `C-x +', or use `C-x C-h' (`inverse-add-mode-abbrev')
instead of `C-x C-a'.  These commands are called "inverse" because they
invert the meaning of the argument found in the buffer and the argument
read using the minibuffer.

   To change the definition of an abbrev, just add the new definition.
You will be asked to confirm if the abbrev has a prior definition.  To
remove an abbrev definition, give a negative argument to `C-x +' or `C-x
C-a'.  You must choose the command to specify whether to kill a global
definition or a mode-specific definition for the current mode, since
those two definitions are independent for one abbrev.

   `M-x kill-all-abbrevs' removes all existing abbrev definitions.


File: lemacs.info,  Node: Expanding Abbrevs,  Next: Editing Abbrevs,  Prev: Defining Abbrevs,  Up: Abbrevs

Controlling Abbrev Expansion
============================

   An abbrev expands whenever it is in a buffer just before point and
you type and a self-inserting punctuation character (SPC, comma, etc.).
Most often an abbrev is used by inserting the abbrev followed by
punctuation.

   Abbrev expansion preserves case; thus, `foo' expands into `find
outer otter'; `Foo' into `Find outer otter', and `FOO' into `FIND OUTER
OTTER' or `Find Outer Otter' according to the variable
`abbrev-all-caps' (a non-`nil' value chooses the first of the two
expansions).

   Two commands are available to control abbrev expansion:

`M-''
     Separate a prefix from a following abbrev to be expanded
     (`abbrev-prefix-mark').

`C-x ''
     Expand the abbrev before point (`expand-abbrev').  This is
     effective even when Abbrev mode is not enabled.

`M-x unexpand-abbrev'
     Undo last abbrev expansion.

`M-x expand-region-abbrevs'
     Expand some or all abbrevs found in the region.

   You may wish to expand an abbrev with a prefix attached.  For
example, if `cnst' expands into `construction', you may want to use it
to enter `reconstruction'.  It does not work to type `recnst', because
that is not necessarily a defined abbrev.  Instead, you can use the
command `M-'' (`abbrev-prefix-mark') between the prefix `re' and the
abbrev `cnst'.  First, insert `re'.  Then type `M-''; this inserts a
minus sign in the buffer to indicate that it has done its work.  Then
insert the abbrev `cnst'.  The buffer now contains `re-cnst'.  Now
insert a punctuation character to expand the abbrev `cnst' into
`construction'.  The minus sign is deleted at this point, by `M-''.
The resulting text is the desired `reconstruction'.

   If you actually want the text of the abbrev in the buffer, rather
than its expansion, insert the following punctuation with `C-q'.  Thus,
`foo C-q -' leaves `foo-' in the buffer.

   If you expand an abbrev by mistake, you can undo the expansion
(replace the expansion by the original abbrev text) with `M-x
unexpand-abbrev'.  You can also use `C-_' (`undo') to undo the
expansion; but that will first undo the insertion of the punctuation
character.

   `M-x expand-region-abbrevs' searches through the region for defined
abbrevs, and  offers to replace each one it finds with its expansion.
This command is useful if you have typed text using abbrevs but forgot
to turn on Abbrev mode first.  It may also be useful together with a
special set of abbrev definitions for making several global
replacements at once.  The command is effective even if Abbrev mode is
not enabled.


File: lemacs.info,  Node: Editing Abbrevs,  Next: Saving Abbrevs,  Prev: Expanding Abbrevs,  Up: Abbrevs

Examining and Editing Abbrevs
=============================

`M-x list-abbrevs'
     Print a list of all abbrev definitions.

`M-x edit-abbrevs'
     Edit a list of abbrevs; you can add, alter or remove definitions.

   The output from `M-x list-abbrevs' looks like this:

     (lisp-mode-abbrev-table)
     "dk"	       0    "define-key"
     (global-abbrev-table)
     "dfn"	       0    "definition"

(Some blank lines of no semantic significance, and some other abbrev
tables, have been omitted.)

   A line containing a name in parentheses is the header for abbrevs in
a particular abbrev table; `global-abbrev-table' contains all the global
abbrevs, and the other abbrev tables that are named after major modes
contain the mode-specific abbrevs.

   Within each abbrev table, each non-blank line defines one abbrev.
The word at the beginning is the abbrev.  The number that appears is
the number of times the abbrev has been expanded.  Emacs keeps track of
this to help you see which abbrevs you actually use, in case you want
to eliminate those that you don't use often.  The string at the end of
the line is the expansion.

   `M-x edit-abbrevs' allows you to add, change or kill abbrev
definitions by editing a list of them in an Emacs buffer.  The list has
the format described above.  The buffer of abbrevs is called
`*Abbrevs*', and is in Edit-Abbrevs mode.  This mode redefines the key
`C-c C-c' to install the abbrev definitions as specified in the buffer.
The  `edit-abbrevs-redefine' command does this.  Any abbrevs not
described in the buffer are eliminated when this is done.

   `edit-abbrevs' is actually the same as `list-abbrevs' except that it
selects the buffer `*Abbrevs*' whereas `list-abbrevs' merely displays
it in another window.


File: lemacs.info,  Node: Saving Abbrevs,  Next: Dynamic Abbrevs,  Prev: Editing Abbrevs,  Up: Abbrevs

Saving Abbrevs
==============

   These commands allow you to keep abbrev definitions between editing
sessions.

`M-x write-abbrev-file'
     Write a file describing all defined abbrevs.

`M-x read-abbrev-file'
     Read such an abbrev file and define abbrevs as specified there.

`M-x quietly-read-abbrev-file'
     Similar, but do not display a message about what is going on.

`M-x define-abbrevs'
     Define abbrevs from buffer.

`M-x insert-abbrevs'
     Insert all abbrevs and their expansions into the buffer.

   Use `M-x write-abbrev-file' to save abbrev definitions for use in a
later session.  The command reads a file name using the minibuffer and
writes a description of all current abbrev definitions into the
specified file.  The text stored in the file looks like the output of
`M-x list-abbrevs'.

   `M-x read-abbrev-file' prompts for a file name using the minibuffer
and reads the specified file, defining abbrevs according to its
contents.  `M-x quietly-read-abbrev-file' is the same but does not
display a message in the echo area; it is actually useful primarily in
the `.emacs' file.  If you give an empty argument to either of these
functions, the file name Emacs uses is the value of the variable
`abbrev-file-name', which is by default `"~/.abbrev_defs"'.

   Emacs offers to save abbrevs automatically if you have changed any of
them, whenever it offers to save all files (for `C-x s' or `C-x C-c').
Set the variable `save-abbrevs' to `nil' to inhibit this feature.

   The commands `M-x insert-abbrevs' and `M-x define-abbrevs' are
similar to the previous commands but work on text in an Emacs buffer.
`M-x insert-abbrevs' inserts text into the current buffer before point,
describing all current abbrev definitions; `M-x define-abbrevs' parses
the entire current buffer and defines abbrevs accordingly.


File: lemacs.info,  Node: Dynamic Abbrevs,  Prev: Saving Abbrevs,  Up: Abbrevs

Dynamic Abbrev Expansion
========================

   The abbrev facility described above operates automatically as you
insert text, but all abbrevs must be defined explicitly.  By contrast,
"dynamic abbrevs" allow the meanings of abbrevs to be determined
automatically from the contents of the buffer, but dynamic abbrev
expansion happens only when you request it explicitly.

`M-/'
     Expand the word in the buffer before point as a "dynamic abbrev",
     by searching in the buffer for words starting with that
     abbreviation (`dabbrev-expand').

   For example, if the buffer contains `does this follow ' and you type
`f o M-/', the effect is to insert `follow' because that is the last
word in the buffer that starts with `fo'.  A numeric argument to `M-/'
says to take the second, third, etc. distinct expansion found looking
backward from point.  Repeating `M-/' searches for an alternative
expansion by looking farther back.  After the entire buffer before
point has been considered, the buffer after point is searched.

   Dynamic abbrev expansion is completely independent of Abbrev mode;
the expansion of a word with `M-/' is completely independent of whether
it has a definition as an ordinary abbrev.


File: lemacs.info,  Node: Picture,  Next: Sending Mail,  Prev: Abbrevs,  Up: Top

Editing Pictures
****************

   If you want to create a picture made out of text characters (for
example, a picture of the division of a register into fields, as a
comment in a program), use the command `edit-picture' to enter Picture
mode.

   In Picture mode, editing is based on the "quarter-plane" model of
text.  In this model, the text characters lie studded on an area that
stretches infinitely far to the right and downward.  The concept of the
end of a line does not exist in this model; the most you can say is
where the last non-blank character on the line is found.

   Of course, Emacs really always considers text as a sequence of
characters, and lines really do have ends.  But in Picture mode most
frequently-used keys are rebound to commands that simulate the
quarter-plane model of text.  They do this by inserting spaces or by
converting tabs to spaces.

   Most of the basic editing commands of Emacs are redefined by Picture
mode to do essentially the same thing but in a quarter-plane way.  In
addition, Picture mode defines various keys starting with the `C-c'
prefix to run special picture editing commands.

   One of these keys, `C-c C-c', is pretty important.  Often a picture
is part of a larger file that is usually edited in some other major
mode.  `M-x edit-picture' records the name of the previous major mode.
You can then use the `C-c C-c' command (`picture-mode-exit') to restore
that mode.  `C-c C-c' also deletes spaces from the ends of lines,
unless you give it a numeric argument.

   The commands used in Picture mode all work in other modes (provided
the `picture' library is loaded), but are only  bound to keys in
Picture mode.  Note that the descriptions below talk of moving "one
column" and so on, but all the picture mode commands handle numeric
arguments as their normal equivalents do.

   Turning on Picture mode calls the value of the variable
`picture-mode-hook' as a function, with no arguments, if that value
exists and is non-`nil'.

* Menu:

* Basic Picture::         Basic concepts and simple commands of Picture Mode.
* Insert in Picture::     Controlling direction of cursor motion
                           after "self-inserting" characters.
* Tabs in Picture::       Various features for tab stops and indentation.
* Rectangles in Picture:: Clearing and superimposing rectangles.


File: lemacs.info,  Node: Basic Picture,  Next: Insert in Picture,  Prev: Picture,  Up: Picture

Basic Editing in Picture Mode
=============================

   Most keys do the same thing in Picture mode that they usually do,
but do it in a quarter-plane style.  For example, `C-f' is rebound to
run `picture-forward-column', which moves point one column to the
right, by inserting a space if necessary, so that the actual end of the
line makes no difference.  `C-b' is rebound to run
`picture-backward-column', which always moves point left one column,
converting a tab to multiple spaces if necessary.  `C-n' and `C-p' are
rebound to run `picture-move-down' and `picture-move-up', which can
either insert spaces or convert tabs as necessary to make sure that
point stays in exactly the same column.  `C-e' runs
`picture-end-of-line', which moves to after the last non-blank
character on the line.  There was no need to change `C-a', as the choice
of screen model does not affect beginnings of lines.

   Insertion of text is adapted to the quarter-plane screen model
through the use of Overwrite mode (*note Minor Modes::.).
Self-inserting characters replace existing text, column by column,
rather than pushing existing text to the right.  RET runs
`picture-newline', which just moves to the beginning of the following
line so that new text will replace that line.

   Text is erased instead of deleted and killed.  DEL
(`picture-backward-clear-column') replaces the preceding character with
a space rather than removing it.  `C-d' (`picture-clear-column') does
the same in a forward direction.  `C-k' (`picture-clear-line') really
kills the contents of lines, but never removes the newlines from a
buffer.

   To do actual insertion, you must use special commands.  `C-o'
(`picture-open-line') creates a blank line, but does so after the
current line; it never splits a line.  `C-M-o', `split-line', makes
sense in Picture mode, so it remains unchanged.  LFD
(`picture-duplicate-line') inserts another line with the same contents
below the current line.

   To actually delete parts of the picture, use `C-w', or with `C-c
C-d' (which is defined as `delete-char', as `C-d' is in other modes),
or with one of the picture rectangle commands (*note Rectangles in
Picture::.).


File: lemacs.info,  Node: Insert in Picture,  Next: Tabs in Picture,  Prev: Basic Picture,  Up: Picture

Controlling Motion after Insert
===============================

   Since "self-inserting" characters just overwrite and move point in
Picture mode, there is no essential restriction on how point should be
moved.  Normally point moves right, but you can specify any of the eight
orthogonal or diagonal directions for motion after a "self-inserting"
character.  This is useful for drawing lines in the buffer.

`C-c <'
     Move left after insertion (`picture-movement-left').

`C-c >'
     Move right after insertion (`picture-movement-right').

`C-c ^'
     Move up after insertion (`picture-movement-up').

`C-c .'
     Move down after insertion (`picture-movement-down').

`C-c `'
     Move up and left ("northwest") after insertion
     (`picture-movement-nw').

`C-c ''
     Move up and right ("northeast") after insertion
     (`picture-movement-ne').

`C-c /'
     Move down and left ("southwest") after insertion
     (`picture-movement-sw').

`C-c \'
     Move down and right ("southeast") after insertion
     (`picture-movement-se').

   Two motion commands move based on the current Picture insertion
direction.  The command `C-c C-f' (`picture-motion') moves in the same
direction as motion after "insertion" currently does, while `C-c C-b'
(`picture-motion-reverse') moves in the opposite direction.


File: lemacs.info,  Node: Tabs in Picture,  Next: Rectangles in Picture,  Prev: Insert in Picture,  Up: Picture

Picture Mode Tabs
=================

   Two kinds of tab-like action are provided in Picture mode.
Context-based tabbing is done with `M-TAB' (`picture-tab-search').
With no argument, it moves to a point underneath the next "interesting"
character that follows whitespace in the previous non-blank line.
"Next" here means "appearing at a horizontal position greater than the
one point starts out at".  With an argument, as in `C-u M-TAB', the
command moves to the next such interesting character in the current
line.  `M-TAB' does not change the text; it only moves point.
"Interesting" characters are defined by the variable
`picture-tab-chars', which contains a string of characters considered
interesting.  Its default value is `"!-~"'.

   TAB itself runs `picture-tab', which operates based on the current
tab stop settings; it is the Picture mode equivalent of
`tab-to-tab-stop'.  Without arguments it just moves point, but with a
numeric argument it clears the text that it moves over.

   The context-based and tab-stop-based forms of tabbing are brought
together by the command `C-c TAB', `picture-set-tab-stops'.  This
command sets the tab stops to the positions which `M-TAB' would
consider significant in the current line.  If you use this command,
together with TAB, you can get the effect of context-based tabbing.  But
`M-TAB' is more convenient in the cases where it is sufficient.


File: lemacs.info,  Node: Rectangles in Picture,  Prev: Tabs in Picture,  Up: Picture

Picture Mode Rectangle Commands
===============================

   Picture mode defines commands for working on rectangular pieces of
the text in ways that fit with the quarter-plane model.  The standard
rectangle commands may also be useful (*note Rectangles::.).

`C-c C-k'
     Clear out the region-rectangle (`picture-clear-rectangle').  With
     argument, kill it.

`C-c C-w R'
     Similar but save rectangle contents in register R first
     (`picture-clear-rectangle-to-register').

`C-c C-y'
     Copy last killed rectangle into the buffer by overwriting, with
     upper left corner at point (`picture-yank-rectangle').  With
     argument, insert instead.

`C-c C-x R'
     Similar, but use the rectangle in register R
     (`picture-yank-rectangle-from-register').

   The picture rectangle commands `C-c C-k' (`picture-clear-rectangle')
and `C-c C-w' (`picture-clear-rectangle-to-register') differ from the
standard rectangle commands in that they normally clear the rectangle
instead of deleting it; this is analogous with the way `C-d' is changed
in Picture mode.

   However, deletion of rectangles can be useful in Picture mode, so
these commands delete the rectangle if given a numeric argument.

   The Picture mode commands for yanking rectangles differ from the
standard ones in overwriting instead of inserting.  This is the same
way that Picture mode insertion of other text is different from other
modes.  `C-c C-y' (`picture-yank-rectangle') inserts (by overwriting)
the rectangle that was most recently killed, while `C-c C-x'
(`picture-yank-rectangle-from-register') does for the rectangle found
in a specified register.

   Since most region commands in Picture mode operate on rectangles,
when you select a region of text with the mouse in Picture mode, it is
highlighted as a rectangle.


File: lemacs.info,  Node: Sending Mail,  Next: Rmail,  Prev: Picture,  Up: Top

Sending Mail
************

   To send a message in Emacs, start by typing the command (`C-x m') to
select and initialize the `*mail*' buffer.  You can then edit the text
and headers of the message in the mail buffer, and type the command
(`C-c C-c') to send the message.

`C-x m'
     Begin composing a message to send (`mail').

`C-x 4 m'
     Likewise, but display the message in another window
     (`mail-other-window').

`C-c C-c'
     In Mail mode, send the message and switch to another buffer
     (`mail-send-and-exit').

   The command `C-x m' (`mail') selects a buffer named `*mail*' and
initializes it with the skeleton of an outgoing message.  `C-x 4 m'
(`mail-other-window') selects the `*mail*' buffer in a different
window, leaving the previous current buffer visible.

   Because the buffer for mail composition is an ordinary Emacs buffer,
you can switch to other buffers while in the middle of composing mail,
and switch back later (or never).  If you use the `C-x m' command again
when you have been composing another message but have not sent it, a
new mail buffer will be created; in this way, you can compose multiple
messages at once.  You can switch back to and complete an unsent
message by using the normal buffer selection mechanisms.

   `C-u C-x m' is another way to switch back to a message in progress:
it will search for an existing, unsent mail message buffer and select
it.

* Menu:

* Format: Mail Format.    Format of the mail being composed.
* Headers: Mail Headers.  Details of allowed mail header fields.
* Mode: Mail Mode.        Special commands for editing mail being composed.


File: lemacs.info,  Node: Mail Format,  Next: Mail Headers,  Prev: Sending Mail,  Up: Sending Mail

The Format of the Mail Buffer
=============================

   In addition to the "text" or contents, a message has "header fields"
which say who sent it, when, to whom, why, and so on.  Some header
fields such as the date and sender are created automatically after the
message is sent.  Others, such as the recipient names, must be
specified by you in order to send the message properly.

   Mail mode provides a few commands to help you edit some header
fields, and some are preinitialized in the buffer automatically at
times.  You can insert or edit any header fields using ordinary editing
commands.

   The line in the buffer that says

     --text follows this line--

is a special delimiter that separates the headers you have specified
from the text.  Whatever follows this line is the text of the message;
the headers precede it.  The delimiter line itself does not appear in
the message actually sent.  The text used for the delimiter line is
controlled by the variable `mail-header-separator'.

   Here is an example of what the headers and text in the `*mail*'
buffer might look like.

     To: rms@mc
     CC: mly@mc, rg@oz
     Subject: The Emacs Manual
     --Text follows this line--
     Please ignore this message.

