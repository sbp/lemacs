Info file ../info/emacs, produced by Makeinfo, -*- Text -*- from input
file lemacs.tex.

   This file documents the GNU Emacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992 Lucid, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: emacs,  Node: Lisp Indent,  Next: C Indent,  Prev: Multi-line Indent,  Up: Grinding

Customizing Lisp Indentation
----------------------------

   The indentation pattern for a Lisp expression can depend on the
function called by the expression.  For each Lisp function, you can
choose among several predefined patterns of indentation, or define an
arbitrary one with a Lisp program.

   The standard pattern of indentation is as follows: the second line
of the expression is indented under the first argument, if that is on
the same line as the beginning of the expression; otherwise, the
second line is indented underneath the function name.  Each following
line is indented under the previous line whose nesting depth is the
same.

   If the variable `lisp-indent-offset' is non-`nil', it overrides the
usual indentation pattern for the second line of an expression, so that
such lines are always indented `lisp-indent-offset' more columns than
the containing list.

   Certain functions override the standard pattern.  Functions whose
names start with `def' always indent the second line by
`lisp-body-indention' extra columns beyond the open-parenthesis
starting the expression.

   Individual functions can override the standard pattern in various
ways, according to the `lisp-indent-hook' property of the function
name.  There are four possibilities for this property:

`nil'
     This is the same as no property; the standard indentation pattern
     is used.

`defun'
     The pattern used for function names that start with `def' is used
     for this function also.

a number, NUMBER
     The first NUMBER arguments of the function are "distinguished"
     arguments; the rest are considered the "body" of the expression. 
     A line in the expression is indented according to whether the
     first argument on it is distinguished or not.  If the argument is
     part of the body, the line is indented `lisp-body-indent' more
     columns than the open-parenthesis starting the containing
     expression.  If the argument is distinguished and is either the
     first or second argument, it is indented twice that many extra
     columns.  If the argument is distinguished and not the first or
     second argument, the standard pattern is followed for that line.

a symbol, SYMBOL
     SYMBOL should be a function name; that function is called to
     calculate the indentation of a line within this expression.  The
     function receives two arguments:

    STATE
          The value returned by `parse-partial-sexp' (a Lisp primitive
          for indentation and nesting computation) when it parses up
          to the beginning of this line.

    POS
          The position at which the line being indented begins.

          It should return either a number, which is the number of columns
     of indentation for that line, or a list whose first element is
     such a number.  The difference between returning a number and
     returning a list is that a number says that all following lines
     at the same nesting level should be indented just like this one;
     a list says that following lines might call for different
     indentations.  This makes a difference when the indentation is
     computed by `C-M-q'; if the value is a number, `C-M-q' need not
     recalculate indentation for the following lines until the end of
     the list.


File: emacs,  Node: C Indent,  Prev: Lisp Indent,  Up: Grinding

Customizing C Indentation
-------------------------

   Two variables control which commands perform C indentation and when.

   If `c-auto-newline' is non-`nil', newlines are inserted both before
and after braces that you insert, and after colons and semicolons. 
Correct C indentation is done on all the lines that are made this way.

   If `c-tab-always-indent' is non-`nil', the TAB command in C mode
does indentation only if point is at the left margin or within the
line's indentation.  If there is non-whitespace to the left of point,
TAB just inserts a tab character in the buffer.  Normally, this
variable is `nil', and TAB always reindents the current line.

   C does not have anything analogous to particular function names for
which special forms of indentation are desirable.  However, it has a
different need for customization facilities: many different styles of
C indentation are in common use.

   There are six variables you can set to control the style that Emacs
C mode will use.

`c-indent-level'
     Indentation of C statements within surrounding block.  The
     surrounding block's indentation is the indentation of the line on
     which the open-brace appears.

`c-continued-statement-offset'
     Extra indentation given to a substatement, such as the
     then-clause of an if or body of a while.

`c-brace-offset'
     Extra indentation for lines that start with an open brace.

`c-brace-imaginary-offset'
     An open brace following other text is treated as if it were this
     far to the right of the start of its line.

`c-argdecl-indent'
     Indentation level of declarations of C function arguments.

`c-label-offset'
     Extra indentation for a line that is a label, case, or default.

   The variable `c-indent-level' controls the indentation for C
statements with respect to the surrounding block.  In the example

         {
           foo ();

the difference in indentation between the lines is `c-indent-level'. 
Its standard value is 2.

   If the open-brace beginning the compound statement is not at the
beginning of its line, the `c-indent-level' is added to the
indentation of the line, not the column of the open-brace.  For
example,

     if (losing) {
       do_this ();

One popular indentation style is that which results from setting
`c-indent-level' to 8 and putting open-braces at the end of a line in
this way.  Another popular style prefers to put the open-brace on a
separate line.

   In fact, the value of the variable `c-brace-imaginary-offset' is
also added to the indentation of such a statement.  Normally this
variable is zero.  Think of this variable as the imaginary position of
the open brace, relative to the first non-blank character on the line.
 By setting the variable to 4 and `c-indent-level' to 0, you can get
this style:

     if (x == y) {
         do_it ();
         }

   When `c-indent-level' is zero, the statements inside most braces
line up exactly under the open brace.  An exception are braces in
column zero, like those surrounding a function's body.  The statements
inside those braces are not placed at column zero.  Instead,
`c-brace-offset' and `c-continued-statement-offset' (see below) are
added to produce a typical offset between brace levels, and the
statements are indented that far.

   `c-continued-statement-offset' controls the extra indentation for a
line that starts within a statement (but not within parentheses or
brackets).  These lines are usually statements inside other statements,
like the then-clauses of `if' statements and the bodies of `while'
statements.  The `c-continued-statement-offset' parameter determines
the difference in indentation between the two lines in

     if (x == y)
       do_it ();

The default value for `c-continued-statement-offset' is 2.  Some
popular indentation styles correspond to a value of zero for
`c-continued-statement-offset'.

   `c-brace-offset' is the extra indentation given to a line that
starts with an open-brace.  Its standard value is zero; compare

     if (x == y)
       {

with

     if (x == y)
       do_it ();

if you set `c-brace-offset' to 4, the first example becomes

     if (x == y)
           {

   `c-argdecl-indent' controls the indentation of declarations of the
arguments of a C function.  It is absolute: argument declarations
receive exactly `c-argdecl-indent' spaces.  The standard value is 5 and
results in code like this:

     char *
     index (string, char)
          char *string;
          int char;

   `c-label-offset' is the extra indentation given to a line that
contains a label, a case statement, or a `default:' statement.  Its
standard value is -2 and results in code like this

     switch (c)
       {
       case 'x':

If `c-label-offset' were zero, the same code would be indented as

     switch (c)
       {
         case 'x':

This example assumes that the other variables above also have their
default values.

   Using the indentation style produced by the default settings of the
variables just discussed, and putting open braces on separate lines
produces clear and readable files.  For an example, look at any of the
C source files of GNU Emacs.


File: emacs,  Node: Matching,  Next: Comments,  Prev: Grinding,  Up: Programs

Automatic Display of Matching Parentheses
=========================================

   The Emacs parenthesis-matching feature shows you automatically how
parentheses match in the text.  Whenever a self-inserting character
that is a closing delimiter is typed, the cursor moves momentarily to
the location of the matching opening delimiter, provided that is
visible on the screen.  If it is not on the screen, some text starting
with that opening delimiter is displayed in the echo area.  Either
way, you see the grouping you are closing off.

   In Lisp, automatic matching applies only to parentheses.  In C, it
also applies to braces and brackets.  Emacs knows which characters to
regard as matching delimiters based on the syntax table set by the
major mode.  *Note Syntax::.

   If the opening delimiter and closing delimiter are mismatched--such
as in `[x)'--the echo area displays a warning message.  The correct
matches are specified in the syntax table.

   Two variables control parenthesis matching displays. 
`blink-matching-paren' turns the feature on or off: `nil' turns it
off, but the default is `t' to turn match display on. 
`blink-matching-paren-distance' specifies how many characters back
Emacs searches to find a matching opening delimiter.  If the match is
not found in the specified region, scanning stops, and nothing is
displayed.  This prevents wasting lots of time scanning when there is
no match.  The default is 4000.


File: emacs,  Node: Comments,  Next: Balanced Editing,  Prev: Matching,  Up: Programs

Manipulating Comments
=====================

   The comment commands insert, kill and align comments.

`M-;'
     Insert or align comment (`indent-for-comment').

`C-x ;'
     Set comment column (`set-comment-column').

`C-u - C-x ;'
     Kill comment on current line (`kill-comment').

`M-LFD'
     Like RET followed by inserting and aligning a comment
     (`indent-new-comment-line').

   The command that creates a comment is `Meta-;'
(`indent-for-comment').  If there is no comment already on the line, a
new comment is created and aligned at a specific column called the
"comment column".  Emacs creates the comment by inserting the string
at the value of `comment-start'; see below.  Point is left after that
string.  If the text of the line extends past the comment column,
indentation is done to a suitable boundary (usually, at least one
space is inserted).  If the major mode has specified a string to
terminate comments, that string is inserted after point, to keep the
syntax valid.

   You can also use `Meta-;' to align an existing comment.  If a line
already contains the string that starts comments, `M-;' just moves
point after it and re-indents it to the conventional place.  Exception:
comments starting in column 0 are not moved.

   Some major modes have special rules for indenting certain kinds of
comments in certain contexts.  For example, in Lisp code, comments
which start with two semicolons are indented as if they were lines of
code, instead of at the comment column.  Comments which start with
three semicolons are supposed to start at the left margin.  Emacs
understands these conventions by indenting a double-semicolon comment
using TAB, and by not changing the indentation of a triple-semicolon
comment at all.

     ;; This function is just an example
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;; And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

   In C code, a comment preceded on its line by nothing but whitespace
is indented like a line of code.

   Even when an existing comment is properly aligned, `M-;' is still
useful for moving directly to the start of the comment.

   `C-u - C-x ;' (`kill-comment') kills the comment on the current
line, if there is one.  The indentation before the start of the
comment is killed as well.  If there does not appear to be a comment in
the line, nothing happens.  To reinsert the comment on another line,
move to the end of that line, type first `C-y', and then `M-;' to
realign the comment.  Note that `C-u - C-x ;' is not a distinct key;
it is `C-x ;' (`set-comment-column') with a negative argument.  That
command is programmed to call `kill-comment' when called with a
negative argument.  However, `kill-comment' is a valid command which
you could bind directly to a key if you wanted to.

Multiple Lines of Comments
--------------------------

   If you are typing a comment and want to continue it on another line,
use the command `Meta-LFD' (`indent-new-comment-line'), which
terminates the comment you are typing, creates a new blank line
afterward, and begins a new comment indented under the old one.  If
Auto Fill mode is on and you go past the fill column while typing, the
comment is continued in just this fashion.  If point is not at the end
of the line when you type `M-LFD', the text on the rest of the line
becomes part of the new comment line.

Options Controlling Comments
----------------------------

   The comment column is stored in the variable `comment-column'.  You
can explicitly set it to a number.  Alternatively, the command `C-x ;'
(`set-comment-column') sets the comment column to the column point is
at.  `C-u C-x ;' sets the comment column to match the last comment
before point in the buffer, and then calls `Meta-;' to align the
current line's comment under the previous one.  Note that `C-u - C-x ;'
runs the function `kill-comment' as described above.

   `comment-column' is a per-buffer variable; altering the variable
affects only the current buffer.  You can also change the default
value.  *Note Locals::.  Many major modes initialize this variable for
the current buffer.

   The comment commands recognize comments based on the regular
expression that is the value of the variable `comment-start-skip'. 
This regexp should not match the null string.  It may match more than
the comment starting delimiter in the strictest sense of the word; for
example, in C mode the value of the variable is `"/\\*+ *"', which
matches extra stars and spaces after the `/*' itself.  (Note that `\\'
is needed in Lisp syntax to include a `\' in the string, which is
needed to deny the first star its special meaning in regexp syntax. 
*Note Regexps::.)

   When a comment command makes a new comment, it inserts the value of
`comment-start' to begin it.  The value of `comment-end' is inserted
after point, and will follow the text you will insert into the
comment.  In C mode, `comment-start' has the value `"/* "' and
`comment-end' has the value `" */"'.

   `comment-multi-line' controls how `M-LFD'
(`indent-new-comment-line') behaves when used inside a comment.  If
`comment-multi-line' is `nil', as it normally is, then `M-LFD'
terminates the comment on the starting line and starts a new comment
on the new following line.  If `comment-multi-line' is not `nil', then
`M-LFD' sets up the new following line as part of the same comment
that was found on the starting line.  This is done by not inserting a
terminator on the old line, and not inserting a starter on the new
line.  In languages where multi-line comments are legal, the value you
choose for this variable is a matter of taste.

   The variable `comment-indent-hook' should contain a function that
is called to compute the indentation for a newly inserted comment or
for aligning an existing comment.  Major modes set this variable
differently.  The function is called with no arguments, but with point
at the beginning of the comment, or at the end of a line if a new
comment is to be inserted.  The function should return the column in
which the comment ought to start.  For example, in Lisp mode, the
indent hook function bases its decision on the number of semicolons
that begin an existing comment, and on the code in the preceding lines.


File: emacs,  Node: Balanced Editing,  Next: Lisp Completion,  Prev: Comments,  Up: Programs

Editing Without Unbalanced Parentheses
======================================

`M-('
     Put parentheses around next sexp(s) (`insert-parentheses').

`M-)'
     Move past next close parenthesis and re-indent
     (`move-over-close-and-reindent').

   The commands `M-(' (`insert-parentheses') and `M-)'
(`move-over-close-
and-reindent') are designed to facilitate a style of editing which
keeps parentheses balanced at all times.  `M-(' inserts a pair of
parentheses, either together as in `()', or, if given an argument,
around the next several sexps, and leaves point after the open
parenthesis.  Instead of typing `( F O O )', you can type `M-( F O O',
which has the same effect except for leaving the cursor before the
close parenthesis.  You can then type `M-)', which moves past the
close parenthesis, deletes any indentation preceding it (in this
example there is none), and indents with LFD after it.


File: emacs,  Node: Lisp Completion,  Next: Documentation,  Prev: Balanced Editing,  Up: Programs

Completion for Lisp Symbols
===========================

   Completion usually happens in the minibuffer.  An exception is
completion for Lisp symbol names, which is available in all buffers.

   The command `M-TAB' (`lisp-complete-symbol') takes the partial Lisp
symbol before point to be an abbreviation, and compares it against all
non-trivial Lisp symbols currently known to Emacs.  Any additional
characters that they all have in common are inserted at point. 
Non-trivial symbols are those that have function definitions, values or
properties.

   If there is an open-parenthesis immediately before the beginning of
the partial symbol, only symbols with function definitions are
considered as completions.

   If the partial name in the buffer has more than one possible
completion and they have no additional characters in common, a list of
all possible completions is displayed in another window.


File: emacs,  Node: Documentation,  Next: Change Log,  Prev: Lisp Completion,  Up: Programs

Documentation Commands
======================

   As you edit Lisp code to be run in Emacs, you can use the commands
`C-h f' (`describe-function') and `C-h v' (`describe-variable') to
print documentation of functions and variables you want to call. 
These commands use the minibuffer to read the name of a function or
variable to document, and display the documentation in a window.

   For extra convenience, these commands provide default arguments
based on the code in the neighborhood of point.  `C-h f' sets the
default to the function called in the innermost list containing point.
 `C-h v' uses the symbol name around or adjacent to point as its
default.

   The `M-x manual-entry' command gives you access to documentation on
Unix commands, system calls, and libraries.  The command reads a topic
as an argument, and displays the Unix manual page for that topic. 
`manual-entry' always searches all 8 sections of the manual, and
concatenates all the entries it finds.  For example, the topic
`termcap' finds the description of the termcap library from section 3,
followed by the description of the termcap data base from section 5.


File: emacs,  Node: Change Log,  Next: Tags,  Prev: Documentation,  Up: Programs

Change Logs
===========

   The Emacs command `M-x add-change-log-entry' helps you keep a record
of when and why you have changed a program.  It assumes that you have a
file in which you write a chronological sequence of entries describing
individual changes.  The default is to store the change entries in a
file called `ChangeLog' in the same directory as the file you are
editing.  The same `ChangeLog' file therefore records changes for all
the files in a directory.

   A change log entry starts with a header line that contains your name
and the current date.  Except for these header lines, every line in the
change log starts with a tab.  One entry can describe several changes;
each change starts with a line starting with a tab and a star.  `M-x
add-change-log-entry' visits the change log file and creates a new
entry unless the most recent entry is for today's date and your name. 
In either case, it adds a new line to start the description of another
change just after the header line of the entry.  When `M-x
add-change-log-entry' is finished, all is prepared for you to edit in
the description of what you changed and how.  You must then save the
change log file yourself.

   The change log file is always visited in Indented Text mode, which
means that LFD and auto-filling indent each new line like the previous
line.  This is convenient for entering the contents of an entry, which
must be indented.  *Note Text Mode::.

   Here is an example of the formatting conventions used in the change
log for Emacs:

     Wed Jun 26 19:29:32 1985  Richard M. Stallman  (rms at mit-prep)
     
             * xdisp.c (try_window_id):
             If C-k is done at end of next-to-last line,
             this fn updates window_end_vpos and cannot leave
             window_end_pos nonnegative (it is zero, in fact).
             If display is preempted before lines are output,
             this is inconsistent.  Fix by setting
             blank_end_of_window to nonzero.
     
     Tue Jun 25 05:25:33 1985  Richard M. Stallman  (rms at mit-prep)
     
             * cmds.c (Fnewline):
             Call the auto fill hook if appropriate.
     
             * xdisp.c (try_window_id):
             If point is found by compute_motion after xp, record that
             permanently.  If display_text_line sets point position wrong
             (case where line is killed, point is at eob and that line is
             not displayed), set it again in final compute_motion.


File: emacs,  Node: Tags,  Next: Fortran,  Prev: Change Log,  Up: Programs

Tag Tables
==========

   A "tag table" is a description of how a multi-file program is
broken up into files.  It lists the names of the component files and
the names and positions of the functions in each file.  Grouping the
related files makes it possible to search or replace through all the
files with one command.  Recording the function names and positions
makes it possible to use the `Meta-.' command which finds the
definition of a function without asking for information on the file it
is in.

   Tag tables are stored in files called "tag table files".  The
conventional name for a tag table file is `TAGS'.

   Each entry in the tag table records the name of one tag, the name
of the file that the tag is defined in (implicitly), and the position
in that file of the tag's definition.

   The programming language of a file determines what names are
recorded in the tag table depends on.  Normally, Emacs includes all
functions and subroutines, and may also include global variables, data
types, and anything else convenient.  Each recorded name is called a
"tag".

* Menu:

* Tag Syntax::
* Create Tag Table::
* Select Tag Table::
* Find Tag::
* Tags Search::
* Tags Stepping::
* List Tags::


File: emacs,  Node: Tag Syntax,  Next: Create Tag Table,  Prev: Tags,  Up: Tags

Source File Tag Syntax
----------------------

   In Lisp code, any function defined with `defun', any variable
defined with `defvar' or `defconst', and the first argument of any
expression that starts with `(def' in column zero, is a tag.

   In C code, any C function is a tag, and so is any typedef if `-t' is
specified when the tag table is constructed.

   In Fortran code, functions and subroutines are tags.

   In LaTeX text, the argument of any of the commands `\chapter',
`\section', `\subsection', `\subsubsection', `\eqno', `\label',
`\ref', `\cite', `\bibitem' and 
`\typeout' is a tag.


File: emacs,  Node: Create Tag Table,  Next: Select Tag Table,  Prev: Tag Syntax,  Up: Tags

Creating Tag Tables
-------------------

   The `etags' program is used to create a tag table file.  It knows
the syntax of C, Fortran, LaTeX, Scheme and Emacs Lisp/Common Lisp.  To
use `etags', use it as a shell command

     etags INPUTFILES...

The program reads the specified files and writes a tag table named
`TAGS' in the current working directory.  `etags' recognizes the
language used in an input file based on the name and contents of the
file; there are no switches for specifying the language.  The `-t'
switch tells `etags' to record typedefs in C code as tags.

   If the tag table data become outdated due to changes in the files
described in the table, you can update the tag table by running the
program from the shell again.  It is not necessary to do this often.

   If the tag table fails to record a tag, or records it for the wrong
file, Emacs cannot find its definition.  However, if the position
recorded in the tag table becomes a little bit wrong (due to some
editing in the file that the tag definition is in), the only
consequence is to slow down finding the tag slightly.  Even if the
stored position is very wrong, Emacs will still find the tag, but it
must search the entire file for it.

   You should update a tag table when you define new tags you want to
have listed, or when you move tag definitions from one file to another,
or when changes become substantial.  You don't have to update the tag
table after each edit, or even every day.


File: emacs,  Node: Select Tag Table,  Next: Find Tag,  Prev: Create Tag Table,  Up: Tags

Selecting a Tag Table
---------------------

   At any time Emacs has one "selected" tag table, and all the commands
for working with tag tables use the selected one.  To select a tag
table, type `M-x visit-tags-table', which reads the tag table file
name as an argument.  The name `TAGS' in the default directory is used
as the default file name.

   `M-x visit-tags-table' only stores the file name you provide in the
variable `tags-file-name'.  Emacs does not actually read in the tag
table contents until you try to use them.  You can set the variable
explicitly instead of using `visit-tags-table'.  The variable's
initial value is `nil'; this value tells all the commands for working
with tag tables that they must ask for a tag table file name to use.


File: emacs,  Node: Find Tag,  Next: Tags Search,  Prev: Select Tag Table,  Up: Tags

Finding a Tag
-------------

   The most important thing that a tag table enables you to do is to
find the definition of a specific tag.

`M-. TAG'
     Find first definition of TAG (`find-tag').

`C-u M-.'
     Find next alternate definition of last tag specified.

`C-x 4 . TAG'
     Find first definition of TAG, but display it in another window
     (`find-tag-other-window').

   `M-.' (`find-tag') is the command to find the definition of a
specified tag.  It searches through the tag table for that tag, as a
string, then uses the tag table information to determine the file in
which the definition is used and the approximate character position of
the definition in the file.  Then `find-tag' visits the file, moves
point to the approximate character position, and starts searching
ever-increasing distances away for the text that should appear at the
beginning of the definition.

   If an empty argument is given (just type RET), the sexp in the
buffer before or around point is used as the name of the tag to find. 
*Note Lists::, for information on sexps.

   The argument to `find-tag' need not be the whole tag name; it can
be a substring of a tag name.  However, there can be many tag names
containing the substring you specify.  Since `find-tag' works by
searching the text of the tag table, it finds the first tag in the
table that the specified substring appears in.  To find other tags
that match the substring, give `find-tag' a numeric argument, as in
`C-u M-.'.  This does not read a tag name, but continues searching the
tag table's text for another tag containing the same substring last
used.  If your keyboard has a real META key, `M-0 M-.' is an easier
alternative to `C-u M-.'.

   Like most commands that can switch buffers, `find-tag' has another
similar command that displays the new buffer in another window.  `C-x 4
.' invokes the function `find-tag-other-window'.  (This key sequence
ends with a period.)

   Emacs comes with a tag table file `TAGS', in the directory
containing Lisp libraries, which includes all the Lisp libraries and
all the C sources of Emacs.  By specifying this file with
`visit-tags-table' and then using `M-.' you can quickly look at the
source of any Emacs function.


File: emacs,  Node: Tags Search,  Next: Tags Stepping,  Prev: Find Tag,  Up: Tags

Searching and Replacing with Tag Tables
---------------------------------------

   The commands in this section visit and search all the files listed
in the selected tag table, one by one.  For these commands, the tag
table serves only to specify a sequence of files to search.  A related
command is `M-x grep' (*note Compilation::.).

`M-x tags-search'
     Search for the specified regexp through the files in the selected
     tag table.

`M-x tags-query-replace'
     Perform a `query-replace' on each file in the selected tag table.

`M-,'
     Restart one of the commands above, from the current location of
     point (`tags-loop-continue').

   `M-x tags-search' reads a regexp using the minibuffer, then visits
the files of the selected tag table one by one, and searches through
each file for that regexp.  It displays the name of the file being
searched so you can follow its progress.  As soon as an occurrence is
found, `tags-search' returns.

   After you have found one match, you probably want to find all the
rest.  To find one more match, type `M-,' (`tags-loop-continue') to
resume the `tags-search'.  This searches the rest of the current
buffer, followed by the remaining files of the tag table.

   `M-x tags-query-replace' performs a single `query-replace' through
all the files in the tag table.  It reads a string to search for and a
string to replace with, just like ordinary `M-x query-replace'.  It
searches much like `M-x tags-search' but repeatedly, processing
matches according to your input.  *Note Replace::, for more
information on `query-replace'.

   It is possible to get through all the files in the tag table with a
single invocation of `M-x tags-query-replace'.  But since any
unrecognized character causes the command to exit, you may need to
continue where you left off.  You can use `M-,' to do this.  It
resumes the last tags search or replace command that you did.

   It may have struck you that `tags-search' is a lot like `grep'. 
You can also run `grep' itself as an inferior of Emacs and have Emacs
show you the matching lines one by one.  This works mostly the same as
running a compilation and having Emacs show you where the errors were. 
*Note Compilation::.


File: emacs,  Node: Tags Stepping,  Next: List Tags,  Prev: Tags Search,  Up: Tags

Stepping Through a Tag Table
----------------------------

   If you wish to process all the files in a selected tag table, but
`M-x tags-search' and `M-x tags-query-replace' are not giving you the
desired result, you can use `M-x next-file'.

`C-u M-x next-file'
     With a numeric argument, regardless of its value, visit the first
     file in the tag table, and prepare to advance sequentially by
     files.

`M-x next-file'
     Visit the next file in the selected tag table.


File: emacs,  Node: List Tags,  Prev: Tags Stepping,  Up: Tags

Tag Table Inquiries
-------------------

`M-x list-tags'
     Display a list of the tags defined in a specific program file.

`M-x tags-apropos'
     Display a list of all tags matching a specified regexp.

   `M-x list-tags' reads the name of one of the files described by the
selected tag table, and displays a list of all the tags defined in that
file.  The "file name" argument is really just a string to compare
against the names recorded in the tag table; it is read as a string
rather than a file name.  Therefore, completion and defaulting are not
available, and you must enter the string the same way it appears in
the tag table.  Do not include a directory as part of the file name
unless the file name recorded in the tag table contains that directory.

   `M-x tags-apropos' is like `apropos' for tags.  It reads a regexp,
then finds all the tags in the selected tag table whose entries match
that regexp, and displays the tag names found.


File: emacs,  Node: Fortran,  Prev: Tags,  Up: Programs

Fortran Mode
============

   Fortran mode provides special motion commands for Fortran
statements and subprograms, and indentation commands that understand
Fortran conventions of nesting, line numbers and continuation
statements.

   Special commands for comments are provided because Fortran comments
are unlike those of other languages.

   Built-in abbrevs optionally save typing when you insert Fortran
keywords.

   Use `M-x fortran-mode' to switch to this major mode.  Doing so calls
the value of `fortran-mode-hook' as a function of no arguments if that
variable has a non- `nil' value.

* Menu:

* Motion: Fortran Motion.     Moving point by statements or subprograms.
* Indent: Fortran Indent.     Indentation commands for Fortran.
* Comments: Fortran Comments. Inserting and aligning comments.
* Columns: Fortran Columns.   Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.     Built-in abbrevs for Fortran keywords.

   Fortran mode was contributed by Michael Prange.


File: emacs,  Node: Fortran Motion,  Next: Fortran Indent,  Prev: Fortran,  Up: Fortran

Motion Commands
---------------

   Fortran mode provides special commands to move by subprograms
(functions and subroutines) and by statements.  There is also a
command to put the region around one subprogram, convenient for
killing it or moving it.

`C-M-a'
     Move to beginning of subprogram
      (`beginning-of-fortran-subprogram').

`C-M-e'
     Move to end of subprogram (`end-of-fortran-subprogram').

`C-M-h'
     Put point at beginning of subprogram and mark at end
     (`mark-fortran-subprogram').

`C-c C-n'
     Move to beginning of current or next statement (`fortran-next-
     statement').

`C-c C-p'
     Move to beginning of current or previous statement (`fortran-
     previous-statement').


File: emacs,  Node: Fortran Indent,  Next: Fortran Comments,  Prev: Fortran Motion,  Up: Fortran

Fortran Indentation
-------------------

   Special commands and features are available for indenting Fortran
code.  They make sure various syntactic entities (line numbers,
comment line indicators and continuation line flags) appear in the
columns that are required for standard Fortran.

* Menu:

* Commands: ForIndent Commands. Commands for indenting Fortran.
* Numbers:  ForIndent Num.      How line numbers auto-indent.
* Conv:     ForIndent Conv.     Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.     Variables controlling Fortran indent style.


File: emacs,  Node: ForIndent Commands,  Next: ForIndent Num,  Prev: Fortran Indent,  Up: Fortran Indent

Fortran Indentation Commands
............................

`TAB'
     Indent the current line (`fortran-indent-line').

`M-LFD'
     Break the current line and set up a continuation line.

`C-M-q'
     Indent all the lines of the subprogram point is in
     (`fortran-indent-subprogram').

   TAB is redefined by Fortran mode to reindent the current line for
Fortran (`fortran-indent-line').  Line numbers and continuation
markers are indented to their required columns, and the body of the
statement is independently indented based on its nesting in the
program.

   The key `C-M-q' is redefined as `fortran-indent-subprogram', a
command that reindents all the lines of the Fortran subprogram
(function or subroutine) containing point.

   The key `M-LFD' is redefined as `fortran-split-line', a command to
split a line in the appropriate fashion for Fortran.  In a non-comment
line, the second half becomes a continuation line and is indented
accordingly.  In a comment line, both halves become separate comment
lines.


File: emacs,  Node: ForIndent Num,  Next: ForIndent Conv,  Prev: ForIndent Commands,  Up: Fortran Indent

Line Numbers and Continuation
.............................

   If a number is the first non-whitespace in the line, it is assumed
to be a line number and is moved to columns 0 through 4.  (Columns are
always counted from 0 in GNU Emacs.)  If the text on the line starts
with the conventional Fortran continuation marker `$', it is moved to
column 5.  If the text begins with any non whitespace character in
column 5, it is assumed to be an unconventional continuation marker
and remains in column 5.

   Line numbers of four digits or less are normally indented one space. 
This amount is controlled by the variable `fortran-line-number-indent'
which is the maximum indentation a line number can have.  Line numbers
are indented to right-justify them to end in column 4 unless that would
require more than the maximum indentation.  The default value of the
variable is 1.

   Simply inserting a line number is enough to indent it according to
these rules.  As each digit is inserted, the indentation is
recomputed.  To turn off this feature, set the variable
`fortran-electric-line-number' to `nil'.  Then inserting line numbers
is like inserting anything else.


File: emacs,  Node: ForIndent Conv,  Next: ForIndent Vars,  Prev: ForIndent Num,  Up: Fortran Indent

Syntactic Conventions
.....................

   Fortran mode assumes that you follow certain conventions that
simplify the task of understanding a Fortran program well enough to
indent it properly:

   * Two nested `do' loops never share a `continue' statement.

   * The same character appears in column 5 of all continuation lines.
      It is the value of the variable `fortran-continuation-char'.  By
     default, this character is `$'.

If you fail to follow these conventions, the indentation commands may
indent some lines unaesthetically.  However, a correct Fortran program
will retain its meaning when reindented even if the conventions are not
followed.


File: emacs,  Node: ForIndent Vars,  Prev: ForIndent Conv,  Up: Fortran Indent

Variables for Fortran Indentation
.................................

   Several additional variables control how Fortran indentation works.

`fortran-do-indent'
     Extra indentation within each level of `do' statement (default 3).

`fortran-if-indent'
     Extra indentation within each level of `if' statement (default 3).

`fortran-continuation-indent'
     Extra indentation for bodies of continuation lines (default 5).

`fortran-check-all-num-for-matching-do'
     If this is `nil', indentation assumes that each `do' statement
     ends on a `continue' statement.  Therefore, when computing
     indentation for a statement other than `continue', it can save
     time by not checking for a `do' statement ending there.  If this
     is non-`nil', indenting any numbered statement must check for a
     `do' that ends there.  The default is `nil'.

`fortran-minimum-statement-indent'
     Minimum indentation for Fortran statements.  For standard Fortran,
     this is 6.  Statement bodies are always indented at least this
     much.


File: emacs,  Node: Fortran Comments,  Next: Fortran Columns,  Prev: Fortran Indent,  Up: Fortran

Comments
--------

   The usual Emacs comment commands assume that a comment can follow a
line of code.  In Fortran, the standard comment syntax requires an
entire line to be just a comment.  Therefore, Fortran mode replaces
the standard Emacs comment commands and defines some new variables.

   Fortran mode can also handle a non-standard comment syntax where
comments start with `!' and can follow other text.  Because only some
Fortran compilers accept this syntax, Fortran mode will not insert
such comments unless you have specified to do so in advance by setting
the variable `comment-start' to `"!"' (*note Variables::.).

`M-;'
     Align comment or insert new comment (`fortran-comment-indent').

`C-x ;'
     Applies to nonstandard `!' comments only.

`C-c ;'
     Turn all lines of the region into comments, or (with arg) turn
     them back into real code (`fortran-comment-region').

   `M-;' in Fortran mode is redefined as the command
`fortran-comment-indent'.  Like the usual `M-;' command, recognizes an
existing comment and aligns its text appropriately.  If there is no
existing comment, a comment is inserted and aligned.

   Inserting and aligning comments is not the same in Fortran mode as
in other modes.  When a new comment must be inserted, a full-line
comment is inserted if the current line is blank.  On a non-blank
line, a non-standard `!' comment is inserted if you previously
specified you wanted to use them.  Otherwise a full-line comment is
inserted on a new line before the current line.

   Non-standard `!' comments are aligned like comments in other
languages, but full-line comments are aligned differently.  In a
standard full-line comment, the comment delimiter itself must always
appear in column zero.  What can be aligned is the text within the
comment.  You can choose from three styles of alignment by setting the
variable `fortran-comment-indent-style' to one of these values:

`fixed'
     The text is aligned at a fixed column, which is the value of
     `fortran-comment-line-column'.  This is the default.

`relative'
     The text is aligned as if it were a line of code, but with an
     additional `fortran-comment-line-column' columns of indentation.

`nil'
     Text in full-line columns is not moved automatically.

   You can also specify the character to be used to indent within
full-line comments by setting the variable
`fortran-comment-indent-char' to the character you want to use.

   Fortran mode introduces two variables `comment-line-start' and
`comment-line-start-skip' which play for full-line comments the same
roles played by `comment-start' and `comment-start-skip' for ordinary
text-following comments.  Normally these are set properly by Fortran
mode so you do not need to change them.

   The normal Emacs comment command `C-x ;' has not been redefined. 
It can therefore be used if you use `!' comments, but is useless in
Fortran mode otherwise.

   The command `C-c ;' (`fortran-comment-region') turns all the lines
of the region into comments by inserting the string `C$$$' at the
front of each one.  With a numeric arg, the region is turned back into
live code by deleting `C$$$' from the front of each line.  You can
control the string used for the comments by setting the variable
`fortran-comment-region'.  Note that here we have an example of a
command and a variable with the same name; the two uses of the name
never conflict because in Lisp and in Emacs it is always clear from
the context which one is referred to.


File: emacs,  Node: Fortran Columns,  Next: Fortran Abbrev,  Prev: Fortran Comments,  Up: Fortran

Columns
-------

`C-c C-r'
     Displays a "column ruler" momentarily above the current line
     (`fortran-column-ruler').

`C-c C-w'
     Splits the current window horizontally so that it is 72 columns
     wide.  This may help you avoid going over that limit
     (`fortran-window-create').

   The command `C-c C-r' (`fortran-column-ruler') shows a column ruler
above the current line.  The comment ruler consists of two lines of
text that show you the locations of columns with special significance
in Fortran programs.  Square brackets show the limits of the columns
for line numbers, and curly brackets show the limits of the columns
for the statement body.  Column numbers appear above them.

   Note that the column numbers count from zero, as always in GNU
Emacs.  As a result, the numbers may not be those you are familiar
with; but the actual positions in the line are standard Fortran.

   The text used to display the column ruler is the value of the
variable `fortran-comment-ruler'.  By changing this variable, you can
change the display.

   For even more help, use `C-c C-w' (`fortran-window-create'), a
command which splits the current window horizontally, resulting in a
window 72 columns wide.  When you edit in this window, you can
immediately see when a line gets too wide to be correct Fortran.


File: emacs,  Node: Fortran Abbrev,  Prev: Fortran Columns,  Up: Fortran

Fortran Keyword Abbrevs
-----------------------

   Fortran mode provides many built-in abbrevs for common keywords and
declarations.  These are the same sort of abbrev that you can define
yourself.  To use them, you must turn on Abbrev mode.  *note
Abbrevs::..

   The built-in abbrevs are unusual in one way: they all start with a
semicolon.  You cannot normally use semicolon in an abbrev, but Fortran
mode makes this possible by changing the syntax of semicolon to "word
constituent".

   For example, one built-in Fortran abbrev is `;c' for `continue'. 
If you insert `;c' and then insert a punctuation character such as a
space or a newline, the `;c' changes automatically to `continue',
provided Abbrev mode is enabled.

   Type `;?' or `;C-h' to display a list of all built-in Fortran
abbrevs and what they stand for.


File: emacs,  Node: Running,  Next: Abbrevs,  Prev: Programs,  Up: Top

Compiling and Testing Programs
******************************

   The previous chapter discusses the Emacs commands that are useful
for making changes in programs.  This chapter deals with commands that
assist in the larger process of developing and maintaining programs.

* Menu:

* Compilation::        Compiling programs in languages other than Lisp
                        (C, Pascal, etc.)
* Modes: Lisp Modes.   Various modes for editing Lisp programs, with
                       different facilities for running the Lisp programs.
* Libraries: Lisp Libraries.      Creating Lisp programs to run in Emacs.
* Interaction: Lisp Interaction.  Executing Lisp in an Emacs buffer.
* Eval: Lisp Eval.     Executing a single Lisp expression in Emacs.
* Debug: Lisp Debug.   Debugging Lisp programs running in Emacs.
* External Lisp::      Communicating through Emacs with a separate Lisp.

