This is Info file ../../info/lispref.info, produced by Makeinfo-1.56
from the input file lispref.texinfo.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Invoking the Debugger,  Next: Internals of Debugger,  Prev: Debugger Commands,  Up: Debugger

Invoking the Debugger
---------------------

   Here we describe fully the function used to invoke the debugger.

 - Function: debug &rest DEBUGGER-ARGS
     This function enters the debugger.  It switches buffers to a buffer
     named `*Backtrace*' (or `*Backtrace*<2>' if it is the second
     recursive entry to the debugger, etc.), and fills it with
     information about the stack of Lisp function calls.  It then
     enters a recursive edit, leaving that buffer in Debugger mode and
     displayed in the selected window.

     Debugger mode provides a `c' command which operates by exiting the
     recursive edit, switching back to the previous buffer, and
     returning to whatever called `debug'.  The `r' command also
     returns from `debug'.  These are the only ways the function
     `debug' can return to its caller.

     If the first of the DEBUGGER-ARGS passed to `debug' is `nil' (or
     if it is not one of the following special values), then the rest
     of the arguments to `debug' are printed at the top of the
     `*Backtrace*' buffer.  This mechanism is used to display a message
     to the user.

     However, if the first argument passed to `debug' is one of the
     following special values, then it has special significance.
     Normally, these values are passed to `debug' only by the internals
     of Emacs and the debugger, and not by programmers calling `debug'.

     The special values are:

    `lambda'
          When the first argument is `lambda', the debugger displays
          `Entering:' as a line of text at the top of the buffer.  This
          means that a function is being entered when
          `debug-on-next-call' is non-`nil'.

    `debug'
          When the first argument is `debug', the debugger displays
          `Entering:' just as in the `lambda' case.  However, `debug'
          as the argument indicates that the reason for entering the
          debugger is that a function set to debug on entry is being
          entered.

          In addition, `debug' as the first argument directs the
          debugger to mark the function that called `debug' so that it
          will invoke the debugger when exited.  (When `lambda' is the
          first argument, the debugger does not do this, because it has
          already been done by the interpreter.)

    `t'
          When the first argument is `t', the debugger displays the
          following as the top line in the buffer:

               Beginning evaluation of function call form:

          This indicates that it was entered due to the evaluation of a
          list form at a time when `debug-on-next-call' is non-`nil'.

    `exit'
          When the first argument is `exit', it indicates the exit of a
          stack frame previously marked to invoke the debugger on exit.
          The second argument given to `debug' in this case is the
          value being returned from the frame.  The debugger displays
          `Return value:' on the top line of the buffer, followed by
          the value being returned.

    `error'
          When the first argument is `error', the debugger indicates
          that it is being entered because an error or `quit' was
          signaled and not handled, by displaying `Signaling:' followed
          by the error signaled and any arguments to `signal'.  For
          example,

               (let ((debug-on-error t))
                    (/ 1 0))
               
               ------ Buffer: *Backtrace* ------
               Signaling: (arith-error)
                 /(1 0)
               ...
               ------ Buffer: *Backtrace* ------

          If an error was signaled, presumably the variable
          `debug-on-error' is non-`nil'.  If `quit' was signaled, then
          presumably the variable `debug-on-quit' is non-`nil'.

    `nil'
          Use `nil' as the first of the DEBUGGER-ARGS when you want to
          enter the debugger explicitly.  The rest of the DEBUGGER-ARGS
          are printed on the top line of the buffer.  You can use this
          feature to display messages--for example, to remind yourself
          of the conditions under which `debug' is called.


File: lispref.info,  Node: Internals of Debugger,  Prev: Invoking the Debugger,  Up: Debugger

Internals of the Debugger
-------------------------

   This section describes functions and variables used internally by the
debugger.

 - Variable: debugger
     The value of this variable is the function to call to invoke the
     debugger.  Its value must be a function of any number of arguments
     (or, more typically, the name of a function).  Presumably this
     function will enter some kind of debugger.  The default value of
     the variable is `debug'.

     The first argument that Lisp hands to the function indicates why it
     was called.  The convention for arguments is detailed in the
     description of `debug'.

 - Command: backtrace
     This function prints a trace of Lisp function calls currently
     active.  This is the function used by `debug' to fill up the
     `*Backtrace*' buffer.  It is written in C, since it must have
     access to the stack to determine which function calls are active.
     The return value is always `nil'.

     In the following example, `backtrace' is called explicitly in a
     Lisp expression.  When the expression is evaluated, the backtrace
     is printed to the stream `standard-output': in this case, to the
     buffer `backtrace-output'.  Each line of the backtrace represents
     one function call.  If the arguments of the function call are all
     known, they are displayed; if they are being computed, that fact
     is stated.  The arguments of special forms are elided.

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))
          
               => nil

          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval-region(1973 2142 #<buffer *scratch*>)
            byte-code("...  for eval-print-last-sexp ...")
            eval-print-last-sexp(nil)
          * call-interactively(eval-print-last-sexp)
          ----------- Buffer: backtrace-output ------------

     The character `*' indicates a frame whose debug-on-exit flag is
     set.

 - Variable: debug-on-next-call
     This variable determines whether the debugger is called before the
     next `eval', `apply' or `funcall'.  It is automatically reset to
     `nil' when the debugger is entered.

     The `d' command in the debugger works by setting this variable.

 - Function: backtrace-debug LEVEL FLAG
     This function sets the debug-on-exit flag of the eval frame LEVEL
     levels down to FLAG.  If FLAG is non-`nil', this will cause the
     debugger to be entered when that frame exits.  Even a nonlocal
     exit through that frame will enter the debugger.

     The debug-on-exit flag is an entry in the stack frame of a
     function call.  This flag is examined on every exit from a
     function.

     Normally, this function is only called by the debugger.

 - Variable: command-debug-status
     This variable records the debugging status of current interactive
     command.  Each time a command is called interactively, this
     variable is bound to `nil'.  The debugger can set this variable to
     leave information for future debugger invocations during the same
     command.

     The advantage of using this variable rather that defining another
     global variable is that the data will never carry over to a later
     other command invocation.

 - Function: backtrace-frame FRAME-NUMBER
     The function `backtrace-frame' is intended for use in Lisp
     debuggers.  It returns information about what computation is
     happening in the eval frame LEVEL levels down.

     If that frame has not evaluated the arguments yet (or is a special
     form), the value is `(nil FUNCTION ARG-FORMS...)'.

     If that frame has evaluated its arguments and called its function
     already, the value is `(t FUNCTION ARG-VALUES...)'.

     In the return value, FUNCTION is whatever was supplied as CAR of
     evaluated list, or a `lambda' expression in the case of a macro
     call.  If the function has a `&rest' argument, that is represented
     as the tail of the list ARG-VALUES.

     If the argument is out of range, `backtrace-frame' returns `nil'.


File: lispref.info,  Node: Syntax Errors,  Next: Compilation Errors,  Prev: Debugger,  Up: Debugging

Debugging Invalid Lisp Syntax
=============================

   The Lisp reader reports invalid syntax, but cannot say where the real
problem is.  For example, the error "End of file during parsing" in
evaluating an expression indicates an excess of open parentheses (or
square brackets).  The reader detects this imbalance at the end of the
file, but it cannot figure out where the close parenthesis should have
been.  Likewise, "Invalid read syntax: ")"" indicates an excess close
parenthesis or missing open parenthesis, but not where the missing
parenthesis belongs.  How, then, to find what to change?

   If the problem is not simply an imbalance of parentheses, a useful
technique is to try `C-M-e' at the beginning of each defun, and see if
it goes to the place where that defun appears to end.  If it does not,
there is a problem in that defun.

   However, unmatched parentheses are the most common syntax errors in
Lisp, and we can give further advice for those cases.

* Menu:

* Excess Open::     How to find a spurious open paren or missing close.
* Excess Close::    How to find a spurious close paren or missing open.


File: lispref.info,  Node: Excess Open,  Next: Excess Close,  Up: Syntax Errors

Excess Open Parentheses
-----------------------

   The first step is to find the defun that is unbalanced.  If there is
an excess open parenthesis, the way to do this is to insert a close
parenthesis at the end of the file and type `C-M-b' (`backward-sexp').
This will move you to the beginning of the defun that is unbalanced.
(Then type `C-SPC C-_ C-u C-SPC' to set the mark there, undo the
insertion of the close parenthesis, and finally return to the mark.)

   The next step is to determine precisely what is wrong.  There is no
way to be sure of this except to study the program, but often the
existing indentation is a clue to where the parentheses should have
been.  The easiest way to use this clue is to reindent with `C-M-q' and
see what moves.

   Before you do this, make sure the defun has enough close parentheses.
Otherwise, `C-M-q' will get an error, or will reindent all the rest of
the file until the end.  So move to the end of the defun and insert a
close parenthesis there.  Don't use `C-M-e' to move there, since that
too will fail to work until the defun is balanced.

   Then go to the beginning of the defun and type `C-M-q'.  Usually all
the lines from a certain point to the end of the function will shift to
the right.  There is probably a missing close parenthesis, or a
superfluous open parenthesis, near that point.  (However, don't assume
this is true; study the code to make sure.)  Once you have found the
discrepancy, undo the `C-M-q', since the old indentation is probably
appropriate to the intended parentheses.

   After you think you have fixed the problem, use `C-M-q' again.  It
should not change anything, if the problem is really fixed.


File: lispref.info,  Node: Excess Close,  Prev: Excess Open,  Up: Syntax Errors

Excess Close Parentheses
------------------------

   To deal with an excess close parenthesis, first insert an open
parenthesis at the beginning of the file and type `C-M-f' to find the
end of the unbalanced defun.  (Then type `C-SPC C-_ C-u C-SPC' to set
the mark there, undo the insertion of the open parenthesis, and finally
return to the mark.)

   Then find the actual matching close parenthesis by typing `C-M-f' at
the beginning of the defun.  This will leave you somewhere short of the
place where the defun ought to end.  It is possible that you will find
a spurious close parenthesis in that vicinity.

   If you don't see a problem at that point, the next thing to do is to
type `C-M-q' at the beginning of the defun.  A range of lines will
probably shift left; if so, the missing open parenthesis or spurious
close parenthesis is probably near the first of those lines.  (However,
don't assume this is true; study the code to make sure.)  Once you have
found the discrepancy, undo the `C-M-q', since the old indentation is
probably appropriate to the intended parentheses.


File: lispref.info,  Node: Compilation Errors,  Next: Edebug,  Prev: Syntax Errors,  Up: Debugging

Debugging Problems in Compilation
=================================

   When an error happens during byte compilation, it is normally due to
invalid syntax in the program you are compiling.  The compiler prints a
suitable error message in the `*Compile-Log*' buffer, and then stops.
The message may state a function name in which the error was found, or
it may not.  Regardless, here is how to find out where in the file the
error occurred.

   What you should do is switch to the buffer ` *Compiler Input*'.
(Note that the buffer name starts with a space, so it does not show up
in `M-x list-buffers'.)  This buffer contains the program being
compiled, and point shows how far the byte compiler was able to read.

   If the error was due to invalid Lisp syntax, point shows exactly
where the invalid syntax was *detected*.  The cause of the error is not
necessarily near by!  Use the techniques in the previous section to find
the error.

   If the error was detected while compiling a form that had been read
successfully, then point is located at the end of the form.  In this
case, it can't localize the error precisely, but can still show you
which function to check.


File: lispref.info,  Node: Edebug,  Prev: Compilation Errors,  Up: Debugging

Edebug
======

   Edebug is a source-level debugger for GNU Emacs Lisp programs that
provides the following features:

   * Step through evaluation, stopping before and after each expression.

   * Set conditional or unconditional breakpoints, install persistent
     breakpoints, or a global break event.

   * Trace slow or fast stopping briefly at each stop point, or each
     breakpoint.

   * Display expression results and evaluate expressions as if outside
     of edebug.  Interface with the custom printing package for
     printing circular structures.

   * Automatically reevaluate a list of expressions and display their
     results each time Edebug updates the display.

   * Output trace info on function enter and exit.

   * Errors stop before the source causing the error.

   * Display backtrace without edebug calls.

   * Allow specification of argument evaluation for macros and defining
     forms.

   * Provide rudimentary coverage testing and display of frequency
     counts.

   The first three sections of this chapter should tell you enough about
Edebug to enable you to use it.

* Menu:

* Using Edebug::		Introduction to use of Edebug.
* Instrumenting::		You must first instrument code.
* Edebug Execution Modes::	Execution modes, stopping more or less often.
* Jumping::			Commands to jump to a specified place.
* Edebug Misc::			Miscellaneous commands.
* Breakpoints::			Setting breakpoints to make the program stop.
* Views::			Viewing the outside buffer and window status.
* Edebug Eval::			Evaluating expressions within Edebug.
* Eval List::			Automatic expression evaluation.
* Printing::			Printing circular structure in Edebug.
* Coverage Testing::		How to test evaluation coverage.
* The Outside Context::		Data that Edebug saves and restores.
* Macro Calls::			Specifying how to handle macro calls.
* Edebug Options::		Option variables for customizing Edebug.


File: lispref.info,  Node: Using Edebug,  Next: Instrumenting,  Prev: Edebug,  Up: Edebug

Using Edebug
------------

   To debug a Emacs Lisp program with Edebug, you must first
"instrument" the Lisp functions that you want to debug.  *Note
Instrumenting::.

   Once a function is instrumented, any call to the function activates
Edebug.  Activating Edebug may stop execution and let you step through
the function, or it may update the display and continue execution while
checking for debugging commands, depending on the selected Edebug
execution mode.  The initial execution mode is `step', by default,
which does stop execution.  *Note Edebug Execution Modes::.

   Within Edebug, you normally view an Emacs buffer showing the source
of the Lisp function you are debugging.  We call this the "Edebug
buffer"--but note that it is not always the same buffer, and it is not
reserved for Edebug use.

   An arrow at the left margin indicates the line where the function is
executing.  Point initially shows where within the line the function is
executing, but this ceases to be true if you move point yourself.

   If you instrument the definition of `fac' (shown below) for Edebug
and then execute `(fac 3)', here is what you normally see.  Point is at
the open-parenthesis before `if'.

     (defun fac (n)
     =>-!-(if (< 0 n)
           (* n (fac (1- n)))
         1))

   The places within a function where Edebug can stop execution are
called "stop points".  These occur both before and after each
subexpression that is a list, and also after each variable reference.
Here we show with periods the stop points found in the function `fac':

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac (1- n.).).).
         1).)

   While a buffer is the Edebug buffer, the special commands of Edebug
are available in it, instead of many usual editing commands.  Type `?'
to display a list of Edebug commands.  In particular, you can exit just
the innermost Edebug activation level with `C-]', and you can return
all the way to top level with `q'.

   For example, you can type the Edebug command SPC to execute until
the next stop point.  If you type SPC once after entry to `fac', here
is the state that you get:

     (defun fac (n)
     =>(if -!-(< 0 n)
           (* n (fac (1- n)))
         1))

   When Edebug stops execution after an expression, it displays the
expression's value in the echo area.  Use the `r' command to display
the value again later.

   If no instrumented code is currently being executed, `debug' is run
normally.  But while Edebug is active, it catches all errors (if
`debug-on-error' is non-`nil') and quits (if `debug-on-quit' is
non-`nil').  When this happens, Edebug displays the last stop point
that it knows about.  This may be the location of a call to a function
which was not instrumented, within which the error actually occurred.
Note that you can also get a full backtrace inside of Edebug (see *Note
Edebug Misc::).


File: lispref.info,  Node: Instrumenting,  Next: Edebug Execution Modes,  Prev: Using Edebug,  Up: Edebug

Instrumenting for Edebug
------------------------

   In order to use Edebug to debug Lisp code, you must first
"instrument" the code.  Instrumenting a form inserts additional code
into it which invokes Edebug at the proper places.  When instrumenting
any kind of definition (not just `defun' or `defmacro'), only the
executable expressions inside of the definition are instrumented.  If
any syntax error is found while instrumenting, point is left at the
error and an `invalid-read-syntax' error is signaled.

   Edebug knows how to instrument all the standard special forms,
interactive forms with or without expression arguments, anonymous lambda
expressions, and other defining forms.  It cannot know what a
user-defined macro will do with the arguments of a macro call so you
must tell it; *note Macro Calls::. for the details.

   Once you have loaded Edebug, the command `C-M-x' (`eval-defun') is
redefined so that when used with a prefix argument on a definition, it
instruments the definition.  If the variable `edebug-all-defs' is
non-`nil', that inverts the meaning of the prefix argument: then
`C-M-x' instruments the definition *unless* it has a prefix argument.
The default value of `edebug-all-defs' is `nil'.  The command `M-x
edebug-all-defs' toggles the value of the variable `edebug-all-defs'.

   If `edebug-all-defs' is non-`nil', then the commands `eval-region'
and `eval-current-buffer' also instrument any definitions they
evaluate.  Similarly, `edebug-all-forms' controls whether `eval-region'
should instrument *any* form, even non-defining forms.  The command
`M-x edebug-all-forms' toggles this option.

   Another command, `M-x edebug-eval-top-level-form', is available to
instrument any top-level form regardless of the value of
`edebug-all-defs'.  Additionally, this command will instrument
top-level forms that are not definitions.

   Loading a file does not instrument expressions for Edebug.
Evaluations in the minibuffer via `eval-expression' (`M-ESC') are never
instrumented.

   To remove instrumentation from a definition, simply reevaluate it
with one of the non-instrumenting commands that evaluate definitions, or
reload the file.

   See *Note Edebug Eval:: for discussion of other evaluation functions
available inside of Edebug.


File: lispref.info,  Node: Edebug Execution Modes,  Next: Jumping,  Prev: Instrumenting,  Up: Edebug

Edebug Execution Modes
----------------------

   Edebug supports several execution modes for running the program you
are debugging.  We call these alternatives "Edebug execution modes"; do
not confuse them with major modes or minor modes.  The current Edebug
execution mode determines how Edebug displays the progress of the
evaluation, whether it stops at each stop point, or continues to the
next breakpoint, for example.

   Normally, you specify the Edebug execution mode by typing a command
to continue the program in a certain mode.  Here is a table of these
commands.  All except for `S' resume execution of the program, at least
for a certain distance.

`S'
     Stop: don't execute any more of the program for now, just wait for
     more Edebug commands.  (`edebug-stop')

`SPC'
     Step: stop at the next stop point encountered. (`edebug-step-mode')

`n'
     Next: stop at the next stop point encountered after an expression.
     Also see `edebug-forward-sexp' in *Note Edebug Misc::.
     (`edebug-next-mode')

`t'
     Trace: pause one second at each Edebug stop point.
     (`edebug-trace-mode')

`T'
     Rapid trace: update at each stop point, but don't actually pause.
     (`edebug-Trace-fast-mode')

`g'
     Go: run until the next breakpoint.  *Note Breakpoints::.
     (`edebug-go-mode')

`c'
     Continue: pause for one second at each breakpoint, but don't stop.
     (`edebug-continue-mode')

`C'
     Rapid continue: update at each breakpoint, but don't actually
     pause.  (`edebug-Continue-fast-mode')

`G'
     Go non-stop: ignore breakpoints.  You can still stop the program
     by typing `S'. (`edebug-Go-nonstop-mode')

   In general, the execution modes earlier in the above list run the
program more slowly or stop sooner.

   When you enter a new Edebug level, the mode comes from the value of
the variable `edebug-initial-mode'.  By default, this specifies "step"
mode.  If the mode thus specified does not stop, then the Edebug level
executes the program (or part of it).

   While executing or tracing, you can interrupt the execution by typing
any Edebug command.  Edebug stops the program at the next stop point and
then executes the command that you typed.  For example, typing `t'
during execution switches to trace mode at the next stop point.

   You can use the `S' command to stop execution without doing anything
else.

   If your function happens to read input, a character you hit
intending to interrupt execution may be read by the function instead.
You can avoid such unintended results by paying attention to when your
program wants input.

   Keyboard macros containing the commands in this section do not
completely work: exiting from Edebug, to resume the program, loses
track of the keyboard macro.  This is not easy to fix.


File: lispref.info,  Node: Jumping,  Next: Edebug Misc,  Prev: Edebug Execution Modes,  Up: Edebug

Jumping
-------

   Commands described here let you jump to a specified location.  All,
except `i', use temporary breakpoints to establish the stop point and
then switch to `go' mode.  Any other breakpoint reached before the
intended stop point will also stop execution.  See *Note Breakpoints::
for the details on breakpoints.

`f'
     Run the program forward over one expression.  More precisely, set a
     temporary breakpoint at the position that `C-M-f' would reach,
     then execute in `go' mode so that the program will stop at
     breakpoints.

     With a prefix argument N, the temporary breakpoint is placed N
     sexps beyond point.  If the containing list ends before N more
     elements, then the place to stop is after the containing
     expression.

     Be careful that the position `C-M-f' finds is a place that the
     program will really get to; this may not be true in a
     `condition-case', for example.

     This command does `forward-sexp' starting at point rather than the
     stop point, thus providing more flexibility.  If you want to
     execute one expression from the current stop point, type `w'
     first, to move point there.

     (`edebug-forward-sexp')

`o'
     Continue "out of" an expression.  It places a temporary breakpoint
     at the end of the sexp containing point.  If the containing sexp
     is the definition itself, it continues until just before the
     returns.  If that is where you are now, it returns from the
     function and then stops.

     In other words, this command does not exit the currently executing
     definition unless you are positioned after the last sexp.

     (`edebug-step-out')

`i'
     Step into the definition of the function or macro about to be
     called, whether or not it has been instrumented.  If its location
     is not known to Edebug, this command cannot be used.  After
     loading Edebug, `eval-region' records the position of every
     definition it evaluates, even if not instrumented.

     Use this command when stopped before the call, since otherwise it
     is too late.

     This command does not switch to `go' mode; instead you must execute
     the arguments before stepping into the function manually.  (A
     future version will probably do as expected: set a temporary
     breakpoint on the first expression in the function and switch to
     `go' mode.)

     Although the automatic instrumentation is convenient, one
     undesirable side effect of using `edebug-step-in' is that it
     doesn't later uninstrument the stepped-into function.

`h'
     Proceed to the stop point near where point is using a temporary
     breakpoint.

     (`edebug-goto-here')

   All the commands in this section may fail to work as expected in case
of nonlocal exit, because a nonlocal exit can bypass the temporary
breakpoint where you expected the program to stop.


File: lispref.info,  Node: Edebug Misc,  Next: Breakpoints,  Prev: Jumping,  Up: Edebug

Miscellaneous
-------------

   Some miscellaneous commands are described here.

`?'
     Display the help message for Edebug.  (`edebug-help')

`C-]'
     Abort one level back to the previous command level.
     (`abort-recursive-edit')

`q'
     Return to the top level editor command loop.  This exits all
     recursive editing levels, including all levels of Edebug activity.
     However, instrumented code protected with `unwind-protect' or
     `condition-case' forms may resume debugging.  (`top-level')

`Q'
     Like `q' but don't stop even for protected code.
     (`top-level-nonstop')

`r'
     Redisplay the most recently known expression result in the echo
     area.  (`edebug-previous-result')

`d'
     Display a backtrace, excluding Edebug's own functions for clarity.

     You cannot use debugger commands in the backtrace buffer in Edebug
     as you would in the standard debugger.

     The backtrace buffer is killed automatically when you continue
     execution.

   From the Edebug recursive edit, you may invoke commands that activate
Edebug again recursively.  Any time Edebug is active, you can quit to
the top level with `q' or abort one recursive edit level with `C-]'.
You can display a backtrace of all the currently active function and
macro calls with `d'.


File: lispref.info,  Node: Breakpoints,  Next: Views,  Prev: Edebug Misc,  Up: Edebug

Breakpoints
-----------

   Three more ways to stop execution once it has started are:
breakpoints, the global break condition, and persistent breakpoints.

   While using Edebug, you can specify "breakpoints" in the program you
are testing: points where execution should stop.  You can set a
breakpoint at any stop point, as defined in *Note Using Edebug::.  For
setting and unsetting breakpoints, the stop point that is affected is
the first one at or after point in the Edebug buffer.  Here are the
Edebug commands for breakpoints:

`b'
     Set a breakpoint at the stop point at or after point.  If you use a
     prefix argument, the breakpoint is temporary (it turns off the
     first time it stops the program). (`edebug-set-breakpoint')

`u'
     Unset the breakpoint (if any) at the stop point at or after the
     current point. (`edebug-unset-breakpoint')

`x CONDITION RET'
     Set a conditional breakpoint which stops the program only if
     CONDITION evaluates to a non-`nil' value.  If you use a prefix
     argument, the breakpoint is temporary (it turns off the first time
     it stops the program). (`edebug-set-conditional-breakpoint')

`B'
     Move point to the next breakpoint in the current definition.
     (`edebug-next-breakpoint')

   While in Edebug, you can set a breakpoint with `b' and unset one
with `u'.  First you must move point to a position at or before the
desired Edebug stop point, then hit the key to change the breakpoint.
Unsetting a breakpoint that has not been set does nothing.

   Reinstrumenting a definition clears all its breakpoints.

   A "conditional breakpoint" tests a condition each time the program
gets there, to decide whether to stop.  To set a conditional breakpoint,
use `x', and specify the condition expression in the minibuffer.
Setting a conditional breakpoint again will put the previously entered
expression in the minibuffer.

   You can make both conditional and unconditional breakpoints
"temporary" by using a prefix arg to the command to set the breakpoint.
After breaking at a temporary breakpoint, it is automatically cleared.

   Edebug always stops or pauses at a breakpoint except when the Edebug
mode is Go-nonstop.  In that mode, it ignores breakpoints entirely.

   To find out where your breakpoints are, use the `B' command, which
moves point to the next breakpoint in the definition following point, or
to the first breakpoint if there are no following breakpoints.  This
command does not continue execution--it just moves point in the buffer.

* Menu:

* Global Break Condition::	Breaking on an event.
* Persistent Breakpoints::	Embedding breakpoints in code.


File: lispref.info,  Node: Global Break Condition,  Next: Persistent Breakpoints,  Prev: Breakpoints,  Up: Breakpoints

Global Break Condition
......................

   In contrast to breaking when execution reaches specified locations,
you can also cause a break when a certain event occurs.  The "global
break condition" is a condition that is repeatedly evaluated at every
stop point.  If it evaluates to a non-`nil' value, then execution is
stopped or paused depending on the execution mode, just like a
breakpoint.  Any errors that might occur as a result of evaluating the
condition are ignored, as if the result were `nil'.

   You can set or edit the condition expression, stored in
`edebug-global-break-condition', using `X'
(`edebug-set-global-break-condition').

   Using the global break condition is perhaps the fastest way to find
where in your code some event occurs, but since it is rather expensive
you should reset the condition to `nil' when not in use.


File: lispref.info,  Node: Persistent Breakpoints,  Prev: Global Break Condition,  Up: Breakpoints

Persistent Breakpoints
......................

   Since all breakpoints in a definition are cleared each time you
reinstrument it, you might rather install a "persistent breakpoint"
which is simply a call to the function `edebug'.  You can, of course,
make such a call conditional.  For example, in the `fac' function,
insert the first line as shown below to stop when the argument reaches
zero:

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   When the `fac' definition is instrumented and the function is called,
edebug will cause a break before the call to `edebug'.  Depending on
the execution mode, edebug will stop or pause.

   However, if no instrumented code is being executed, calling `edebug'
will instead invoke `debug'.


File: lispref.info,  Node: Views,  Next: Edebug Eval,  Prev: Breakpoints,  Up: Edebug

Views
-----

   These Edebug commands let you view aspects of the buffer and window
status that obtained before entry to Edebug.

`v'
     View the outside window configuration. (`edebug-view-outside')

`p'
     Temporarily display the outside current buffer with point at its
     outside position. If prefix arg is supplied, sit for that many
     seconds instead.  (`edebug-bounce-point')

`w'
     Switch back to the buffer showing the currently executing
     function, and move point back to the current stop point.
     (`edebug-where')

`W'
     Toggle the `edebug-save-windows' variable which indicates whether
     the outside window configuration is saved and restored.  Also,
     each time it is toggled on, make the outside window configuration
     the same as the current window configuration.
     (`edebug-toggle-save-windows')

   You can view the outside window configuration with `v' or just
bounce to the current point in the current buffer with `p', even if it
is not normally displayed.  After moving point, you may wish to pop
back to the stop point with `w' from the Edebug buffer.

   By using the `W' command twice, Edebug again saves and restores the
outside window configuration, but to the current configuration.  This is
a convenient way to, for example, add another buffer to be displayed
whenever Edebug is active.  However, the automatic redisplay of
`*edebug*' and `*edebug-trace*' may conflict with the buffers you wish
to see unless you have enough windows open.


File: lispref.info,  Node: Edebug Eval,  Next: Eval List,  Prev: Views,  Up: Edebug

Evaluation
----------

   While within Edebug, you can evaluate expressions "as if" Edebug were
not running.  Edebug tries to be invisible to the expression's
evaluation and printing.  See *Note The Outside Context:: for details on
this process.  Also see *Note Printing:: for how to control printing.

`e EXP RET'
     Evaluate expression EXP in the context outside of Edebug.  That
     is, Edebug tries to avoid altering the effect of EXP.
     (`edebug-eval-expression')

`M-ESC EXP RET'
     Evaluate expression EXP in the context of Edebug itself.

`C-x C-e'
     Evaluate the expression before point, in the context outside of
     Edebug.  (`edebug-eval-last-sexp')


File: lispref.info,  Node: Eval List,  Next: Printing,  Prev: Edebug Eval,  Up: Edebug

Evaluation List Buffer
----------------------

   You can use the "evaluation list buffer", called `*edebug*', to
evaluate expressions interactively.  You can also set up the
"evaluation list" of expressions to be evaluated automatically each
time Edebug updates the display.

`E'
     Switch to the evaluation list buffer `*edebug*'.
     (`edebug-visit-eval-list')

   In the `*edebug*' buffer you can use the commands of Lisp
Interaction as well as these special commands:

`LFD'
     Evaluate the expression before point, in the context outside of
     Edebug, and insert the value in the buffer.
     (`edebug-eval-print-last-sexp')

`C-x C-e'
     Evaluate the expression before point, in the context outside of
     Edebug.  (`edebug-eval-last-sexp')

`C-c C-u'
     Build a new evaluation list from the first expression of each
     group, reevaluate and redisplay.  Groups are separated by comment
     lines.  (`edebug-update-eval-list')

`C-c C-d'
     Delete the evaluation list group that point is in.
     (`edebug-delete-eval-item')

`C-c C-w'
     Switch back to the Edebug buffer at the current stop point.
     (`edebug-where')

   You can evaluate expressions in the evaluation list window with
`LFD' or `C-x C-e', just as you would in `*scratch*'; but they are
evaluated in the context outside of Edebug.

   The expressions you enter interactively (and their results) are lost
when you continue execution unless you add them to the evaluation list
with `C-c C-u'.  This command builds a new list from the first
expression of each "evaluation list group".  Groups are separated by
comment lines.  Be careful not to add expressions that execute
instrumented code otherwise an infinite loop will result.

   When the evaluation list is redisplayed, each expression is displayed
followed by the result of evaluating it, and a comment line.  If an
error occurs during an evaluation, the error message is displayed in a
string as if it were the result.  Therefore expressions that use
variables not currently valid, for example, do not interrupt your
debugging.

   Here is an example of what the evaluation list window looks like
after several expressions have been added to it:

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   To delete a group, move point into it and type `C-c C-d', or simply
delete the text for the group and update the evaluation list with `C-c
C-u'.  When you add a new group, be sure it is separated from its
neighbors by a comment line.

   After selecting `*edebug*', you can return to the source code buffer
(the Edebug buffer) with `C-c C-w'.  The `*edebug*' buffer is killed
when you continue execution, and recreated next time it is needed.


File: lispref.info,  Node: Printing,  Next: Coverage Testing,  Prev: Eval List,  Up: Edebug

Printing
--------

   If some structures that may be printed contain circular references to
other parts of the same structure, you can print them more usefully with
the `cust-print' package.

   To load the package and activate custom printing only for Edebug,
simply use the command `edebug-install-custom-print-funcs'.  To restore
the standard print functions, use `edebug-uninstall-custom-print-funcs'.

   While printing results, edebug binds `print-length', `print-level',
and `print-circle' to `edebug-print-length' (`50'), `edebug-print-level'
(`50'), and `edebug-print-circle' (`t') respectively, if these values
are non-`nil'.

   Here is an example of circular structure printing.  An error will
still be generated when `format' executes.

     (progn
       (edebug-install-custom-print-funcs)
       (setq a '(1 2))
       (format "%s" (setcar a a)))


File: lispref.info,  Node: Coverage Testing,  Next: The Outside Context,  Prev: Printing,  Up: Edebug

Coverage Testing
----------------

   Edebug provides a rudimentary coverage tester and frequency of
execution display.  Frequency counts are always accumulated, both
before and after evaluation of each instrumented expression, even if
the execution mode is Go-nonstop.  Coverage testing is only done if the
option `edebug-test-coverage' is non-`nil' because this is relatively
expensive.  Both data sets are displayed by `edebug-display-freq-count'.

 - Function: edebug-display-freq-count
     Display the frequency count data for each line of the current
     definition.  The frequency counts are inserted as comment lines
     after each line, and you can undo all insertions with one `undo'
     command.  The counts are inserted starting under the `(' before an
     expression or the `)' after an expression, or on the last char of
     a symbol.  The counts are only displayed when they differ from
     previous counts on the same line.

     If coverage is being tested, whenever all known results of an
     expression are `eq', the char `=' will be appended after the count
     for that expression.  Note that this is always the case for an
     expression only evaluated once.

     To clear the frequency count and coverage data for a definition,
     reinstrument it.


   For example, after evaluating `(fac 5)' with a persistent
breakpoint, and setting `edebug-test-coverage' to `t', the frequency
data is looks like this:

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      0 =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0


File: lispref.info,  Node: The Outside Context,  Next: Macro Calls,  Prev: Coverage Testing,  Up: Edebug

The Outside Context
-------------------

   Edebug tries to be transparent to the program you are debugging.  In
addition, most evaluations you do within Edebug (see *Note Edebug
Eval::) occur in the same outside context which is temporarily restored
for the evaluation.  But Edebug is not completely successful and this
section explains precisely how it fails.

* Menu:

* Just Checking::		When Edebug decides what to do.
* Outside Window Configuration::  When Edebug updates the display.
* Edebug Recursive Edit::	When Edebug stops execution.
* Side Effects::		How Edebug fails to be transparent.


File: lispref.info,  Node: Just Checking,  Next: Outside Window Configuration,  Prev: The Outside Context,  Up: The Outside Context

Just Checking
.............

   Whenever Edebug is entered just to think about whether to take some
action, it needs to save and restore certain data.

   * `max-lisp-eval-depth' and `max-specpdl-size' are both incremented
     so that your code should not be impacted by Edebug frames on the
     stack.

   * The state of keyboard macro execution is saved and cleared out.


File: lispref.info,  Node: Outside Window Configuration,  Next: Edebug Recursive Edit,  Prev: Just Checking,  Up: The Outside Context

Outside Window Configuration
............................

   When Edebug needs to display something (e.g., in trace mode), it
saves the current window configuration from "outside" Edebug.  When you
exit Edebug (by continuing the program), it restores the previous window
configuration.

   Emacs redisplays only when it pauses.  Usually, when you continue
execution, the program comes back into Edebug at a breakpoint or after
stepping, without pausing or reading input in between.  In such cases,
Emacs never gets a chance to redisplay the "outside" configuration.
What you see is the window configuration for within Edebug, with no
interruption.

   Entry to Edebug for displaying something also saves and restores the
following data.  (Some of these variables are deliberately not restored
if an error or quit signal occurs.)

   * The window configuration proper does not include which buffer is
     current or where point and mark are in the current buffer, but
     Edebug saves and restores these also.  However, the position of
     point in the Edebug buffer is only saved and restored if the
     outside current buffer is the same as the Edebug buffer.

   * The outside window configuration, is saved and restored if
     `edebug-save-windows' is non-`nil'.  It is not restored on error
     or quit, but the outside selected window is reselected even on
     error or quit in case a `save-excursion' is active.  The window
     start for the Edebug buffer is not restored, however.

   * The value of point in each displayed buffer is saved and restored
     if `edebug-save-displayed-buffer-points' is non-`nil'.

   * The variables `overlay-arrow-position' and `overlay-arrow-string'
     are saved and restored.  This permits recursive use of Edebug, and
     use of Edebug while using GUD.

   * `cursor-in-echo-area' is locally bound to `nil' so that the cursor
     shows up in the window.


File: lispref.info,  Node: Edebug Recursive Edit,  Next: Side Effects,  Prev: Outside Window Configuration,  Up: The Outside Context

Edebug Recursive Edit
.....................

   When Edebug is entered and actually reads commands from the user, it
saves (and later restores) these additional data:

   * The current match data, for whichever buffer was current.

   * `last-command', `this-command', `last-command-char', and
     `last-input-char'.  Commands used within Edebug do not affect these
     variables outside of Edebug.

     But note that it is not possible to preserve the status reported by
     `(this-command-keys)' and the variables `unread-command-char' and
     `unread-command-event'.

   * `standard-output' and `standard-input'.


File: lispref.info,  Node: Side Effects,  Prev: Edebug Recursive Edit,  Up: The Outside Context

Side Effects
............

   Edebug operation unavoidably alters some data in Emacs, and this can
interfere with debugging certain programs.

   * Lisp stack usage is increased, but the limits,
     `max-lisp-eval-depth' and `max-specpdl-size', are also increased
     proportionally.

   * The key sequence returned by `this-command-keys' is changed by
     executing commands within Edebug and there is no way to reset the
     key sequence from Lisp.

   * Edebug cannot save and restore the value of `unread-command-char'
     or `unread-command-event'.  Entering Edebug while these variables
     have nontrivial values can interfere with execution of the program
     you are debugging.

   * Complex commands executed while in Edebug are added to the variable
     `command-history'.  In rare cases this can alter execution.

   * Within Edebug, the recursion depth appears one deeper than the
     recursion depth outside Edebug.  This is not true of the
     automatically updated evaluation list window.

   * Horizontal scrolling of the Edebug buffer is not recovered.


File: lispref.info,  Node: Macro Calls,  Next: Edebug Options,  Prev: The Outside Context,  Up: Edebug

Macro Calls
-----------

   When Edebug instruments an expression that calls a Lisp macro, it
needs additional advice to do the job properly.  This is because there
is no way to tell which subexpressions of the macro call may be
evaluated.  (Evaluation may occur explicitly in the macro body, or when
the resulting expansion is evaluated, or any time later.)  You must
explain the format of macro call arguments by using `def-edebug-spec' to
define an "Edebug specification" for each macro.

 - Macro: def-edebug-spec MACRO SPECIFICATION
     Specify which parts of a call to macro MACRO are subexpressions to
     be evaluated.  The second argument, SPECIFICATION, often looks like
     the formal macro argument list, but it specifies the structure of
     the macro call arguments.

     The MACRO argument may be any symbol, not just a macro name, as
     explained below.

   Here is a table of the possibilities for SPECIFICATION and how each
directs processing of arguments.

*`t'
     All arguments are instrumented for evaluation.

*`0'
     None of the arguments is instrumented.

*a symbol
     The symbol must have an Edebug specification which is used instead.
     This indirection is repeated until another kind of specification is
     found.  This allows you to inherit the specification for another
     macro.

*a list
     The elements of the list describe the types of the arguments of a
     calling form.  The possible elements of a specification list are
     described below.

* Menu:

* Specification List::		How to specify complex patterns of evaluation.
* Backtracking::		What Edebug does when matching fails.
* Specification Examples::

