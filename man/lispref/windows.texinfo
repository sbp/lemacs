@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc. 
@c See the file lispref.texinfo for copying conditions.
@setfilename ../../info/windows.info
@node Windows, Screens, Buffers, Top
@chapter Windows

  This chapter describes most of the functions and variables related to
Emacs windows.  See @ref{Display}, for information on how text is
displayed in windows.

@menu
* Basic Windows::          Basic information on using windows.
* Splitting Windows::      Splitting one window into two windows.
* Deleting Windows::       Deleting a window gives its space to other windows.
* Selecting Windows::      The selected window is the one that you edit in.
* Cyclic Window Ordering:: Moving around the existing windows.
* Buffers and Windows::    Each window displays the contents of a buffer.
* Displaying Buffers::     Higher-lever functions for displaying a buffer
                             and choosing a window for it.
* Choosing Window::	   How to choose a window for displaying a buffer.
* Window Point::           Each window has its own location of point.
* Window Start::           The display-start position controls which text
                             is on-screen in the window. 
* Vertical Scrolling::     Moving text up and down in the window.
* Horizontal Scrolling::   Moving text sideways on the window.
* Size of Window::         Accessing the size of a window.
* Resizing Windows::       Changing the size of a window.
* Coordinates and Windows::Converting coordinates to windows.
* Window Configurations::  Saving and restoring the state of the screen.
@end menu

@node Basic Windows
@section Basic Concepts of Emacs Windows
@cindex window
@cindex selected window

  A @dfn{window} is the physical area of the screen in which a buffer is
displayed.  The term is also used to refer to a Lisp object which
represents that screen area in Emacs Lisp.  It should be
clear from the context which is meant.

  There is always at least one window displayed on the screen, and there
is exactly one window that we call the @dfn{selected window}.  The
cursor is in the selected window.  The selected window's buffer is
usually the current buffer (except when @code{set-buffer} has
been used.)  @xref{Current Buffer}.

  For all intents, a window only exists while it is displayed on the
terminal.  Once removed from the display, the window is effectively
deleted and should not be used, @emph{even though there may still be
references to it} from other Lisp objects.  Restoring a saved window
configuration is the only way for a window no longer on the screen to
come back to life.  (@xref{Deleting Windows}.)

  Each window has the following attributes:

@itemize @bullet
@item
containing screen

@item 
window height

@item 
window width

@item 
window edges with respect to the screen or screen

@item 
the buffer it displays

@item 
position within the buffer at the upper left of the window

@item 
the amount of horizontal scrolling, in columns

@item 
point

@item 
the mark

@item 
how recently the window was selected
@end itemize

@cindex multiple windows
  Applications use multiple windows for a variety of reasons, but most
often to give different views of the same information.  In Rmail, for
example, you can move through a summary buffer in one window while the
other window shows messages one at a time as they are reached.

  The term ``window'' in Emacs means something similar to what it means
in the context of general purpose window systems such as X, but not
identical.  The X Window System subdivides the screen into X windows;
Emacs uses one or more X windows, called @dfn{screens} in Emacs
terminology, and subdivides each of them into (nonoverlapping) Emacs
windows.  When you use Emacs on an ordinary display terminal, Emacs
subdivides the terminal screen into Emacs windows.

@cindex terminal screen
@cindex screen of terminal
@cindex tiled windows
  Most window systems support arbitrarily located overlapping windows.
In contrast, Emacs windows are @dfn{tiled}; they never overlap, and
together they fill the whole of the screen or screen.  Because of the way
in which Emacs creates new windows and resizes them, you can't create
every conceivable tiling on an Emacs screen.  @xref{Splitting Windows}.
Also, see @ref{Size of Window}.

  @xref{Display}, for information on how the contents of the
window's buffer are displayed in the window.

@defun windowp object
  This function returns @code{t} if @var{object} is a window.
@end defun

@node Splitting Windows
@section Splitting Windows
@cindex splitting windows
@cindex window splitting

  The functions described here are the primitives used to split a window
into two windows.  Two higher level functions sometimes split a window,
but not always: @code{pop-to-buffer} and @code{display-buffer}
(@pxref{Displaying Buffers}).

  The functions described here do not accept a buffer as an argument.
They let the two ``halves'' of the split window display the same buffer
previously visible in the window that was split.

@defun one-window-p &optional no-mini
This function returns non-@code{nil} if there is only one window.  The
argument @var{no-mini}, if non-@code{nil}, means don't count the
minibuffer even if it is active; otherwise, the minibuffer window is
included, if active, in the total number of windows which is compared
against one.
@end defun

@deffn Command split-window &optional window size horizontal
This function splits @var{window} into two windows.  The original
window @var{window} remains the selected window, but occupies only
part of its former screen area.  The rest is occupied by a newly created
window which is returned as the value of this function.

  If @var{horizontal} is non-@code{nil}, then @var{window} splits side
by side, keeping the leftmost @var{size} columns and giving the rest of
the columns to the new window.  Otherwise, it splits into halves one
above the other, keeping the upper @var{size} lines and giving the rest
of the lines to the new window.  The original window is therefore the
right-hand or upper of the two, and the new window is the left-hand or
lower.

  If @var{window} is omitted or @code{nil}, then the selected window is
split.  If @var{size} is omitted or @code{nil}, then @var{window} is
divided evenly into two parts.  (If there is an odd line, it is
allocated to the new window.)  When @code{split-window} is called
interactively, all its arguments are @code{nil}.

  The following example starts with one window on a screen that is 50
lines high by 80 columns wide; then the window is split.

@smallexample
@group
(setq w (selected-window))
     @result{} #<window 8 on windows.texi>
(window-edges)          ; @r{Edges in order:}
     @result{} (0 0 80 50)     ;   @r{left--top--right--bottom}
@end group

@group
;; @r{Returns window created}
(setq w2 (split-window w 15))   
     @result{} #<window 28 on windows.texi>
@end group
@group
(window-edges w2)
     @result{} (0 15 80 50)    ; @r{Bottom window;}
                        ;   @r{top is line 15}
@end group
@group
(window-edges w)
     @result{} (0 0 80 15)     ; @r{Top window}
@end group
@end smallexample

The screen looks like this:

@smallexample
@group
         __________ 
        |          |  line 0  
        |    w     |
        |__________|
        |          |  line 15
        |    w2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Next, the top window is split horizontally:

@smallexample
@group
(setq w3 (split-window w 35 t))
     @result{} #<window 32 on windows.texi>
@end group
@group
(window-edges w3)
     @result{} (35 0 80 15)  ; @r{Left edge at column 35}
@end group
@group
(window-edges w)
     @result{} (0 0 35 15)   ; @r{Right edge at column 35}
@end group
@group
(window-edges w2)
     @result{} (0 15 80 50)  ; @r{Bottom window unchanged}
@end group
@end smallexample

Now, the screen looks like this:

@smallexample
@group
     column 35
         __________ 
        |   |      |  line 0  
        | w |  w3  |
        |___|______|
        |          |  line 15
        |    w2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample
@end deffn

@deffn Command split-window-vertically size
  This function splits the selected window into two windows, one above
the other, leaving the selected window with @var{size} lines.

  This function is simply an interface to @code{split-windows}.
Here is the complete function definition for it:

@smallexample
@group
(defun split-window-vertically (&optional arg)
  "Split selected window into two windows,
one above the other..."
  (interactive "P")
  (split-window nil (and arg (prefix-numeric-value arg))))
@end group
@end smallexample
@end deffn

@deffn Command split-window-horizontally size
  This function splits the selected window into two windows
side-by-side, leaving the selected window with @var{size} columns.

  This function is simply an interface to @code{split-windows}.  Here is
the complete definition for @code{split-window-horizontally} (except for
part of the documentation string):

@smallexample
@group
(defun split-window-horizontally (&optional arg)
  "Split selected window into two windows
side by side..."
  (interactive "P")
  (split-window nil (and arg (prefix-numeric-value arg)) t))
@end group
@end smallexample
@end deffn

@node Deleting Windows
@section Deleting Windows
@cindex deleting windows

A window remains visible on its screen unless you @dfn{delete} it by
calling certain functions that delete windows.  A deleted window cannot
appear on the screen, but continues to exist as a Lisp object until
there are no references to it.  There is no way to cancel the deletion
of a window aside from restoring a saved window configuration
(@pxref{Window Configurations}).  Restoring a window configuration also
deletes any windows that aren't part of that configuration.

  When you delete a window, the space it took up is given to one
adjacent sibling.  (In Emacs version 18, the space was divided evenly
among all the siblings.)

@c Emacs 19 feature
@defun window-live-p window
This function returns @code{nil} if @var{window} is deleted, and
@code{t} otherwise.

@strong{Warning:} erroneous information or fatal errors may result from
using a deleted window as if it were live.
@end defun

@deffn Command delete-window &optional window
  This function removes @var{window} from the display.  If @var{window}
is omitted, then the selected window is deleted.  An error is signaled
if there is only one window when @code{delete-window} is called.

  This function returns @code{nil}.

  When @code{delete-window} is called interactively, @var{window}
defaults to the selected window.
@end deffn

@deffn Command delete-other-windows &optional window
  This function makes @var{window} the only window on its screen, by
deleting all the other windows.  If @var{window} is omitted or
@code{nil}, then the selected window is used by default.

  The result is @code{nil}.
@end deffn

@deffn Command delete-windows-on buffer &optional screen
This function deletes all windows showing @var{buffer}.  If there are
no windows showing @var{buffer}, then this function does nothing.  If
all windows in some screen are showing @var{buffer} (including the case
where there is only one window), then the screen reverts to having a
single window showing the buffer chosen by @code{other-buffer}.
@xref{The Buffer List}.

If there are several windows showing different buffers, then those
showing @var{buffer} are removed, and the others are expanded to fill the
void.

If @var{screen} is a screen, then @code{delete-windows-on} considers just
the windows on @var{screen}.  If @var{screen} is @code{nil}, all windows
on all screens are considered.  If @var{screen} is @code{t}, that stands
for the selected screen.

This function always returns @code{nil}.
@end deffn

@node Selecting Windows
@section Selecting Windows
@cindex selecting windows

  When a window is selected, the buffer in the window becomes the current
buffer, and the cursor will appear in it.

@defun selected-window
  This function returns the selected window.  This is the window in
which the cursor appears and to which many commands apply.
@end defun

@defun select-window window
  This function makes @var{window} the selected window.  The cursor then
appears in @var{window} (on redisplay).  The buffer being displayed in
@var{window} is immediately designated the current buffer.

  The return value is @var{window}.

@example
@group
(setq w (next-window))
(select-window w)
     @result{} #<window 65 on windows.texi>
@end group
@end example
@end defun

@cindex finding windows
  The following functions choose one of the windows on the screen,
offering various criteria for the choice.

@defun get-lru-window &optional all-screens
This function returns the window least recently ``used'' (that is,
selected).  The selected window is always the most recently used window.

The selected window can be the least recently used window if it is the
only window.  A newly created window becomes the least recently used
window until it is selected.  The minibuffer window is not considered a
candidate.

The argument @var{all-screens} controls which set of windows are
considered.  If it is non-@code{nil}, then all windows on all screens are
considered.  Otherwise, only windows in the selected screen are
considered.
@end defun

@defun get-largest-window &optional all-screens
This function returns the window with the largest area (height times
width).  If there are no side-by-side windows, then this is the window
with the most lines.  The minibuffer window is not considered a
candidate.

If there are two windows of the same size, then the function returns
the window which is first in the cyclic ordering of windows (see
following section), starting from the selected window.

The argument @var{all-screens} controls which set of windows are
considered.  If it is non-@code{nil}, then all windows on all screens are
considered.  Otherwise, only windows in the selected screen are
considered.
@end defun

@node Cyclic Window Ordering
@comment  node-name,  next,  previous,  up
@section Cycling Ordering of Windows
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic 

  When you use the command @kbd{C-x o} (@code{other-window}) to select
the next window, it moves through all the windows on the screen in a
specific cyclic order.  For any given configuration of windows, this
order never varies.  It is called the @dfn{cyclic ordering of windows}.

  This ordering generally goes from top to bottom, and from left to
right.  But it may go down first or go right first, depending on the
order in which the windows were split.

  If the first split was vertical (into windows one above each other),
and then the subwindows were split horizontally, then the ordering is
left to right in the top, and then left to right in the next lower part
of the screen, and so on.  If the first split was horizontal, the
ordering is top to bottom in the left part, and so on.  In general,
within each set of siblings at any level in the window tree, the order
is left to right, or top to bottom.

@defun next-window window &optional minibuf all-screens
@cindex minibuffer window
This function returns the window following @var{window} in the cyclic
ordering of windows.  This is the window which @kbd{C-x o} would select
if done when @var{window} is selected.  If @var{window} is the only
window visible, then this function returns @var{window}.

The value of the argument @var{minibuf} determines whether the
minibuffer is included in the window order.  Normally, when
@var{minibuf} is @code{nil}, the minibuffer is included if it is
currently active; this is the behavior of @kbd{C-x o}.

If @var{minibuf} is @code{t}, then the cyclic ordering includes the
minibuffer window even if it is not active.

If @var{minibuf} is neither @code{t} nor @code{nil}, then the minibuffer
window is not included even if it is active.  (The minibuffer window is
active while the minibuffer is in use.  @xref{Minibuffers}.)

When there are multiple screens, this functions normally cycles through
all the windows in the selected screen, plus the minibuffer used by the
selected screen even if it lies in some other screen.

If @var{all-screens} is @code{t}, then it cycles through all the windows
in all the screens that currently exist.

If @var{all-screens} is neither @code{t} nor @code{nil}, then it cycles
through precisely the windows in the selected screen, excluding the
minibuffer in use if it lies in some other screen.

This example shows two windows, which both happen to be displaying the
same buffer:

@example
@group
(selected-window)
     @result{} #<window 56 on windows.texi>
@end group
@group
(next-window (selected-window))
     @result{} #<window 52 on windows.texi>
@end group
@group
(next-window (next-window (selected-window)))
     @result{} #<window 56 on windows.texi>
@end group
@end example
@end defun

@defun previous-window window &optional minibuf all-screens
  This function returns the window preceding @var{window} in the cyclic
ordering of windows.  The other arguments affect which windows are
included in the cycle, as in @code{next-window}.
@end defun

@deffn Command other-window count
  This function selects the @var{count}th next window in the cyclic
order.  If count is negative, then it selects the @minus{}@var{count}th
preceding window.  It returns @code{nil}.

  In an interactive call, @var{count} is the numeric prefix argument.
@end deffn

@c Emacs 19 feature
@defun walk-windows proc &optional minibuf all-screens
This function cycles through all visible windows, calling @code{proc}
once for each window with the window as its sole argument.

The optional argument @var{minibuf} says whether to include minibuffer
windows.  A value of @code{t} means count the minibuffer window even if
not active.  A value of @code{nil} means count it only if active.  Any
other value means not to count the minibuffer even if it is active.

If the optional third argument @var{all-screens} is @code{t}, that means
include all windows in all screens.  If @var{all-screens} is @code{nil},
it means to cycle within the selected screen, but include the minibuffer
window (if @var{minibuf} says so) that that screen uses, even if it is on
another screen.  If @var{all-screens} is neither @code{nil} nor @code{t},
@code{walk-windows} sticks strictly to the selected screen.
@end defun

@node Buffers and Windows
@section Buffers and Windows
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

  This section describes low-level functions to examine windows or to
show buffers in windows in a precisely controlled fashion.
@iftex
See the following section for
@end iftex
@ifinfo
@xref{Displaying Buffers}, for
@end ifinfo
related functions that find a window to use and specify a buffer for it.
The functions described there are easier to use than these, but they
employ heuristics in choosing or creating a window; use these functions
when you need complete control.

@defun set-window-buffer window buffer-or-name
  This function makes @var{window} display @var{buffer-or-name} as its
contents.  It returns @code{nil}.

@example
@group
(set-window-buffer (selected-window) "foo")
     @result{} nil
@end group
@end example
@end defun

@defun window-buffer &optional window
  This function returns the buffer that @var{window} is displaying.  If
@var{window} is omitted, then this function returns the buffer for the
selected window.

@example
@group
(window-buffer)
     @result{} #<buffer windows.texi>
@end group
@end example
@end defun

@defun get-buffer-window buffer-or-name &optional all-screens
This function returns a window currently displaying
@var{buffer-or-name}, or @code{nil} if there is none.  If there are
several such windows, then the function returns the first one in the
cyclic ordering of windows, starting from the selected window.
@xref{Cyclic Window Ordering}.

The argument @var{all-screens} controls which set of windows are
considered.
@itemize @bullet
@item
If it is @code{nil}, then windows on the selected screen are considered.
@item
If it is a screen, then windows on that screen are considered.
@item
If it is @code{t}, then windows on all visible screens are considered.
@item
If it is some other non-@code{nil} value, then all windows on all screens
are considered.
@end itemize
@end defun

@deffn Command replace-buffer-in-windows buffer
  This function replaces @var{buffer} with some other buffer in all
windows displaying it.  The other buffer used is chosen with
@code{other-buffer}.  In the usual applications of this function, you
don't care which other buffer is used; you just want to make sure that
@var{buffer} is no longer displayed.

  This function returns @code{nil}.
@end deffn

@node Displaying Buffers
@section Displaying Buffers in Windows
@cindex switching to a buffer
@cindex displaying a buffer

  In this section we describe convenient functions that choose a window
automatically and use it to display a specified buffer.  These functions
can also split an existing window in certain circumstances.  We also
describe variables that parameterize the heuristics used for choosing a
window.
@iftex
See the preceding section for
@end iftex
@ifinfo
@xref{Buffers and Windows}, for
@end ifinfo
low-level functions that give you more precise control.

  Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which is gratuitous and will surprise the user.  Instead, use
@code{set-buffer} (@pxref{Current Buffer}) and @code{save-excursion}
(@pxref{Excursions}), which designate buffers as current for programmed
access without affecting the display of buffers in windows.

@deffn Command switch-to-buffer buffer-or-name &optional norecord
  This function makes @var{buffer-or-name} the current buffer, and also
displays the buffer in the selected window.  This means that a human can
see the buffer and subsequent keyboard commands will apply to it.
Contrast this with @code{set-buffer}, which makes @var{buffer-or-name}
the current buffer but does not display it in the selected window.
@xref{Current Buffer}.

  If @var{buffer-or-name} does not identify an existing buffer, then
a new buffer by that name is created.

  Normally the specified buffer is put at the front of the buffer list.
This affects the operation of @code{other-buffer}.  However, if
@var{norecord} is non-@code{nil}, this is not done.  @xref{The Buffer
List}.

  The @code{switch-to-buffer} function is often used interactively, as
the binding of @kbd{C-x b}.  It is also used frequently in programs.  It
always returns @code{nil}.
@end deffn

@deffn Command switch-to-buffer-other-window buffer-or-name
  This function makes @var{buffer-or-name} the current buffer and
displays it in a window not currently selected.  It then selects that
window.  The handling of the buffer is the same as in
@code{switch-to-buffer}.

  The previously selected window is absolutely never used to display the
buffer.  If it is the only window, then it is split to make a distinct
window for this purpose.  If the selected window is already displaying
the buffer, then it continues to do so, but another window is
nonetheless found to display it in as well.
@end deffn

@defun pop-to-buffer buffer-or-name &optional other-window
  This function makes @var{buffer-or-name} the current buffer and
switches to it in some window, preferably not the window previously
selected.  The ``popped-to'' window becomes the selected window.

  If the variable @code{pop-up-screens} is non-@code{nil},
@code{pop-to-buffer} creates a new screen to display the buffer in.
Otherwise, if the variable @code{pop-up-windows} is non-@code{nil},
windows may be split to create a new window that is different from the
original window.  For details, see @ref{Choosing Window}.

  If @var{other-window} is non-@code{nil}, @code{pop-to-buffer} finds or
creates another window even if @var{buffer-or-name} is already visible
in the selected window.  Thus @var{buffer-or-name} could end up
displayed in two windows.  On the other hand, if @var{buffer-or-name} is
already displayed in the selected window and @var{other-window} is
@code{nil}, then the selected window is considered sufficient display
for @var{buffer-or-name}, so that nothing needs to be done.

  If @var{buffer-or-name} is a string that does not name an existing
buffer, a buffer by that name is created.

  An example use of this function is found at the end of @ref{Filter
Functions}.
@end defun

@node Choosing Window
@section Choosing a Window

  This section describes the basic facility which chooses a window to
display a buffer in---@code{display-buffer}.  All the higher-level
functions and commands use this subroutine.  Here we describe how to use
@code{display-buffer} and how to customize it.

@defun display-buffer buffer-or-name &optional not-this-window
This function makes @var{buffer-or-name} appear in some window, like
@code{pop-to-buffer}, but it does not select that window and does not
make the buffer current.  The identity of the selected window is
unaltered by this function.

If @var{not-this-window} is non-@code{nil}, it means that the
specified buffer should be displayed in a window other than the selected
one, even if it is already on display in the selected window.  This can
cause the buffer to appear in two windows at once.  Otherwise, if
@var{buffer-or-name} is already being displayed in any window, that is
good enough, so this function does nothing.

@code{display-buffer} returns the window chosen to display
@var{buffer-or-name}.

Precisely how @code{display-buffer} finds or creates a window depends on
the variables described below.
@end defun

@c Emacs 19 feature
@cindex dedicated window
A window can be marked as ``dedicated'' to its buffer.  Then
@code{display-buffer} does not try to use that window.

@defun window-dedicated-p window
This function returns @code{t} if @var{window} is marked as dedicated;
otherwise @code{nil}.
@end defun

@defun set-window-dedicated-p window flag
This function marks @var{window} as dedicated if @var{flags} is
non-@code{nil}, and nondedicated otherwise.
@end defun

@defopt pop-up-windows
This variable controls whether @code{display-buffer} makes new windows.
If it is non-@code{nil} and there is only one window, then that window
is split.  If it is @code{nil}, then @code{display-buffer} does not
split the single window, but rather replaces its buffer.
@end defopt

@defopt split-height-threshold
This variable determines when @code{display-buffer} may split a
window, if there are multiple windows.  @code{display-buffer} splits the
largest window if it has at least this many lines.

If there is only one window, it is split regardless of this value,
provided @code{pop-up-windows} is non-@code{nil}.
@end defopt

@c Emacs 19 feature
@defopt pop-up-screens
This variable controls whether @code{display-buffer} makes new
screens.  If it is non-@code{nil}, @code{display-buffer} makes a new
screen.  If it is @code{nil}, then @code{display-buffer} either splits a
window or reuses one.

If this is non-@code{nil}, the variables @code{pop-up-windows} and
@code{split-height-threshold} do not matter.

@xref{Screens}, for more information.
@end defopt

@c Emacs 19 feature
@defvar pop-up-screen-function
This variable specifies how to make a new screen if @code{pop-up-screen}
is non-@code{nil}.

Its value should be a function of no arguments.  When
@code{display-buffer} makes a new screen, it does so by calling that
function, which should return a screen.  The default value of the
variable is a function which creates a screen using parameters from
@code{pop-up-screen-alist}.
@end defvar

@defvar pop-up-screen-alist
This variable holds an alist specifying screen parameters used when
@code{display-buffer} makes a new screen.  @xref{Screen Parameters}, for
more information about screen parameters.
@end defvar

@c Emacs 19 feature
@defvar display-buffer-function
This variable is the most flexible way to customize the behavior of
@code{display-buffer}.  If it is non-@code{nil}, it should be a function
that @code{display-buffer} calls to do the work.  The function should
accept two arguments, the same two arguments that @code{display-buffer}
received.  It should choose or create a window, display the specified
buffer, and then return the window.

This hook takes precedence over all the other options and hooks
described above.
@end defvar

@node Window Point
@section Window Point
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

  Each window has its own value of point, independent of the value of
point in other windows displaying the same buffer.  This makes it useful
to have multiple windows showing one buffer.

@itemize @bullet
@item
The window point is established when a window is first created; it is
initialized from the buffer's point, or from the window point of another
window opened on the buffer if such a window exists.

@item
Selecting a window sets the value of point in its buffer to the window's
value of point.  Conversely, deselecting a window sets the window's
value of point from that of the buffer.  Thus, when you switch between
windows that display a given buffer, the point value for the selected
window is in effect in the buffer, while the point values for the other
windows are stored in those windows.

@item
As long as the selected window displays the current buffer, the window's
point and the buffer's point always move together; they remain equal.

@item
@xref{Positions}, for more details on positions.
@end itemize

  As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

@defun window-point window
  This function returns the current position of point in @var{window}.
For a nonselected window, this is the value point would have (in that
window's buffer) if that window were selected.

  When @var{window} is the selected window and its buffer is also the
current buffer, the value returned is the same as point in that buffer.

  Strictly speaking, it would be more correct to return the
``top-level'' value of point, outside of any @code{save-excursion}
forms.  But that value is hard to find.
@end defun

@defun set-window-point window position
  This function positions point in @var{window} at position
@var{position} in @var{window}'s buffer.
@end defun

@node Window Start
@section The Window Start Position

  Each window contains a marker used to keep track of a buffer position
which specifies where in the buffer display should start.  This position
is called the @dfn{display-start} position of the window (or just the
@dfn{start}).  The character after this position is the one that appears
at the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

@defun window-start &optional window
@cindex window top line
  This function returns the display-start position of window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.

@example
@group
(window-start)
     @result{} 7058
@end group
@end example

  For a more complicated example of use, see the description of
@code{count-lines} in @ref{Text Lines}.
@end defun

@defun window-end &optional window
This function returns the position of the end of the display in window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.
@end defun

@defun set-window-start window position &optional noforce
  This function sets the display-start position of @var{window} to
@var{position} in @var{window}'s buffer.

  The display routines insist that the position of point be visible when
a buffer is displayed.  Normally, they change the display-start position
(that is, scroll the window) whenever necessary to make point visible.
However, if you specify the start position with this function with
@code{nil} for @var{noforce}, it means you want display to start at
@var{position} even if that would put the location of point off the
screen.  What the display routines do in this case is move point
instead, to the left margin on the middle line in the window.

  For example, if point @w{is 1} and you attempt to set the start of the
window @w{to 2}, then the position of point would be ``above'' the top
of the window.  The display routines would automatically move point if
it is still 1 when redisplay occurs.  Here is an example:

@example
@group
;; @r{Here is what @samp{foo} looks like before executing}
;;   @r{the @code{set-window-start} expression.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (1+ (window-start)))
@end group

@group
;; @r{Here is what @samp{foo} looks like after executing}
;;   @r{the @code{set-window-start} expression.}

---------- Buffer: foo ----------
his is the contents of buffer foo.
2
3
@point{}4
5
6
---------- Buffer: foo ----------

     @result{} 2
@end group
@end example

  However, when @var{noforce} is non-@code{nil}, @code{set-window-start}
does nothing if the specified start position would make point invisible.

  This function returns @var{position}, regardless of whether the
@var{noforce} option caused that position to be overruled.
@end defun

@defun pos-visible-in-window-p &optional position window
  This function returns @code{t} if @var{position} is within the range
of text currently visible on the screen in @var{window}.  It returns
@code{nil} if @var{position} is scrolled vertically out of view.  The
argument @var{position} defaults to the current position of point;
@var{window}, to the selected window.  Here is an example:

@example
@group
(or 
(pos-visible-in-window-p
 (point) (selected-window))
    (recenter 0))
@end group
@end example

 The @code{pos-visible-in-window-p} function considers only vertical
scrolling.  It returns @code{t} if @var{position} is out of view only
because @var{window} has been scrolled horizontally.  @xref{Horizontal
Scrolling}.
@end defun

@node Vertical Scrolling
@section Vertical Scrolling
@cindex vertical scrolling
@cindex scrolling vertically

  Vertical scrolling means moving the text up or down in a window.  It
works by changing the value of the window's display-start location.  It
may also change the value of @code{window-point} to keep it on the
screen.

  In the commands @code{scroll-up} and @code{scroll-down}, the directions
``up'' and ``down'' refer to the motion of the text in the buffer at which
you are looking through the window.  Imagine that the text is
written on a long roll of paper and that the scrolling commands move the
paper up and down.  Thus, if you are looking at text in the middle of a
buffer and repeatedly call @code{scroll-down}, you will eventually see
the beginning of the buffer.

  Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
``down'' commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

  The scrolling functions (aside from @code{scroll-other-window}) will
have unpredictable results if the current buffer is different from the
buffer that is displayed in the selected window.  @xref{Current
Buffer}.

@deffn Command scroll-up &optional count
  This function scrolls the text in the selected window upward
@var{count} lines.  If @var{count} is negative, scrolling is actually
downward.

  If @var{count} is @code{nil} (or omitted), then the length of scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its mode line).

  @code{scroll-up} returns @code{nil}.
@end deffn

@deffn Command scroll-down &optional count
  This function scrolls the text in the selected window downward
@var{count} lines.  If @var{count} is negative, scrolling is actually
upward.

  If @var{count} is omitted or @code{nil}, then the length of the scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window.

  @code{scroll-down} returns @code{nil}.
@end deffn

@deffn Command scroll-other-window &optional count
  This function scrolls the text in another window upward @var{count}
lines.  Negative values of @var{count}, or @code{nil}, are handled
as in @code{scroll-up}.

  The window that is scrolled is normally the one following the selected
window in the cyclic ordering of windows---the window that
@code{next-window} would return.  @xref{Cyclic Window Ordering}.

  If the selected window is the minibuffer, the next window is normally
the one at the top left corner.  However, you can specify the window to
scroll by binding the variable @code{minibuffer-scroll-window}.  This
variable has no effect when any other window is selected.
@xref{Minibuffer Misc}.

  When the minibuffer is active, it is the next window if the selected
window is the one at the bottom right corner.  In this case,
@code{scroll-other-window} attempts to scroll the minibuffer.  If the
minibuffer contains just one line, it has nowhere to scroll to, so the
line reappears after the echo area momentarily displays the message
``Beginning of buffer''.
@end deffn

@c Emacs 19 feature
@defvar other-window-scroll-buffer
If this variable is non-@code{nil}, it tells @code{scroll-other-window}
which buffer to scroll.
@end defvar

@defopt scroll-step
This variable controls how scrolling is done automatically when point
moves off the screen.  If the value is zero, then the text is scrolled
so that point is centered vertically in the window.  If the value is a
positive integer @var{n}, then if it is possible to bring point back on
screen by scrolling @var{n} lines in either direction, that is done;
otherwise, point is centered vertically as usual.  The default value is
zero.
@end defopt

@defopt next-screen-context-lines
  The value of this variable is the number of lines of continuity to
retain when scrolling by full screens.  For example, when
@code{scroll-up} executes, this many lines that were visible at the
bottom of the window move to the top of the window.  The default value
is @code{2}.
@end defopt

@deffn Command recenter &optional count
@cindex centering point
  This function scrolls the selected window to put the text where point
is located at a specified vertical position within the window.

  If @var{count} is a nonnegative number, it puts the line containing
point @var{count} lines down from the top of the window.  If @var{count}
is a negative number, then it counts upward from the bottom of the
window, so that @minus{}1 stands for the last usable line in the window.
If @var{count} is a non-@code{nil} list, then it stands for the line in
the middle of the window.

  If @var{count} is @code{nil}, then it puts the line containing point
in the middle of the window, then clears and redisplays the entire
selected screen.

  When @code{recenter} is called interactively, Emacs sets @var{count}
to the raw prefix argument.  Thus, typing @kbd{C-u} as the prefix sets
the @var{count} to a non-@code{nil} list, while typing @kbd{C-u 4} sets
@var{count} to 4, which positions the current line four lines from the
top.

  Typing @kbd{C-u 0 C-l} positions the current line at the top of the
window.  This action is so handy that some people bind the command to a
function key.  For example,

@example
@group
(defun line-to-top-of-window ()
  "Scroll current line to top of window.
Replaces three keystroke sequence C-u 0 C-l."
  (interactive) 
  (recenter 0))

(global-set-key "\C-cl" 'line-to-top-of-window)  
@end group
@end example
@end deffn

@node Horizontal Scrolling
@section Horizontal Scrolling
@cindex horizontal scrolling

  Because we read English first from top to bottom and second from left
to right, horizontal scrolling is not like vertical scrolling.  Vertical
scrolling involves selection of a contiguous portion of text to display.
Horizontal scrolling causes part of each line to go off screen.  The
amount of horizontal scrolling is therefore specified as a number of
columns rather than as a position in the buffer.  It has nothing to do
with the display-start position returned by @code{window-start}.

  Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the
screen to be revealed by it, so it is not allowed.  Scrolling to the
left is allowed; it causes the first columns of text to go off the edge
of the window and can reveal additional columns on the right that were
truncated before.  Once a window has a nonzero amount of leftward
horizontal scrolling, you can scroll it back to the right, but only so
far as to reduce the net horizontal scroll to zero.  There is no limit
to how far left you can scroll, but eventually all the text will
disappear off the left edge.

@deffn Command scroll-left count
  This function scrolls the selected window @var{count} columns to the
left (or to the right if @var{count} is negative).  The return value is
the total amount of leftward horizontal scrolling in effect after the
change---just like the value returned by @code{window-hscroll}.
@end deffn

@deffn Command scroll-right count
  This function scrolls the selected window @var{count} columns to the right
 (or to the left if @var{count} is negative).  The return value is the
total amount of leftward horizontal scrolling in effect after the
change---just like the value returned by @code{window-hscroll}.

  Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll
any farther have no effect.
@end deffn

@defun window-hscroll &optional window
  This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window}
is scrolled left past the left margin.

  The value is never negative.  It is zero when no horizontal scrolling
has been done in @var{window} (which is usually the case).

  If @var{window} is @code{nil}, the selected window is used.

@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
  This function sets the number of columns from the left margin that
@var{window} is scrolled to the value of @var{columns}.  The argument
@var{columns} should be zero or positive; if not, it is taken as zero.

  The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

  Here is how you can determine whether a given position @var{position}
is off the screen due to horizontal scrolling:

@example
@group
(save-excursion 
  (goto-char @var{position})
  (and 
   (>= (- (current-column) (window-hscroll @var{window})) 0)
   (< (- (current-column) (window-hscroll @var{window}))
      (window-width @var{window}))))
@end group
@end example

@node Size of Window
@section The Size of a Window
@cindex window size
@cindex size of window

  An Emacs window is rectangular, and its size information consists of
the height (the number of lines) and the width (the number of character
positions in each line).  The mode line is included in the height.  For
a window that does not abut the right hand edge of the screen, the
column of @samp{|} characters that separates it from the window on the
right is included in the width.

  The following three functions return size information about a window:

@defun window-height &optional window
  This function returns the number of lines in @var{window}, including
its mode line.  If @var{window} fills its entire screen, this is one less
than the value of @code{screen-height} on that screen (since the last line
is always reserved for the minibuffer).

  If @var{window} is @code{nil}, the function uses the selected window.

@example
@group
(window-height)
     @result{} 23
@end group
@group
(split-window-vertically)
     @result{} #<window 4 on windows.texi>
@end group
@group
(window-height)
     @result{} 11
@end group
@end example
@end defun

@defun window-width &optional window
  This function returns the number of columns in @var{window}.  If
@var{window} fills its entire screen, this is the same as the value of
@code{screen-width} on that screen.

  If @var{window} is @code{nil}, the function uses the selected window.

@example
@group
(window-width)
     @result{} 80
@end group
@end example
@end defun

@defun window-edges &optional window
  This function returns a list of the edge coordinates of @var{window}.
If @var{window} is @code{nil}, the selected window is used.

  The order of the list is @code{(@var{left} @var{top} @var{right}
@var{bottom})}, all elements relative to 0, 0 at the top left corner of
the screen.  The element @var{right} of the value is one more than the
rightmost column used by @var{window}, and @var{bottom} is one more than
the bottommost row used by @var{window} and its mode-line.

  Here is the result obtained on a typical 24-line terminal with just one
window:

@example
@group
(window-edges (selected-window))
     @result{} (0 0 80 23)
@end group
@end example

  If @var{window} is at the upper left corner of its screen, @var{right}
and @var{bottom} are the same as the values returned by
@code{(window-width)} and @code{(window-height)} respectively, and
@var{top} and @var{bottom} are zero.  For example, the edges of the
following window are @w{@samp{0 0 5 8}}.  Assuming that the screen has
more than 8 columns, the last column of the window (column 7) holds a
border rather than text.  The last row (row 4) holds the mode line,
shown here with @samp{xxxxxxxxx}.

@example
@group
           0    
           _______
        0 |       | 
          |       |   
          |       | 
          |       | 
          xxxxxxxxx  4

                  7  
@end group
@end example

  When there are side-by-side windows, any window not at the right
edge of its screen has a border in its last column.  This border counts
as one column in the width of the window.  A window never includes a
border on its left, since the border there belongs to the window to the
left.

  In the following example, let's imagine that the screen is 7
columns wide.  Then the edges of the left window are @w{@samp{0 0 4 3}}
and the edges of the right window are @w{@samp{4 0 7 3}}.

@example
@group
           ___ ___
          |   |   |    
          |   |   |    
          xxxxxxxxx 

           0  34  7
@end group
@end example
@end defun

@node Resizing Windows
@section Changing the Size of a Window
@cindex window resizing
@cindex changing window size
@cindex window size, changing

  The window size functions fall into two classes: high-level commands
that change the size of windows and low-level functions that access
window size.  Emacs does not permit overlapping windows or gaps between
windows, so resizing one window affects other windows.

@deffn Command enlarge-window size &optional horizontal
  This function makes the selected window @var{size} lines bigger,
stealing lines from neighboring windows.  It takes the lines from one
window at a time until that window is used up, then takes from another.
If a window from which lines are stolen shrinks below
@code{window-min-height} lines, then that window disappears.

  If @var{horizontal} is non-@code{nil}, then this function makes
@var{window} wider by @var{size} columns, stealing columns instead of
lines.  If a window from which columns are stolen shrinks below
@code{window-min-width} columns, then that window disappears.

  If the window's screen is smaller than @var{size} lines (or columns),
then the function makes the window occupy the entire height (or width)
of the screen.

  If @var{size} is negative, this function shrinks the window by
@minus{}@var{size} lines.  If it becomes shorter than
@code{window-min-height}, it disappears.

  @code{enlarge-window} returns @code{nil}.  
@end deffn

@deffn Command enlarge-window-horizontally columns
  This function makes the selected window @var{columns} wider.
It could be defined as follows:

@example
@group
(defun enlarge-window-horizontally (columns)
  (enlarge-window columns t))
@end group
@end example
@end deffn

@deffn Command shrink-window size &optional horizontal
  This function is like @code{enlarge-window} but negates the argument
@var{size}, making the selected window smaller by giving lines (or
columns) to the other windows.  If the window shrinks below
@code{window-min-height} or @code{window-min-width}, then it disappears.

If @var{size} is negative, the window is enlarged by @minus{}@var{size}
lines.
@end deffn

@deffn Command shrink-window-horizontally columns
  This function makes the selected window @var{columns} narrower.
It could be defined as follows:

@example
@group
(defun shrink-window-horizontally (columns)
  (shrink-window columns t))
@end group
@end example
@end deffn

@cindex minimum window size
  The following two variables constrain the window size changing
functions to a minimum height and width.

@defopt window-min-height
  The value of this variable determines how short a window may become
before it disappears.  A window disappears when it becomes smaller than
@code{window-min-height}, and no window may be created that is smaller.
The absolute minimum height is two (allowing one line for the mode line,
and one line for the buffer display).  Actions which change window sizes
reset this variable to two if it is less than two.  The default value is
4.
@end defopt

@defopt window-min-width
  The value of this variable determines how narrow a window may become
before it disappears.  A window disappears when it becomes narrower than
@code{window-min-width}, and no window may be created that is narrower.
The absolute minimum width is one; any value below that is ignored.  The
default value is 10.
@end defopt

@node Coordinates and Windows
@section Coordinates and Windows

This section describes how to compare screen coordinates with windows.

@defun window-at x y &optional screen
This function returns the window containing the specified cursor
position in the screen @var{screen}.  The coordinates @var{x} and @var{y}
are measured in characters and count from the top left corner of the
screen or screen.

If you omit @var{screen}, the selected screen is used.
@end defun

@defun coordinates-in-window-p coordinates window
This function checks whether a particular screen position falls within
the window @var{window}.

The argument @var{coordinates} is a cons cell of this form:

@example
(@var{x} . @var{y})
@end example

@noindent
The coordinates @var{x} and @var{y} are measured in characters, and
count from the top left corner of the screen or screen.

The value of @code{coordinates-in-window-p} is non-@code{nil} if the
coordinates are inside @var{window}.  The value also indicates what part
of the window the position is in, as follows:

@table @code
@item (@var{relx} . @var{rely})
The coordinates are inside @var{window}.  The numbers @var{relx} and
@var{rely} are the equivalent window-relative coordinates for the
specified position, counting from 0 at the top left corner of the
window.

@item mode-line
The coordinates are in the mode line of @var{window}.

@item vertical-split
The coordinates are in the vertical line between @var{window} and its
neighbor to the right.

@item nil
The coordinates are not in any sense within @var{window}.
@end table

The function @code{coordinates-in-window-p} does not require a screen as
argument because it always uses the screen that window @var{window} is
on.
@end defun

@node Window Configurations
@section Window Configurations
@cindex window configurations
@cindex saving window information

  A @dfn{window configuration} records the entire layout of a
screen---all windows, their sizes, which buffers they contain, what part
of each buffer is displayed, and the values of point and the mark.  You
can bring back an entire previous layout by restoring a window
configuration previously saved.

@ignore  @c Not in Lucid Emacs
  If you want to record all screens instead of just one, use a screen
configuration instead of a window configuration.  @xref{Screen
Configurations}.
@end ignore

@defun current-window-configuration
  This function returns a new object representing Emacs's current window
configuration, namely the number of windows, their sizes and current
buffers, which window is the selected window, and for each window the
displayed buffer, the display-start position, and the positions of point
and the mark.  An exception is made for point in the current buffer,
whose value is not saved.
@end defun

@defun set-window-configuration configuration
  This function restores the configuration of Emacs's windows and
buffers to the state specified by @var{configuration}.  The argument
@var{configuration} must be a value that was previously returned by
@code{current-window-configuration}.

  Here is a way of using this function to get the same effect
as @code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-vertically nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defspec save-window-excursion forms@dots{}
  This special form executes @var{forms} in sequence, preserving window
sizes and contents, including the value of point and the portion of the
buffer which is visible.  It also preserves the choice of selected
window.  However, it does not restore the value of point in the current
buffer; use @code{save-excursion} for that.

  The return value is the value of the final form in @var{forms}.
For example:

@example
@group
(split-window)
     @result{} #<window 25 on control.texi>
@end group
@group
(setq w (selected-window))
     @result{} #<window 19 on control.texi>
@end group
@group
(save-window-excursion
  (delete-other-windows w)
  (switch-to-buffer "foo")
  'do-something)
     @result{} do-something
     ;; @r{The screen is now split again.}
@end group
@end example
@end defspec

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

  Primitives to look inside of window configurations would make sense,
but none are implemented.  It is not clear they are useful enough to be
worth implementing.
